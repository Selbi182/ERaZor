; /======================================================\
; |                     Sonic ERaZor                     |
; \======================================================/

; ------------------------------------------------------
	if def(__BENCHMARK__)=0
; Vladik's Debugger
__DEBUG__: equ 1

	else
		; MD Replay state. Used for playing pre-recorded gameplay in benchmarks.
		; Change to 'rec' to record benchmark gameplay to SRAM, then dump to to file.
		__MD_REPLAY__:	equ 'play'

		if def(__DEBUG__)
			inform 2, "__DEBUG__ shouldn't be with __BENCHMARK__"
		endif
	endif

; ------------------------------------------------------

	include	"_Variables.asm"
	include	"_Constants.asm"
	include	"_Macros.asm"

; ======================================================
; ------------------------------------------------------
; Developer Assembly Options
; ------------------------------------------------------
;   -1 - boot to title screen level select
; $400 - Uberhub Place
; $501 - Tutorial Place
; $000 - Night Hill Place
; $002 - Green Hill Place
; $300 - Special Place
; $200 - Ruined Place
; $101 - Labyrinthy Place
; $401 - Unreal Place
; $301 - Scar Night Place
; $302 - Star Agony Place
; $502 - Finalor Place
	if def(__BENCHMARK__)=0
QuickLevelSelect = 0
QuickLevelSelect_ID = -1
; ------------------------------------------------------
DebugModeDefault = 1
DebugSurviveNoRings = 1
; ------------------------------------------------------
DoorsAlwaysOpen = 0
LowBossHP = 0
; ------------------------------------------------------
TestDisplayDeleteBugs = 0
; ======================================================
	else
; BENCHMARK build settings (DO NOT CHANGE!)
QuickLevelSelect = 0
QuickLevelSelect_ID = $400
DebugModeDefault = 1
DebugSurviveNoRings = 1
DoorsAlwaysOpen = 1
LowBossHP = 1
TestDisplayDeleteBugs = 0
	endif

; ------------------------------------------------------
		include	"Debugger/Debugger.asm"
		include	"modules/MD Replay.asm"
; ------------------------------------------------------

; ===========================================================================
; ---------------------------------------------------------------------------
; Start of ROM - Sonic ERaZor
; ---------------------------------------------------------------------------

StartOfRom:
		dc.l $FFFE00, EntryPoint, BusError, AddressError
		dc.l IllegalInstr, ZeroDivide, ChkInstr, TrapvInstr
		dc.l PrivilegeViol, Trace, -Line1010Emu, Line1111Emu
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorExcept, ErrorExcept, ErrorExcept
		dc.l ErrorExcept, ErrorTrap, ErrorTrap,	ErrorTrap
		dc.l HBlankHndl, ErrorTrap, VBlank, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap
		dc.l ErrorTrap,	ErrorTrap, ErrorTrap, ErrorTrap

		dc.b 'SEGA MEGA DRIVE ' ; Hardware system ID

Date:		dc.b '(C)SELBI 2024   ' ; Release date
Title_Local:	dc.b 'Sonic ERaZor                                    ' ; Domestic name
Title_Int:	dc.b 'Sonic ERaZor                                    ' ; International name
Serial:		dc.b 'SP 18201337-07' 	; Serial/version number

Checksum:	dc.w 0
		dc.b 'J               '	; I/O support

RomStartLoc:	dc.l StartOfRom		; ROM start
RomEndLoc:	dc.l EndOfRom-1		; ROM end

RamStartLoc:	dc.l $FF0000		; RAM start
RamEndLoc:	dc.l $FFFFFF		; RAM end

	; MD Replay allows to record and playback gameplay everywhere using SRAM
	; It's used by Benchmark ROM to consistently reproduce the same gameplay.
	if def(__MD_REPLAY__)
	if __MD_REPLAY__='rec'
		dc.b	'RA', %10100000, %00100000
		dc.l	$200000
		dc.l	$3FFFFF
	else	; __MD_REPLAY__='play'
		dc.l	$20202020
		dc.l	$20202020
		dc.l	$20202020
	endif
	else	; __MD_REPLAY__ not present, normal game
SRAMSupport:	dc.l $5241F820		; create SRAM
		dc.l $200000		; SRAM start
		dc.l $2001FF		; SRAM end
	endif

Notes:		dc.b '                                                    '	; Notes

Region:		dc.b 'JUE             ' ; Region

; ===========================================================================

ErrorTrap:
		nop	
		nop	
		bra.s	ErrorTrap
; ===========================================================================

EntryPoint:
		tst.l	($A10008).l	; test port A control
		bne.s	PortA_Ok
		tst.w	($A1000C).l	; test port C control
PortA_Ok:	bne.s	PortC_Ok

Init:
		lea	SetupValues(pc),a5
		movem.w	(a5)+,d5-d7
		movem.l	(a5)+,a0-a4
		move.b	-$10FF(a1),d0	; get hardware version
		andi.b	#$F,d0
		beq.s	SkipSecurity
		move.l	#'SEGA',$2F00(a1)

SkipSecurity:
		move.w	(a4),d0		; check	if VDP works
		moveq	#0,d0
		movea.l	d0,a6
		move.l	a6,usp		; set usp to $0
		moveq	#$17,d1
VDPInitLoop:	move.b	(a5)+,d5	; add $8000 to value
		move.w	d5,(a4)		; move value to	VDP register
		add.w	d7,d5		; next register
		dbf	d1,VDPInitLoop

		move.l	(a5)+,(a4)
		move.w	d0,(a3)		; clear	the screen
		move.w	d7,(a1)		; stop the Z80
		move.w	d7,(a2)		; reset	the Z80

WaitForZ80:	btst	d0,(a1)		; has the Z80 stopped?
		bne.s	WaitForZ80	; if not, branch

		moveq	#$25,d2
Z80InitLoop:	move.b	(a5)+,(a0)+
		dbf	d2,Z80InitLoop

		move.w	d0,(a2)
		move.w	d0,(a1)		; start	the Z80
		move.w	d7,(a2)		; reset	the Z80
ClrRAMLoop:	move.l	d0,-(a6)
		dbf	d6,ClrRAMLoop	; clear	the entire RAM

		move.l	(a5)+,(a4)	; set VDP display mode and increment
		move.l	(a5)+,(a4)	; set VDP to CRAM write
		moveq	#$1F,d3
ClrCRAMLoop:	move.l	d0,(a3)
		dbf	d3,ClrCRAMLoop	; clear	the CRAM

		move.l	(a5)+,(a4)
		moveq	#$13,d4
ClrVDPStuff:	move.l	d0,(a3)
		dbf	d4,ClrVDPStuff

		moveq	#3,d5
PSGInitLoop:	move.b	(a5)+,$11(a3)	; reset	the PSG
		dbf	d5,PSGInitLoop

		move.w	d0,(a2)
		movem.l	(a6),d0-a6	; clear	all registers

PortC_Ok:
		bra.s	GameProgram

; ===========================================================================
SetupValues:	dc.w $8000		; VDP register start number
		dc.w $3FFF		; size of RAM/4
		dc.w $100		; VDP register diff

		dc.l $A00000		; start	of Z80 RAM
		dc.l $A11100		; Z80 bus request
		dc.l $A11200		; Z80 reset
		dc.l $C00000
		dc.l $C00004		; address for VDP registers

		dc.b 4			; VDP $80 - 8-colour mode
		dc.b $14		; VDP $81 - Megadrive mode, DMA enable
		dc.b ($C000>>10)	; VDP $82 - foreground nametable address
		dc.b ($F000>>10)	; VDP $83 - window nametable address
		dc.b ($E000>>13)	; VDP $84 - background nametable address
		dc.b ($D800>>9)		; VDP $85 - sprite table address
		dc.b 0			; VDP $86 - unused
		dc.b 0			; VDP $87 - background colour
		dc.b 0			; VDP $88 - unused
		dc.b 0			; VDP $89 - unused
		dc.b 255		; VDP $8A - HBlank register
		dc.b 0			; VDP $8B - full screen scroll
		dc.b $81		; VDP $8C - 40 cell display
		dc.b ($DC00>>10)	; VDP $8D - hscroll table address
		dc.b 0			; VDP $8E - unused
		dc.b 1			; VDP $8F - VDP increment
		dc.b 1			; VDP $90 - 64 cell hscroll size
		dc.b 0			; VDP $91 - window h position
		dc.b 0			; VDP $92 - window v position
		dc.w $FFFF		; VDP $93/94 - DMA length
		dc.w 0			; VDP $95/96 - DMA source
		dc.b $80		; VDP $97 - DMA fill VRAM
		dc.l $40000080		; VRAM address 0

		dc.b $AF, 1, $D9, $1F, $11, $27, 0, $21, $26, 0, $F9, $77 ; Z80	instructions
		dc.b $ED, $B0, $DD, $E1, $FD, $E1, $ED,	$47, $ED, $4F
		dc.b $D1, $E1, $F1, 8, $D9, $C1, $D1, $E1, $F1,	$F9, $F3
		dc.b $ED, $56, $36, $E9, $E9

		dc.w $8104		; value	for VDP	display	mode
		dc.w $8F02		; value	for VDP	increment
		dc.l $C0000000		; value	for CRAM write mode
		dc.l $40000010

		dc.b $9F, $BF, $DF, $FF	; values for PSG channel volumes
		even
; ===========================================================================

GameProgram:
		ints_disable
		
		; super mega ultra clear the entire RAM from start to finish
		; (used to clear just 0000-FDFF, updated to go to FFFF)
		; (this was done to avoid RAM inconsistencies from soft reboots)
		lea	($FF0000).l,a6
		moveq	#0,d7
		move.w	#($10000/4)-1,d6	
GameClrRAM:	move.l	d7,(a6)+
		dbf	d6,GameClrRAM

		bsr	VDPSetupGame
		bsr	JoypadInit
		if def(__MD_REPLAY__)=0
			bsr.w	LoadSRAM
		else
			bsr.w	ResetGameProgress
		endif

		jsr     MegaPCM_LoadDriver
		lea     SampleTable, a0
		jsr     MegaPCM_LoadSampleTable
		tst.w   d0                      ; was sample table loaded successfully?
		beq.s   @SampleTableOk          ; if yes, branch
		if def(__DEBUG__)
			; for MD Debugger v.2.5 or above
			RaiseError "MegaPCM_LoadSampleTable returned %<.b d0>", MPCM_Debugger_LoadSampleTableException
		else
			illegal
		endif
@SampleTableOk:

		jsr	PLC_ClearQueue	; setup PLC system

		jsr	DrawBuffer_Clear		; initialize drawing buffer

		jsr	BlackBars.FullReset		; setup black bars
		move.l	HBlank_BaseHandler, HBlankHndl	; setup HBlank handler

	if DebugModeDefault=1
		move.w	#1,($FFFFFFFA).w ; enable debug mode
	endif

	if QuickLevelSelect=1
		if (QuickLevelSelect_ID=-1)
			move.b	#4,($FFFFF600).w ; set Game Mode to title scren
		else
		move.w	#QuickLevelSelect_ID,($FFFFFE10).w	; set level to QuickLevelSelect_ID
		if (QuickLevelSelect_ID=$300) | (QuickLevelSelect_ID=$401)
			move.b	#$10,($FFFFF600).w		; set game mode to special stage
		else
			move.b	#$C,($FFFFF600).w		; set game mode to level
		endif
		endif
	else
		jsr	Start_FirstGameMode	; start default first game mode (Sega Screen)
	endif

	if def(__BENCHMARK__)
		; Benchmark build uses a custom bootstrap program
		jmp	Benchmark
	else
		bra.w	MainGameLoop	; continue to main game loop
	endif

; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; SRAM Loading Routine
; ---------------------------------------------------------------------------
; Format (note, SRAM can only be written to odd addresses):
; 00 op 00 ch  00 d1 00 d2  00 l1 00 l2  00 r1 00 r2  00 s1 00 s2  00 s3 00 s4  00 cm 00 rs  00 mg
;    01    03     05    07     09    0B     0D    0F     11    13     15    17     19    1A     1C
;
;  op = Options Bitset ($FFFFFF92)
;  ch = Current Chapter ($FFFFFFA7)
;  d_ = Open Doors Bitset - Casual/Frantic  ($FFFFFF8A-$FFFFFF8B)
;  l_ = Lives (or Deaths rather, lol) ($FFFFFE12-FFFFFE13)
;  r_ = Rings ($FFFFFE20-FFFFFE21)
;  s_ = Score ($FFFFFE26-FFFFFE29)
;  cm = Complete (Base Game / Blackout challenge) ($FFFFFF93)
;  rs = Resume Flag (0 first launch / 1 load save game) ($FFFFF601)
;  mg = Magic Number (always set to 182, absence implies no SRAM)
; ---------------------------------------------------------------------------
SRAM_Options	= 1
SRAM_Chapter	= 2 + SRAM_Options
SRAM_Doors	= 2 + SRAM_Chapter ; 2 bytes
SRAM_Lives	= 4 + SRAM_Doors ; 2 bytes
SRAM_Rings	= 4 + SRAM_Lives ; 2 bytes
SRAM_Score	= 4 + SRAM_Rings ; 4 bytes
SRAM_Complete	= 8 + SRAM_Score
SRAM_Resume	= 2 + SRAM_Complete
SRAM_Exists	= 2 + SRAM_Resume

SRAM_MagicNumber = 182
; ---------------------------------------------------------------------------

LoadSRAM:
	; Supress SRAM if MD Replay takes over it
	if def(__MD_REPLAY__)
		rts
	else
		moveq	#0,d0					; clear d0
		move.b	#1,($A130F1).l				; enable SRAM
		lea	($200000).l,a1				; base of SRAM
		cmpi.b	#SRAM_MagicNumber,SRAM_Exists(a1)	; does SRAM exist?
		beq.s	SRAMFound				; if yes, branch
		
		bsr.s	SRAM_Delete				; clear any existing SRAM
		bra.w	SRAMEnd

SRAMFound:
		lea	($200000).l,a1				; base of SRAM
		move.b	SRAM_Options(a1),(OptionsBits).w		; load options flags
		move.b	SRAM_Chapter(a1),($FFFFFFA7).w		; load current chapter
		movep.w	SRAM_Doors(a1),d0			; load...
		move.w	d0,($FFFFFF8A).w			; ...open doors bitsets
		movep.w	SRAM_Lives(a1),d0			; load...
		move.w	d0,($FFFFFE12).w			; ...lives/deaths counter
		movep.w	SRAM_Rings(a1),d0			; load...
		move.w	d0,($FFFFFE20).w			; ...rings
		movep.l	SRAM_Score(a1),d0			; load...
		move.l	d0,($FFFFFE26).w			; ...score
		move.b	SRAM_Complete(a1),($FFFFFF93).w		; load game beaten state
		move.b	SRAM_Resume(a1),($FFFFF601).w		; load resume flag

SRAMEnd:
		move.b	#0,($A130F1).l				; disable SRAM
		rts
	endif	; def(__MD_REPLAY__)=0
; ===========================================================================

SRAM_Delete:
	if def(__MD_REPLAY__)
		rts
	else
		moveq	#$00,d0					; if not, set the whole SRAM to 0 for safety
		move.b	#2,d1
@ClearSRAM:	movep.l	d0,1(a1)
		adda.w	#8,a1
		dbf	d1,@ClearSRAM

		lea	($200000).l,a1				; base of SRAM
		move.b	#SRAM_MagicNumber,SRAM_Exists(a1) 	; set magic number ("SRAM exists")
		jsr	Options_SetDefaults			; reset default options
		move.b	(OptionsBits).w,1(a1)			; ^
	endif	; def(__MD_REPLAY__)=0
		
ResetGameProgress:
		moveq	#0,d0
		move.b	d0,($FFFFFFA7).w			; clear current chapter
		move.w	d0,($FFFFFF8A).w			; clear open doors bitsets
		move.w	d0,($FFFFFE12).w			; clear lives/deaths counter
		move.w	d0,($FFFFFE20).w			; clear rings
		move.l	d0,($FFFFFE26).w			; clear score
		move.b	d0,($FFFFFF93).w			; clear game beaten state
		rts

; ===========================================================================

SRAM_SaveNow:
	; Supress SRAM if MD Replay takes over it
	if def(__MD_REPLAY__)
		rts
	else
		move.b	#1,($A130F1).l				; enable SRAM
		lea	($200000).l,a1				; base of SRAM
		cmpi.b	#SRAM_MagicNumber,SRAM_Exists(a1)	; does SRAM exist?
		bne.s	SRAM_SaveNow_End			; if not, branch
		
		move.l	d0,-(sp)				; backup d0
		moveq	#0,d0					; clear d0
		move.b	(OptionsBits).w,d0			; move option flags to d0
		move.b	d0,SRAM_Options(a1)			; backup option flags
		move.b	($FFFFFFA7).w,d0			; move current chapter to d0
		move.b	d0,SRAM_Chapter(a1)			; backup current chapter
		move.w	($FFFFFF8A).w,d0			; move open doors bitset to d0
		movep.w	d0,SRAM_Doors(a1)			; backup open doors bitset
		move.w	($FFFFFE12).w,d0			; move lives/deaths to d0
		movep.w	d0,SRAM_Lives(a1)			; backup lives/deaths
		move.w	($FFFFFE20).w,d0			; move rings to d0
		movep.w	d0,SRAM_Rings(a1)			; backup rings
		move.l	($FFFFFE26).w,d0			; move score to d0
		movep.l	d0,SRAM_Score(a1)			; backup score
		move.b	($FFFFFF93).w,d0			; move game beaten state to d0
		move.b	d0,SRAM_Complete(a1)			; backup option flags
		move.b	($FFFFF601).w,d0			; move resume flag to d0
		move.b	d0,SRAM_Resume(a1)			; backup resume flag
		move.l	(sp)+,d0				; restore d0

SRAM_SaveNow_End:
		move.b	#0,($A130F1).l				; disable SRAM
		rts
	endif	; def(__MD_REPLAY__)=0
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; H-Blank - LZ water palette swap effect
; Source: https://sonicresearch.org/community/index.php?threads/removing-the-water-surface-object-in-sonic-1.5975/
; ---------------------------------------------------------------------------

; HBlank:
HBlank_LZWaterSurface:
		tst.w	($FFFFF644).w		; is flag set to transfer water palette mid-frame?
		beq.w	locret_119C		; if not, branch
		move.w	#0,($FFFFF644).w	; clear said flag
		movem.l	d0-d2/a0-a2,-(sp)
		
		lea	VDP_Data,a1
		move.w	#$8A00|$DF,4(a1)	; Reset HInt timing

		movea.l	($FFFFF610).w,a2
		move.w	(a2)+,d1
		move.b	($FFFFFE07).w,d0	; get water surface height for the screen transfer
		subi.b	#200,d0			; is H-int occuring below line 200?
		bcs.s	@transferColors		; if it is, branch
		sub.b	d0,d1
		bcs.s	@skipTransfer

@transferColors:
		moveq	#0, d0
		move.w	(a2)+,d0
		lea	($FFFFFA80).w,a0
		adda.w	d0,a0
		addi.w	#$C000,d0
		swap	d0
		move.l	d0,4(a1)		; write to CRAM at appropriate address

		swap	d1			; high word of D1 is used for buffering
		move.l	(a0)+, d2		; buffer colors to registers for faster transfer
		move.w	(a0)+, d1		; ''

		moveq	#$FFFFFFB2-16, d0
	@waitforit:
		cmp.b	9(a1), d0
		bhi.s	@waitforit

		move.l	d2,(a1)			; transfer two colors
		move.w	d1,(a1)			; transfer the third color

		swap	d1			; use D1 as counter again
		dbf	d1,@transferColors	; repeat for number of colors

@skipTransfer:
		movem.l	(sp)+,d0-d2/a0-a2

locret_119C:
		rte
; End of function HBlank

; ===========================================================================
; ---------------------------------------------------------------------------
; Vladik's cool and awesome black bars that replaced my garbage ones B)
; ---------------------------------------------------------------------------

; BlackBars::
BlackBars.GrowSize = 2
BlackBars.MaxHeight = 40
; ---------------------------------------------------------------------------

NullInt:
		rte
; ---------------------------------------------------------------------------

HBlank_BaseHandler:
		jmp	NullInt.w
; ===========================================================================

HBlank_Bars:
		move.l	#$81748720,VDP_Ctrl				; enable display, restore backdrop color
		move.w	BlackBars.SecondHCnt,VDP_Ctrl			; send $8Axx to VDP to set HInt counter for the second invocation
		move.w	#@ToBottom,HBlankSubW				; handle bottom next time
		rte
@ToBottom:
		move.w	#HBlank_Bars_Bottom,HBlankSubW
		rte
; ---------------------------------------------------------------------------

HBlank_Bars_PastQuarter:
		move.w	BlackBars.SecondHCnt,VDP_Ctrl			; send $8Axx to VDP to set HInt counter for the second invocation
		move.w	#@ToBottom,HBlankSubW				; handle bottom next time
		rte

@ToBottom:
		move.l	#$81748720,VDP_Ctrl				; enable display, restore backdrop color
		move.w	#HBlank_Bars_Bottom,HBlankSubW
		rte
; ---------------------------------------------------------------------------

HBlank_Bars_Bottom:
		move.l	#$81348701,VDP_Ctrl				; disable display + set backdrop color to black
		move.w	#$8A00|$DF,VDP_Ctrl				; set H-int timing to not occur this frame anymore
		move.w	#NullInt,HBlankSubW				; don't run any code during HInt
		rte
; ===========================================================================

; called once on system start
BlackBars.FullReset:
		move.l	#$8ADF8ADF,BlackBars.FirstHCnt			; + BlackBars.SecondHCnt

BlackBars.Reset:
		move.w	#NullInt,HBlankSubW				; don't run any code during HInt
		move.w	#0,BlackBars.Height				; set current height to 0
		move.w	#BlackBars.MaxHeight,BlackBars.BaseHeight	; set base height to default
		move.w	BlackBars.BaseHeight,BlackBars.TargetHeight	; set target height to default
		move.l	#$81748720,VDP_Ctrl				; enable display, restore backdrop color
		rts
; ---------------------------------------------------------------------------

; called from VBlank every single frame
BlackBars.VBlankUpdate:
		tst.w	($FFFFFE02).w					; is level set to restart?
		bne.s	@notlz						; if yes, branch
		tst.b	($FFFFFFE9).w					; is fade out currently in progress?
		bne.s	@notlz						; if yes, branch
		cmpi.b	#1,($FFFFFE10).w				; are we in LZ?
		bne.s	@notlz						; if not, branch
		cmpi.b	#$C,($FFFFF600).w				; are we done with the pre-level sequence?
		bne.w	@notlz						; if not, branch
		cmpi.w	#HBlank_LZWaterSurface,HBlankSubW		; already set up?
		beq.s	@end						; if yes, branch
		bsr.s	BlackBars.FullReset				; reset black bars (not supported in LZ)
		move.w	#HBlank_LZWaterSurface,HBlankSubW		; go to original HBlank subroutine for LZ
@end		rts

@notlz:
		bsr.s	BlackBars.SetState
	
		move.w	BlackBars.Height,d0				; is height 0?
		beq.s	@disable_bars					; if yes, branch
		cmp.w	#224/2-1,d0					; are we taking half the screen?
		bhi.s	@make_black_screen				; if yes, branch
		cmp.w	#224/4-1,d0					; are we quater the screen?
		bhs.s	@make_bars_past_quarter				; if yes, branch

		move.w	#HBlank_Bars,HBlankSubW
		move.w	d0,d1
		add.w	d1,d1
		add.w	d0,d1
		sub.w	#224-1,d1
		neg.w	d1

@make_bars_cont:
		move.b	d0,BlackBars.FirstHCnt+1
		move.b	d1,BlackBars.SecondHCnt+1
		move.w	BlackBars.FirstHCnt,VDP_Ctrl
		move.l	#$81348701,VDP_Ctrl				; disable display, set backdrop color to black
		rts
; ---------------------------------------------------------------------------

@make_bars_past_quarter:	
		move.w	#HBlank_Bars_PastQuarter,HBlankSubW
		move.w	d0,d1
		add.w	d1,d1
		sub.w	#224-1,d1
		neg.w	d1
		lsr.w	#1,d0
		bra.s	@make_bars_cont
; ---------------------------------------------------------------------------

@make_black_screen:
		move.l	#$81348701,VDP_Ctrl				; disable display, set backdrop color to black

@disable_bars:
		move.w	#NullInt,HBlankSubW
		bsr	BlackBars.Reset
		rts
; End of function HBlank_Bars
; ===========================================================================

; ---------------------------------------------------------------------------
; Black bars control logic
; ---------------------------------------------------------------------------

BlackBars.SetState:
		moveq	#0,d0				; clear d0		
		move.b	($FFFFF600).w,d0		; get current game mode
		cmpi.b	#$C,d0				; are we in a level?
		beq.s	@validgamemode			; if yes, branch
		cmpi.b	#$1C,d0				; are we in Selbi?
		beq.w	BlackBars_Selbi			; if yes, :|
		cmpi.b	#$10,d0				; are we in a special stage?
		beq.s	@validgamemode			; if yes, branch
		cmpi.b	#$18,d0				; are we in the ending sequence?
		beq.w	BlackBars_Ending		; if yes, branch
		bra.w	BlackBars_DontShow		; don't show black bars in any other game modes

@validgamemode:
		tst.b	($FFFFFF6E).w			; are tutorial boxes currently shown?
		bne.w	BlackBars_DontShow		; if yes, don't show to not mess with the h-ints
		move.w	($FFFFFE10).w,d0		; get current level ID
		cmpi.w	#$500,d0			; is this the bomb machine cutscene?
		bne.s	@notmachine			; if not, branch
		move.w	#8,BlackBars.TargetHeight	; set custom target height for the first part of the cutscene
		tst.b	($FFFFFFC8).w			; did Eggman press the switch?
		beq.s	BlackBars_ShowCustom		; if not yet, show small black bars
		move.w	#28,BlackBars.TargetHeight	; set full bars once the machine is destroyed
		bra.s	BlackBars_ShowCustom		; force display

@notmachine:
		cmpi.w	#$002,d0			; are we in Green Hill Place?
		bne.s	@notghp				; if not, branch
		cmpi.b	#4,($FFFFFE30).w		; did we hit the final checkpoint yet?
		bne.s	BlackBars.GHP			; if not, go to custom GHP black bars logic

@notghp:
		tst.b	($FFFFF7CC).w			; are controls locked?
		bne.s	BlackBars_Show			; if yes, always enable
		tst.w	($FFFFF63A).w			; is game paused?
		bne.s	BlackBars_Show			; if yes, always enable
		cmpi.b	#6,($FFFFD024).w		; is Sonic dying?
		bhs.s	BlackBars_Show			; if yes, branch
		btst	#3,(OptionsBits).w		; is cinematic HUD enabled?
		bne.s	BlackBars_Show			; if yes, always enable

		cmpi.w	#$400,d0			; are we in Uberhub?
		bne.s	BlackBars_DontShow		; if not, branch
		tst.b	($FFFFFF7F).w			; are we done falling down the intro tube?
		bne.s	BlackBars_DontShow		; if yes, don't display
; ---------------------------------------------------------------------------

BlackBars_Show:
		move.w	BlackBars.BaseHeight,BlackBars.TargetHeight	; set target height to the default max (32px)
BlackBars_ShowCustom:
		move.w	BlackBars.Height,d0		; get currently set height
		addi.w	#BlackBars.GrowSize,d0		; continue to increase height
		cmp.w	BlackBars.TargetHeight,d0	; compare against max allowed height
		bls.s	BlackBars_SetHeight		; if we're below, branch
		move.w	BlackBars.TargetHeight,d0	; make sure we don't exceed the maximum
		bra.s	BlackBars_SetHeight

BlackBars_DontShow:
		move.w	#0,BlackBars.TargetHeight	; set target height to 0
		move.w	BlackBars.Height,d0		; get currently set height
		subi.w	#BlackBars.GrowSize,d0		; continue to reduce height
		tst.w	d0				; are we on height 0?
		bpl.s	BlackBars_SetHeight		; if yes, branch
		move.w	#0,d0				; make sure we don't exceed the minimum

BlackBars_SetHeight:
		move.w	d0,BlackBars.Height		; set final black bars height
		rts					; return
; ===========================================================================

BlackBars.GHPCasual  = 120
BlackBars.GHPFrantic = 60
; ---------------------------------------------------------------------------

BlackBars.GHP:
		tst.w	($FFFFF63A).w			; is game paused?
		bne.s	@timeleft			; if yes, don't affect height
		
		cmpi.b	#6,($FFFFD024).w		; is Sonic dying?
		bhs.s	BlackBars_Show			; if yes, show regular black bars
		
		move.b	#BlackBars.GHPCasual,d0		; set casual reset time
		frantic					; are we in Frantic mode?
		beq.s	@notfrantic			; if not, branch
		move.b	#BlackBars.GHPFrantic,d0	; set frantic reset time
@notfrantic:
		move.b	d0,BlackBars.GHPTimerReset	; set reset time

		subq.b	#1,BlackBars.GHPTimer		; sub 1 from shrink timer
		bpl.s	@timeleft			; if time is left, branch
		move.b	BlackBars.GHPTimerReset,BlackBars.GHPTimer	; reset timer
		addq.w	#BlackBars.GrowSize,BlackBars.TargetHeight	; shrink bars

		cmpi.w	#224/2-2,BlackBars.Height	; did we reach kill height yet? (full screen covered)
		blo.s	@noscreenkill			; if not, branch
		jmp	KillSonic_Inhuman		; hecking kill Sonic, even in nonstop inhuman
		
@noscreenkill:
		move.w	#$BB,d0				; play...
		jsr	PlaySound_Special		; ...badump sound		

@timeleft:		
		bra	BlackBars_ShowCustom		; force display
; ---------------------------------------------------------------------------

BlackBars_Selbi:
		moveq	#0,d0				; disable black bars
		tst.b	($FFFFFFAF).w			; are we in the final phase?
		bne.w	BlackBars_SetHeight		; if yes, disable black bars immediately
		
		; I'm well aware of how terrible this code is
		cmpi.l	#$4EE00001,($FFFFFF7A).w
		bne.w	BlackBars_SetHeight
		subi.w	#1,BlackBars.Height
		moveq	#60,d0
		move.w	d0,BlackBars.TargetHeight
		bra.w	BlackBars_ShowCustom
; ---------------------------------------------------------------------------

BlackBars_Ending:
		tst.b	($FFFFFF78).w			; is pit flag set?
		beq.w	BlackBars_DontShow		; if not, don't show black bars yet

		tst.w	($FFFFFE02).w			; is level set to restart? (after Sonic died)
		beq.s	@noshrink			; if not, branch
		cmpi.w	#224/2-2,BlackBars.Height	; did we fill up the full screen?
		bhs.s	@show				; if not, branch
		addq.w	#2,BlackBars.TargetHeight	; grow black bars
@show:		bra.w	BlackBars_ShowCustom		; show bars

@noshrink:
		cmpi.b	#6,($FFFFD024).w		; is Sonic dead yet?
		bhs.w	BlackBars_DontShow		; if yes, stop showing bars
		bra.w	BlackBars_Show			; otherwise, keep bars at all times
		
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Main Game Loop, everything before this is only done on startup.
; ---------------------------------------------------------------------------

MainGameLoop:
		moveq	#0,d0				; clear d0
		move.b	($FFFFF600).w,d0		; get current game mode
		movea.l	GameModeArray(pc,d0.w),a1	; locate address in GameModeArray
		KDebug.WriteLine "MainGameLoop(): Launching %<.l a1 sym>..."
		jsr	(a1)				; enter game mode
	;	jsr	BlackBars.FullReset		; reset black bars between game mode transitions
		bra.s	MainGameLoop			; if we're here, we exited the game mode; load new one

; ===========================================================================
; ---------------------------------------------------------------------------
; Main game mode array (screen modes / game modes)
; ---------------------------------------------------------------------------
GameModeArray:
		dc.l	SegaScreen		; Sega Screen		($00)
		dc.l	TitleScreen		; Title	Screen		($04)
		dc.l	Deleted_Mode		; X Demo Mode		($08)
		dc.l	Level			; Normal Level		($0C)
		dc.l	SpecialStage		; Special Stage		($10)
		dc.l	Deleted_Mode		; X Continue Screen	($14)
		dc.l	EndingSequence		; Ending Sequence	($18)
		dc.l	SelbiSplash		; Selbi Splash Screen	($1C)
		dc.l	StoryTextScreen		; Story Text Screen	($20)
		dc.l	OptionsScreen		; Options Screen	($24)
		dc.l	ChapterScreen		; Chapters Screen	($28)
		dc.l	CreditsScreen		; Credits Screen	($2C)
		dc.l	GameplayStyleScreen	; Gameplay Style Screen	($30)
		dc.l	SoundTestScreen		; Sound Test Screen	($34)
; ---------------------------------------------------------------------------

Deleted_Mode:
		jmp	ReturnToUberhub		; we somehow ended up in a deleted game mode, immediately go back to Uberhub
; ---------------------------------------------------------------------------
; ===========================================================================

*VBlank:
		include	"modules/VBlank.asm"

; ---------------------------------------------------------------------------
; Subroutine to	initialise joypads
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


JoypadInit:				; XREF: GameClrRAM
		moveq	#$40,d0
		move.b	d0,($A10009).l	; init port 1 (joypad 1)
		move.b	d0,($A1000B).l	; init port 2 (joypad 2)
		move.b	d0,($A1000D).l	; init port 3 (extra)

		if def(__MD_REPLAY__)
			MDReplay_Init
		endif
		rts
; End of function JoypadInit

; ---------------------------------------------------------------------------
; Subroutine to	read joypad input, and send it to the RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ReadJoypads:
	if def(__MD_REPLAY__)
		MDReplay_Update
	else
		lea	($FFFFF604).w,a0 ; address where joypad	states are written
		lea	($A10003).l,a1	; first	joypad port
		bsr.s	Joypad_Read	; do the first joypad
		addq.w	#2,a1		; do the second	joypad

Joypad_Read:
		move.b	#0,(a1)
		nop	
		nop	
		move.b	(a1),d0
		lsl.b	#2,d0
		andi.b	#$C0,d0
		move.b	#$40,(a1)
		nop	
		nop	
		move.b	(a1),d1
		andi.b	#$3F,d1
		or.b	d1,d0
		not.b	d0
		move.b	(a0),d1
		eor.b	d0,d1
		move.b	d0,(a0)+
		and.b	d0,d1
		move.b	d1,(a0)+
		rts
	endif
; End of function ReadJoypads


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


VDPSetupGame:				; XREF: GameClrRAM; ChecksumError
		lea	($C00004).l,a0
		lea	($C00000).l,a1
		lea	(VDPSetupArray).l,a2
		moveq	#$12,d7

VDP_Loop:
		move.w	(a2)+,(a0)
		dbf	d7,VDP_Loop	; set the VDP registers

		move.w	(VDPSetupArray+2).l,d0
		move.w	d0,($FFFFF60C).w
		move.w	#$8ADF,($FFFFF624).w
		moveq	#0,d0
		move.l	#$C0000000,($C00004).l ; set VDP to CRAM write
		move.w	#$3F,d7

VDP_ClrCRAM:
		move.w	d0,(a1)
		dbf	d7,VDP_ClrCRAM	; clear	the CRAM

		clr.l	($FFFFF616).w
		clr.l	($FFFFF61A).w
		move.l	d1,-(sp)
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$94FF93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$40000080,(a5)
		move.w	#0,($C00000).l	; clear	the screen

loc_128E:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_128E

		move.w	#$8F02,(a5)
		move.l	(sp)+,d1
		rts	
; End of function VDPSetupGame

; ===========================================================================
VDPSetupArray:	dc.w $8004	; 8-colour mode
		dc.w $8134	; enable V.interrupts, enable DMA
		dc.w $8230	; set foreground nametable address
		dc.w $8328	; set window nametable address
		dc.w $8407	; set background nametable address
		dc.w $857C	; set sprite table address
		dc.w $8600	; (unused)
		dc.w $8700	; set background colour (palette entry 0)
		dc.w $8800	; (unused)
		dc.w $8900	; (unused)
		dc.w $8A00	; default H.interrupt register
		dc.w $8B00	; full-screen vertical scrolling
		dc.w $8C81	; 40-cell display mode
		dc.w $8D3F	; set background hscroll address
		dc.w $8E00	; (unused)
		dc.w $8F02	; set VDP increment size
		dc.w $9001	; 64-cell hscroll size
		dc.w $9100	; window horizontal position
		dc.w $9200	; window vertical position
; ===========================================================================


; ---------------------------------------------------------------------------
; Subroutine to	clear the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ClearScreen:
		VBlank_SetMusicOnly
		jsr	DrawBuffer_Clear

		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$940F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$40000083,(a5)
		move.w	#0,($C00000).l

loc_12E6:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_12E6

		move.w	#$8F02,(a5)
		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$940F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$60000083,(a5)
		move.w	#0,($C00000).l

loc_1314:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_1314

		move.w	#$8F02,(a5)
		move.l	#0,($FFFFF616).w
		move.l	#0,($FFFFF61A).w
		lea	($FFFFF800).w,a1
		moveq	#0,d0
		move.w	#$A0-1,d1

loc_133A:
		move.l	d0,(a1)+
		dbf	d1,loc_133A

		lea	($FFFFCC00).w,a1
		moveq	#0,d0
		move.w	#$100-1,d1

loc_134A:
		move.l	d0,(a1)+
		dbf	d1,loc_134A

		VBlank_UnsetMusicOnly
		rts
; End of function ClearScreen

; ---------------------------------------------------------------------------
; Subroutine to	clear the entire VRAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

ClearVRAM:
		move.w	sr, -(sp)
		move	#$2700,sr		; disable IRQ's
		lea	($C00000).l,a5		; load VDP data port address to a5
		lea	$04(a5),a6		; load VDP address port address to a6
		move.w	#$8F01,(a6)		; set increment mode to 1 byte
		move.l	#$94FF93FF,(a6)		; set repeat times (number of bytes)
		move.w	#$9780,(a6)		; set source (no source location)
		move.l	#$40000080,(a6)		; set destination
		move.w	#$0000,(a5)		; set value to write

WaitForVDP:
		move.w	(a6),d1			; load VDP value
		btst	#$01,d1			; has DMA finished?
		bne.s	WaitForVDP		; if not, branch
		move.w	#$8F02,(a6)		; set increment mode to 2 bytes
		move.w	(sp)+,sr		; restore previous IRQ's state
		rts				; return
; End of function ClearVRAM

; ---------------------------------------------------------------------------
; Subroutine to	play a sound or	music track
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PlaySound:
		move.b	d0,($FFFFF00A).w
		rts	
; End of function PlaySound

; ---------------------------------------------------------------------------
; Subroutine to	play a special sound/music (E0-E4)
;
; E0 - Fade out
; E1 - Sega
; E2 - Speed up
; E3 - Normal speed
; E4 - Stop
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PlaySound_Special:
		move.b	d0,($FFFFF00B).w
		rts	
; End of function PlaySound_Special

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	pause the game
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PauseGame:				; XREF: Level_MainLoop; et al
	;	nop				; no operation
		tst.w	($FFFFF63A).w		; is game already paused?
		bne.s	Paused			; if yes, branch
		btst	#7,($FFFFF605).w	; is Start button pressed?
		beq.w	Pause_DoNothing		; if not, branch
Paused:
		; skip cutscenes
		cmpi.w	#$500,($FFFFFE10).w	; is this the bomb machine cutscene?
		bne.s	@notmachine		; if not, branch
		jmp	Exit_BombMachineCutscene
@notmachine:
		cmpi.w	#$001,($FFFFFE10).w	; is level intro cutscene?
		bne.s	PG_CheckAllowed		; if not, branch
		jmp	Exit_IntroCutscene
; ===========================================================================

PG_CheckAllowed:
		tst.b	($FFFFD000).w		; does Sonic exist? (e.g. has he not jumped into a ring)?
		beq.w	Pause_DoNothing		; if not, disallow pausing
		cmpi.b	#$10,($FFFFF600).w	; are we in a special stage?
		beq.s	PG_SSPause		; if yes, branch
		cmpi.w	#$501,($FFFFFE10).w	; are we in the tutorial?
		beq.s	PG_DoPause		; if yes, branch
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	PG_DoPause		; if yes, branch
		tst.b	($FFFFD040).w		; is HUD already loaded?
		bne.s	PG_DoPause		; if yes, allow to pause
		tst.b	(FZEscape).w		; are we in the FZ escape sequence?
		bne.s	PG_DoPause		; if yes, allow to pause
		rts				; otherwise, disallow pausing
; ===========================================================================

PG_SSPause:
		btst	#7,($FFFFF605).w	; is Start button pressed?
		beq.s	PG_DoPause		; if not, branch
		move.w	#$8014,($C00004).l	; enable h-ints for the black bars

PG_DoPause:
		move.w	#1,($FFFFF63A).w	; freeze time
		tst.b	($FFFFFFB5).w		; is flag set?
		bne.s	Pause_MainLoop		; if yes, branch
		move.b	#1,($FFFFFFB5).w	; set flag
		move.b	#1,($FFFFF003).w	; pause music
		jsr	Pal_MakeBlackWhite	; make palette grayscale while game is paused

Pause_MainLoop:
		move.b	#$10,VBlankRoutine
		bsr	DelayProgram
		
		; return to Uberhub on Pause+A
		btst	#6,($FFFFF605).w 	; is button A pressed?
		beq.s	Pause_ChkBC		; if not, branch
		bsr.s	Pause_Restore		; restore from pause (grayscale palette, etc.)
		cmpi.w	#$400,($FFFFFE10).w	; are we already in Uberhub?
		beq.s	@uberhubception		; if yes, branch
		jmp	ReturnToUberhub		; return to Uberhub from anywhere (needs to be a jump due to range)

@uberhubception:
		jmp	Start_FirstGameMode	; return to Sega Screen from within Uberhub itself
; ===========================================================================

Pause_ChkBC:
		tst.w	($FFFFFFFA).w		; is debug mode enabled?
		beq.s	Pause_ChkStart		; if not, branch
		btst	#4,($FFFFF604).w 	; is button B held?
		bne.s	Pause_SlowMo		; if yes, branch
		btst	#5,($FFFFF605).w 	; is button C pressed?
		bne.s	Pause_SlowMo		; if yes, branch

Pause_ChkStart:	
		btst	#7,($FFFFF605).w 	; is Start button pressed?
		beq.w	Pause_MainLoop		; if not, loop

Pause_Restore:
		move.b	#$80,($FFFFF003).w	; something with music
		lea	($FFFFFA80).w,a0	; get palette
		lea	($FFFFC910).w,a1 	; get backup up palette
		move.w	#$007F,d3		; set d3 to $3F (+1 for the first run)
@restorepal:	move.w	(a1)+,(a0)+		; set new palette
		dbf	d3,@restorepal		; loop for each colour
		clr.b	($FFFFFFB5).w		; clear flag
		move.w	#0,($FFFFF63A).w 	; unpause the game

Pause_DoNothing:
		rts				; return
; ===========================================================================

Pause_SlowMo:
		move.w	#1,($FFFFF63A).w	; delay program
		move.b	#$80,($FFFFF003).w	; something with music
		rts				; return
; End of function PauseGame

; ---------------------------------------------------------------------------
; Subroutine to	display	patterns via the VDP
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ShowVDPGraphics:			; XREF: SegaScreen; TitleScreen; SS_BGLoad
		lea	($C00000).l,a6		; load VDP data port address to a6
		lea	($C00004).l,a4		; load VDP address port address to a4
		move.l	#$800000,d4		; prepare line add value

MapScreen_Row:
		move.l	d0,(a4)			; set VDP to VRam write mode
		move.w	d1,d3			; reload number of columns

MapScreen_Column:
		move.w	(a1)+,(a6)		; dump map to VDP map slot
		dbf	d3,MapScreen_Column	; repeat til columns have dumped
		add.l	d4,d0			; increae to next row on VRam
		dbf	d2,MapScreen_Row	; repeat til all rows have dumped
		rts				; return
; End of function ShowVDPGraphics

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine for queueing VDP commands (seems to only queue transfers to VRAM),
; to be issued the next time ProcessDMAQueue is called.
; Can be called a maximum of 18 times before the buffer needs to be cleared
; by issuing the commands (this subroutine DOES check for overflow)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_144E: DMA_68KtoVRAM: QueueCopyToVRAM: QueueVDPCommand: Add_To_DMA_Queue:
QueueDMATransfer:
		movea.l	DMAQueuePos, a1

		;move.l	a0, -(sp)
		;movea.l	4(sp), a0
		;KDebug.WriteLine "QueueDMATransfer(): frame=%<.w $FFFFFE0C+2>, pos=%<.w a1>, src=%<.l d1 sym>, dest=%<.w d2>, size=%<.w d3>, caller=%<.l a0 sym>"
		;move.l	(sp)+, a0

		cmpa.w	#$C8FC,a1
		beq.s	QueueDMATransfer_Done ; return if there's no more room in the buffer

		; piece together some VDP commands and store them for later...
		move.w	#$9300,d0 ; command to specify DMA transfer length & $00FF
		move.b	d3,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9400,d0 ; command to specify DMA transfer length & $FF00
		lsr.w	#8,d3
		move.b	d3,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9500,d0 ; command to specify source address & $0001FE
		lsr.l	#1,d1
		move.b	d1,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9600,d0 ; command to specify source address & $01FE00
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+ ; store command

		move.w	#$9700,d0 ; command to specify source address & $FE0000
		lsr.l	#8,d1
		move.b	d1,d0
		move.w	d0,(a1)+ ; store command

		andi.l	#$FFFF,d2 ; command to specify destination address and begin DMA
		lsl.l	#2,d2
		lsr.w	#2,d2
		swap	d2
		ori.l	#$40000080,d2 ; set bits to specify VRAM transfer
		move.l	d2,(a1)+ ; store command

		move.l	a1, DMAQueuePos	; set the next free slot address
		cmpa.w	#$C8FC,a1
		beq.s	QueueDMATransfer_Done ; return if there's no more room in the buffer
		move.w	#0,(a1) ; put a stop token at the end of the used part of the buffer
; return_14AA:
QueueDMATransfer_Done:
		rts
; End of function QueueDMATransfer


; ---------------------------------------------------------------------------
; Subroutine for issuing all VDP commands that were queued
; (by earlier calls to QueueDMATransfer)
; Resets the queue when it's done
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||

; sub_14AC: CopyToVRAM: IssueVDPCommands: Process_DMA: Process_DMA_Queue:
ProcessDMAQueue:
		; Interrupts should be disabled
		if def(__DEBUG__)
			tst.b	VBlank_MusicOnly
			bne.s	@interrupts_ok
			move.w	sr, -(sp)
			assert.b (sp), hs, #$26
			addq.w	#2, sp
		@interrupts_ok:
		endif

		lea	VDP_Ctrl, a5
		lea	DMAQueue, a1
; loc_14B6:
ProcessDMAQueue_Loop:
		move.w	(a1)+,d0
		beq.s	ProcessDMAQueue_Done ; branch if we reached a stop token
		; issue a set of VDP commands...
		move.w	d0,(a5)		; transfer length
		move.w	(a1)+,(a5)	; transfer length
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; source address
		move.w	(a1)+,(a5)	; destination
		move.w	(a1)+,(a5)	; destination
		cmpa.w	#$C8FC,a1
		bne.s	ProcessDMAQueue_Loop ; loop if we haven't reached the end of the buffer
; loc_14CE:
ProcessDMAQueue_Done:
		move.w	#0, DMAQueue			; put end marker at the start of the queue
		move.l	#DMAQueue, DMAQueuePos		; reset queue position to start
		rts
; End of function ProcessDMAQueue
; ---------------------------------------------------------------------------

*LoadPLC:
*LoadPLC2:
*LoadPLC_Direct:
	include	'modules\Pattern Load Cues.asm'

*EniDec:
	include 'modules\Enigma Decompressor.asm'

*KosPlusDec:
*KosPlusMDec_VRAM:
	include	'modules\Kosinski+ Decompressor.asm'

	; TODO: Completely replace remaining Kosinski art with Kosinski+, remove this decompressor
*KosDec:
	include	'modules\Kosinski Decompressor.asm'

; ---------------------------------------------------------------------------

	include	'modules\Draw Buffer.asm'

; ===========================================================================
; ---------------------------------------------------------------------------
; Palette cycling routine loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Load:				; XREF: Demo; Level_MainLoop; End_MainLoop
		tst.w	($FFFFFE02).w		; is level set to restart?
		bne.s	@nopalcycle		; if yes, branch
		tst.b	($FFFFFFE9).w		; is fade out currently in progress?
		bne.s	@nopalcycle		; if yes, branch
		tst.b	($FFFFFFB1).w		; is white flash in progress?
		bpl.s	@nopalcycle		; if yes, branch
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	@nopalcycle		; if yes, branch
		cmpi.b	#$C,($FFFFF600).w	; is game mode still level?
		bne.s	@nopalcycle		; if not, branch

		bsr	PCL_Load		; do pal cycle
@nopalcycle:
		rts
; ---------------------------------------------------------------------------

PCL_Load:
		moveq	#0,d2
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0 ; get level number
		add.w	d0,d0
		move.w	PalCycle(pc,d0.w),d0
		jsr	PalCycle(pc,d0.w)
		rts
; End of function PalCycle_Load

; ===========================================================================
; ---------------------------------------------------------------------------
; Palette cycling routines
; ---------------------------------------------------------------------------
PalCycle:	dc.w PalCycle_GHZ-PalCycle
		dc.w PalCycle_LZ-PalCycle
		dc.w PalCycle_MZ-PalCycle
		dc.w PalCycle_SLZ-PalCycle
		dc.w PalCycle_SYZ-PalCycle
		dc.w PalCycle_SBZ-PalCycle
		dc.w PalCycle_GHZ-PalCycle

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Title:				; XREF: TitleScreen
		lea	(Pal_TitleCyc).l,a0
		bra.s	loc_196A
; ===========================================================================

PalCycle_GHZ:				; XREF: PalCycle
	;	cmpi.w	#$002,($FFFFFE10).w
	;	bne.s	@0
	;	cmpi.b	#4,($FFFFFE30).w
	;	bne.s	locret_1990
@0:
		lea	(Pal_GHZCyc).l,a0

loc_196A:				; XREF: PalCycle_Title
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1990
		move.w	#4,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	($FFFFFB50).w,a1
		move.l	(a0,d0.w),d4
		move.l	4(a0,d0.w),d5
		
		move.w	d4,d0
		jsr	PissFilter 
		move.w	d0,(a1)+
		swap	d4
		move.w	d4,d0
		jsr	PissFilter
		move.w	d0,(a1)+
		
		move.w	d5,d0
		jsr	PissFilter
		move.w	d0,(a1)+
		swap	d5
		move.w	d5,d0
		jsr	PissFilter
		move.w	d0,(a1)+
		
locret_1990:
		rts	
; End of function PalCycle_Title


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_LZ:				; XREF: PalCycle
		subq.w	#1,($FFFFF634).w
		bpl.s	loc_19D8
		move.w	#2,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#3,d0
		lea	(Pal_LZCyc1).l,a0

		lea	($FFFFFB56).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	obMap(a0,d0.w),(a1)
		lea	($FFFFFAD6).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	obMap(a0,d0.w),(a1)

loc_19D8:
		move.w	($FFFFFE04).w,d0
		andi.w	#7,d0
		move.b	byte_1A3C(pc,d0.w),d0
		beq.s	locret_1A3A
		moveq	#1,d1
		tst.b	($FFFFF7C0).w
		beq.s	loc_19F0
		neg.w	d1

loc_19F0:
		move.w	($FFFFF650).w,d0
		andi.w	#3,d0
		add.w	d1,d0
		cmpi.w	#3,d0
		bcs.s	loc_1A0A
		move.w	d0,d1
		moveq	#0,d0
		tst.w	d1
		bpl.s	loc_1A0A
		moveq	#2,d0

loc_1A0A:
		move.w	d0,($FFFFF650).w
		add.w	d0,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	(Pal_LZCyc2).l,a0
		lea	($FFFFFB76).w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	obMap(a0,d0.w),(a1)
		lea	(Pal_LZCyc3).l,a0
		lea	($FFFFFAF6).w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	obMap(a0,d0.w),(a1)

locret_1A3A:
		rts	
; End of function PalCycle_LZ

; ===========================================================================
byte_1A3C:	dc.b 1,	0, 0, 1, 0, 0, 1, 0
; ===========================================================================

PalCycle_MZ:				; XREF: PalCycle
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_SLZ:				; XREF: PalCycle
		subq.w	#1,($FFFFF634).w
		bpl.w	PalCycle_SAP
		move.w	#5,($FFFFF634).w
		cmpi.w	#$3D0,($FFFFF726).w	; is boss playing?
		bne.s	@cont
		move.w	#2,($FFFFF634).w

@cont:
		move.w	($FFFFF632).w,d0
		addq.w	#1,d0
		cmpi.w	#6,d0
		bcs.s	loc_1A60
		moveq	#0,d0

loc_1A60:
		move.w	d0,($FFFFF632).w
		move.w	d0,d1
		add.w	d1,d1
		add.w	d1,d0
		add.w	d0,d0
		lea	(Pal_SLZCyc).l,a0
		lea	($FFFFFB56).w,a1
		move.w	(a0,d0.w),(a1)
		move.l	obGfx(a0,d0.w),obMap(a1)
; ---------------------------------------------------------------------------

PalCycle_SAP:
		cmpi.w	#$302,($FFFFFE10).w	; are we in SAP?
		bne.w	PCSLZ_Red_End		; if not, branch
		tst.b	($FFFFFF77).w		; is antigrav enabled?
		beq.w	PCSLZ_Red_End		; if not, branch
		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		bne.s	@dosappal		; if yes, branch
		move.b	#5,($FFFFFFBC).w	; fixate color to red
		bra.w	PCSLZ_Red_Cont		; skip all the other pal cycle stuff

@dosappal:

		; palette rotation for Sonic
cyoff = 4
cylen = 8
		move.w	#$2780,($FFFFD000+obGfx).w	; force Sonic to use palette line 2
		lea	($FFFFFB20).w,a2		; set start location
		btst	#3,(OptionsBits).w		; is cinematic HUD enabled?
		beq.s	@notcinematic			; if not, branch
		move.w	#$0780,($FFFFD000+obGfx).w	; welp
		lea	($FFFFFB00).w,a2		; have fun with the eyesore
@notcinematic:
		move.w	($FFFFFE04).w,d0		; load V-Blank counter into d0
		move.w	d0,d2				; copy to d2
		andi.w	#3,d0				; mask it against 3
		bne.s	@redwalls			; if result isn't 0, branch	
		move.w	cyoff(a2),d0			; load first blue colour of sonic's palette into d0
		moveq	#cylen-1,d1			; set loop counter to 7
		lea	cyoff+2(a2),a1			; load second blue colour into a1
@blueloop:	move.w	(a1),-2(a1)			; move colour to last spot
		adda.l	#2,a1				; increase location pointer
		dbf	d1,@blueloop			; loop
		move.w	d0,cyoff+(cylen-1)*2(a2)			; move first colour to last one

@redwalls:
		btst	#0,($FFFFFE05).w
		beq.s	PCSLZ_Red_End
		moveq	#0,d1
		addq.b	#1,($FFFFFFBC).w
		cmpi.b	#14,($FFFFFFBC).w
		bne.s	PCSLZ_Red_Cont
		move.b	#0,($FFFFFFBC).w
PCSLZ_Red_Cont:
		move.b	($FFFFFFBC).w,d1
		andi.w	#$000F,d1
		add.b	d1,d1
		lea	(PCSLZ_Red).l,a1
		adda.w	d1,a1
		lea	($FFFFFB44).w,a2
		moveq	#4,d2
PCSLZ_Red_Loop:
		move.w	(a1),(a2)
		adda.w	#14*2,a1
		adda.w	#2,a2
		dbf	d2,PCSLZ_Red_Loop
		move.w	(a1),($FFFFFB5E).w

PCSLZ_Red_End:
		move.w	($FFFFFE04).w,d0
		andi.w	#%111,d0
		bne.s	@end
		lea	($FFFFFB60+$10).w,a1
		jsr	RandomNumber
		moveq	#4,d0

@loop:
		ror.l	#1,d1
		move.w	d1,d2
		andi.w	#$E62,d2
		ori.w	#%1100 0100 0010,d2
		move.w	d2,(a1)+
		dbf	d0,@loop
@end:
		rts

; End of function PalCycle_SLZ

; ---------------------------------------------------------------------------
PCSLZ_Red:
	dc.w	$0222, $0002, $0002, $0002, $0002, $0002, $0002, $0002, $0002, $0002, $0002, $0002, $0002, $0002
	dc.w	$0444, $0224, $0004, $0004, $0004, $0004, $0004, $0004, $0004, $0004, $0004, $0004, $0004, $0224
	dc.w	$0666, $0446, $0226, $0006, $0006, $0006, $0006, $0006, $0006, $0006, $0006, $0006, $0226, $0446
	dc.w	$0888, $0668, $0448, $0228, $0008, $0008, $0008, $0008, $0008, $0008, $0008, $0228, $0448, $0668
	dc.w	$0AAA, $088A, $066A, $044A, $022A, $000A, $000A, $000A, $000A, $000A, $022A, $044A, $066A, $088A
	dc.w	$0EEE, $0CCE, $0AAE, $088E, $066E, $044E, $022E, $000E, $022E, $044E, $066E, $088E, $0AAE, $0CCE
	even
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_SYZ:				; XREF: PalCycle
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1AC6
		move.w	#5,($FFFFF634).w

		; palcycle protection for the trophy gallery
		move.w	($FFFFF700).w,d1	; get camera X pos
		cmpi.w	#$00B0,d1		; trophy gallery out of sight to the left?
		bls.s	@dopalcycle		; if yes, branch
		cmpi.w	#$0300,d1		; trophy galelry out of sight to the right?
		bhs.s	@dopalcycle		; if yes, branch
		moveq	#0,d0			; force to start of palcycle
		bra.s	@nopalcycle		; skip
@dopalcycle:
		move.w	($FFFFF632).w,d0
		addq.w	#1,($FFFFF632).w
		andi.w	#3,d0
		lsl.w	#2,d0
@nopalcycle:
		move.w	d0,d1
		add.w	d0,d0
		lea	(Pal_SYZCyc1).l,a0
		lea	($FFFFFB6E).w,a1
		move.l	(a0,d0.w),(a1)+
		move.l	4(a0,d0.w),(a1)
		lea	(Pal_SYZCyc2).l,a0
		lea	($FFFFFB76).w,a1
		move.w	(a0,d1.w),(a1)
		move.w	2(a0,d1.w),4(a1)

locret_1AC6:
		rts	
; End of function PalCycle_SYZ


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

PalCycle_SBZ:
		lea	(Pal_SBZCycList2).l,a2
		lea	($FFFFF650).w,a1
		move.w	(a2)+,d1

		cmpi.w	#$500,($FFFFFE10).w
		bne.s	loc_1AE0
		tst.b	($FFFFFFC8).w
		beq.s	loc_1AE0
		move.w	#7,d1

loc_1AE0:
		subq.b	#1,(a1)
		bmi.s	loc_1AEA
		addq.l	#2,a1
		addq.l	#6,a2
		bra.s	loc_1B06
; ===========================================================================

loc_1AEA:				; XREF: PalCycle_SBZ
		move.b	(a2)+,(a1)+
		move.b	(a1),d0
		addq.b	#1,d0
		cmp.b	(a2)+,d0
		bcs.s	loc_1AF6
		moveq	#0,d0

loc_1AF6:
		move.b	d0,(a1)+
		andi.w	#$F,d0
		add.w	d0,d0
		movea.w	(a2)+,a0
		movea.w	(a2)+,a3
		move.w	(a0,d0.w),(a3)

loc_1B06:				; XREF: PalCycle_SBZ
		dbf	d1,loc_1AE0
		subq.w	#1,($FFFFF634).w
		bpl.s	locret_1B64
		lea	(Pal_SBZCyc4).l,a0
		move.w	#2,($FFFFF634).w
		tst.b	($FFFFFE11).w
		beq.s	loc_1B2E
		lea	(Pal_SBZCyc10).l,a0
		move.w	#0,($FFFFF634).w

loc_1B2E:
		moveq	#-1,d1
		tst.b	($FFFFF7C0).w
		beq.s	loc_1B38
		neg.w	d1

loc_1B38:
		move.w	($FFFFF632).w,d0
		andi.w	#3,d0
		add.w	d1,d0
		cmpi.w	#3,d0
		bcs.s	loc_1B52
		move.w	d0,d1
		moveq	#0,d0
		tst.w	d1
		bpl.s	loc_1B52
		moveq	#2,d0

loc_1B52:
		move.w	d0,($FFFFF632).w
		add.w	d0,d0
		lea	($FFFFFB58).w,a1
		move.l	(a0,d0.w),(a1)+
		move.w	obMap(a0,d0.w),(a1)

locret_1B64:
		rts	
; End of function PalCycle_SBZ


; ===========================================================================
Pal_TitleCyc:	incbin	palette\c_title.bin
Pal_GHZCyc:	incbin	palette\c_ghz.bin
Pal_LZCyc1:	incbin	palette\c_lz_wat.bin	; waterfalls palette
Pal_LZCyc2:	incbin	palette\c_lz_bel.bin	; conveyor belt palette
Pal_LZCyc3:	incbin	palette\c_lz_buw.bin	; conveyor belt (underwater) palette
Pal_SLZCyc:	incbin	palette\c_slz.bin
Pal_SYZCyc1:	incbin	palette\c_syz_1.bin
Pal_SYZCyc2:	incbin	palette\c_syz_2.bin
; ===========================================================================

Pal_SBZCycList2: 
		dc.w 6
		dc.b 7,	8
		dc.w Pal_SBZCyc1
		dc.w $FB50
		dc.b $D, 8
		dc.w Pal_SBZCyc2
		dc.w $FB52
		dc.b 9,	8
		dc.w Pal_SBZCyc9
		dc.w $FB70
		dc.b 7,	8
		dc.w Pal_SBZCyc6
		dc.w $FB72
		dc.b 3,	3
		dc.w Pal_SBZCyc8
		dc.w $FB78
		dc.b 3,	3
		dc.w Pal_SBZCyc8+2
		dc.w $FB7A
		dc.b 3,	3
		dc.w Pal_SBZCyc8+4
		dc.w $FB7C
		dc.b 3, 8
		dc.w Pal_SBZCyc2
		dc.w $FB32
		even

Pal_SBZCyc1:	incbin	palette\c_sbz_1.bin
Pal_SBZCyc2:	incbin	palette\c_sbz_2.bin
Pal_SBZCyc3:	incbin	palette\c_sbz_3.bin
Pal_SBZCyc4:	incbin	palette\c_sbz_4.bin
Pal_SBZCyc5:	incbin	palette\c_sbz_5.bin
Pal_SBZCyc6:	incbin	palette\c_sbz_6.bin
Pal_SBZCyc7:	incbin	palette\c_sbz_7.bin
Pal_SBZCyc8:	incbin	palette\c_sbz_8.bin
Pal_SBZCyc9:	incbin	palette\c_sbz_9.bin
Pal_SBZCyc10:	incbin	palette\c_sbz_10.bin
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	fade from black
; ---------------------------------------------------------------------------

; PaletteFadeIn:
Pal_FadeTo:
		move.w	#$3F,($FFFFF626).w

Pal_FadeTo2:
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		moveq	#0,d1
		move.b	($FFFFF627).w,d0
Pal_ToBlack:	move.w	d1,(a0)+
		dbf	d0,Pal_ToBlack	; fill palette with $000	(black)

		moveq	#$E,d4					; MJ: prepare maximum colour check
		moveq	#0,d6					; MJ: clear d6
loc_1DCE:
		movem.l	d4/d6, -(sp)
		bsr.w	PLC_Execute
		movem.l	(sp)+, d4/d6
		move.b	#$12,VBlankRoutine
		bsr.w	DelayProgram
		bchg	#0,d6					; MJ: change delay counter
		beq	loc_1DCE				; MJ: if null, delay a frame

		bsr.s	Pal_FadeIn
		subq.b	#2,d4					; MJ: decrease colour check
		bne	loc_1DCE				; MJ: if it has not reached null, branch
		move.b	#$12,VBlankRoutine			; MJ: wait for V-blank again (so colours transfer)
		bra.w	DelayProgram				; MJ: ''
; ===========================================================================

;FadeIn_FromBlack:
Pal_FadeIn:				; XREF: Pal_FadeTo
		moveq	#0,d0
		lea	($FFFFFB00).w,a0	; destination
		lea	($FFFFFB80).w,a1	; source
		move.b	($FFFFF626).w,d0	; number of colors to affect
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1DFA:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1DFA

		cmpi.b	#1,($FFFFFE10).w	; are we in LZ?
		bne.s	locret_1E24		; if not, branch
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		lea	($FFFFFA00).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1E1E:
		bsr.s	Pal_AddColor
		dbf	d0,loc_1E1E

locret_1E24:
		rts	
; ===========================================================================

;FadeIn_AddColor:
Pal_AddColor:				; XREF: Pal_FadeIn
		move.b	(a1),d5					; MJ: load blue
		move.w	(a1)+,d1				; MJ: load green and red
		move.b	d1,d2					; MJ: load red
		lsr.b	#$04,d1					; MJ: get only green
		andi.b	#$0E,d2					; MJ: get only red
		move.w	(a0),d3					; MJ: load current colour in buffer
		cmp.b	d5,d4					; MJ: is it time for blue to fade?
		bhi	FCI_NoBlue				; MJ: if not, branch
		addi.w	#$0200,d3				; MJ: increase blue

FCI_NoBlue:
		cmp.b	d1,d4					; MJ: is it time for green to fade?
		bhi	FCI_NoGreen				; MJ: if not, branch
		addi.b	#$20,d3					; MJ: increase green

FCI_NoGreen:
		cmp.b	d2,d4					; MJ: is it time for red to fade?
		bhi	FCI_NoRed				; MJ: if not, branch
		addq.b	#$02,d3					; MJ: increase red

FCI_NoRed:
		move.w	d3,(a0)+				; MJ: save colour
		rts						; MJ: return

; End of function Pal_FadeIn

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to fade out to black
; ---------------------------------------------------------------------------

;PaletteFadeOut:
Pal_FadeFrom:
		move.b	#1,($FFFFFFE9).w	; set flag that fade-out is in progress

		move.w	#$3F,($FFFFF626).w
		moveq	#$07,d4					; MJ: set repeat times
		moveq	#$00,d6					; MJ: clear d6
loc_1E5C:
		bsr.w	PLC_Execute
		
		move.b	#$12,VBlankRoutine
		bsr.w	DelayProgram
		bchg	#$00,d6					; MJ: change delay counter
		beq	loc_1E5C				; MJ: if null, delay a frame
		bsr.s	Pal_FadeOut
		dbf	d4,loc_1E5C

		move.b	#0,($FFFFFFE9).w	; unset flag that fade-out is in progress
		rts	
; ===========================================================================

;FadeOut_ToBlack:
Pal_FadeOut:				; XREF: Pal_FadeFrom
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1E82:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E82

		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1E98:
		bsr.s	Pal_DecColor
		dbf	d0,loc_1E98
		rts	
; ===========================================================================

;FadeOut_DecColor:
Pal_DecColor:				; XREF: Pal_FadeOut
		move.w	(a0),d5					; MJ: load colour
		move.w	d5,d1					; MJ: copy to d1
		move.b	d1,d2					; MJ: load green and red
		move.b	d1,d3					; MJ: load red
		andi.w	#$0E00,d1				; MJ: get only blue
		beq	FCO_NoBlue				; MJ: if blue is finished, branch
		subi.w	#$0200,d5				; MJ: decrease blue

FCO_NoBlue:
		andi.b	#$E0,d2					; MJ: get only green
		beq	FCO_NoGreen				; MJ: if green is finished, branch
		subi.b	#$20,d5					; MJ: decrease green

FCO_NoGreen:
		andi.b	#$0E,d3					; MJ: get only red
		beq	FCO_NoRed				; MJ: if red is finished, branch
		subq.b	#$02,d5					; MJ: decrease red

FCO_NoRed:
		move.w	d5,(a0)+				; MJ: save new colour
		rts						; MJ: return
; End of function Pal_FadeFrom

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	fade to white (special stage)
; ---------------------------------------------------------------------------

;PaletteWhiteIn
Pal_MakeWhite:				; XREF: SpecialStage
		move.w	#$3F,($FFFFF626).w
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.w	#$EEE,d1
		move.b	($FFFFF627).w,d0

PalWhite_Loop:
		move.w	d1,(a0)+
		dbf	d0,PalWhite_Loop
		move.w	#$15,d5

loc_1EF4:
		move.b	#$12,VBlankRoutine
		bsr	DelayProgram
		bsr.s	Pal_WhiteToBlack

	;	bsr	PLC_Execute	; this was in the original game, now it just causes trouble

		dbf	d5,loc_1EF4
		rts
; ===========================================================================

;WhiteIn_FromWhite:
Pal_WhiteToBlack:			; XREF: Pal_MakeWhite
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		lea	($FFFFFB80).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1F20:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F20

		cmpi.b	#$10,($FFFFF600).w	; is game mode = special stage?
		bne.s	Pal_NoSpecial		; if not, branch
		move.w	#$EEE,($FFFFFB58).w	; make sure a specific colour is always white

Pal_NoSpecial:
		cmpi.b	#1,($FFFFFE10).w
		bne.s	locret_1F4A
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		lea	($FFFFFA00).w,a1
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		adda.w	d0,a1
		move.b	($FFFFF627).w,d0

loc_1F44:
		bsr.s	Pal_DecColor2
		dbf	d0,loc_1F44

locret_1F4A:
		rts	
; ===========================================================================

;WhiteIn_DecColor:
Pal_DecColor2:				; XREF: Pal_WhiteToBlack
		move.w	(a1)+,d2	; get current source color
		move.w	(a0),d3		; get current target color
		move.w	d3,d4		; copy for later
		cmp.w	d2,d3		; are they identical?
		beq.s	loc_1F78	; if yes, we already reached our source color

		andi.w	#$EEE,d2
		andi.w	#$EEE,d4
		subi.w	#$200,d4	; decrease blue	value
		bcs.s	loc_1F64	; if we reached black, branch
		cmp.w	d2,d4		; did we reach the source color?
		bcs.s	loc_1F64	; if yes, branch
		subi.w	#$200,d3	; decrease blue	value

loc_1F64:				; XREF: Pal_DecColor2
		andi.w	#$0EE,d2
		andi.w	#$0EE,d4
		subi.w	#$20,d4		; decrease green value
		bcs.s	loc_1F74	; if we reached black, branch
		cmp.w	d2,d4		; did we reach the source color?
		bcs.s	loc_1F74	; if yes, branch
		subi.w	#$20,d3		; decrease green value

loc_1F74:				; XREF: loc_1F64
		andi.w	#$00E,d2
		andi.w	#$00E,d4
		subi.w	#2,d4		; decrease red value
		bcs.s	loc_1F78	; if we reached black, branch
		cmp.w	d2,d4		; did we reach the source color?
		bcs.s	loc_1F78	; if yes, branch
		subi.w	#2,d3		; decrease red value

loc_1F78:				; XREF: Pal_DecColor2
		move.w	d3,(a0)+	; write updated color
		rts	
; End of function Pal_MakeWhite

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	fade to white (Special Stage)
; ---------------------------------------------------------------------------

;PaletteWhiteOut:
Pal_MakeFlash:				; XREF: SpecialStage
		move.b	#1,($FFFFFFE9).w	; set flag that fade-out is in progress

		move.w	#$3F,($FFFFF626).w
		move.w	#$15,d4

loc_1F86:
		move.b	#$12,VBlankRoutine
		bsr	DelayProgram
		bsr.s	Pal_ToWhite
		bsr	PLC_Execute
		dbf	d4,loc_1F86

		move.b	#0,($FFFFFFE9).w	; unset flag that fade-out is in progress
		rts	
; ===========================================================================

;WhiteOut_ToWhite:
Pal_ToWhite:				; XREF: Pal_MakeFlash
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1FAC:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FAC
		moveq	#0,d0
		lea	($FFFFFA80).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.b	($FFFFF627).w,d0

loc_1FC2:
		bsr.s	Pal_AddColor2
		dbf	d0,loc_1FC2
		rts	
; ===========================================================================

;WhiteOut_AddColour:
Pal_AddColor2:				; XREF: Pal_ToWhite
		move.w	(a0),d2		; get current color
		cmpi.w	#$EEE,d2	; is it already full white?
		beq.s	loc_2006	; if yes, branch
		move.w	d2,d1		; move current color to d1
		andi.w	#$E,d1		; get only red part
		cmpi.w	#$E,d1		; is it at full redness?
		beq.s	loc_1FE2	; if yes, branch
		addq.w	#2,(a0)		; increase red value

loc_1FE2:				; XREF: Pal_AddColor2
		move.w	d2,d1		; move current color to d1
		andi.w	#$E0,d1		; get only green part
		cmpi.w	#$E0,d1		; is it at full greenness?
		beq.s	loc_1FF4	; if yes, branch
		addi.w	#$20,(a0)	; increase green value

loc_1FF4:				; XREF: loc_1FE2
		move.w	d2,d1		; move current color to d1
		andi.w	#$E00,d1	; get only blue part
		cmpi.w	#$E00,d1	; is it at full blueness?
		beq.s	loc_2006	; if yes, branch
		addi.w	#$200,(a0)	; increase blue	value

loc_2006:				; XREF: Pal_AddColor2
		addq.w	#2,a0		; go to next color
		rts	
; End of function Pal_MakeFlash
; ===========================================================================

Pal_CutToBlack:
		lea	($FFFFFB00).w,a0
		moveq	#$000,d0
		move.w	#$40-1,d1
@fillblack:
		move.w	d0,(a0)+
		dbf	d1,@fillblack
		rts
; ---------------------------------------------------------------------------

Pal_CutToWhite:
		lea	($FFFFFB00).w,a0
		move.w	#$EEE,d0
		move.w	#$40-1,d1
@fillwhite:
		move.w	d0,(a0)+
		dbf	d1,@fillwhite
		rts
; ===========================================================================

		
; ===========================================================================
; ---------------------------------------------------------------------------
; Palette cycling routine - Sega logo
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_Sega:				; XREF: SegaScreen
		tst.b	($FFFFF635).w
		bne.s	loc_206A
		lea	($FFFFFB20).w,a1
		lea	(Pal_Sega1).l,a0
		moveq	#5,d1
		move.w	($FFFFF632).w,d0

loc_2020:
		bpl.s	loc_202A
		addq.w	#2,a0
		subq.w	#1,d1
		addq.w	#2,d0
		bra.s	loc_2020
; ===========================================================================

loc_202A:				; XREF: PalCycle_Sega
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	loc_2034
		addq.w	#2,d0

loc_2034:
		cmpi.w	#$60,d0
		bcc.s	loc_203E
		move.w	(a0)+,(a1,d0.w)

loc_203E:
		addq.w	#2,d0
		dbf	d1,loc_202A
		move.w	($FFFFF632).w,d0
		addq.w	#2,d0
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	loc_2054
		addq.w	#2,d0

loc_2054:
		cmpi.w	#$64,d0
		blt.s	loc_2062
		move.w	#$401,($FFFFF634).w
		moveq	#-$C,d0

loc_2062:
		move.w	d0,($FFFFF632).w
		moveq	#1,d0
		rts	
; ===========================================================================

loc_206A:				; XREF: loc_202A
		subq.b	#1,($FFFFF634).w
		bpl.s	loc_20BC
		move.b	#4,($FFFFF634).w
		move.w	($FFFFF632).w,d0
		addi.w	#$C,d0
		cmpi.w	#$30,d0
		bcs.s	loc_2088
		moveq	#0,d0
		rts	
; ===========================================================================

loc_2088:				; XREF: loc_206A
		move.w	d0,($FFFFF632).w
		lea	(Pal_Sega2).l,a0
		lea	(a0,d0.w),a0
		lea	($FFFFFB04).w,a1
		move.l	(a0)+,(a1)+
		move.l	(a0)+,(a1)+
		move.w	(a0)+,(a1)
		lea	($FFFFFB20).w,a1
		moveq	#0,d0
		moveq	#$2C,d1

loc_20A8:
		move.w	d0,d2
		andi.w	#$1E,d2
		bne.s	loc_20B2
		addq.w	#2,d0

loc_20B2:
		move.w	(a0),(a1,d0.w)
		addq.w	#2,d0
		dbf	d1,loc_20A8

loc_20BC:
		moveq	#1,d0
		rts	
; End of function PalCycle_Sega

; ===========================================================================

Pal_Sega1:	incbin	palette\sega1.bin
Pal_Sega2:	incbin	palette\sega2.bin
Pal_Sega2OG:	incbin	palette\sega2_original.bin

; ---------------------------------------------------------------------------
; Subroutines to load pallets
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalLoad1:
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2		; pointer
		movea.w	(a1)+,a3		; RAM address
		adda.w	#$80,a3
		move.w	(a1)+,d7		; (palette length / 2) - 1
		
		bra.s	loc_2128
; End of function PalLoad1


; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||
	

PalLoad2:	; virtually identical to PalLoad1, except the missing +$80 on a3
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		move.w	(a1)+,d7

loc_2128:
		move.w	(a2)+,d0
		bsr	PissFilter
		move.w	d0,(a3)+
		move.w	(a2)+,d0
		bsr	PissFilter
		move.w	d0,(a3)+
		dbf	d7,loc_2128
		rts
; End of function PalLoad2

; ---------------------------------------------------------------------------
; Underwater palette loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||


PalLoad3_Water:	; this subroutine is for palette line 1
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$80,a3
		move.w	(a1)+,d7

loc_2144:
		move.w	(a2)+,d0
		bsr	PissFilter
		move.w	d0,(a3)+
		move.w	(a2)+,d0
		bsr	PissFilter
		move.w	d0,(a3)+
		dbf	d7,loc_2144
		rts
; End of function PalLoad3_Water


; ||||||||||||||| S U B R O U T I N E |||||||||||||||||||||||||||||||||||||||


PalLoad4_Water:	; this subroutine is for palette lines 2-4
		lea	(PalPointers).l,a1
		lsl.w	#3,d0
		adda.w	d0,a1
		movea.l	(a1)+,a2
		movea.w	(a1)+,a3
		suba.w	#$100,a3
		move.w	(a1)+,d7

loc_2160:
		move.w	(a2)+,d0
		bsr	PissFilter
		move.w	d0,(a3)+
		move.w	(a2)+,d0
		bsr	PissFilter
		move.w	d0,(a3)+
		dbf	d7,loc_2160
		rts
; End of function PalLoad4_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to turn the entire palette into grayscale
; ---------------------------------------------------------------------------

Pal_MakeBlackWhite:
		lea	($FFFFFA80).w,a3 	; get palette index

Pal_MakeBlackWhite2:
		lea	($FFFFC910).w,a4	; backup palette location
		moveq	#0,d3			; clear d3
		move.w	#$7F,d3			; set d3 to $3F (+1 for the first run)

Pal_MBW_Loop:
		moveq	#0,d0			; clear d0
		move.w	(a3),d0			; get colour
		move.w	d0,(a4)+		; backup colour
		bsr.s	Pal_AsGrayscale		; convert current color to grayscale
		move.w	d0,(a3)+		; set new colour
		
		dbf	d3,Pal_MBW_Loop		; loop for each colour
		rts
; ---------------------------------------------------------------------------

; Turn the given color into grayscale
; input/output = d0
Pal_AsGrayscale:
		moveq	#0,d1			; clear d1
		moveq	#0,d2			; clear d1

		; sum up the values of the individual RGB channels
		move.b	d0,d1			; copy Green and Red of colour to d1
		lsr.b	#4,d1			; get only Green amount
		move.b	d0,d2			; copy Green and Red of colour to d2
		andi.b	#$E,d2			; get only Red amount
		lsr.w	#8,d0			; get only Blue amount of d0
		add.b	d1,d0			; add Green amount to Blue amount
		add.b	d2,d0			; then add Red to the amount
		
		; calculate average
		divu.w	#3,d0			; divide by 3
		andi.b	#$E,d0			; keep it an even value (Keep 9-bit VDP)
		move.b	d0,d1			; copy to d1

		; copy average to all three channels
		lsl.b	#4,d1			; shift to left nybble
		add.b	d1,d0			; add to d0 (Setting the green)
		lsl.w	#4,d1			; shift to next left nybble
		add.w	d1,d0			; add to d0 (Setting the blue)

		rts
; End of function Pal_MakeBlackWhite
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Contrast boosting a single color in d0
; ---------------------------------------------------------------------------

ColorBoostB = $C
ColorBoostG = $4

; ContrastBoost:
PissFilter:
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	PissFilter_Do		; if yes, enable piss filter anywhere

		; GHP piss filter
		move.b	($FFFFF600).w,d1	; get current
		andi.b	#$0F,d1			; include the level pre-sequence ($8C)
		cmpi.b	#$C,d1			; are we in a level?
		bne.s	PissFilter_End		; if not, don't do filer
		cmpi.w	#$000,($FFFFFE10).w	; are we in Night Hill Place?
		bne.s	@notnhp			; if not, branch
		cmpi.b	#2,($FFFFFFAA).w	; has the crabmeat boss been defeated?
		beq.s	PissFilter_Do		; if yes, start contrast already
		bra.s	PissFilter_End		; otherwise, don't
@notnhp:	cmpi.w	#$002,($FFFFFE10).w	; are we in Green Hill Place?
		bne.s	PissFilter_End		; if not, branch
		cmpi.b	#4,($FFFFFE30).w	; did we hit the final checkpoint yet?
		beq.s	PissFilter_End		; if yes, branch

PissFilter_Do:
		move.w	d0,d1			; copy color

		ror.w	#4,d1			; get green color
		move.w	d1,d2			; copy to d2
		andi.w	#$00E,d2		; limit to one channel

		cmpi.w	#ColorBoostG,d2		; are we at or avobe the minimum value?
		bge.s	@decreaseG		; if yes, decrease
		moveq	#0,d2			; otherwise, set green 0
		bra.s	@applyG			; skip
@decreaseG:	subi.w	#ColorBoostG,d2		; decrease green value

@applyG:
		ror.w	#4,d1			; get blue color
		move.w	d1,d3			; copy to d3
		andi.w	#$00E,d3		; limit to one channel
		
		cmpi.w	#ColorBoostB,d3		; are we at or avobe the minimum value?
		bge.s	@decrease		; if yes, decrease
		moveq	#0,d3			; otherwise, set blue 0
		bra.s	@apply			; skip
@decrease:	subi.w	#ColorBoostB,d3		; decrease blue value

@apply:
		rol.w	#4,d2			; prepare for merge
		rol.w	#8,d3			; prepare for merge
		or.w	d2,d3			; merge green and blue channel
		andi.w	#$000E,d0		; clear the previous upper byte of the previous color
		or.w	d3,d0			; merge with new red value
PissFilter_End:
		rts
; ---------------------------------------------------------------------------
; ===========================================================================



; ===========================================================================
; ---------------------------------------------------------------------------
; Palette pointers
; ---------------------------------------------------------------------------
PalPointers:
	;    palette		RAM   length/2-1
	dc.l Pal_SegaBG,	$FB00 001F	; $00
	dc.l Pal_Title,		$FB00 001F	; $01
	dc.l Pal_LevelSel,	$FB00 001F	; $02
	dc.l Pal_Sonic,		$FB00 0007	; $03
	dc.l Pal_GHZ,		$FB20 0017	; $04
	dc.l Pal_LZ2,		$FB20 0017	; $05
	dc.l Pal_MZ,		$FB20 0017	; $06
	dc.l Pal_SLZ,		$FB20 0017	; $07
	dc.l Pal_SYZ,		$FB20 0017	; $08
	dc.l Pal_SBZ2,		$FB20 0017	; $09
	dc.l Pal_Special,	$FB00 001F	; $0A
	dc.l Pal_LZWater2,	$FB00 001F	; $0B
	dc.l Pal_GHZ3,		$FB20 0017	; $0C
	dc.l Pal_GHZ2,		$FB20 0017	; $0D
	dc.l Pal_FZ,		$FB20 0017	; $0E
	dc.l Pal_LZSonWater,	$FB00 0007	; $0F
	dc.l Pal_SonicAntigrav,	$FB00 0007	; $10
	dc.l Pal_SonicAntigrav,	$FB20 0007	; $11
	dc.l Pal_SpeContinue,	$FB00 000F	; $12
	dc.l Pal_GHZ2,		$FB20 001F	; $13
	dc.l STS_Palette,	$FB00 001F	; $14
	dc.l Pal_BCutscene,	$FB20 001F	; $15
	dc.l Pal_SpecialEaster,	$FB00 001F	; $16
	dc.l Pal_LZWater2_Evil,	$FB00 001F	; $17
	even

; ---------------------------------------------------------------------------
; Palette data
; ---------------------------------------------------------------------------
Pal_SegaBG:		incbin	palette\sega_bg.bin
Pal_Title:		incbin	palette\title.bin
Pal_LevelSel:		incbin	Screens\OptionsScreen\Options_Pal.bin
Pal_Sonic:		incbin	palette\sonic.bin
Pal_SonicAntigrav:	incbin	palette\sonic_antigrav.bin
Pal_GHZ:		incbin	palette\ghz.bin
Pal_GHZ2:		incbin	palette\ghz2.bin
Pal_GHZ3:		incbin	palette\ghz3.bin
Pal_LZ2:		incbin	palette\lz2.bin
Pal_LZWater2:		incbin	palette\lz_uw2.bin
Pal_MZ:			incbin	palette\mz.bin
Pal_SLZ:		incbin	palette\slz.bin
Pal_SYZ:		incbin	palette\syz.bin
Pal_SYZGray:
		dc.w	$0222,$0000,$0444,$0666,$0888,$0CCC,$0EEE,$0AAA,$0888,$0444,$0AAA,$0666,$00EE,$0088,$0044,$0444
		dc.w	$0444,$0000,$0EEE,$0AAA,$0888,$0666,$0222,$0222,$0000,$0AAA,$0666,$0222,$0EEE,$0888,$0666,$0000
		dc.w	$0444,$0000,$0666,$0888,$0AAA,$0CCC,$0EEE,$0444,$0000,$0888,$0666,$0EEE,$0222,$0444,$0888,$0000
		even
	
	
Pal_SBZ2:		incbin	palette\fz.bin
Pal_FZ:			incbin	palette\fz.bin
Pal_Special:		incbin	palette\special.bin
Pal_LZSonWater:		incbin	palette\son_lzuw.bin
Pal_SpeContinue:	incbin	palette\sscontin.bin
Pal_Ending:		incbin	palette\ending.bin
Pal_Null:		incbin	palette\null.bin
Pal_BCutscene:		incbin	palette\bombcutscene.bin
Pal_SpecialEaster:	incbin	palette\specialeaster.bin
Pal_LZWater2_Evil:	incbin	palette\lz_uw2_evil.bin
Pal_ERaZorBanner:	incbin	palette\ERaZor.bin

; ---------------------------------------------------------------------------
; Subroutine to	delay the program by ($FFFFF62A) frames
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DelayProgram:			; XREF: PauseGame
		move	#$2300,sr	; enable interrupts
		movem.l	d0-d2, -(sp)
		movem.l	VSyncWaitTicks_64bit, d0-d1	; load 64-bit number
		moveq	#0, d2

	@WaitVBlank:
			addq.l	#1, d1			; 64-bit math (uses Blast processing(tm))
			addx.l	d2, d0			; ''
			tst.b	VBlankRoutine
			bne.s	@WaitVBlank

		movem.l	d0-d1, VSyncWaitTicks_64bit
		movem.l	(sp)+, d0-d2
		rts	
; End of function DelayProgram

; ---------------------------------------------------------------------------
; Subroutine to	generate a pseudo-random number	in d0
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

CurrentRandomNumber equ	$FFFFF636

RandomNumber:
		move.l	(CurrentRandomNumber).w,d1
		bne.s	loc_29C0
		move.l	#$2A6D365A,d1
loc_29C0:
		move.l	d1,d0
		asl.l	#2,d1
		add.l	d0,d1
		asl.l	#3,d1
		add.l	d0,d1
		move.w	d1,d0
		swap	d1
		add.w	d1,d0

		move.w	d0,d1
		swap	d1
		move.l	d1,(CurrentRandomNumber).w
		rts
; End of function RandomNumber


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcSine:				; XREF: SS_BGAnimate; et al
		andi.w	#$FF,d0
		add.w	d0,d0
		addi.w	#$80,d0
		move.w	Sine_Data(pc,d0.w),d1
		subi.w	#$80,d0
		move.w	Sine_Data(pc,d0.w),d0
		rts	
; End of function CalcSine

; ===========================================================================

Sine_Data:	incbin	misc\sinewave.bin	; values for a 360? sine wave

; ===========================================================================
		movem.l	d1-d2,-(sp)
		move.w	d0,d1
		swap	d1
		moveq	#0,d0
		move.w	d0,d1
		moveq	#7,d2

loc_2C80:
		rol.l	#2,d1
		add.w	d0,d0
		addq.w	#1,d0
		sub.w	d0,d1
		bcc.s	loc_2C9A
		add.w	d0,d1
		subq.w	#1,d0
		dbf	d2,loc_2C80
		lsr.w	#1,d0
		movem.l	(sp)+,d1-d2
		rts	
; ===========================================================================

loc_2C9A:
		addq.w	#1,d0
		dbf	d2,loc_2C80
		lsr.w	#1,d0
		movem.l	(sp)+,d1-d2
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CalcAngle:
		movem.l	d3-d4,-(sp)
		moveq	#0,d3
		moveq	#0,d4
		move.w	d1,d3
		move.w	d2,d4
		or.w	d3,d4
		beq.s	loc_2D04
		move.w	d2,d4
		tst.w	d3
		bpl.w	loc_2CC2
		neg.w	d3

loc_2CC2:
		tst.w	d4
		bpl.w	loc_2CCA
		neg.w	d4

loc_2CCA:
		cmp.w	d3,d4
		bcc.w	loc_2CDC
		lsl.l	#8,d4
		divu.w	d3,d4
		moveq	#0,d0
		move.b	Angle_Data(pc,d4.w),d0
		bra.s	loc_2CE6
; ===========================================================================

loc_2CDC:				; XREF: CalcAngle
		lsl.l	#8,d3
		divu.w	d4,d3
		moveq	#$40,d0
		sub.b	Angle_Data(pc,d3.w),d0

loc_2CE6:
		tst.w	d1
		bpl.w	loc_2CF2
		neg.w	d0
		addi.w	#$80,d0

loc_2CF2:
		tst.w	d2
		bpl.w	loc_2CFE
		neg.w	d0
		addi.w	#$100,d0

loc_2CFE:
		movem.l	(sp)+,d3-d4
		rts	
; ===========================================================================

loc_2D04:				; XREF: CalcAngle
		move.w	#$40,d0
		movem.l	(sp)+,d3-d4
		rts	
; End of function CalcAngle

; ===========================================================================

Angle_Data:	incbin	misc\angles.bin

; ===========================================================================

SineWavePalette:
		move.w	($FFFFFE0E).w,d0
		lsl.w	#5,d0
		jsr	CalcSine
		cmpi.w	#$100,d0
		bne.s	@contff
		subq.w	#1,d0
		
@contff:
		addi.w	#$100,d0
		tst.w	d0
		bne.s	@cont
		cmpi.w	#12,($FFFFFF6C).w
		beq.s	@contx
		addq.w	#4,($FFFFFF6C).w
		cmpi.w	#12,($FFFFFF6C).w
		bne.s	@cont

@contx:
		clr.w	($FFFFFF6C).w
		
@cont:
		lsr.w	#5,d0
		move.w	($FFFFFF6C).w,d1
		lsl.w	d1,d0
		andi.w	#$00E,d0
		move.w	d0,(a1)
	;	move.w	d0,($FFFFFB40).w
		rts

; ---------------------------------------------------------------------------
; Sega screen
; ---------------------------------------------------------------------------

SegaScreen:				; XREF: GameModeArray
		move.b	#$E4,d0
		bsr	PlaySound_Special ; stop music
		bsr	PLC_ClearQueue
		bsr	Pal_FadeFrom
		display_disable
		VBlank_SetMusicOnly

		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$8700,(a6)
		move.w	#$8B03,(a6)
		clr.b	($FFFFF64E).w
		bsr	ClearScreen

		lea	($FFFFCC00).w,a1
		moveq	#0,d0
		move.w	#224-1,d1
@clearscroll:	move.l	d0,(a1)+
		dbf	d1,@clearscroll

		move.l	#$40000010,(a6)	; set VDP control port to VSRAM mode and start at 00
		lea	($C00000).l,a0	; init VDP data port in a0	
		moveq	#0,d0		; clear VSRAM
		moveq	#40-1,d1	; do it for all 16-pixel strips
@clearvsram:	move.w	d0,(a0)		; dump art to VSRAM
		dbf	d1,@clearvsram	; repeat until all lines are done

		move.l	#$40000000,($C00004).l
		lea	(ArtKospM_SegaLogo).l,a0 ; load Sega logo patterns
		bsr	KosPlusMDec_VRAM

		lea	(Maps_SegaLogo).l,a1 ; load Sega logo mappings
		move.l	#$65100003,d0
		moveq	#$17,d1
		moveq	#7,d2
		bsr	ShowVDPGraphics

		lea	(Maps_SegaLogo+$180).l,a1 ; load Sega logo mappings
		move.l	#$40000003,d0
		moveq	#$27,d1
		moveq	#$1B-5,d2
		bsr	ShowVDPGraphics

		moveq	#0,d0
		bsr	PalLoad2	; load Sega logo palette
		move.w	#$0000,($FFFFFB00).w	; set background colour to black
		move.w	#$0000,($FFFFFB02).w	; set background colour to black
		move.b	#$00,($FF2000).l	; clear counter

Sega_WaitFrames:
		move.b	#2,VBlankRoutine	; set to function 2 in V-blank
		bsr	DelayProgram		; do V-blank
		addq.b	#1,($FF2000).l		; increase wait timer
		cmpi.b	#8,($FF2000).l		; has time been reached?
		bne.s	Sega_WaitFrames		; if not, branch

		move.w	#-$A,($FFFFF632).w
		move.w	#0,($FFFFF634).w
		move.w	#0,($FFFFF662).w
		move.w	#0,($FFFFF660).w
		
		display_enable
		VBlank_UnsetMusicOnly

Sega_WaitPallet:
		lea	($FFFFCC00).w,a1
		moveq	#0,d0
		move.w	#224-1,d1
@clearscroll:	move.l	d0,(a1)+
		dbf	d1,@clearscroll

		tst.b	($FFFFF635).w
		bne.s	@0
		jsr	BackgroundEffects_Deformation2
@0:
		move.b	#2,VBlankRoutine
		bsr	DelayProgram
		andi.b	#$F0,($FFFFF605).w ; is	A, B, C, or Start pressed?
		bne.w	Sega_GotoTitle	; if yes, branch
		bsr	PalCycle_Sega
		bne.s	Sega_WaitPallet

		move.b	#$B5,d0
		move.b	#$E1,d0
		bsr	PlaySound_Special  ; play "SEGA" sound (featuring the beautiful voice of yours truly)

		move	#120, d6
@Wait_SegaPCM:
		move.b	#$14,VBlankRoutine
		bsr	DelayProgram
		dbf	d6, @Wait_SegaPCM

		move.b	#30,($FFFFFFBD).w	; frames to wait after SEGA sound
		move.w	#150,($FFFFF614).w	; frames to wait after crash sound

Sega_WaitEnd:
		tst.b	($FFFFFFBE).w
		beq.s	@notendphase
		move.b	#25,d0
		sub.b	($FFFFFFBD).w,d0
		lsr.w	#7,d0
				
		move.w	($FFFFFE0E).w, d5 	; timer
		lea	($FFFFCC00+80*4).w, a1	; scroll location
		move.w	#64-1, d2			; how many lines we want

@Smegma:
		move.b	d5, d0
		jsr	CalcSine
		asr.w	#5, d1

		btst	#0,	d5
		beq.s 	@NoNegation

		neg.l	d1

@NoNegation:
		addq 	#1, d5
		move.w	d1, (a1)+
		move.w	d1, (a1)+
		dbf	d2, @Smegma

@notendphase:
		tst.b	($FFFFFFBE).w
		bne.s	Sega_NoSound
		
		subq.b	#1,($FFFFFFBD).w
		bpl.s	Sega_NoSound
		move.b	#$D3,d0
		bsr	PlaySound_Special ; play crash sound
		move.b	#1,($FFFFFFBE).w
		move.w	#$000,($FFFFFB00).w
		move.w	#$000,($FFFFFB02).w
		move.w	#$222,($FFFFFB04).w
		move.w	#$222,($FFFFFB0C).w
		jsr	Pal_MakeBlackWhite
		
		lea	($FFFFFB20).w,a0
		move.w	#$E80,d0
		move.w	#$10*3-1,d1
@white:		move.w	d0,(a0)+
		dbf	d1,@white
		
Sega_NoSound:
		move.b	#2,VBlankRoutine
		bsr	DelayProgram
		tst.w	($FFFFF614).w
		beq.s	Sega_GotoTitle
		andi.b	#$80,($FFFFF605).w ; is	Start button pressed?
		beq.w	Sega_WaitEnd	; if not, branch

Sega_GotoTitle:
		clr.b	($FFFFFFBE).w
		jmp	Exit_SegaScreen
; ===========================================================================

; ---------------------------------------------------------------------------
; Title	screen
; ---------------------------------------------------------------------------
; TitleScreen::
TitleScreen:				; XREF: GameModeArray
		move.b	#$E0,d0
		bsr	PlaySound_Special ; fade out music
		bsr	Pal_FadeFrom

		VBlank_SetMusicOnly
		bsr	PLC_ClearQueue
		lea	($C00004).l,a6
		move.w	#$8004,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$9001,(a6)
		move.w	#$9200,(a6)
		move.w	#$8B03,(a6)
		move.w	#$8720,(a6)
		clr.b	($FFFFF64E).w
		bsr	ClearScreen
		VBlank_UnsetMusicOnly

		lea	($FFFFD000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1
Title_ClrObjRam:
		move.l	d0,(a1)+
		dbf	d1,Title_ClrObjRam ; fill object RAM ($D000-$EFFF) with	$0

		VBlank_SetMusicOnly		; disable unterbrechen
		move.l	#$40000001,($C00004).l
		lea	(ArtKospM_TitleFg).l,a0 ; load title screen patterns
		bsr	KosPlusMDec_VRAM
		move.l	#$60000001,($C00004).l
		lea	(ArtKospM_TitleSonic).l,a0 ; load Sonic title screen patterns
		bsr	KosPlusMDec_VRAM

		move.b	#0,($FFFFFE30).w ; clear lamppost counter
		move.w	#0,($FFFFFE08).w ; disable debug item placement	mode
		move.w	#0,($FFFFFFF0).w ; disable demo mode
		move.w	#0,($FFFFFFEA).w
		move.w	#0, CurrentLevel	; set level to	GHZ (00)
		move.w	#0,($FFFFF634).w ; disable palette cycling

		bsr	LevelSizeLoad
		bsr	DeformBgLayer
		move.l	#Blk16_TitleScreen, BlocksAddress	; load 16x16 blocks

		lea	(Blk256_TitleScreen).l,a0 ; load title screen chunk mappings
		lea	($FF0000).l,a1
		bsr	KosDec
		bsr	LevelLayoutLoad
		VBlank_UnsetMusicOnly

		bsr	Pal_FadeFrom

		VBlank_SetMusicOnly
		lea	LevelRenderer_DefaultConfig_BG, a0
		jsr 	LevelRenderer_DrawLayout_BG_2

		lea	(Maps_Title).l,a1 ; load title screen mappings
		move.l	#$42080003,d0
		moveq	#$21,d1
		moveq	#$15,d2
		bsr	ShowVDPGraphics

		move.l	#$40000000,($C00004).l
		lea	(ArtKospM_TitleScreen).l,a0 ; load title screen patterns
		bsr	KosPlusMDec_VRAM

		move.l	#$64000002,($C00004).l
		lea	(ArtKospM_ERaZor).l,a0
		bsr	KosPlusMDec_VRAM

		moveq	#1,d0		; load title screen palette
		bsr	PalLoad1


		move.w	#$618,($FFFFF614).w ; run title screen for $618 frames (this matches the music length)

		lea	($FFFFD000).w,a1
		moveq	#0,d0
		move.w	#7,d1
Title_ClrObjRam2:
		move.l	d0,(a1)+
		dbf	d1,Title_ClrObjRam2

		move.b	#$E,($FFFFD040).w ; load big Sonic object
		move.b	#$F,($FFFFD080).w ; load "PRESS	START BUTTON" object
		move.b	#$2,($FFFFD0C0).w	; load ERaZor banner object
		move.b	#$F,($FFFFD100).w
		move.b	#2,($FFFFD11A).w

		movem.l	d0-a2,-(sp)		; backup d0 to a2
		lea	(Pal_ERaZorBanner).l,a1	; set ERaZor banner's palette pointer
		lea	($FFFFFBE0).l,a2	; set palette location
		moveq	#7,d0			; set number of loops to 7
Title_SonPalLoop:
		move.l	(a1)+,(a2)+		; load 2 colours (4 bytes)
		dbf	d0,Title_SonPalLoop	; loop
		movem.l	(sp)+,d0-a2		; restore d0 to a2

		jsr	ObjectsLoad
		bsr	DeformBgLayer
		jsr	BuildSprites
		moveq	#0,d0			; load standard patterns
		bsr	LoadPLC2
		move.w	#0,($FFFFFFE4).w
		move.w	#0,($FFFFFFE6).w
		VBlank_UnsetMusicOnly
		display_enable
	if QuickLevelSelect=1 
		if QuickLevelSelect_ID=-1
		bra.s	LevelSelect_Load
		endif
	endif
		move.b	#$8A,d0		; play title screen music
		bsr	PlaySound_Special
		bsr	Pal_FadeTo


; ===========================================================================
Title_MainLoop:
		addq.w	#3,($FFFFD008).w

		move.b	#4,VBlankRoutine
		bsr	DelayProgram
		jsr	ObjectsLoad
		bsr	DeformBgLayer
		jsr	BuildSprites
		bsr	PalCycle_Title
		bsr	PLC_Execute

		tst.w	($FFFFF614).w	; is time over?
		beq.s	StartGame	; if yes, start game

		lea	($FFFFFB60).w,a2
		bsr.w	GenericPalCycle_Blue
		lea	($FFFFFB60).w,a2
		bsr.w	GenericPalCycle_Red		

		move.b	($FFFFF605).w,d1	; get button presses
		andi.b	#$B0,d1			; is B, C, or Start pressed?
		beq.w	Title_MainLoop		; if not, branch

StartGame:
		tst.w	($FFFFFFFA).w		; is debug mode enabled?
		beq.w	Title_NoLevSel		; if not, branch. quick level select only in dev mode
		btst	#6,($FFFFF604).w	; is A held?
		beq.w	Title_NoLevSel		; if not, start game normally

LevelSelect_Load:
		move.w	#$E0,d0			; fade out music for level select
		bsr	PlaySound_Special

		bsr	LevelSelect_Palette

		lea	($FFFFCC00).w,a1
		moveq	#0,d0
		move.w	#$DF,d1
@clearscroll:	move.l	d0,(a1)+
		dbf	d1,@clearscroll
		move.l	d0,($FFFFF616).w
		
		move	#$2700,sr
		lea	($C00000).l,a6
		move.l	#$60000003,($C00004).l
		move.w	#$3FF,d1
@clearvram:	move.l	d0,(a6)
		dbf	d1,@clearvram

		lea	($C00000).l,a6
		move.l	#$50000003,4(a6)
		lea	(Art_Text).l,a5
		move.w	#$28F,d1
@loadtextart:	move.w	(a5)+,(a6)
		dbf	d1,@loadtextart

		clr.b	($FFFFD040).w		; delete big Sonic object
		clr.b	($FFFFD080).w		; delete "PRESS START BUTTON" object
		move.w	#0,($FFFFFF82).w	; set initial cursor position to entry 1
		bsr.w	LevSelTextLoad

		addi.w	#15,($FFFFD0C0+obScreenY).w	; slightly adjust banner
		jsr	ObjectsLoad
		jsr	BuildSprites
		move.b	#4,VBlankRoutine	; run v-blank one more time...
		bsr.w	DelayProgram		; ...to clear inputs

		bra.w	LevelSelect		; to go level select loop
; ===========================================================================

Title_NoLevSel:
		bsr.s	ERZ_FadeOut		; ERZ fadeout hell yea
		jmp	Exit_TitleScreen
; ===========================================================================

ERZ_FadeOut:
		move.b	#$E0,d0			; fade out music
		jsr	PlaySound
		move.w	#50,($FFFFF614).w
@fade
		move.b	#4,VBlankRoutine
		bsr	DelayProgram
		move.b	#4,VBlankRoutine
		bsr	DelayProgram
		move.b	#4,VBlankRoutine
		bsr	DelayProgram
		move.w	#$00E,($FFFFFB60+$14).w
		move.w	#$00E,($FFFFFB60+$16).w
		move.w	#$00E,($FFFFFB60+$1A).w
		jsr	Pal_FadeOut
		subq.w	#1,($FFFFF614).w
		bpl.s	@fade
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Generic palette cycles used for stuff like the ERaZor banner
; ---------------------------------------------------------------------------

; 6 colors, offset $14 of a2
GenericPalCycle_Red:
		move.w	($FFFFFE0E).w,d0		; load V-Blank counter into d0
		andi.w	#3,d0				; mask it
		bne.s	@end				; if result isn't 0, branch	

		move.w	$14(a2),d0			; load first red colour of sonic's palette into d0
		moveq	#6-1,d1				; set loop count
		lea	$16(a2),a1			; load second red colour into a1
@redloop:	move.w	(a1),-2(a1)			; move colour to last spot
		adda.l	#2,a1				; increase location pointer
		dbf	d1,@redloop			; loop
		move.w	d0,$1E(a2)			; move first colour to last one
@end:	
		rts
; ---------------------------------------------------------------------------

; 8 colors, offset $06 of a2
GenericPalCycle_Blue:
		move.w	($FFFFFE0E).w,d0		; load V-Blank counter into d0
		andi.w	#3,d0				; mask it
		bne.s	@end				; if result isn't 0, branch
		
		move.w	4(a2),d0			; load first blue colour of sonic's palette into d0
		moveq	#8-1,d1				; set loop count
		lea	6(a2),a1			; load second blue colour into a1
@blueloop:	move.w	(a1),-2(a1)			; move colour to last spot
		adda.l	#2,a1				; increase location pointer
		dbf	d1,@blueloop			; loop
		move.w	d0,$12(a2)			; move first colour to last one
@end:	
		rts
; ---------------------------------------------------------------------------

ERZBanner_PalCycle:
		lea	($FFFFFB20).w,a2
		bra.w	GenericPalCycle_Red
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Level	Select
; ---------------------------------------------------------------------------

LevelSelect:
		move.b	#4,VBlankRoutine
		bsr.w	DelayProgram

		bsr.w	LevSelControls		; up/down controls
		andi.b	#$F0,($FFFFF605).w	; is A, B, C, or Start pressed?
		beq.s	LevelSelect		; if not, loop

		; quick casual/frantic toggle with A
		andi.b	#$40,($FFFFF605).w	; was specifically A pressed?
		beq.s	LevelSelect_DoSelect	; if not, start level
		move.w	#$DA,d0			; set option off sound
		bchg	#5,(OptionsBits).w	; toggle gameplay style
		bne.s	@playsound		; if it's now set to casual, branch
		move.w	#$D9,d0			; set option on sound
@playsound:	jsr	PlaySound_Special	; play it
		bsr	LevelSelect_Palette	; update palette
		bra.s	LevelSelect		; loop (don't make A start any level)
; ---------------------------------------------------------------------------

LevelSelect_DoSelect:
		moveq	#0,d0
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE16).w ; clear special stage number
		move.b	d0,($FFFFFE57).w ; clear emeralds
		move.l	d0,($FFFFFE58).w ; clear emeralds
		move.l	d0,($FFFFFE5C).w ; clear emeralds
		move.b	d0,($FFFFFE18).w ; clear continues

		move.w	($FFFFFF82),d0
		add.w	d0,d0
		lea	(LSelectPointers).l,a1
		adda.w	d0,a1
		move.w	(a1),d0
		bmi.w	LevelSelect
		andi.w	#$3FFF,d0
		move.w	d0,($FFFFFE10).w
		
		cmpi.w	#$001,d0	; is this the intro sequence?
		beq.s	LevSel_Intro	; if yes, branch
		cmpi.w	#$601,d0	; is this the ending sequence?
		beq.s	LevSel_Ending	; if yes, branch
		cmpi.w	#$666,d0	; is blackout challenge?
		beq.s	LevSel_Blackout	; if yes, branch
		
		move.b	#1,($FFFFF5D1).w ; skip tutorial introduction text

		jmp	StartLevel	; otherwise, start level normally

; jumpers, cause the exit logic is too far out of range
LevSel_Intro:	jmp	HubRing_IntroStart
LevSel_Ending:	jmp	HubRing_Ending
LevSel_Blackout:jmp	HubRing_Blackout
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	load the palette, based on gameplay style
; (casual white / frantic red)
; ---------------------------------------------------------------------------

LevelSelect_Palette:
		moveq	#0,d1			; instantly turn the entire palette black
		lea	($FFFFFB00).w,a1
		move.w	#$3F,d2
@clearpalafter:	move.w	d1,(a1)+
		dbf	d2,@clearpalafter

		move.w	#$222,d0		; gray filling for the text
		lea	($FFFFFB64).w,a1
		moveq	#7,d1
@grayfilling:	move.w	d0,(a1)+
		dbf	d1,@grayfilling

		move.w	#$EEE,d0		; white outline for selected line
		frantic				; is frantic enabled?
		beq.s	@selectedline		; if not, branch
		move.w	#$00E,d0		; red outline for selected line
@selectedline:	move.w	d0,($FFFFFB42).w	; write select line color
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	change what you're selecting in the level select
; ---------------------------------------------------------------------------
LevSelEntries = 15
; ---------------------------------------------------------------------------

LevSelControls:				; XREF: LevelSelect
		move.b	($FFFFF605).w,d1
		andi.b	#3,d1		; is up/down pressed?
		beq.s	LevSel_End	; if not, branch
		move.b	#$D8,d0
		bsr	PlaySound_Special
		move.w	($FFFFFF82).w,d0
		btst	#0,d1		; is up	pressed?
		beq.s	LevSel_Down	; if not, branch
		subq.w	#1,d0		; move up 1 selection
		bpl.s	LevSel_Down
		moveq	#LevSelEntries-1,d0	; if selection moves below 0, jump to selection	13

LevSel_Down:
		btst	#1,d1		; is down pressed?
		beq.s	LevSel_Refresh	; if not, branch
		addq.w	#1,d0		; move down 1 selection
		cmpi.w	#LevSelEntries-1,d0
		bls.s	LevSel_Refresh
		moveq	#0,d0		; if selection moves above $14,	jump to	selection 0

LevSel_Refresh:
		move.w	d0,($FFFFFF82).w ; set new selection
		bsr	LevSelTextLoad	; refresh text

LevSel_End:
		rts	
; End of function LevSelControls

; ---------------------------------------------------------------------------
; Subroutine to load level select text
; ---------------------------------------------------------------------------

LevSelTextLoad:				; XREF: TitleScreen
		lea	(LevelMenuText).l,a1
		lea	($C00000).l,a6
		move.l	#$62900003,d4	; screen position (text)
		move.w	#$E680,d3	; VRAM setting
		moveq	#$14,d1		; number of lines of text

loc_34FE:
		move.l	d4,4(a6)
		bsr	LevSel_ChgLine
		addi.l	#$800000,d4
		dbf	d1,loc_34FE

		moveq	#0,d0
		move.w	($FFFFFF82).w,d0
		move.w	d0,d1
		move.l	#$62900003,d4
		lsl.w	#7,d0
		swap	d0
		add.l	d0,d4
		lea	(LevelMenuText).l,a1
		lsl.w	#3,d1
		move.w	d1,d0
		add.w	d1,d1
		add.w	d0,d1
		adda.w	d1,a1
		move.w	#$C680,d3
		move.l	d4,4(a6)
		bsr	LevSel_ChgLine
		rts	
; End of function LevSelTextLoad


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

LevSel_ChgLine:				; XREF: LevSelTextLoad
		moveq	#$17,d2		; number of characters per line

loc_3588:
		moveq	#0,d0
		move.b	(a1)+,d0	; get next character in line
		bmi.s	@illegal	; if it's an illegal character, skip
		
		cmpi.b	#$20,d0		; is this a space?
		beq.s	@space		; if yes, branch
		cmpi.b	#$39,d0		; is it a number?
		bhi.s	@regular	; if not, branch
		addq.b	#2,d0
		bra.s	@regular
@space:
		moveq	#-1,d0		; adjust for space character
		bra.s	loc_3598

@regular:
		subi.w	#50,d0
		bra.s	loc_3598

@illegal:
		move.w	#0,(a6)
		dbf	d2,loc_3588
		rts	
; ===========================================================================

loc_3598:				; XREF: LevSel_ChgLine
		add.w	d3,d0
		move.w	d0,(a6)
		dbf	d2,loc_3588
		rts	
; End of function LevSel_ChgLine

; ===========================================================================
; ---------------------------------------------------------------------------
; Level	select menu text and pointer
; ---------------------------------------------------------------------------

LevelMenuText:
		dc.b	'   UBERHUB PLACE        '
		dc.b	'   1 NIGHT HILL PLACE   '
		dc.b	'   2 GREEN HILL PLACE   '
		dc.b	'   3 SPECIAL PLACE      '
		dc.b	'   4 RUINED PLACE       '
		dc.b	'   5 LABYRINTHY PLACE   '
		dc.b	'   6 UNREAL PLACE       '
		dc.b	'   7 SCAR NIGHT PLACE   '
		dc.b	'   8 STAR AGONY PLACE   '
		dc.b	'   9 FINALOR PLACE      '
		dc.b	'   TUTORIAL PLACE       '
		dc.b	'   INTRO SEQUENCE       '
		dc.b	'   BOMB MACHINE         '
		dc.b	'   ENDING SEQUENCE      '
		dc.b	'   BLACKOUT CHALLENGE   '		
		rept 21-LevSelEntries ; padding
		dc.b	'                        '
		endr
		even

LSelectPointers:
		dc.w	$400	; Uberhub Place
		dc.w	$000	; Night Hill Place
		dc.w	$002	; Green Hill Place
		dc.w	$300	; Special Place
		dc.w	$200	; Ruined Place
		dc.w	$101	; Labyrinthy Place
		dc.w	$401	; Unreal Place
		dc.w	$301	; Scar Night Place
		dc.w	$302	; Star Agony Place
		dc.w	$502	; Finalor Place
		dc.w	$501	; Tutorial Place
		dc.w	$001	; Intro Sequence
		dc.w	$500	; Bomb Machine Cutscene
		dc.w	$601	; Ending Sequence
		dc.w	$666	; Blackout Challenge
		even


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to check if the current level is one of the main ones
; and set "Fake Level ID" in d5 if so.
; ---------------------------------------------------------------------------

; CheckIfMainLevel:
FakeLevelID:
		move.l	a1,-(sp)		; backup a1
		moveq	#-1,d5			; set d5 to -1 (it'll be 0)
		lea	(MainLevelArray).l,a1	; set level array index to a1
CIML_Loop:
		addq.w	#1,d5			; increase d5
		move.w	(a1)+,d3		; get next level ID and load it into d3
		bmi.s	CIML_Error		; end of the list? quit loop
		cmp.w	($FFFFFE10).w,d3	; does it match with the current ID?
		bne.s	CIML_Loop		; if not, loop
		bra.s	CIML_End		; otherwise return

CIML_Error:
		moveq	#-1,d5			; set d5 to "no result"
CIML_End:
		move.l	(sp)+,a1		; restore a1
		rts				; otherwise return
; ---------------------------------------------------------------------------

MainLevelArray:
		; the order here is a historically grown mess,
		; but it must stay like this or everything breaks
		dc.w	$000	; 0 - Night Hill Place
		dc.w	$002	; 1 - Green Hill Place
		dc.w	$300	; 2 - Special Place (yes, it uses an SLZ ID)
		dc.w	$200	; 3 - Ruined Place
		dc.w	$101	; 4 - Labyrinthy Place
		dc.w	$401	; 5 - Unreal Place (yes, it uses an SYZ ID)
		dc.w	$301	; 6 - Scar Night Place
		dc.w	$502	; 7 - Finalor Place
		dc.w	$400	; 8 - Uberhub
		dc.w	$501	; 9 - Tutorial Place (SBZ 2)
		dc.w	$302	; A - Star Agony Place
		dc.w	-1	; None of the above
		even


; ---------------------------------------------------------------------------
; Subroutine to play level music.
; ---------------------------------------------------------------------------

PlayLevelMusic:
		jsr	FakeLevelID		; get main level ID and load it into d5
		lea	(MusicList).l,a1	; load Playlist into a1
		move.b	(a1,d5.w),d0		; get music ID
		cmp.b	SoundDriverRAM+v_last_bgm,d0	; is last played music ID the same one as the one to be played?
		beq.s	PLM_NoMusic		; if yes, don't restart music
		bsr.w	PlaySound		; play music
PLM_NoMusic:
		rts				; return
; ---------------------------------------------------------------------------

MusicList:
		dc.b	$81	; Night Hill Place
		dc.b	$86	; Green Hill Place
		dc.b	$89	; Special Stage (Unused)
		dc.b	$83	; Ruined Place
		dc.b	$82	; Labyrinthy Place
		dc.b	$89	; Special Stage 2 (Unused)
		dc.b	$84	; Scar Night Place
		dc.b	$8D	; Finalor Place
		dc.b	$85	; Uberhub Place (Overworld)
		dc.b	$87	; Tutorial Place (SBZ 2)
		dc.b	$84	; Star Agony Place
		even
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Level
; ---------------------------------------------------------------------------

; Level::	<-- for quick search
Level:					; XREF: GameModeArray
		bset	#7,($FFFFF600).w ; add $80 to screen mode (for pre level sequence)
		bsr	PLC_ClearQueue
		jsr	DrawBuffer_Clear
		display_enable
		move.w	#$8014,($C00004).l	; enable h-ints
		bsr	Pal_FadeFrom
		move.w	#$8004,($C00004).l	; disable h-ints

		; immediately clear the first tile in VRAM to avoid graphical issues
		VBlank_SetMusicOnly
		vram	$0000
		rept	$20-1
		move.w	#0,VDP_Data
		endr
		VBlank_UnsetMusicOnly

	;	jsr	ClearVRAM	; only comment this in for testing, never in prod!

		cmpi.w	#$001,($FFFFFE10).w
		beq.s	@notitlecardart
		lea	PLC_TitleCard, a1
		jsr	LoadPLC_Direct
@notitlecardart:

		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	loc_37FC
		bsr	LoadPLC		; load level patterns

loc_37FC:
		cmpi.w	#$500,($FFFFFE10).w	; is this the bomb machine cutscene?
		beq.s	@skipstandard		; if yes, don't load these PLCs to avoid breaching the queue
		moveq	#1,d0
		bsr	LoadPLC			; load standard patterns 2
@skipstandard:
		cmpi.w	#$001,($FFFFFE10).w	; is current level GHZ 2 (intro level)?
		bne.s	Level_ClrRam		; if not, branch
		moveq	#$13,d0			; set to star patterns
		jsr	(LoadPLC).l		; load star patterns

Level_ClrRam:
		lea	($FFFFD000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1
Level_ClrObjRam:move.l	d0,(a1)+
		dbf	d1,Level_ClrObjRam ; clear object RAM

		lea	($FFFFF628).w,a1
		moveq	#0,d0
		move.w	#$15,d1
Level_ClrVars:	move.l	d0,(a1)+
		dbf	d1,Level_ClrVars ; clear misc variables

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1
Level_ClrVars2:	move.l	d0,(a1)+
		dbf	d1,Level_ClrVars2 ; clear misc variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$47,d1
Level_ClrVars3:	move.l	d0,(a1)+
		dbf	d1,Level_ClrVars3 ; clear object variables

		VBlank_SetMusicOnly
		bsr	ClearScreen
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$857C,(a6)
		move.w	#$9001,(a6)
		move.w	#$8720,(a6)
		
	;	move.w	#$8014,(a6)			; enable horizontal interrupts (normally only enabled in LZ)
		move.w	#$8A00|$DF,($FFFFF624).w	; set initial H-int counter value to apply once per frame
		move.w	($FFFFF624).w,(a6)		; apply H-int counter
		
		clr.w	DMAQueue
		move.l	#DMAQueue, DMAQueuePos

		cmpi.b	#1,($FFFFFE10).w	; is level LZ?
		beq.s	Level_LZWaterSetup	; if yes, branch
		clr.b	($FFFFFF97).w		; clear the lamp post counter if we're not in Labyrinth Zone
		clr.b	($FFFFFFFE).w
		bra.s	Level_LoadPal		; branch

Level_LZWaterSetup:
		tst.b	($FFFFFF97).w		; did the player die before the first checkpoint?
		bne.s	@cont			; if not, branch
		clr.b	($FFFFFFFE).w		; otherwise, make sure =P state is off

@cont:
		move.l	#WaterTransition_LZ,($FFFFF610).w
		move.w	#$8014,(a6)
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		lea	(WaterHeight).l,a1 ; load water	height array
		move.w	(a1,d0.w),d0
		move.w	d0,($FFFFF646).w ; set water heights
		move.w	d0,($FFFFF648).w
		move.w	d0,($FFFFF64A).w
		clr.b	($FFFFF64D).w	; clear	water routine counter
		clr.b	($FFFFF64E).w	; clear	water movement
		move.b	#1,($FFFFF64C).w ; enable water

Level_LoadPal:
		move.w	#$1E,($FFFFFE14).w ; set oxygen timer
		cmpi.b	#1,($FFFFFE10).w ; is level LZ?
		bne.s	Level_GetBgm	; if not, branch
		moveq	#$F,d0		; palette number	$0F (LZ)
		cmpi.b	#3,($FFFFFE11).w ; is act number 3?
		bne.s	Level_WaterPal	; if not, branch
		moveq	#$10,d0		; palette number	$10 (SBZ3)

Level_WaterPal:
		bsr	PalLoad3_Water	; load underwater palette (see d0)
		tst.b	($FFFFFE30).w
		beq.s	Level_GetBgm
		move.b	($FFFFFE53).w,($FFFFF64E).w
		
; ---------------------------------
Level_GetBgm:
		move.b	#$E3,d0			; resume at normal speed
		jsr	PlaySound_Special
		VBlank_UnsetMusicOnly

		; tutorial introduction text
		cmpi.w	#$501,($FFFFFE10).w	; are we starting the tutorial?
		bne.s	Level_NoPreTut		; if not, branch
		
		tst.b	($FFFFF5D1).w		; did the player die?
		bne.s	Level_NoPreTut		; if yes, don't replay intro text
		
		move.b	#$99,d0			; play introduction music
		jsr	PlaySound_Special

		moveq	#$E,d0		; use FZ palette
		bsr	PalLoad2	; load palette (based on	d0)
		move.w	#$0000,($FFFFFB40).w

		move.b	#10,d0		; VLADIK => Load hint number
		jsr	Tutorial_DisplayHint	; VLADIK => Display hint
		
		jsr	ClearScreen

		moveq	#0,d1
		lea	($FFFFFB20).w,a1
		move.w	#$17,d2
	@clearpalafter:
		move.l	d1,(a1)+
		dbf	d2,@clearpalafter

Level_NoPreTut:
		cmpi.w	#$001,($FFFFFE10).w	; is level intro cutscene?
		beq.s	Level_NoMusic		; if yes, don't play music here

		cmpi.w	#$002,($FFFFFE10).w	; is level GHP?
		bne.s	@playregularlevelmusic	; if not, branch
		cmpi.b	#4,($FFFFFE30).w	; did we hit the fourth checkpoint yet?
		bne.s	@playregularlevelmusic	; if not, branch
		move.b	#$94,d0			; play regular GHZ music
		jsr	PlaySound
		bra.s	Level_NoMusic
		
@playregularlevelmusic:
		bsr	PlayLevelMusic		; play level music

Level_NoMusic:
		cmpi.w	#$500,($FFFFFE10).w	; is level SBZ1?
		bne.s	Level_NoMusic2		; if yes, don't play music
		move.b	#$8D,d0
		jsr	PlaySound

Level_NoMusic2:
; ---------------------------------

		clr.b	($FFFFFF98).w
		clr.b	($FFFFFF99).w
		clr.w	($FFFFFFCE).w	; clear extended camera counter
		bsr	ClearEverySpecialFlag
		
@runplc:	; run PLC now to avoid breaching the queue limit
		move.b	#$C,VBlankRoutine
		bsr	DelayProgram
		bsr	PLC_Execute
		tst.l	PLC_Pointer	; are there any items in the pattern load cue?
		bne.s	@runplc		; if yes, branch

		cmpi.w	#$001,($FFFFFE10).w	; are we in the intro cutscene?
		bne.w	@notintrocutscene
		VBlank_SetMusicOnly
		vram	$D700
		lea	(ArtKospM_ExplBall).l,a0
		jsr	KosPlusMDec_VRAM
		moveq	#2,d0
		jsr	LoadPLC			; load explosion patterns
		VBlank_UnsetMusicOnly
		bra.s	Level_NoTitleCard
		
@notintrocutscene:
		cmpi.w	#$502,($FFFFFE10).w	; is this Finalor Place?
		bne.s	@notfinalor		; if not, branch
		moveq	#$1F,d0
		jsr	LoadPLC			; load FZ boss patterns

@notfinalor:
		cmpi.w	#$500,($FFFFFE10).w	; is this the bomb machine cutscene?
		bne.s	@notmachine		; if not, branch
		move.b	#1,($FFFFF7CC).w	; lock controls 
		moveq	#$1E,d0
		jsr	LoadPLC			; load SBZ2 Eggman patterns
		moveq	#2,d0
		jsr	LoadPLC			; load explosion patterns
		bra.s	Level_NoTitleCard

@notmachine:
		move.b	#$34,($FFFFD080).w ; load title	card object
		bra.s	Level_TtlCard
; ===========================================================================

Level_NoTitleCard:
		moveq	#3,d0
		bsr	PalLoad2	; load Sonic's palette line

Level_TtlCard:
		move.b	#$C,VBlankRoutine
		bsr	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr	PLC_Execute
		move.w	($FFFFD108).w,d0
		cmp.w	($FFFFD130).w,d0 ; has title card sequence finished?
		bne.s	Level_TtlCard	; if not, branch
		tst.l	PLC_Pointer		 	; are there any items in the pattern load cue?
		bne.s	Level_TtlCard		; if yes, branch
		
		move.b	#$C,VBlankRoutine	; run for one more frame to avoid hiccups in the title card
		bsr	DelayProgram
		jsr	Hud_Base

loc_3946:
		moveq	#3,d0
		bsr	PalLoad1	; load Sonic's palette line
		bsr	LevelSizeLoad
		bsr	DeformBgLayer
		bset	#2,($FFFFF754).w
		bsr	MainLoadBlockLoad	; load block mappings and palettes

		cmpi.b	#1,($FFFFFE10).w	; are we in LZ
		beq.s	@notlz			; if not, branch
		moveq	#0,d0
		bsr	LoadPLC			; (re-)load standard patterns 1
@notlz:
		cmpi.w	#$400,($FFFFFE10).w	; are we in Uberhub?
		bne.s	@notuberhub		; if not, branch
		move.b	#0,($FFFFFF7F).w	; set intro tube flag
		move.b	#1,($FFFFF7CC).w	; lock controls
		ori.w	#2,($FFFFF7BE).w	; skip loading giant ring patterns (already done in PLC)

@notuberhub:
		VBlank_SetMusicOnly
		jsr 	LevelRenderer_DrawLayout_FG
		jsr 	LevelRenderer_DrawLayout_BG
		VBlank_UnsetMusicOnly
		bsr	ColIndexLoad
		bsr	LZWaterEffects
		
		cmpi.w	#$302,($FFFFFE10).w		; is current level SAP?
		bne.s	@notsap				; if not, branch
		jsr	SAP_ResetChallengeObjects	; set up challenge objects
@notsap:
		; bomb machine cutscene setup
		cmpi.w	#$500,($FFFFFE10).w
		bne.s	@SBZcont2

		lea	($FFFFD440).w,a1
		move.b	#$5F,(a1)	; load walking bomb enemy
		move.w	#$01E4,obX(a1)
		move.w	#$0150,obY(a1)

		jsr	SingleObjLoad
		move.b	#$82,(a1)	; load SBZ2 Eggman object

		move.w	#12*60,($FFFFFFD8).w	; set cutscene time (controlled in Resize_SBZ1)
		ori.w	#2,($FFFFF7BE).w	; skip loading giant ring patterns (collides otherwise)

		bra.s	@SBZCont

@SBZcont2:
		move.b	#1,($FFFFD000).w ; load	Sonic object (load Sonic object)

@SBZcont:
		cmpi.w	#$400,($FFFFFE10).w
		bne.s	Level_ChkWater
		bset	#1,($FFFFD022).w
		move.b	#2,($FFFFD01C).w
		move.w	#$800,($FFFFD012).w

Level_ChkWater:
		move.w	#0,($FFFFF602).w
		move.w	#0,($FFFFF604).w
		cmpi.b	#1,($FFFFFE10).w ; is level LZ?
		bne.s	Level_LoadObj	; if not, branch
	;	move.b	#$1B,($FFFFD780).w ; load water	surface	object
		move.w	#$60,($FFFFD788).w
		move.b	#$1B,($FFFFD7C0).w
		move.w	#$120,($FFFFD7C8).w

Level_LoadObj:
		jsr	ObjPosLoad
		jsr	ObjectsLoad
		jsr	BuildSprites
		moveq	#0,d0
		tst.b	($FFFFFE30).w	; are you starting from	a lamppost?
		bne.s	loc_39E8	; if yes, branch
		move.l	d0,($FFFFFE22).w ; clear time
		move.b	d0,($FFFFFE1B).w ; clear lives counter

		clr.w	(FranticDrain).w		; clear frantic ring drain
		cmpi.w	#$400,($FFFFFE10).w	; are we in Uberhub?
		beq.s	loc_39E8		; if yes, don't do ring drain
		move.w	($FFFFFE20).w,d1	; get your rings from the last level
		beq.s	loc_39E8		; if you had none, branch
		cmpi.w	#999,d1			; did it somehow end up above the allowed maximum?
		bls.s	@allgood		; if not, branch
		move.w	#999,d1			; otherwise, cap it to 999
@allgood:
		move.w	d1,(FranticDrain).w	; copy previous amount of rings to frantic ring draining
		move.w	d1,($FFFFFE20).w	; cap rings if necessary

loc_39E8:
		move.b	d0,($FFFFFE1A).w
		move.b	d0,($FFFFFE2C).w ; clear shield
	;	move.b	d0,($FFFFFFFC).w ; clear multi shield counter
		move.b	d0,($FFFFFE2D).w ; clear invincibility
		move.b	d0,($FFFFFE2E).w ; clear speed shoes
		move.b	d0,($FFFFD034).w ; clear speed shoes timer
		move.b	d0,($FFFFFE2F).w
		move.w	d0,($FFFFFE08).w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		bsr	OscillateNumInit
		move.b	#1,($FFFFFE1F).w ; update score	counter
		move.b	#1,($FFFFFE1D).w ; update rings	counter
		move.b	#1,($FFFFFE1E).w ; update time counter
		move.w	#0,($FFFFF790).w

		move.w	#1800,($FFFFF614).w

Level_ChkWaterPal:
		cmpi.b	#1,($FFFFFE10).w ; is level LZ/SBZ3?
		bne.s	Level_Delay	; if not, branch
		moveq	#$B,d0		; palette $0B (LZ underwater)
		cmpi.b	#3,($FFFFFE11).w ; is level SBZ3?
		bne.s	Level_WaterPal2	; if not, branch
		moveq	#$D,d0		; palette $0D (SBZ3 underwater)

Level_WaterPal2:
		bsr	PalLoad4_Water

Level_Delay:
		cmpi.b	#3,($FFFFFE10).w	; are we in SLZ?
		bne.s	@notslz			; if not, branch
		jsr	SingleObjLoad
		bne.s	@notslz
		move.b	#$5C,(a1)		; load metal girder overlay object
@notslz:

	;	move.w	#3,d1
Level_DelayLoop:
	;	move.b	#8,VBlankRoutine
	;	bsr	DelayProgram
	;	dbf	d1,Level_DelayLoop

		move.w	#$202F,($FFFFF626).w
		bsr	Pal_FadeTo2
		addq.b	#2,($FFFFD0A4).w ; make	title card move
		addq.b	#4,($FFFFD0E4).w ; make	title card move
		addq.b	#4,($FFFFD124).w ; make	title card move
		addq.b	#4,($FFFFD164).w ; make	title card move

Level_StartGame:
		move.w	#$8014,($C00004)	; enable horizontal interrupts (normally only enabled in LZ)
		ints_enable
		bclr	#7,($FFFFF600).w	; clear pre-level sequence flag

		
; ---------------------------------------------------------------------------
; Main level loop (when	all title card and loading sequences are finished)
; ---------------------------------------------------------------------------

; LVML::
Level_MainLoop:
		bsr	PauseGame

		bsr	RandomNumber		; constantly create a new random number every frame to make use of RandomNumber
		bsr	CinematicScreenFuzz	; do cinematic screen fuzz if applicable

		move.b	#8,VBlankRoutine
		bsr	DelayProgram
		addq.w	#1,($FFFFFE04).w ; add 1 to level timer

		tst.b	(RedrawEverything).w	; was flag set to redraw screen after teleportation?
		beq.s	@noredraw		; if not, branch
		jsr	FixLevel		; fix level
		clr.b	(RedrawEverything).w	; clear redraw flag
@noredraw:

		; main level rendering
		bsr	LZWaterEffects
		jsr	ObjectsLoad
		bsr	DeformBgLayer		; GenerateCameraShake is called from within here
		jsr 	LevelRenderer_Update_FG
		jsr 	LevelRenderer_Update_BG
		jsr	BuildSprites
		bsr	UndoCameraShake		; undo camera shake now that the rendering is done
		jsr	ObjPosLoad
		bsr	PalCycle_Load
		bsr	PLC_Execute
		bsr	OscillateNumDo
		bsr	ChangeRingFrame
		bsr	SignpostArtLoad

		tst.w	($FFFFFE02).w		; is the level set to restart?
		bne.w	Level			; if yes, restart level
		cmpi.b	#$C,($FFFFF600).w	; has game mode changed?
		beq.w	Level_MainLoop		; if not, loop
		rts				; screen mode changed, exit level

; ===========================================================================

WaterTransition_LZ:	dc.w $13    ; # of entries - 1
		dc.w $62
		dc.w $68
		dc.w $7A
		dc.w $6E
		dc.w $74
		dc.w $42
		dc.w $48
		dc.w $4E
		dc.w $54
		dc.w $5A
		dc.w 2
		dc.w 8
		dc.w $E
		dc.w $14
		dc.w $1A
		dc.w $34
		dc.w $22
		dc.w $3A
		dc.w $2E
		dc.w $28
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	do special water effects in Labyrinth Zone
; ---------------------------------------------------------------------------

LZWaterEffects:				; XREF: Level
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	locret_3C28	; if not, branch
		cmpi.b	#6,($FFFFD024).w
		bcc.s	LZMoveWater
	;	bsr	LZWindTunnels
	;	bsr	LZWaterSlides
		bsr	LZDynamicWater

LZMoveWater:
		clr.b	($FFFFF64E).w
		moveq	#0,d0
		move.b	($FFFFFE60).w,d0
		lsr.w	#2,d0
		add.w	($FFFFF648).w,d0
		move.w	d0,($FFFFF646).w
		move.w	($FFFFF646).w,d0
		sub.w	($FFFFF704).w,d0
		bcc.s	loc_3C1A
		tst.w	d0
		bpl.s	loc_3C1A
		move.b	#-$21,($FFFFF625).w
		move.b	#1,($FFFFF64E).w

loc_3C1A:
		cmpi.w	#$DF,d0
		bcs.s	loc_3C24
		move.w	#$DF,d0

loc_3C24:
		move.b	d0,($FFFFF625).w

locret_3C28:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Labyrinth default water heights
; ---------------------------------------------------------------------------
WaterHeight:	incbin	misc\lz_heigh.bin
		even
; ===========================================================================

; ---------------------------------------------------------------------------
; Labyrinth dynamic water routines
; ---------------------------------------------------------------------------

LZDynamicWater:				; XREF: LZWaterEffects
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	DynWater_Index(pc,d0.w),d0
		jsr	DynWater_Index(pc,d0.w)
		moveq	#0,d1
		move.b	($FFFFF64C).w,d1
		move.w	($FFFFF64A).w,d0
		sub.w	($FFFFF648).w,d0
		beq.s	locret_3C5A
		bcc.s	loc_3C56
		neg.w	d1

loc_3C56:
		add.w	d1,($FFFFF648).w

locret_3C5A:
		rts	
; ===========================================================================
DynWater_Index:	dc.w DynWater_LZ1-DynWater_Index
		dc.w DynWater_LZ2-DynWater_Index
		dc.w DynWater_LZ3-DynWater_Index
		dc.w DynWater_SBZ3-DynWater_Index
; ===========================================================================

DynWater_LZ1:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3CD0
		move.w	#$B8,d1
		cmpi.w	#$600,d0
		bcs.s	loc_3CB4
		move.w	#$108,d1
		cmpi.w	#$200,($FFFFD00C).w
		bcs.s	loc_3CBA
		cmpi.w	#$C00,d0
		bcs.s	loc_3CB4
		move.w	#$318,d1
		cmpi.w	#$1080,d0
		bcs.s	loc_3CB4
		move.b	#-$80,($FFFFF7E5).w
		move.w	#$5C8,d1
		cmpi.w	#$1380,d0
		bcs.s	loc_3CB4
		move.w	#$3A8,d1
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3CB4
		move.b	#1,($FFFFF64D).w

loc_3CB4:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3CBA:				; XREF: DynWater_LZ1
		cmpi.w	#$C80,d0
		bcs.s	loc_3CB4
		move.w	#$E8,d1
		cmpi.w	#$1500,d0
		bcs.s	loc_3CB4
		move.w	#$108,d1
		bra.s	loc_3CB4
; ===========================================================================

loc_3CD0:				; XREF: DynWater_LZ1
		subq.b	#1,d2
		bne.s	locret_3CF4
		cmpi.w	#$2E0,($FFFFD00C).w
		bcc.s	locret_3CF4
		move.w	#$3A8,d1
		cmpi.w	#$1300,d0
		bcs.s	loc_3CF0
		move.w	#$108,d1
		move.b	#2,($FFFFF64D).w

loc_3CF0:
		move.w	d1,($FFFFF64A).w

locret_3CF4:
		rts	
; ===========================================================================

DynWater_LZ2:				; XREF: DynWater_Index
		tst.b 	($FFFFFFF9).w		; is flooding section even happening?
		beq.s	@noflood		; if not, branch
		btst	#1,($FFFFFFF9).w	; one frame passed since Jaws was destroyed?
		bne.s	@flood			; if yes, branch
		bset	#1,($FFFFFFF9).w	; set flag
		rts				; don't flood yet, because we need to drain first for 1 frame
@flood:
		move.b	#8,($FFFFF64C).w	; set increased water rising speed
		move.w	#$058,d1		; flood this place
		bra.s	@setheight

@noflood:
		move.w	#$328,d1		; set default target water level

		cmpi.b	#1,($FFFFFF97).w	; was first lamppost passed?
		bne.s	@notfirst		; if not, branch
		move.w	#$228,d1		; set default target water level
		bra.s	@immediately
@notfirst:
		cmpi.b	#3,($FFFFFF97).w	; was third lamppost passed?
		bne.s	@setheight		; if not, branch
		move.w	#$3B0,d1		; set water level before Jaws

@immediately:
		move.w	d1,($FFFFF646).w	; current water level
		move.w	d1,($FFFFF648).w	; average water level
@setheight:
		move.w	d1,($FFFFF64A).w	; set target water level
		rts	
; ===========================================================================

DynWater_LZ3:				; XREF: DynWater_Index
		move.w	($FFFFF700).w,d0
		move.b	($FFFFF64D).w,d2
		bne.s	loc_3D5E
		move.w	#$900,d1
		cmpi.w	#$600,d0
		bcs.s	loc_3D54
		cmpi.w	#$3C0,($FFFFD00C).w
		bcs.s	loc_3D54
		cmpi.w	#$600,($FFFFD00C).w
		bcc.s	loc_3D54
		move.w	#$4C8,d1
		move.b	#$4B, LevelLayout_FG+$40*2+6 ; change level layout
		move.b	#1,($FFFFF64D).w
		move.w	#$B7,d0
		bsr	PlaySound_Special ; play sound $B7 (rumbling)

loc_3D54:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts	
; ===========================================================================

loc_3D5E:				; XREF: DynWater_LZ3
		subq.b	#1,d2
		bne.s	loc_3DA8
		move.w	#$4C8,d1
		cmpi.w	#$770,d0
		bcs.s	loc_3DA2
		move.w	#$308,d1
		cmpi.w	#$1400,d0
		bcs.s	loc_3DA2
		cmpi.w	#$508,($FFFFF64A).w
		beq.s	loc_3D8E
		cmpi.w	#$600,($FFFFD00C).w
		bcc.s	loc_3D8E
		cmpi.w	#$280,($FFFFD00C).w
		bcc.s	loc_3DA2

loc_3D8E:
		move.w	#$508,d1
		move.w	d1,($FFFFF648).w
		cmpi.w	#$1770,d0
		bcs.s	loc_3DA2
		move.b	#2,($FFFFF64D).w

loc_3DA2:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3DA8:
		subq.b	#1,d2
		bne.s	loc_3DD2
		move.w	#$508,d1
		cmpi.w	#$1860,d0
		bcs.s	loc_3DCC
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		bcc.s	loc_3DC6
		cmp.w	($FFFFF648).w,d1
		bne.s	loc_3DCC

loc_3DC6:
		move.b	#3,($FFFFF64D).w

loc_3DCC:
		move.w	d1,($FFFFF64A).w
		rts	
; ===========================================================================

loc_3DD2:
		subq.b	#1,d2
		bne.s	loc_3E0E
		move.w	#$188,d1
		cmpi.w	#$1AF0,d0
		bcs.s	loc_3E04
		move.w	#$900,d1
		cmpi.w	#$1BC0,d0
		bcs.s	loc_3E04
		move.b	#4,($FFFFF64D).w
		move.w	#$608,($FFFFF64A).w
		move.w	#$7C0,($FFFFF648).w
		move.b	#1,($FFFFF7E8).w
		rts	
; ===========================================================================

loc_3E04:
		move.w	d1,($FFFFF64A).w
		move.w	d1,($FFFFF648).w
		rts	
; ===========================================================================

loc_3E0E:
		cmpi.w	#$1E00,d0
		bcs.s	locret_3E1A
		move.w	#$128,($FFFFF64A).w

locret_3E1A:
		rts	
; ===========================================================================

DynWater_SBZ3:				; XREF: DynWater_Index
		move.w	#$228,d1
		cmpi.w	#$F00,($FFFFF700).w
		bcs.s	loc_3E2C
		move.w	#$4C8,d1

loc_3E2C:
		move.w	d1,($FFFFF64A).w
		rts

; ---------------------------------------------------------------------------
; Labyrinth Zone "wind tunnels"	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LZWindTunnels:				; XREF: LZWaterEffects
		cmpi.w	#$101,($FFFFFE10).w	; is level LZ2?
		bne.s	LZWT_NotLZ2		; if not, branch
		rts				; disabled for act 2
; ===========================================================================

LZWT_NotLZ2:
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	locret_3F0A	; if yes, branch
		lea	(LZWind_Data).l,a2
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		lsl.w	#3,d0
		adda.w	d0,a2
		moveq	#0,d1
		tst.b	($FFFFFE11).w
		bne.s	loc_3E56
		moveq	#1,d1
		subq.w	#8,a2

loc_3E56:
		lea	($FFFFD000).w,a1

LZWind_Loop:
		move.w	obX(a1),d0
		cmp.w	(a2),d0
		bcs.w	loc_3EF4
		cmp.w	obMap(a2),d0
		bcc.w	loc_3EF4
		move.w	obY(a1),d2
		cmp.w	obGfx(a2),d2
		bcs.s	loc_3EF4
		cmp.w	6(a2),d2
		bcc.s	loc_3EF4
		move.b	($FFFFFE05).w,d0
		andi.b	#$3F,d0
		bne.s	loc_3E90
		move.w	#$D0,d0
		jsr	(PlaySound_Special).l ;	play rushing water sound

loc_3E90:
		tst.b	($FFFFF7C9).w
		bne.w	locret_3F0A
		cmpi.b	#4,obRoutine(a1)
		bcc.s	loc_3F06
		move.b	#1,($FFFFF7C7).w
		subi.w	#$80,d0
		cmp.w	(a2),d0
		bcc.s	LZWind_Move
		moveq	#2,d0
		cmpi.b	#1,($FFFFFE11).w
		bne.s	loc_3EBA
		neg.w	d0

loc_3EBA:
		add.w	d0,obY(a1)

LZWind_Move:
		addq.w	#4,obX(a1)
		move.w	#$400,obVelX(a1)	; move Sonic horizontally
		move.w	#0,obVelY(a1)
		move.b	#$F,obAnim(a1)	; use floating animation
		bset	#1,obStatus(a1)
		btst	#0,($FFFFF602).w ; is up pressed?
		beq.s	LZWind_MoveDown	; if not, branch
		subq.w	#1,obY(a1)	; move Sonic up

LZWind_MoveDown:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	locret_3EF2	; if not, branch
		addq.w	#1,obY(a1)	; move Sonic down

locret_3EF2:
		rts	
; ===========================================================================

loc_3EF4:				; XREF: LZWindTunnels
		addq.w	#8,a2
		dbf	d1,LZWind_Loop
		tst.b	($FFFFF7C7).w
		beq.s	locret_3F0A
		move.b	#0,obAnim(a1)

loc_3F06:
		clr.b	($FFFFF7C7).w

locret_3F0A:
		rts	
; End of function LZWindTunnels

; ===========================================================================
		dc.w $A80, $300, $C10, $380
LZWind_Data:	dc.w $F80, $100, $1410,	$180, $460, $400, $710,	$480, $A20
		dc.w $600, $1610, $6E0,	$C80, $600, $13D0, $680
					; XREF: LZWindTunnels
		even

; ---------------------------------------------------------------------------
; Labyrinth Zone water slide subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LZWaterSlides:				; XREF: LZWaterEffects
		lea	($FFFFD000).w,a1
		btst	#1,obStatus(a1)
		bne.s	loc_3F6A
		move.w	obY(a1),d0
		lsr.w	#2,d0
		andi.w	#$1C0,d0
		move.b	obX(a1),d1
		andi.w	#$3F,d1
		add.w	d1,d0
		lea	LevelLayout_FG,a2
		move.b	(a2,d0.w),d0
		lea	byte_3FCF(pc),a2
		moveq	#6,d1

loc_3F62:
		cmp.b	-(a2),d0
		dbeq	d1,loc_3F62
		beq.s	LZSlide_Move

loc_3F6A:
		tst.b	($FFFFF7CA).w
		beq.s	locret_3F7A
		move.w	#5,$3E(a1)
		clr.b	($FFFFF7CA).w

locret_3F7A:
		rts	
; ===========================================================================

LZSlide_Move:				; XREF: LZWaterSlides
		cmpi.w	#3,d1
		bcc.s	loc_3F84
		nop	

loc_3F84:
		bclr	#0,obStatus(a1)
		move.b	byte_3FC0(pc,d1.w),d0
		move.b	d0,obInertia(a1)
		bpl.s	loc_3F9A
		bset	#0,obStatus(a1)

loc_3F9A:
		clr.b	$15(a1)
		move.b	#$1B,obAnim(a1)	; use Sonic's "sliding" animation
		move.b	#1,($FFFFF7CA).w ; lock	controls (except jumping)
		move.b	($FFFFFE05).w,d0
		andi.b	#$1F,d0
		bne.s	locret_3FBE
		move.w	#$D0,d0
		jsr	(PlaySound_Special).l ;	play water sound

locret_3FBE:
		rts	
; End of function LZWaterSlides

; ===========================================================================
byte_3FC0:	dc.b $A, $F5, $A, $F6, $F5, $F4, $B, 0,	2, 7, 3, $4C, $4B, 8, 4
byte_3FCF:	dc.b 0			; XREF: LZWaterSlides
		even
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to generate a random camera offset (X and Y), if necessary
; (This routine is called from within DeformBgLayer)
; ---------------------------------------------------------------------------
CamShake_DefaultIntensity = 7	; should be 2^n - 1
; ---------------------------------------------------------------------------

GenerateCameraShake:
		tst.b	(CameraShake).w			; is camera shake currently active?
		beq.s	@nocamshake			; if not, nothing to do
		btst	#7,(OptionsBits).w		; is photosensitive mode enabled?
		bne.s	@docamshake			; if not, do cam shake
		clr.b	(CameraShake).w			; clear camera shake counter immediately
@nocamshake:	rts					; don't do any camera shake
; ---------------------------------------------------------------------------

@docamshake:
		moveq	#0,d0				; clear d0
		moveq	#0,d1				; clear d1
		move.b	(CurrentRandomNumber).w,d0	; get a random number (will be used for X shake)
		move.b	(CurrentRandomNumber+1).w,d1	; get a different random number (will be used for Y shake)

		moveq	#0,d2				; clear d2
		move.b	(CameraShake_Intensity).w,d2	; get currently set camera shake intensity
		bhi.s	@intensityset			; if it's already set, branch
		moveq	#CamShake_DefaultIntensity,d2	; if it's 0, set it to the default
		move.b	d2,(CameraShake_Intensity).w	; update intensity in RAM
@intensityset:
		moveq	#0,d3				; clear d3
		move.b	d2,d3				; copy intensity
		lsr.b	#1,d3				; half the copy

		and.w	d2,d0				; limit random number by intensity (this is now the Y offset)
		sub.w	d3,d0				; make 50% of the numbers negative
		and.w	d2,d1				; limit random number by intensity (this is now the X offset)
		sub.w	d3,d1				; make 50% of the numbers negative
		
		add.w	d0,($FFFFF700).w		; add X shake offset to camera X position
		bpl.s	@xgood				; if not, branch
		add.w	($FFFFF700).w,d0
		move.w	#0,($FFFFF700).w
@xgood:
		add.w	d1,($FFFFF704).w		; add Y shake offset to camera Y position
		bpl.s	@remember			; if not, branch
		add.w	($FFFFF704).w,d1
		move.w	#0,($FFFFF704).w

@remember:
		move.w	d0,(CameraShake_XOffset).w	; remember X shake offset for later
		move.w	d1,(CameraShake_YOffset).w	; remember Y shake offset for later
		rts
; ===========================================================================

; called after level and sprites rendering is done
UndoCameraShake:
		tst.b	(CameraShake).w			; is camera shake currently active?
		bne.s	@undocamshake			; if not, nothing to do
		rts
; ---------------------------------------------------------------------------

@undocamshake:
		subq.b	#1,(CameraShake).w		; subtract one from timer

		move.w	(CameraShake_XOffset).w,d0	; get X shake offset for this frame
		sub.w	d0,($FFFFF700).w		; undo X shake
		move.w	(CameraShake_YOffset).w,d0	; get Y shake offset for this frame
		sub.w	d0,($FFFFF704).w		; undo shake
		rts

; ---------------------------------------------------------------------------
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Adds a screen fuzz effect when cinematic mode is enabled
; ---------------------------------------------------------------------------

CinematicScreenFuzz:
		btst	#6,(OptionsBits).w	; is screen fuzz enabled?
		bne.s	@fuzzallowed		; if yes, always enable fuzz
		cmpi.w	#$400,($FFFFFE10).w	; are we in Uberhub?
		beq.w	Fuzz_Uberhub		; if yes, go to its custom routine
		bra.w	CinematicScreenFuzz_End	; otherwise, disallow fuzz
		
@fuzzallowed:
		tst.b	(CameraShake).w		; camera shake currently set?
		bne.w	CinematicScreenFuzz_End	; if yes, fuzz currently disabled cause holy shit is it slow
		cmpi.b	#$10,($FFFFF600).w	; is game mode special stage?
		beq.w	CinematicScreenFuzz_End	; if yes, fuzz is ALSO currently disabled cause holy shit is it STILL slow

	;	cmpi.w	#$002,($FFFFFE10).w	; are we in Green Hill Place?
	;	bne.w	CinematicScreenFuzz_End	; if not, branch
	;	cmpi.b	#4,($FFFFFE30).w	; did we hit the final checkpoint yet?
	;	beq.w	CinematicScreenFuzz_End	; if yes, branch

CinematicScreenFuzz_Do:
		move.w	($FFFFFE04).w,d7	; move timer into d7
		andi.w 	#1,d7			; only use least significant bit

		lea	(LineLengths).l,a2	; load line lengths address to a2
		lea	($FFFFCC00).w,a1	; get h-scroll data
		moveq	#0,d0			; by default, don't change scroll
		btst	#0,($FFFFFE05).w	; are we on an odd frame?
		bne.s	@odd			; if yes, branch
		moveq	#0,d0			; otherwise, set to -1
@odd:
		move.w	#224-1,d1		; do for all scanlines
		
		; calculate the exact amount of lines we need, minus ones occupied by black bars
		move.w	(BlackBars.Height).w,d2
		ext.w	d2
		sub.w	d2,d1
		sub.w	d2,d1
		bmi.w	CinematicScreenFuzz_End
@prefill:	adda.l	#4,a1
		dbf	d2,@prefill

		move.l	(CurrentRandomNumber).w,d2	; get random number

		moveq	#1,d6
	;	move.b	($FFFFD010).w,d3	; get Sonic's X speed
		move.b	($FFFFF73A).w,d3	; get number of pixels scrolled horizontally since the previous frame
		bpl.s	@0
		neg.b	d3
		moveq	#-1,d6
		
@0:
	;	move.b	($FFFFD012).w,d4	; get Sonic's Y speed
		move.b	($FFFFF73C).w,d4	; get number of pixels scrolled vertically since the previous frame
		bpl.s	@1
		neg.b	d4
		
@1:		
		cmp.b	d3,d4			; compare the two
		blo.s	@loop			; if X is stronger, branch

@yfuzz:
		moveq	#0,d6
	;	move.b	($FFFFD012).w,d3	; get Sonic's Y speed
		move.b	d4,d3			; use vertical delta

; ---------------------------------------------------------------------------

@loop:
		bchg 	#0,d7			; change the least significant bit of the AND'ed timer, for alternating lines

		moveq	#0,d4			; clear d4
		tst.b	d3			; does Sonic move at all?
		beq.s	@apply			; if not, skip

		ror.l	#1,d2			; get next random number
		move.b	d2,d4			; store working copy of current random byte
		andi.b	#$F,d4			; limit it to a random number between 0-15

		and.b	d3,d4			; mask against current speed (effectively a cheap way of emulating Math.min(d3,d4))
		ext.w	d4			; extend to word
		add.w	d4,d4			; double for word addressing mode
		
		tst.b	d0			; are we on an even frame?
		bne.s	@nolongline		; if not, branch
		tst.b	d6			; are we doing a Y shift?
		beq.s	@nolongline		; if yes, don't do long lines
		btst	#4,d1			; are we in the allowed range?
		bne.s	@nolongline		; if not, branch	
		add.w	d4,d4			; increase line length

@nolongline:
		move.w	(a2,d4.w),d4		; get actual line length value from LUT
		
		tst.b	d6			; is Sonic faster on X than Y velocity?
		bne.s	@xshift			; if yes, branch
		btst	#0,d1
		bne.s	@negate
		bra.s	@apply

@xshift:
		bmi.s	@apply			; if he's also walking left, branch
@negate:
		neg.w	d4			; otherwise, invert effect

@apply:
		move.w	(a1),d5			; get foreground scroll
		add.w	d0,d5			; add manipulation
		add.w	d4,d5			; apply RNG lines
		add.w 	d7,d5			; apply alternating lines
		move.w	d5,(a1)+		; store new position
		
		move.w	(a1),d5			; get background position
		add.w	d0,d5			; add manipulation
		add.w	d4,d5			; apply RNG lines
		add.w 	d7,d5			; apply alternating lines
		move.w	d5,(a1)+		; store new position
		
		not.w	d0			; invert manipulation for next row
		dbf	d1,@loop		; loop

CinematicScreenFuzz_End:
		rts				; return

; ---------------------------------------------------------------------------
LineLengths:
		dc.w	0
		dc.w	1
		dc.w	1
		dc.w	2
		dc.w	3
		dc.w	4
		dc.w	4
		dc.w	5
		dc.w	5
		dc.w	6
		dc.w	6
		dc.w	7
		
		dc.w	7
		dc.w	8
		dc.w	10
		dc.w	12
		dc.w	14
		dc.w	16
		dc.w	18
		dc.w	20
		dc.w	22
		dc.w	24
		dc.w	26
		dc.w	28
		dc.w	30
		dc.w	32
		dc.w	34
		even
; ---------------------------------------------------------------------------
; ===========================================================================

Fuzz_Uberhub:
		tst.b	($FFFFFFA5).w	; have we entered the room to the blackout challenge?
		beq.w	@fuzzuberhubend	; if not, don't display fuzz

		bra.w	CinematicScreenFuzz_Do	; fuck the below stuff actually

		move.w	($FFFFFE04).w,d7 ; move timer into d7
		and.w 	#1, d7 ; only use least significant bit

		lea	(LineLengths).l,a2	; load line lengths address to a2
		lea	($FFFFCC00).w,a1	; get h-scroll data
		moveq	#0,d0			; by default, don't change scroll
		btst	#0,($FFFFFE05).w	; are we on an odd frame?
		bne.s	@odd			; if yes, branch
		moveq	#0,d0			; otherwise, set to -1
@odd:
		move.w	#224-1,d1		; do for all scanlines
		
		; calculate the exact amount of lines we need, minus ones occupied by black bars
		move.w	(BlackBars.Height).w,d2
		ext.w	d2
		sub.w	d2,d1
		sub.w	d2,d1
		bmi.w	@fuzzuberhubend
@prefill:	adda.l	#4,a1
		dbf	d2,@prefill

		move.l	(CurrentRandomNumber).w,d2	; get random number
		move.w	d2,d3
; ---------------------------------------------------------------------------

@loop:
		bchg 	#0,d7			; change the least significant bit of the AND'ed timer, for alternating lines

		moveq	#0,d4			; clear d4
		tst.b	d3			; does Sonic move at all?
		beq.s	@apply			; if not, skip

		ror.l	#1,d2			; get next random number
		move.b	d2,d4			; store working copy of current random byte
		andi.b	#3,d4			; limit it to a random number between 0-3

		and.b	d3,d4			; mask against current speed (effectively a cheap way of emulating Math.min(d3,d4))
		ext.w	d4			; extend to word
		add.w	d4,d4			; double for word addressing mode
		
		tst.b	d0			; are we on an even frame?
		bne.s	@nolongline		; if not, branch
		tst.b	d6			; are we doing a Y shift?
		beq.s	@nolongline		; if yes, don't do long lines
		btst	#4,d1			; are we in the allowed range?
		bne.s	@nolongline		; if not, branch	
		add.w	d4,d4			; increase line length

@nolongline:
		move.w	(a2,d4.w),d4		; get actual line length value from LUT
		bmi.s	@apply			; if he's also walking left, branch
		neg.w	d4			; otherwise, invert effect

@apply:
		move.w	(a1),d5			; get foreground scroll
		add.w	d0,d5			; add manipulation
		add.w	d4,d5			; apply RNG lines
		add.w 	d7,d5			; apply alternating lines
		move.w	d5,(a1)+		; store new position
		
		move.w	(a1),d5			; get background position
		add.w	d0,d5			; add manipulation
		add.w	d4,d5			; apply RNG lines
		add.w 	d7,d5			; apply alternating lines
		move.w	d5,(a1)+		; store new position
		
		not.w	d0			; invert manipulation for next row
		dbf	d1,@loop		; loop

@fuzzuberhubend:
		rts				; return


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to clear every special flag (e.g. cutscenes, custom bosses).
; ---------------------------------------------------------------------------

ClearEverySpecialFlag:
		moveq	#0,d0
		move.b	d0,(FZEscape).w
		move.w	d0,($FFFFC904).w
		move.w	d0,($FFFFF7BE).w
		move.b	d0,($FFFFF5D0).w
		move.b	d0,($FFFFF5D1).w
		move.w	d0,(FranticDrain).w
		move.b	d0,(RedrawEverything).w
		move.l	d0,($FFFFFF60).w
		move.l	d0,($FFFFFF64).w
		move.l	d0,($FFFFFF68).w
		move.l	d0,($FFFFFF6C).w
		move.b	d0,($FFFFFF73).w
		move.w	d0,($FFFFFF74).w
		move.b	d0,($FFFFFF76).w
		move.b	d0,($FFFFFF77).w
		move.l	d0,($FFFFFF78).w
		move.l	d0,($FFFFFF7C).w
		move.b	d0,($FFFFFF7D).w
		move.b	d0,($FFFFFF7F).w
		move.w	d0,($FFFFFF86).w
		move.w	d0,($FFFFFF88).w
		move.b	d0,($FFFFFFEB).w
		move.b	d0,($FFFFFF91).w
		move.w	d0,($FFFFFF9C).w
		move.l	d0,($FFFFFFA0).w
		move.w	d0,($FFFFFFA4).w
		move.l	d0,($FFFFFFA8).w
		move.l	d0,($FFFFFFAC).w
		move.l	d0,($FFFFFFB0).w
		move.l	d0,($FFFFFFB4).w
		move.l	d0,($FFFFFFB8).w
		move.b	d0,($FFFFFFBD).w
		move.b	d0,($FFFFFFBF).w
		move.b	d0,($FFFFFFC8).w
		move.w	d0,($FFFFFFD0).w
		move.l	d0,($FFFFFFD2).w
		move.l	d0,($FFFFFFD6).w
		move.b	d0,($FFFFFFE5).w
		move.b	d0,($FFFFFFE7).w
		move.b	d0,($FFFFFFF9).w
		rts
; End of function ClearEverySpecialFlag
	

; ---------------------------------------------------------------------------
; Collision index loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ColIndexLoad:				; XREF: Level
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#2,d0
		move.l	ColPointers(pc,d0.w),($FFFFF796).w
		rts	
; End of function ColIndexLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision index pointers
; ---------------------------------------------------------------------------
ColPointers:
	dc.l Col_GHZ
	dc.l Col_LZ
	dc.l Col_MZ
	dc.l Col_SLZ
	dc.l Col_SYZ
	dc.l Col_SBZ

; ---------------------------------------------------------------------------
; Oscillating number subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumInit:			; XREF: Level
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data).l,a2
		moveq	#$20,d1

Osc_Loop:
		move.w	(a2)+,(a1)+
		dbf	d1,Osc_Loop
		rts	
; End of function OscillateNumInit

; ===========================================================================
Osc_Data:	dc.w $7C, $80		; baseline values
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$80
		dc.w 0,	$50F0
		dc.w $11E, $2080
		dc.w $B4, $3080
		dc.w $10E, $5080
		dc.w $1C2, $7080
		dc.w $276, $80
		dc.w 0,	$80
		dc.w 0
		even

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


OscillateNumDo:				; XREF: Level
		cmpi.b	#6,($FFFFD024).w
		bcc.s	locret_41C4
		lea	($FFFFFE5E).w,a1
		lea	(Osc_Data2).l,a2
		move.w	(a1)+,d3
		moveq	#$F,d1

loc_4184:
		move.w	(a2)+,d2
		move.w	(a2)+,d4
		btst	d1,d3
		bne.s	loc_41A4
		move.w	obGfx(a1),d0
		add.w	d2,d0
		move.w	d0,obGfx(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bhi.s	loc_41BA
		bset	d1,d3
		bra.s	loc_41BA
; ===========================================================================

loc_41A4:				; XREF: OscillateNumDo
		move.w	obGfx(a1),d0
		sub.w	d2,d0
		move.w	d0,obGfx(a1)
		add.w	d0,0(a1)
		cmp.b	0(a1),d4
		bls.s	loc_41BA
		bclr	d1,d3

loc_41BA:
		addq.w	#4,a1
		dbf	d1,loc_4184
		move.w	d3,($FFFFFE5E).w

locret_41C4:
		rts	
; End of function OscillateNumDo

; ===========================================================================
Osc_Data2:	dc.w 2,	$10		; XREF: OscillateNumDo
		dc.w 2,	$18
		dc.w 2,	$20
		dc.w 2,	$30
		dc.w 4,	$20
		dc.w 8,	8
		dc.w 8,	$40
		dc.w 4,	$40
		dc.w 2,	$50
		dc.w 2,	$50
		dc.w 2,	$20
		dc.w 3,	$30
		dc.w 5,	$50
		dc.w 7,	$70
		dc.w 2,	$10
		dc.w 2,	$10
		even

; ---------------------------------------------------------------------------
; Subroutine to	change object animation	variables (rings, giant	rings)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChangeRingFrame:			; XREF: Level
		subq.b	#1,($FFFFFEC0).w
		bpl.s	loc_421C
		move.b	#5,($FFFFFEC0).w ; $B
		subq.b	#1,($FFFFFEC1).w
		andi.b	#7,($FFFFFEC1).w

loc_421C:
		subq.b	#1,($FFFFFEC2).w
		bpl.s	loc_4232
		move.b	#4,($FFFFFEC2).w ; 7
		addq.b	#1,($FFFFFEC3).w
		andi.b	#3,($FFFFFEC3).w

loc_4232:
		subq.b	#1,($FFFFFEC4).w
		bpl.s	loc_4250
		move.b	#4,($FFFFFEC4).w ; 7
		addq.b	#1,($FFFFFEC5).w
		cmpi.b	#6,($FFFFFEC5).w
		bcs.s	loc_4250
		move.b	#0,($FFFFFEC5).w

loc_4250:
		tst.b	($FFFFFEC6).w
		beq.s	locret_4272
		moveq	#0,d0
		move.b	($FFFFFEC6).w,d0
		add.w	($FFFFFEC8).w,d0
		move.w	d0,($FFFFFEC8).w
		rol.w	#7,d0
		andi.w	#3,d0
		move.b	d0,($FFFFFEC7).w
		subq.b	#1,($FFFFFEC6).w

locret_4272:
		rts	
; End of function ChangeRingFrame

; ---------------------------------------------------------------------------
; End-of-act signpost pattern loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SignpostArtLoad:			; XREF: Level
		move.w	($FFFFF700).w,d0	; get X camera position
		move.w	($FFFFF72A).w,d1	; get right level boundary
		subi.w	#$100,d1		; adjust
		cmp.w	d1,d0			; has Sonic reached the	edge of	the level?
		blt.s	Signpost_Exit		; if not, branch
		tst.b	($FFFFF5D0).w		; sign post art already loaded?
		bne.s	Signpost_Exit		; if yes, don't load again
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	Signpost_Exit		; if yes, don't load

		move.w	($FFFFFE10).w,d0	; get current Level ID
		cmpi.w	#$002,d0		; is level GHP?
		bne.s	@notghp			; if not, branch		
		tst.b	($FFFFFF91).w		; GHP boss defeated?
		beq.s	@notghp			; if not, branch
		bra.s	Signpost_DoLoad		; do load

@notghp:
		cmpi.w	#$200,d0		; is level RP?
		beq.s	Signpost_DoLoad		; if yes, branch
		cmpi.w	#$101,d0		; is level LP?
		beq.s	Signpost_DoLoad_NoLock	; if yes, branch (don't lock screen)
		cmpi.w	#$302,d0		; is level SAP?
		beq.s	Signpost_DoLoad		; if yes, branch
		rts				; otherwise, don't load

Signpost_DoLoad:
		move.w	d1,($FFFFF728).w	; move left boundary to current screen position

Signpost_DoLoad_NoLock:
		moveq	#$12,d0
		jsr	LoadPLC2		; load signpost	patterns
		move.b	#1,($FFFFF5D0).w	; set "signpost patterns have been loaded" flag

Signpost_Exit:
		rts	
; End of function SignpostArtLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Special Stage
; ---------------------------------------------------------------------------

SpecialStage:				; XREF: GameModeArray
		bsr	PLC_ClearQueue
		jsr	DrawBuffer_Clear
		display_enable

		tst.b	($FFFFFF5F).w	; is this the blackout special stage?
		beq.s	@notblackout	; if not, branch
		
		clr.b	($FFFFFFD0).w	; disable distortion effect
		clr.b	(CameraShake).w	; disable screen shake effect
		
		move.w	#$E4,d0		; stop music
		bsr	PlaySound_Special
		
		; instantly turn the entire palette black
		jsr	Pal_CutToBlack

		move.b	#$12,VBlankRoutine	; apply palette changes before we move on
		bsr	DelayProgram
		bra.s	@sssetup

@notblackout:
		move.w	#$CA,d0
		bsr	PlaySound_Special ; play special stage entry sound
		move.w	#$8014,($C00004).l	; enable h-ints
		bsr	Pal_MakeFlash
; ---------------------------------------------------------------------------

@sssetup:
		VBlank_SetMusicOnly
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8AAF,($FFFFF624).w
		move.w	#$9011,(a6)
		move.w	#$8004,(a6)		; enable h-ints
		move.w	#$8A00|$DF,($FFFFF624).w	; set initial H-int counter value to apply once per frame
		move.w	($FFFFF624).w,(a6)		; apply H-int counter
		bsr	ClearScreen

		lea	($C00004).l,a5
		move.w	#$8F01,(a5)
		move.l	#$946F93FF,(a5)
		move.w	#$9780,(a5)
		move.l	#$50000081,(a5)
		move.w	#0,($C00000).l
loc_463C:
		move.w	(a5),d1
		btst	#1,d1
		bne.s	loc_463C
		move.w	#$8F02,(a5)
		
		bsr	SS_BGLoad
		
		moveq	#$14,d0
		bsr	PLC_ExecuteOnce	; load special stage patterns

		tst.b	($FFFFFF5F).w	; is this the blackout special stage?
		beq.s	@contx		; if not, branch
		moveq	#$1B,d0
		bsr	PLC_ExecuteOnce	; load unique blackout challenge patterns (skull)
@contx:

		lea	($FFFFD000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1
SS_ClrObjRam:	move.l	d0,(a1)+
		dbf	d1,SS_ClrObjRam	; clear	the object RAM

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1
SS_ClrRam:	move.l	d0,(a1)+
		dbf	d1,SS_ClrRam	; clear	variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$27,d1
SS_ClrRam2:	move.l	d0,(a1)+
		dbf	d1,SS_ClrRam2	; clear	variables

		lea	($FFFFAA00).w,a1
		moveq	#0,d0
		move.w	#$7F,d1
SS_ClrNemRam:	move.l	d0,(a1)+
		dbf	d1,SS_ClrNemRam	; clear	BG buffer

		lea	PLC_TitleCard, a1
		jsr	LoadPLC_Direct

		bsr	DeformBgLayer

		bsr	ClearEverySpecialFlag
		clr.b	($FFFFF64E).w
		clr.w	($FFFFFE02).w
		clr.b	($FFFFFE57).w

		moveq	#$A,d0		; load default palette
		tst.b	($FFFFFF5F).w	; is this the blackout special stage?
		beq.s	@contx		; if not, branch
		moveq	#22,d0		; load dark/red palette
@contx:		bsr	PalLoad1	; load special stage palette
		jsr	SS_Load
		bsr	SS_BGAnimate

		move.l	#0,($FFFFF700).w
		move.l	#0,($FFFFF704).w
		move.b	#9,($FFFFD000).w ; load	special	stage Sonic object
		move.b	#$34,($FFFFD080).w ; load title	card object

		bsr	PalCycle_SS
		clr.w	($FFFFF780).w	; set stage angle to "upright"
		move.w	#0,($FFFFF782).w ; no rotation speed
	;	move.w	#$40,($FFFFF782).w ; set stage rotation	speed
		move.w	#$89,d0
		tst.b	($FFFFFF5F).w	; is this the blackout special stage?
		beq.s	@conto
		move.w	#$9C,d0		; play creepy music
		move.w	#-$1F00,($FFFFF780).w	; pre-rotate stage so that it's 45 degrees

@conto:
		bsr	PlaySound	; play special stage BG	music
		move.w	#0,($FFFFF790).w
		move.w	#0,($FFFFFE08).w
		move.w	#1800,($FFFFF614).w

		display_enable
		VBlank_UnsetMusicOnly

		; the following code is basically just Pal_MakeWhite but
		; adjusted to already start displaying the level during the fade-in
		move.w	#$8014,($C00004).l	; enable h-ints for the black bars
		move.w	#BlackBars.MaxHeight,BlackBars.Height
		move.w	#$3F,($FFFFF626).w
		moveq	#0,d0
		lea	($FFFFFB00).w,a0
		move.b	($FFFFF626).w,d0
		adda.w	d0,a0
		move.w	#$EEE,d1
		move.b	($FFFFF627).w,d0
@PalWhiteLoop:	move.w	d1,(a0)+
		dbf	d0,@PalWhiteLoop
		move.w	#$15,d5
@loc_1EF4:	move.l	d5,-(sp)
		move.b	#$A,VBlankRoutine
		bsr	DelayProgram
		move.w	($FFFFF604).w,($FFFFF602).w
		jsr	ObjectsLoad
		jsr	BuildSprites
		jsr	SS_ShowLayout
		bsr	SS_BGAnimate
		bsr	Pal_WhiteToBlack
		move.l	(sp)+,d5
		dbf	d5,@loc_1EF4


; ---------------------------------------------------------------------------
; Main Special Stage loop
; ---------------------------------------------------------------------------

SS_MainLoop:
		cmpi.b	#4,($FFFFD024).w	; is special stage exiting routine already being run?
		bhs.w	SS_WaitVBlank		; if yes, branch
		bsr	PauseGame		; make the game pausing when pressing start

		; respawn at last checkpoint when pressing A (inteded to be used when you get stuck in nonstop inhuman)
		btst	#6,($FFFFF603).w	; was A pressed this frame?
		beq.s	@nota			; if not, branch
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	@nota			; if not, branch
		lea	($FFFFD000).w,a0	; load Sonic object
		jsr	TouchGoalBlock		; respawn at last checkpoint
@nota:
		; reduce Sonic's vertical movement when holding ABC in Unreal Place
		move.b	($FFFFF602).w,d0	; get held buttons
		andi.w	#$70,d0			; is ABC held?
		beq.s	@notc			; if not, branch
		tst.b	($FFFFFFBF).w		; Unreal Place floating challenge enabled?
		beq.s	@notc			; if not, branch
		move.w	($FFFFFE0E).w,d0
		andi.w	#7,d0
		bne.s	@notc			; only every 8th frame
		move.w	($FFFFD012).w,d0
		asr.w	#1,d0
		move.w	d0,($FFFFD012).w	; reduce Sonic's vertical speed
@notc:
		; SS hard part skipper
		tst.b	($FFFFF603).w		; was anything pressed this frame?
		beq.s	SS_WaitVBlank		; if not, branch
		move.b	($FFFFF602).w,d0	; get button presses
		tst.w	($FFFFFFFA).w		; is debug cheat enabled?
		beq.s	@notdebug		; if not, branch
		cmpi.b	#$60,d0			; is A&C held? (filter out B to not interfere with debug mode)
		bne.s	SS_WaitVBlank		; if not, branch
		bra.s	@abcpressed		; do the thing
@notdebug:	cmpi.b	#$70,d0			; is exactly ABC held?
		bne.s	SS_WaitVBlank		; if not, branch

@abcpressed:
		tst.b	($FFFFFF5F).w		; is this the blackout special stage?
		bne.s	@disallowed		; if yes, disallow hard part skippers
		frantic				; is frantic mode enabled?
		beq.s	@dohardpartskip		; if not, allow hard part skippers
@disallowed:	move.w	#$DC,d0			; play option disallowed sound
		jsr	(PlaySound_Special).l	; play sound		
		bra.s	SS_WaitVBlank		; skip

@dohardpartskip:
		move.b	#4,($FFFFD024).w	; make SS-Sonic object run "Obj09_Exit"
		move.w	#$A8,d0			; play special stage exit sound
		jsr	(PlaySound_Special).l	; play sound
		clr.w	($FFFFFE20).w		; lose all your rings, loser

SS_WaitVBlank:
		move.b	#$A,VBlankRoutine
		bsr	DelayProgram
		move.w	($FFFFF604).w,($FFFFF602).w
		jsr	ObjectsLoad
		jsr	BuildSprites
		jsr	SS_ShowLayout
		bsr	SS_BGAnimate

		bsr	BlackoutChallenge

		cmpi.b	#$10,($FFFFF600).w ; is	game mode still special stage?
		beq.w	SS_MainLoop	; if yes, loop
; ---------------------------------------------------------------------------

		; exit special stage
		move.w	#60,($FFFFF614).w ; set	delay time to 1	second
		move.w	#$3F,($FFFFF626).w
		clr.w	($FFFFF794).w

SS_EndLoop:
		move.b	#$16,VBlankRoutine
		bsr	DelayProgram
		move.w	($FFFFF604).w,($FFFFF602).w
		jsr	ObjectsLoad
		jsr	BuildSprites
	;	bsr	PLC_Execute
		jsr	SS_ShowLayout
		bsr	SS_BGAnimate
		
		subq.w	#1,($FFFFF794).w
		bpl.s	loc_47D4
		move.w	#2,($FFFFF794).w
		bsr	Pal_ToWhite

loc_47D4:
		tst.w	($FFFFF614).w
		bne.s	SS_EndLoop

		moveq	#0,d0
		bsr	LoadPLC2
		moveq	#0,d0
		move.w	#$7FF,d1

SS_EndClrObjRamX:
		move.l	d0,(a1)+
		dbf	d1,SS_EndClrObjRamX ; clear object RAM
		
		jsr	ClearEverySpecialFlag
		
		move.l	a0,-(sp)
		lea	($FFFFD000).w,a0
		jsr	Sonic_ResetOnFloor
		move.l	(sp)+,a0

		move.b	#$C,VBlankRoutine
		bsr	DelayProgram
		jsr	ObjectsLoad
		jsr	BuildSprites
		bsr	Pal_MakeFlash

		move.l	#10000,d0		; add 100000 ...
		jsr	AddPoints		; ... points
		jmp	Exit_Level
; ===========================================================================

Blackout_RotationSpeed = $140

BlackoutChallenge:
		tst.b	($FFFFFF5F).w	;  is this the blackout special stage?
		beq.s	@blackoutend
		cmpi.b	#4,($FFFFD024).w	; is special stage exiting routine being run?
		bhs.w	@blackoutend		; if yes, branch

		; continously apply the red/black palette
		movem.l	d0-a1,-(sp)
		lea	($FFFFFB4E).w,a1 	; get palette
		moveq	#0,d3			; clear d3
		move.b	#7,d3			; set d3 to 7 (+1 for the first run)
@blackoutpalette:
		moveq	#0,d0			; clear d0
		move.w	(a1),d0			; get colour
		moveq	#0,d1			; clear d1
		move.b	d0,d1 			; copy Green and Red of colour to d1
		lsr.b	#4,d1 			; get only Green amount
		move.b	d0,d2 			; copy Green and Red of colour to d2
		and.b	#$E,d2 			; get only Red amount
		lsr.w	#8,d0 			; get only Blue amount of d0
		add.b	d1,d0 			; add Green amount to Blue amount
		add.b	d2,d0 			; then add Red to the amount
		divu.w	#3,d0 			; divide by 3
		and.b	#$E,d0 			; keep it an even value (Keep 9-bit VDP)
		move.b	d0,d1 			; copy to d1
		lsl.b	#4,d1 			; shift to left nybble
		add.b	d1,d0 			; add to d0 (Setting the green)
		lsl.w	#4,d1 			; shift to next left nybble
		add.w	d1,d0			; add to d0 (Setting the blue)
		move.w	d0,(a1)+		; set new colour
		dbf	d3,@blackoutpalette	; loop for each colour
		movem.l	(sp)+,d0-a1

		; blackout challenge controls
		clr.w	($FFFFF782).w		; clear rotation speed

		btst	#2,($FFFFF602).w	; is left being pressed?
		beq.s	@contnotl		; if not, branch
		move.w	#-Blackout_RotationSpeed,($FFFFF782).w ; counterclockwise rotation
		bra.s	@blackoutend
@contnotl:
		btst	#3,($FFFFF602).w	; is right being pressed?
		beq.s	@blackoutend		; if not, branch
		move.w	#Blackout_RotationSpeed,($FFFFF782).w ; clockwise rotation

@blackoutend:
		rts
; ---------------------------------------------------------------------------

; ---------------------------------------------------------------------------
; Special stage	background loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_BGLoad:				; XREF: SpecialStage
		lea	($FF0000).l,a1
		lea	(Eni_SSBg2).l,a0 ; load	mappings for the clouds
		move.w	#$4000,d0
		bsr	EniDec
		lea	($FF0000).l,a1
		move.l	#$40000003,d0
		moveq	#$3F,d1
		moveq	#$1F,d2
		bsr	ShowVDPGraphics
		lea	($FF0000).l,a1
		move.l	#$50000003,d0
		moveq	#$3F,d1
		moveq	#$3F,d2
		bsr	ShowVDPGraphics
		rts	
; End of function SS_BGLoad

; ---------------------------------------------------------------------------
; Palette cycling routine - special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PalCycle_SS:				; XREF: loc_DA6; SpecialStage
		tst.w	($FFFFF63A).w		; is game paused?
		bne.w	locret_49E6		; if yes, branch

		subq.w	#1,($FFFFF79C).w	; sub 1 from remaining time before changing pal
		bpl.w	locret_49E6		; if time remains, branch

		lea	($C00004).l,a6
		move.w	($FFFFF79A).w,d0
		addq.w	#1,($FFFFF79A).w
		andi.w	#$1F,d0
		lsl.w	#2,d0
		lea	(byte_4A3C).l,a0
		adda.w	d0,a0
		move.b	(a0)+,d0
		bpl.s	loc_4992
		move.w	#$1FF,d0
		frantic
		beq.s	loc_4992
		move.w	#$FF,d0

loc_4992:
		move.w	d0,($FFFFF79C).w
		moveq	#0,d0
		move.b	(a0)+,d0
		move.w	d0,($FFFFF7A0).w
		lea	(byte_4ABC).l,a1
		lea	(a1,d0.w),a1
		move.w	#-$7E00,d0
		move.b	(a1)+,d0
		move.w	d0,(a6)
		move.b	(a1),($FFFFF616).w
		move.w	#-$7C00,d0
		move.b	(a0)+,d0
		move.w	d0,(a6)
		move.l	#$40000010,($C00004).l
		move.l	($FFFFF616).w,($C00000).l
		moveq	#0,d0
		move.b	(a0)+,d0
		bmi.s	loc_49E8
		lea	(Pal_SSCyc1).l,a1
		adda.w	d0,a1
		lea	($FFFFFB4E).w,a2
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+

locret_49E6:
		rts	
; ===========================================================================

loc_49E8:				; XREF: PalCycle_SS
		move.w	($FFFFF79E).w,d1
		cmpi.w	#$8A,d0
		bcs.s	loc_49F4
		addq.w	#1,d1

loc_49F4:
		mulu.w	#$2A,d1
		lea	(Pal_SSCyc2).l,a1
		adda.w	d1,a1
		andi.w	#$7F,d0
		bclr	#0,d0
		beq.s	loc_4A18
		lea	($FFFFFB6E).w,a2
		move.l	(a1),(a2)+
		move.l	obMap(a1),(a2)+
		move.l	obX(a1),(a2)+

loc_4A18:
		adda.w	#$C,a1
		lea	($FFFFFB5A).w,a2
		cmpi.w	#$A,d0
		bcs.s	loc_4A2E
		subi.w	#$A,d0
		lea	($FFFFFB7A).w,a2

loc_4A2E:
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		adda.w	d0,a1
		move.l	(a1)+,(a2)+
		move.w	(a1)+,(a2)+
		rts	
; End of function PalCycle_SS

; ===========================================================================
byte_4A3C:	dc.b 3,	0, 7, $92, 3, 0, 7, $90, 3, 0, 7, $8E, 3, 0, 7,	$8C
		dc.b 3,	0, 7, $8B, 3, 0, 7, $80, 3, 0, 7, $82, 3, 0, 7,	$84
		dc.b 3,	0, 7, $86, 3, 0, 7, $88, 7, 8, 7, 0, 7,	$A, 7, $C
		dc.b $FF, $C, 7, $18, $FF, $C, 7, $18, 7, $A, 7, $C, 7,	8, 7, 0
		dc.b 3,	0, 6, $88, 3, 0, 6, $86, 3, 0, 6, $84, 3, 0, 6,	$82
		dc.b 3,	0, 6, $81, 3, 0, 6, $8A, 3, 0, 6, $8C, 3, 0, 6,	$8E
		dc.b 3,	0, 6, $90, 3, 0, 6, $92, 7, 2, 6, $24, 7, 4, 6,	$30
		dc.b $FF, 6, 6,	$3C, $FF, 6, 6,	$3C, 7,	4, 6, $30, 7, 2, 6, $24
		even
byte_4ABC:	dc.b $10, 1, $18, 0, $18, 1, $20, 0, $20, 1, $28, 0, $28, 1
		even

Pal_SSCyc1:	incbin	palette\c_ss_1.bin
		even
Pal_SSCyc2:	incbin	palette\c_ss_2.bin
		even

; ---------------------------------------------------------------------------
; Subroutine to	make the special stage background animated
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_BGAnimate:				; XREF: SpecialStage
		move.w	($FFFFF7A0).w,d0
		bne.s	loc_4BF6
		move.w	#0,($FFFFF70C).w
		move.w	($FFFFF70C).w,($FFFFF618).w

loc_4BF6:
		cmpi.w	#8,d0
		bcc.s	loc_4C4E
		cmpi.w	#6,d0
		bne.s	loc_4C10
		addq.w	#1,($FFFFF718).w
		addq.w	#1,($FFFFF70C).w
		move.w	($FFFFF70C).w,($FFFFF618).w

loc_4C10:
		moveq	#0,d0
		move.w	($FFFFF708).w,d0
		neg.w	d0
		swap	d0
		lea	(byte_4CCC).l,a1
		lea	($FFFFAA00).w,a3
		moveq	#9,d3

loc_4C26:
		move.w	obGfx(a3),d0
		bsr	CalcSine
		moveq	#0,d2
		move.b	(a1)+,d2
		muls.w	d2,d0
		asr.l	#8,d0
		move.w	d0,(a3)+
		move.b	(a1)+,d2
		ext.w	d2
		add.w	d2,(a3)+
		dbf	d3,loc_4C26
		lea	($FFFFAA00).w,a3
		lea	(byte_4CB8).l,a2
		bra.s	loc_4C7E
; ===========================================================================

loc_4C4E:				; XREF: SS_BGAnimate
		cmpi.w	#$C,d0
		bne.s	loc_4C74
		subq.w	#1,($FFFFF718).w
		lea	($FFFFAB00).w,a3
		move.l	#$18000,d2
		moveq	#6,d1

loc_4C64:
		move.l	(a3),d0
		sub.l	d2,d0
		move.l	d0,(a3)+
		subi.l	#$2000,d2
		dbf	d1,loc_4C64

loc_4C74:
		lea	($FFFFAB00).w,a3
		lea	(byte_4CC4).l,a2

loc_4C7E:
		lea	($FFFFCC00).w,a1
		move.w	($FFFFF718).w,d0
		neg.w	d0
		swap	d0
		moveq	#0,d3
		move.b	(a2)+,d3
		move.w	($FFFFF70C).w,d2
		neg.w	d2
		andi.w	#$FF,d2
		lsl.w	#2,d2

loc_4C9A:
		move.w	(a3)+,d0
		addq.w	#2,a3
		moveq	#0,d1
		move.b	(a2)+,d1
		subq.w	#1,d1

loc_4CA4:
		move.l	d0,(a1,d2.w)
		addq.w	#4,d2
		andi.w	#$3FC,d2
		dbf	d1,loc_4CA4
		dbf	d3,loc_4C9A
		rts	
; End of function SS_BGAnimate

; ===========================================================================
byte_4CB8:	dc.b 9,	$28, $18, $10, $28, $18, $10, $30, $18,	8, $10,	0
		even
byte_4CC4:	dc.b 6,	$30, $30, $30, $28, $18, $18, $18
		even
byte_4CCC:	dc.b 8,	2, 4, $FF, 2, 3, 8, $FF, 4, 2, 2, 3, 8,	$FD, 4,	2, 2, 3, 2, $FF
		even
					; XREF: SS_BGAnimate
; ===========================================================================

; ---------------------------------------------------------------------------
; Object 80 - Continue screen elements
; ---------------------------------------------------------------------------

Obj80:					; XREF: Obj_Index
		rts
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Ending sequence in Green Hill	Zone
; ---------------------------------------------------------------------------

EndingSequence:				; XREF: GameModeArray
		jsr	Pal_FadeFrom
		VBlank_SetMusicOnly

		lea	($FFFFD000).w,a1
		moveq	#0,d0
		move.w	#$7FF,d1
End_ClrObjRam:	move.l	d0,(a1)+
		dbf	d1,End_ClrObjRam ; clear object	RAM

		lea	($FFFFF628).w,a1
		moveq	#0,d0
		move.w	#$15,d1
End_ClrRam:	move.l	d0,(a1)+
		dbf	d1,End_ClrRam	; clear	variables

		lea	($FFFFF700).w,a1
		moveq	#0,d0
		move.w	#$3F,d1
End_ClrRam2:	move.l	d0,(a1)+
		dbf	d1,End_ClrRam2	; clear	variables

		lea	($FFFFFE60).w,a1
		moveq	#0,d0
		move.w	#$47,d1
End_ClrRam3:	move.l	d0,(a1)+
		dbf	d1,End_ClrRam3	; clear	variables

		bsr	ClearScreen
		lea	($C00004).l,a6
		move.w	#$8B03,(a6)
		move.w	#$8230,(a6)
		move.w	#$8407,(a6)
		move.w	#$857C,(a6)
		move.w	#$9001,(a6)
		move.w	#$8014,(a6)	; enable h-ints for black bars
		move.w	#$8ADF,(a6)
		move.w	#$8720,(a6)
		move.w	#$8ADF,($FFFFF624).w
		move.w	($FFFFF624).w,(a6)
		move.w	#$1E,($FFFFFE14).w
		move.w	#$601,($FFFFFE10).w ; set level	number to 0601 (no flowers)
		move.b	#1,($FFFFF7CC).w

End_LoadData:
		move.b	#4,VBlankRoutine
		bsr	DelayProgram
		moveq	#$1C,d0
		bsr	PLC_ExecuteOnce	; load ending sequence patterns
		jsr	Hud_Base
		bsr	LevelSizeLoad
		bsr	DeformBgLayer
		bset	#2,($FFFFF754).w
		
		bsr	MainLoadBlockLoad	; load block mappings and palettes
		jsr 	LevelRenderer_DrawLayout_FG
		jsr 	LevelRenderer_DrawLayout_BG
		VBlank_UnsetMusicOnly

		move.l	#Col_GHZ,($FFFFF796).w ; load collision	index
		moveq	#3,d0
		bsr	PalLoad1	; load Sonic's palette

End_LoadSonic:
		moveq	#0,d0
		move.l	d0,($FFFFFE22).w
		move.b	d0,($FFFFFE1B).w
		move.b	d0,($FFFFFE2C).w
		move.b	d0,($FFFFFE2D).w
		move.b	d0,($FFFFFE2E).w
		move.b	d0,($FFFFFE2F).w
		move.w	d0,($FFFFFE08).w
		move.w	d0,($FFFFFE02).w
		move.w	d0,($FFFFFE04).w
		move.b	d0,($FFFFD034).w ; clear speed shoes timer

		move.b	#1,($FFFFD000).w ; load	Sonic object
		
		bset	#0,($FFFFD022).w ; make	Sonic face left
		move.b	#1,($FFFFF7CC).w ; lock	controls
		move.w	#$400,($FFFFF602).w ; move Sonic to the	left
		move.w	#-$800,($FFFFD014).w ; set Sonic's speed
		move.b	#4,VBlankRoutine
		bsr	DelayProgram
		jsr	ObjPosLoad
		jsr	ObjectsLoad
		jsr	BuildSprites

		bsr	OscillateNumInit
		move.b	#1,($FFFFFE1F).w
		move.b	#1,($FFFFFE1D).w
		move.b	#0,($FFFFFE1E).w
		move.w	#1800,($FFFFF614).w
		move.b	#$18,VBlankRoutine
		bsr	DelayProgram
		move.w	#$8014,($C00004).l	; enable h-ints
		display_enable
		move.w	#$3F,($FFFFF626).w
		bsr	Pal_FadeTo

; ---------------------------------------------------------------------------
; Main ending sequence loop
; ---------------------------------------------------------------------------

End_MainLoop:
		move.b	#$18,VBlankRoutine
		bsr	DelayProgram
		addq.w	#1,($FFFFFE04).w
		bsr	End_MoveSonic
		jsr	ObjectsLoad
		bsr	DeformBgLayer
		jsr 	LevelRenderer_Update_FG
		jsr 	LevelRenderer_Update_BG
		jsr	BuildSprites
		jsr	ObjPosLoad
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	@checkeaster		; if not, branch
		bsr	PCL_Load		; pal cycle while alive

@checkeaster:
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	@checkfadeout		; if not, branch	
		move.w	($FFFFF72A).w,d0	; get right level boundary
		addi.w	#$128,d0		; adjust a bit
		cmp.w	($FFFFD008).w,d0	; compare to Sonic's X pos
		bgt.s	@checkfadeout		; if he's left of the boundary, all good
		move.w	#1,($FFFFFE02).w	; start credits to not softlock in nonstop inhuman

@checkfadeout:
		tst.w	($FFFFFE02).w			; is level set to restart? (after Sonic died)
		beq.w	End_MainLoop			; if not, loop
		cmpi.w	#224/2-2,BlackBars.Height	; did black bars finish covering up the screen?
		blo.s	End_MainLoop			; if not, loop
		jmp	Exit_EndingSequence		; go to credits screen

; ---------------------------------------------------------------------------
; Subroutine controlling Sonic on the ending sequence
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


End_MoveSonic:				; XREF: End_MainLoop
		move.b	#1,($FFFFF7CC).w ; lock	controls
		cmpi.w	#$90,($FFFFD008).w ; has Sonic passed $90 on y-axis?
		bcc.s	End_MoveSonExit	; if not, branch
		move.w	#$800,($FFFFF602).w ; move Sonic to the	right

End_MoveSonExit:	
		rts	
; End of function End_MoveSonic

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 87 - Sonic on ending sequence
; ---------------------------------------------------------------------------

Obj87:					; XREF: Obj_Index
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 88 - chaos emeralds on	the ending sequence
; ---------------------------------------------------------------------------

Obj88:					; XREF: Obj_Index
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 89 - "SONIC THE HEDGEHOG" text	on the ending sequence
; ---------------------------------------------------------------------------

Obj89:					; XREF: Obj_Index
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Credits ending sequence
; ---------------------------------------------------------------------------

Credits:				; XREF: GameModeArray
		rts	; eradicated

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8B - Starfield Star
; ---------------------------------------------------------------------------

Starfield_SpawnInterval = 10

Obj8B:
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	@Index(pc,d0.w),d1
		jsr	@Index(pc,d1.w)
		jmp	DisplaySprite

; ===========================================================================
@Index:		dc.w @Emitter-@Index
		dc.w @Particle-@Index
		dc.w @ChkOffscreen-@Index
; ===========================================================================

@Emitter:
	
		move.b	#Starfield_SpawnInterval,$31(a0)	; set casual spawn interval
		move.w 	#$125,obX(a0)				; horizontally center emitter
		move.w 	#$80,obScreenY(a0)			; set emitter to top of screen
		frantic						; frantic mode selected?
		beq.s	@cont					; if not, branch
		move.w 	#$170,obScreenY(a0)			; set emitter to top of screen
		move.b	#Starfield_SpawnInterval/3,$31(a0)	; tripe particle spawn rate
		
@cont:
		subq.b	#1,$30(a0)				; subtract 1 from remaining emitter time
		bpl.s	@Return					; if time left, branch
		move.b	$31(a0),$30(a0)				; reset timer

		jsr	SingleObjLoad				; load star particle
		bne.s	@Return
		move.b	(a0),(a1)
		move.b	#2,obRoutine(a1)
		move.w	#$125,obX(a1) 
		move.w	#$EC,obScreenY(a1) 

@Return:
		rts
; ===========================================================================

@Particle:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj8B,obMap(a0)
		move.w	#($2000/$20),obGfx(a0)
		
		jsr 	RandomNumber
		and.w 	#$3, d0
		add.w 	d0, obGfx(a0)
	;	move.w	($FFFFFE0E).w,d0
	;	andi.w	#$3F,d0
	;	add.w	d0,obGfx(a0)
		
		move.b	#0,obRender(a0)
		
		jsr	RandomDirection
		
; ---------------------------------------------------------------------------

@ChkOffscreen:
		jsr 	SpeedToScreenPos
		
		; X < $40
		cmpi.w	#$40,obX(a0)
		bmi.w	@Destroy

		; X > $1D0
		cmpi.w	#$1D0,obX(a0)
		bpl.w	@Destroy

		; Y < $60
		cmpi.w	#$60,obScreenY(a0)
		bmi.w	@Destroy

		; Y > $100
		cmpi.w	#$170,obScreenY(a0)
		bpl.w	@Destroy
		rts

@Destroy:
		addq.w  #4,sp 		; skip the `jmp DisplaySprite` so it doesn't save the object (tysm markey)
		jmp 	DeleteObject
; ---------------------------------------------------------------------------
Map_obj8B:
		include	"_maps\obj8B.asm"
; ---------------------------------------------------------------------------
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8C - chaos emeralds on	the "TRY AGAIN"	screen
; ---------------------------------------------------------------------------

Obj8C:					; XREF: Obj_Index
		rts
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	load level boundaries and start	locations
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LevelSizeLoad:				; XREF: TitleScreen; Level; EndingSequence
		moveq	#0,d0
		move.b	d0,($FFFFF740).w
		move.b	d0,($FFFFF741).w
		move.b	d0,($FFFFF746).w
		move.b	d0,($FFFFF748).w
		move.b	d0,($FFFFF742).w
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		lea	LevelSizeArray(pc,d0.w),a0 ; load level	boundaries
		move.w	(a0)+,d0
		move.w	d0,($FFFFF730).w
		move.l	(a0)+,d0
		move.l	d0,($FFFFF728).w
		move.l	d0,($FFFFF720).w
		move.l	(a0)+,d0
		move.l	d0,($FFFFF72C).w
		move.l	d0,($FFFFF724).w
		move.w	($FFFFF728).w,d0
		addi.w	#$240,d0
		move.w	d0,($FFFFF732).w
		move.w	#$1010,($FFFFF74A).w
		move.w	(a0)+,d0
		move.w	d0,($FFFFF73E).w
		bra.w	LevSz_ChkLamp
; ===========================================================================
; ---------------------------------------------------------------------------
; Level size array and ending start location array
; ---------------------------------------------------------------------------
LevelSizeArray:	include "misc\lvl_size.asm"
		even

; ===========================================================================

LevSz_ChkLamp:				; XREF: LevelSizeLoad
		tst.b	($FFFFFE30).w	; have any lampposts been hit?
		beq.s	LevSz_StartLoc	; if not, branch
		cmpi.w	#$400,($FFFFFE10).w	; is level Uberhub?
		bne.s 	@notuberhub			; if not, branch
		clr.w	($FFFFFE30).w		; make sure nothing with checkpoints ever happens in Uberhub
		bra.s	LevSz_StartLoc

@notuberhub:
		jsr	obj79_LoadInfo
		move.w	($FFFFD008).w,d1
		move.w	($FFFFD00C).w,d0
		bra.w	loc_60D0
; ===========================================================================

LevSz_StartLoc:				; XREF: LevelSizeLoad
		move.w	($FFFFFE10).w,d0
		
		; frantic Uberhub fast spawn
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ?
		bne.s 	@load			; if not, branch
		frantic				; are we in frantic mode
		beq.s	@load			; if not, branch
		tst.w	($FFFFFF8A).w		; have any levels been beaten yet?
		beq.s	@load			; if not, branch
		addq.w	#1,d0			; use SYZ2 start locations (unused anyway, has the frantic coordinates)
@load:
		lsl.b	#6,d0
		lsr.w	#4,d0
		lea	StartLocArray(pc,d0.w),a1 ; load Sonic's start location
		bra.s	LevSz_SonicPos

; ---------------------------------------------------------------------------
; Sonic	start location array
; ---------------------------------------------------------------------------
StartLocArray:	include "misc\sloc_lev.asm"
; ---------------------------------------------------------------------------


LevSz_SonicPos:
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ?
		bra.s 	@cont			; if not, branch
	;	move.w	#$04A0,($FFFFD008).w ; set Sonic's position on x-axis
	;	move.w	#$00A0,($FFFFD00C).w ; set Sonic's position on y-axis
		
		move.w	#$04A0,($FFFFF700).w ; set Sonic's position on x-axis
		move.w	#$00A0,($FFFFF704).w ; set Sonic's position on y-axis
		
		move.w	#-$800,($FFFFD012).w
		bra.s	loc_60D0

@cont:
		moveq	#0,d1
		move.w	(a1)+,d1
		move.w	d1,($FFFFD008).w ; set Sonic's position on x-axis
		moveq	#0,d0
		move.w	(a1),d0
		move.w	d0,($FFFFD00C).w ; set Sonic's position on y-axis

loc_60D0:				; XREF: LevSz_ChkLamp
		clr.w	($FFFFF7A8).w		; reset Sonic's position tracking index
		lea	($FFFFCB00).w,a2	; load the tracking array into a2
		moveq	#63,d2			; begin a 64-step loop
@looppoint:
		move.w	d1,(a2)+		; fill in X
		move.w	d0,(a2)+		; fill in Y
		dbf	d2,@looppoint		; loop

		subi.w	#$A0,d1
		bcc.s	loc_60D8
		moveq	#0,d1

loc_60D8:
		move.w	($FFFFF72A).w,d2
		cmp.w	d2,d1
		bcs.s	loc_60E2
		move.w	d2,d1

loc_60E2:
		move.w	d1,($FFFFF700).w
		subi.w	#$60,d0
		bcc.s	loc_60EE
		moveq	#0,d0

loc_60EE:
		cmp.w	($FFFFF72E).w,d0
		blt.s	loc_60F8
		move.w	($FFFFF72E).w,d0

loc_60F8:
		move.w	d0,($FFFFF704).w
		bsr	BgScrollSpeed
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.b	#2,d0
		move.l	LoopTileNums(pc,d0.w),($FFFFF7AC).w
		bra.w	LevSz_Unk
; ===========================================================================
; ---------------------------------------------------------------------------
; Which	256x256	tiles contain loops or roll-tunnels
; ---------------------------------------------------------------------------
; Format - 4 bytes per zone, referring to which 256x256 evoke special events:
; loop,	loop, tunnel, tunnel
; ---------------------------------------------------------------------------
LoopTileNums:	incbin	misc\loopnums.bin
		even

; ===========================================================================

LevSz_Unk:				; XREF: LevelSizeLoad
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#3,d0
		lea	dword_61B4(pc,d0.w),a1
		lea	($FFFFF7F0).w,a2
		move.l	(a1)+,(a2)+
		move.l	(a1)+,(a2)+
		rts	
; End of function LevelSizeLoad

; ===========================================================================
dword_61B4:	dc.l $700100, $1000100
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $8000100, $1000000
		dc.l $700100, $1000100
; ===========================================================================

*BgScrollSpeed:
*DeformBgLayer:
*Deform_GHZ:
		include	'modules/Plane Scrolling.asm'

; ---------------------------------------------------------------------------
; Main Load Block loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MainLoadBlockLoad:			; XREF: Level; EndingSequence
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		lsl.w	#4,d0
		lea	(MainLoadBlocks).l,a2
		lea	(a2,d0.w),a2
		move.l	a2,-(sp)
		addq.l	#4,a2
		
		move.l	(a2)+,BlocksAddress

		movea.l	(a2)+,a0
		lea	($FF0000).l,a1	; RAM address for 256x256 mappings
		bsr	KosDec
		bsr	LevelLayoutLoad

		move.w	(a2)+,d0
		move.w	(a2),d0
		andi.w	#$FF,d0

		cmpi.w	#$500,($FFFFFE10).w
		bne.s	MLB_NotBCut
		moveq	#$15,d0

MLB_NotBCut:
		cmpi.w	#$001,($FFFFFE10).w	; is level GHZ2?
		bne.s	MLB_NotGHZ2		; if not, branch
		moveq	#$D,d0			; use GHZ2 palette

MLB_NotGHZ2:
		cmpi.w	#$002,($FFFFFE10).w	; is level GHZ3?
		bne.s	MLB_NotGHZ3		; if not, branch
		moveq	#$C,d0			; use GHZ3 palette

MLB_NotGHZ3:
		cmpi.w	#$502,($FFFFFE10).w ; is level FZ?
		bne.s	MLB_NormalPal	; if not, branch
		moveq	#$E,d0		; use FZ palette

MLB_NormalPal:
		bsr	PalLoad1	; load palette (based on	d0)
		movea.l	(sp)+,a2
		addq.w	#4,a2
		moveq	#0,d0
		move.b	(a2),d0
		beq.s	locret_6D10
		bsr	LoadPLC		; load pattern load cues

locret_6D10:
		rts	
; End of function MainLoadBlockLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Level	layout loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LevelLayoutLoad:			; XREF: TitleScreen; MainLoadBlockLoad
		lea 	LevelLayout_FG, a1
		moveq	#0, d1
		bsr.s	LevelLayoutLoad_DecompressLayout

LevelLayoutLoad_BG:
		lea 	LevelLayout_BG, a1 		; RAM address for background layout
		moveq	#2, d1
		;bra.s	LevelLayoutLoad_DecompressLayout

	LevelLayoutLoad_DecompressLayout:
			move.w	CurrentLevel, d0	; d0 = %0000zzzz 000000aa
			ror.b	#2, d0			; d0 = %0000zzzz aa000000
			lsr.w	#4, d0			; d0 = %00000000 zzzzaa00
			add.w	d1, d0
			lea 	Level_Index, a0
			move.w	(a0, d0), d0
			lea 	(a0, d0), a0		; a0 = layout base address
		if def(__DEBUG__)
			KDebug.WriteLine "LevelLayoutLoad(): Loaded layout: %<.l a0 sym>"
			movem.l	a0-a1, -(sp)
			jsr	KosPlusDec
			move.w	a1, d1
			movem.l	(sp)+, a0-a1
			sub.w	a1, d1
			cmp.w	#$200, d1
			bne.s	@err_illegal_layout
			rts

		@err_illegal_layout:
			RaiseError	"Illegal layout size ($%<.w d1>)%<endl>Source: %<.l a0 sym>%<endl>Dest: %<.l a1 sym>"

		else
			jmp	KosPlusDec
		endif


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to change a single chunk in the level layout.
;
; Usage:
;  d0 = rough X position of the chunk to replace
;  d1 = rough Y position of the chunk to replace
;  d2 = ID of the new chunk
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Sub_ChangeChunk:
		lsr.w	#7,d0			; d0 = X / $80
		lsr.w	#1,d0			; d0 = X / $100
		lsr.w	#2,d1			; d1 = Y / 4
		andi.w	#$FFC0,d1		; d1 = (Y / 4) & $FFC0
		add.w	d1,d0
		lea	LevelLayout_FG, a0
		adda.w	d0,a0
		move.b	d2,(a0)
		rts
; End of function Sub_ChangeChunk

; ===========================================================================
; ---------------------------------------------------------------------------
; Dynamic screen resize	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DynScrResizeLoad:			; XREF: DeformBgLayer
		cmpi.b	#6,($FFFFD024).w	; is Sonic dead?
		bhs.s	locret_6DAA		; if yes, branch

		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	Resize_Index(pc,d0.w),d0
		jsr	Resize_Index(pc,d0.w)
		moveq	#2,d1
		move.w	($FFFFF726).w,d0
		sub.w	($FFFFF72E).w,d0
		beq.s	locret_6DAA
		bcc.s	loc_6DAC
		neg.w	d1
		move.w	($FFFFF704).w,d0
		cmp.w	($FFFFF726).w,d0
		bls.s	loc_6DA0
		move.w	d0,($FFFFF72E).w
		andi.w	#-2,($FFFFF72E).w

loc_6DA0:
		add.w	d1,($FFFFF72E).w
		move.b	#1,($FFFFF75C).w

locret_6DAA:
		rts	
; ===========================================================================

loc_6DAC:				; XREF: DynScrResizeLoad
		move.w	($FFFFF704).w,d0
		addq.w	#8,d0
		cmp.w	($FFFFF72E).w,d0
		bcs.s	loc_6DC4
	;	btst	#1,($FFFFD022).w	; this stuff makes the vertical camera movement slower when not in air
	;	beq.s	loc_6DC4		; it can kiss my ass
		add.w	d1,d1
		add.w	d1,d1

loc_6DC4:
		add.w	d1,($FFFFF72E).w
		move.b	#1,($FFFFF75C).w
		rts	
; End of function DynScrResizeLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Offset index for dynamic screen resizing
; ---------------------------------------------------------------------------
Resize_Index:	dc.w Resize_GHZ-Resize_Index, Resize_LZ-Resize_Index
		dc.w Resize_MZ-Resize_Index, Resize_SLZ-Resize_Index
		dc.w Resize_SYZ-Resize_Index, Resize_SBZ-Resize_Index
		dc.w Resize_Ending-Resize_Index
; ===========================================================================
; ---------------------------------------------------------------------------
; Green	Hill Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_GHZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_GHZx(pc,d0.w),d0
		jmp	Resize_GHZx(pc,d0.w)

; ===========================================================================
Resize_GHZx:	dc.w Resize_GHZ1-Resize_GHZx
		dc.w Resize_GHZ2-Resize_GHZx
		dc.w Resize_GHZ3-Resize_GHZx
; ===========================================================================

Resize_GHZ1:
		cmpi.w	#$2600,($FFFFF700).w	; has the camera reached $2600 on x-axis?
		bcc.w	Resize_GHZ3		; if yes, branch

		move.w	#$300,($FFFFF726).w ; set lower	y-boundary
		cmpi.w	#$12A0,($FFFFF700).w ; has the camera reached $1780 on x-axis?
		bcs.s	locret_6E08	; if not, branch
		move.w	#$400,($FFFFF726).w ; set lower	y-boundary

locret_6E08:
	;	cmpi.w	#$20AA,($FFFFF700).w ; has the camera reached $20AA on x-axis?
		cmpi.w	#$214A,($FFFFD008).w ; has Sonic reached position $214A on X-axis?
		bcs.s	locret_6E08X	; if not, branch
		move.w	#$410,($FFFFF726).w ; set lower	y-boundary
		tst.b	($FFFFFFA9).w
		bne.s	locret_6E08X
		cmpi.b	#2,($FFFFFFD4).w
		beq.s	locret_6E08X
		move.b	#1,($FFFFF7CC).w		; lock controls
		move.b	#1,($FFFFF7AA).w 		; lock screen
		move.b	#$E0,d0
		bsr	PlaySound_Special

		jsr	SingleObjLoad
		move.b	#$1F,0(a1)
		move.w	#$22E7,obX(a1)
		move.w	#$04AE,obY(a1)

		clr.w	($FFFFD014).w
		clr.w	($FFFFD012).w
		move.w	#$800,($FFFFF602).w ; make Sonic run to	the right
		move.b	#1,($FFFFFFA9).w
		move.b	#1,($FFFFF7AA).w ; lock	screen

locret_6E08X:
		rts	
; ===========================================================================

Resize_GHZ2:
		move.b	#1,($FFFFF7CC).w		; lock controls
		move.w	#$210,($FFFFF726).w
		cmpi.w	#$F00,($FFFFF700).w
		bcs.s	locret_6E96
		cmpi.w	#$15E0,($FFFFF700).w
		bcc.s	locret_6E96
		move.w	#$110,($FFFFF726).w		; alternate bottom boundary during the buzz bomber death
		rts	
; ===========================================================================

Resize_GHZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_6E4A(pc,d0.w),d0
		jmp	off_6E4A(pc,d0.w)
; ===========================================================================
off_6E4A:	dc.w Resize_GHZ3main-off_6E4A
		dc.w Resize_GHZ3boss-off_6E4A
		dc.w Resize_GHZ3end-off_6E4A
; ===========================================================================

GHZ3Add = $2700

Resize_GHZ3main:
		move.w	#$320,($FFFFF726).w	; set lower y-boundary

		cmpi.w	#$1780+GHZ3Add,($FFFFF700).w	; has the camera reached $1780 on x-axis?
		bcs.s	locret_6E96			; if not, branch
		move.w	#$400,($FFFFF726).w		; set lower y-boundary

		cmpi.w	#$27D0+GHZ3Add,($FFFFD008).w	; is Sonic near boss?
		bcc.s	loc_6E98			; if yes, branch
		
locret_6E96:
		rts
; ===========================================================================

loc_6E98:
		move.w	#$300,($FFFFF726).w
		addq.b	#2,($FFFFF742).w
		rts
; ===========================================================================

Resize_GHZ3boss:
		move.w	#$300,($FFFFF726).w
		move.w	($FFFFF700).w,($FFFFF728).w

		cmpi.w	#$2960+GHZ3Add,($FFFFF700).w
		bcs.s	locret_6EE8
		jsr	SingleObjLoad
		bne.s	loc_6ED0
		move.b	#$3D,0(a1)	; load GHZ boss	object
		move.w	#$2A00+GHZ3Add,obX(a1)
		move.w	#$400,obY(a1)

loc_6ED0:
		move.w	#$8C,d0
		bsr	PlaySound	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#$11,d0
		bra.w	LoadPLC		; load boss patterns
; ===========================================================================

locret_6EE8:
		rts	
; ===========================================================================

Resize_GHZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Labyrinth Zone dynamic screen	resizing
; ---------------------------------------------------------------------------

Resize_LZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_LZx(pc,d0.w),d0
		jmp	Resize_LZx(pc,d0.w)
; ===========================================================================
Resize_LZx:	dc.w Resize_LZ1-Resize_LZx
		dc.w Resize_LZ2-Resize_LZx
		dc.w Resize_LZ3-Resize_LZx
		dc.w Resize_SBZ3-Resize_LZx
; ===========================================================================

Resize_LZ1:
		rts	
; ===========================================================================

Resize_LZ2:
		tst.b 	($FFFFFFFE).w
		bne.s	@blubb
		move.w	#$71F,($FFFFF726).w		; set default lower level boundary
		move.w	#$71F,($FFFFF72E).w
		rts
			
@blubb:
		tst.b	($FFFFFF97).w			; has at least one lamppost been touched?
		beq.s	@nosubchange			; if not, branch
		move.w	#$0100,d0
		move.w	#$0100,d1
		move.b	#$E,d2
		jsr	Sub_ChangeChunk			; wall off backtracing after hitting the first lamppost

@nosubchange:
		cmpi.b	#1,($FFFFFF97).w		; has first lamppost been touched?
		beq.s	@cont				; if yes, branch
		cmpi.b	#3,($FFFFFF97).w		; has third lamppost been touched?
		bne.s	@contx				; if not, branch

		move.w	#$0900,d0
		move.w	#$0200,d1
		move.b	#$4F,d2
		jsr	Sub_ChangeChunk			; wall off backtracing after hitting the third lamppost

@cont:
		move.w	#$800,($FFFFF726).w		; set default lower level boundary
		move.w	#$800,($FFFFF72E).w
		cmpi.w	#$0C50,($FFFFF700).w
		bcs.s	@contxx
		move.w	#$540,($FFFFF726).w		; set alterante lower level boundary at end of level
		move.w	#$540,($FFFFF72E).w
		rts					; don't mess with the camera at the end anymore

@contx:
		moveq	#0,d0
		moveq	#0,d1
		move.w	($FFFFF72E).w,d0		; get target lower level boundary
		move.w	($FFFFFF9C).w,d1		; get stored LZ boundary bottom limit
		sub.w	d1,d0				; subtract that limit from the current lower level boundary
		bmi.s	@contXX				; is the current camera higher than 
		move.w	($FFFFF704).w,d0		; get current Y camera position
		move.w	d0,($FFFFF726).w		; set it to lower level boundary
		move.w	d0,($FFFFF72E).w		; set it to lower level boundary
		move.w	d0,($FFFFFF9C).w		; remember

@contXX:
		rts	

; ===========================================================================

Resize_LZ3:
		tst.b	($FFFFF7EF).w	; has switch $F	been pressed?
		beq.s	loc_6F28	; if not, branch
		lea 	LevelLayout_FG+($40*2)+6, a1
		cmpi.b	#7,(a1)
		beq.s	loc_6F28
		move.b	#7,(a1)		; modify level layout
		move.w	#$B7,d0
		bsr	PlaySound_Special ; play rumbling sound

loc_6F28:
		tst.b	($FFFFF742).w
		bne.s	locret_6F64
		cmpi.w	#$1CA0,($FFFFF700).w
		bcs.s	locret_6F62
		cmpi.w	#$600,($FFFFF704).w
		bcc.s	locret_6F62
		jsr	SingleObjLoad
		bne.s	loc_6F4A
		move.b	#$77,0(a1)	; load LZ boss object

loc_6F4A:
		move.w	#$8C,d0
		bsr	PlaySound	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#$11,d0
		bra.w	LoadPLC		; load boss patterns
; ===========================================================================

locret_6F62:
		rts	
; ===========================================================================

locret_6F64:
		rts	
; ===========================================================================

Resize_SBZ3:
		cmpi.w	#$D00,($FFFFF700).w
		bcs.s	locret_6F8C
		cmpi.w	#$18,($FFFFD00C).w ; has Sonic reached the top of the level?
		bcc.s	locret_6F8C	; if not, branch
		clr.b	($FFFFFE30).w
		move.w	#1,($FFFFFE02).w ; restart level
		move.w	#$502,($FFFFFE10).w ; set level	number to 0502 (FZ)
		move.b	#1,($FFFFF7C8).w ; freeze Sonic

locret_6F8C:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Marble Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_MZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_MZx(pc,d0.w),d0
		jmp	Resize_MZx(pc,d0.w)
; ===========================================================================
Resize_MZx:	dc.w Resize_MZ1-Resize_MZx
		dc.w Resize_MZ2-Resize_MZx
		dc.w Resize_MZ3-Resize_MZx
; ===========================================================================

Resize_MZ1:
		move.w	#$520,($FFFFF726).w
		rts
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_6FB2(pc,d0.w),d0
		jmp	off_6FB2(pc,d0.w)
; ===========================================================================
off_6FB2:	dc.w loc_6FBA-off_6FB2
		dc.w loc_6FEA-off_6FB2
		dc.w loc_702E-off_6FB2
		dc.w loc_7050-off_6FB2
; ===========================================================================

loc_6FBA:
		move.w	#$1D0,($FFFFF726).w
		cmpi.w	#$700,($FFFFF700).w
		bcs.s	locret_6FE8
		move.w	#$220,($FFFFF726).w
		cmpi.w	#$D00,($FFFFF700).w
		bcs.s	locret_6FE8
		move.w	#$340,($FFFFF726).w
		cmpi.w	#$340,($FFFFF704).w
		bcs.s	locret_6FE8
		addq.b	#2,($FFFFF742).w

locret_6FE8:
		rts	
; ===========================================================================

loc_6FEA:
		cmpi.w	#$340,($FFFFF704).w
		bcc.s	loc_6FF8
		subq.b	#2,($FFFFF742).w
		rts	
; ===========================================================================

loc_6FF8:
		move.w	#0,($FFFFF72C).w
		cmpi.w	#$E00,($FFFFF700).w
		bcc.s	locret_702C
		move.w	#$340,($FFFFF72C).w
		move.w	#$340,($FFFFF726).w
		cmpi.w	#$A90,($FFFFF700).w
		bcc.s	locret_702C
		move.w	#$500,($FFFFF726).w
		cmpi.w	#$370,($FFFFF704).w
		bcs.s	locret_702C
		addq.b	#2,($FFFFF742).w

locret_702C:
		rts	
; ===========================================================================

loc_702E:
		cmpi.w	#$370,($FFFFF704).w
		bcc.s	loc_703C
		subq.b	#2,($FFFFF742).w
		rts	
; ===========================================================================

loc_703C:
		cmpi.w	#$500,($FFFFF704).w
		bcs.s	locret_704E
		move.w	#$500,($FFFFF72C).w
		addq.b	#2,($FFFFF742).w

locret_704E:
		rts	
; ===========================================================================

loc_7050:
		cmpi.w	#$E70,($FFFFF700).w
		bcs.s	locret_7072
		move.w	#0,($FFFFF72C).w
		move.w	#$600,($FFFFF726).w
	;	cmpi.w	#$1430,($FFFFF700).w
	;	bcs.s	locret_7072
	;	move.w	#$210,($FFFFF726).w

locret_7072:
		rts	
; ===========================================================================

Resize_MZ2:
		move.w	#$520,($FFFFF726).w
		cmpi.w	#$1700,($FFFFF700).w
		bcs.s	locret_7088
		move.w	#$200,($FFFFF726).w

locret_7088:
		rts	
; ===========================================================================

Resize_MZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7098(pc,d0.w),d0
		jmp	off_7098(pc,d0.w)
; ===========================================================================
off_7098:	dc.w Resize_MZ3boss-off_7098
		dc.w Resize_MZ3end-off_7098
; ===========================================================================

Resize_MZ3boss:
		move.w	#$720,($FFFFF726).w
		cmpi.w	#$1560,($FFFFF700).w
		bcs.s	locret_70E8
		move.w	#$210,($FFFFF726).w
		cmpi.w	#$17F0,($FFFFF700).w
		bcs.s	locret_70E8
		jsr	SingleObjLoad
		bne.s	loc_70D0
		move.b	#$73,0(a1)	; load MZ boss object
		move.w	#$19F0,obX(a1)
		move.w	#$22C,obY(a1)

loc_70D0:
		move.w	#$8C,d0
		bsr	PlaySound	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		addq.b	#2,($FFFFF742).w
		moveq	#$11,d0
		bra.w	LoadPLC		; load boss patterns
; ===========================================================================

locret_70E8:
		rts	
; ===========================================================================

Resize_MZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Star Light Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SLZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SLZx(pc,d0.w),d0
		jmp	Resize_SLZx(pc,d0.w)
; ===========================================================================
Resize_SLZx:	dc.w Resize_SLZ1-Resize_SLZx
		dc.w Resize_SLZ2-Resize_SLZx
		dc.w Resize_SLZ3-Resize_SLZx
; ===========================================================================

Resize_SLZ1:
		rts	
; ===========================================================================

Resize_SLZ2:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7118(pc,d0.w),d0
		jmp	off_7118(pc,d0.w)
; ===========================================================================
off_7118:	dc.w Resize_SLZ2main-off_7118
		dc.w Resize_SLZ2boss1-off_7118
		dc.w Resize_SLZ2boss2-off_7118
		dc.w Resize_SLZ2end-off_7118
; ===========================================================================

Resize_SLZ2main:
		cmpi.w	#$A0C,($FFFFD008).w
		bcs.s	locret_7130
		addq.b	#2,($FFFFF742).w		; go to SLZboss1 next frame
		move.w	#$2D0,d0		; set boundary
		move.w	d0,($FFFFF726).w	; target boundary
		move.w	d0,($FFFFF72E).w	; current boundary
		move.w	#$A10,($FFFFD008).w
		clr.l	($FFFFF602).w			; clear any remaining button presses
		clr.w	($FFFFD010).w
		clr.w	($FFFFD014).w
		move.b	#$E0,d0				; fade out music
		bsr	PlaySound_Special
		move.b	#1,($FFFFF7CC).w		; lock controls
		move.b	#1,($FFFFF7AA).w 		; lock screen
		move.b	#1,($FFFFFFA9).w		; set bomb boss flag

		lea	($FFFFD800).w,a1	; set a1 to level object RAM
		moveq	#$5F,d2			; set d2 to $5F ($D800 to $F000 = $60 objects)
@deletebombs:
		cmpi.b	#$5E,(a1)
		bne.s	@0
		clr.b	(a1)			; delete all bomb objects before the boss
@0:
		adda.l	#$40,a1			; increase pointer by $40 (next object)
		dbf	d2,@deletebombs		; loop
		
locret_7130:
		rts	
; ===========================================================================

Resize_SLZ2boss1:
		btst	#1,($FFFFD022).w
		bne.s	locret_715C
		move.w	#$800,($FFFFF602).w ; make Sonic run to	the right
		addq.b	#2,($FFFFF742).w
		move.w	#$2D0,($FFFFF72C).w	; set upper level boundary
		rts
; ===========================================================================

Resize_SLZ2boss2:
		cmpi.w	#$B00,($FFFFD008).w
		bcs.s	locret_715C
		clr.l	($FFFFF602).w			; clear any remaining button presses
		clr.w	($FFFFD010).w
		clr.w	($FFFFD014).w

		jsr	SingleObjLoad
		move.b	#$5F,0(a1)		; load bomb boss
		move.w	#$BD0,obX(a1)
		move.w	#$038C,obY(a1)
		
	if LowBossHP=1
		move.b	#2,(BossHealth).w	; set lives
	else
		move.b	#21,(BossHealth).w	; set lives
	endif
		
		move.b	(BossHealth).w,(HUD_BossHealth).w

		addq.b	#2,($FFFFF742).w
		rts
; ===========================================================================

locret_715C:
		rts	
; ===========================================================================

Resize_SLZ2end:
		; arena size during bomb boss fight
		move.w	#$860,($FFFFF728).w	; left
		move.w	#$F60,($FFFFF72A).w	; right
		rts

; ===========================================================================

Resize_SLZ3:
		move.w	#$620,($FFFFF726).w
		move.w	#$A60,($FFFFF728).w
		move.w	#0,($FFFFF72C).w	; reset upper level boundary
		
		frantic				; are we in frantic?
		beq.s	@sapending		; if not, branch
		rts				; "training wheels don't exist."

@sapending:
		cmpi.w	#$2080,($FFFFD008).w
		bcs.s	@cont3
		bra.w	@contret

@cont3:		
		cmpi.w	#$1F00,($FFFFD008).w	; is Sonic at the end of the stage?
		bcs.w	@contret		; if not, branch
		
		bclr	#0,($FFFFD022).w	; make Sonic face right	
		clr.b	($FFFFFFE5).w		; clear air freeze flag
		
		tst.b	($FFFFF7CC).w		; are controls already locked?
		bne.s	@cont5			; if yes, branch
		moveq	#$12,d0
		jsr	LoadPLC2		; load signpost	patterns
		clr.l	($FFFFF602).l		; clear button inputs

@cont5:
		cmpi.w	#$1FC0,($FFFFD008).w
		bcs.w	@cont
		
		cmpi.w	#$4C,($FFFFD00C).w
		bcc.s	@cont2
		move.w	#$48,($FFFFD00C).w
		move.w	#$200,($FFFFD010).w
		move.w	#0,($FFFFD012).w
		move.b	#$E,($FFFFD01C).w
		bra.w	@contret

@cont2:
		move.b	#1,($FFFFF7CC).w
		move.w	#$1FC0,($FFFFD008).w
		move.w	#0,($FFFFD010).w

		cmpi.w	#$688,($FFFFD00C).w
		bcs.s	@cont2x
		subq.w	#8,($FFFFFFB6).w
		move.w	($FFFFFFB6).w,($FFFFD012).w
		move.b	#2,($FFFFD01C).w
		bra.s	@cont3x
		
@cont2x:
		cmpi.w	#$8C,($FFFFD00C).w
		bcc.s	@cont4x
		addq.w	#8,($FFFFFFB6).w
		tst.w	($FFFFFFB6).w
		bmi.s	@cont5x
		move.w	#-8,($FFFFFFB6).w
		
@cont5x:
		move.w	($FFFFFFB6).w,($FFFFD012).w
		move.b	#2,($FFFFD01C).w
		bra.s	@cont3x
@cont4x:
		move.w	#-$C00,($FFFFD012).w
		move.b	#$F,($FFFFD01C).w
@cont3x:
		bra.s	@contret

@cont:
		move.b	#1,($FFFFF7CC).w
		move.w	#$6C8,($FFFFD00C).w
		move.w	#$300,($FFFFD010).w
		move.w	#0,($FFFFD012).w
		move.b	#$E,($FFFFD01C).w

@contret:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Spring Yard Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SYZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SYZx(pc,d0.w),d0
		jmp	Resize_SYZx(pc,d0.w)
; ===========================================================================
Resize_SYZx:	dc.w Resize_SYZ1-Resize_SYZx
		dc.w Resize_SYZ2-Resize_SYZx
		dc.w Resize_SYZ3-Resize_SYZx
; ===========================================================================

; Resize_Uberhub:
Resize_SYZ1:
		move.w	#$21C,($FFFFF726).w	; default boundary bottom
		
		tst.b	($FFFFFFA5).w		; entered the blackout area?
		beq.s	@noblackout		; if not, branch
		move.w	#$A8,($FFFFF726).w	; boundary bottom in blackout section
		rts

@noblackout:
		cmpi.w	#$500,($FFFFF700).w	; after 500 units?
		blo.s	@uberhubend		; if not, branch
		move.w	#$1C0,($FFFFF726).w	; raise boundary bottom (to center the level signs vertically on screen)

		cmpi.w	#$1180,($FFFFF700).w	; in the finalor section?
		blo.s	@mainpart		; if yes, do smooth camera transition
		cmpi.w	#$1840,($FFFFF700).w	; in the finalor section?
		bhs.s	@mainpart		; if yes, do smooth camera transition
		move.w	#$2E8,($FFFFF726).w	; target boundary
		rts

@mainpart:
		cmpi.w	#$260,($FFFFD00C).w	; entered a tube?
		blo.s	@uberhubend		; if not, branch
		cmpi.w	#$600,($FFFFD008).w	; make sure Sonic is in the right area
		blo.s	@uberhubend		; if before that, branch
		move.w	#$440,d0		; set boundary bottom for tubes
		move.w	d0,($FFFFF726).w	; target boundary
		move.w	d0,($FFFFF72E).w	; current boundary

@uberhubend:
		rts	
; ===========================================================================

Resize_SYZ2:
		move.w	#$520,($FFFFF726).w
		cmpi.w	#$25A0,($FFFFF700).w
		bcs.s	locret_71A2
		move.w	#$420,($FFFFF726).w
		cmpi.w	#$4D0,($FFFFD00C).w
		bcs.s	locret_71A2
		move.w	#$520,($FFFFF726).w

locret_71A2:
		rts	
; ===========================================================================

Resize_SYZ3:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_71B2(pc,d0.w),d0
		jmp	off_71B2(pc,d0.w)
; ===========================================================================
off_71B2:	dc.w Resize_SYZ3main-off_71B2
		dc.w Resize_SYZ3boss-off_71B2
		dc.w Resize_SYZ3end-off_71B2
; ===========================================================================

Resize_SYZ3main:
		cmpi.w	#$2AC0,($FFFFF700).w
		bcs.s	locret_71CE
		jsr	SingleObjLoad
		bne.s	locret_71CE
		move.b	#$76,(a1)	; load blocks that boss	picks up
		addq.b	#2,($FFFFF742).w

locret_71CE:
		rts	
; ===========================================================================

Resize_SYZ3boss:
		cmpi.w	#$2C00,($FFFFF700).w
		bcs.s	locret_7200
		move.w	#$4CC,($FFFFF726).w
		jsr	SingleObjLoad
		bne.s	loc_71EC
		move.b	#$75,(a1)	; load SYZ boss	object
		addq.b	#2,($FFFFF742).w

loc_71EC:
		move.w	#$8C,d0
		bsr	PlaySound	; play boss music
		move.b	#1,($FFFFF7AA).w ; lock	screen
		moveq	#$11,d0
		bra.w	LoadPLC		; load boss patterns
; ===========================================================================

locret_7200:
		rts	
; ===========================================================================

Resize_SYZ3end:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Scrap	Brain Zone dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_SBZ:				; XREF: Resize_Index
		moveq	#0,d0
		move.b	($FFFFFE11).w,d0
		add.w	d0,d0
		move.w	Resize_SBZx(pc,d0.w),d0
		jmp	Resize_SBZx(pc,d0.w)
; ===========================================================================
Resize_SBZx:	dc.w Resize_SBZ1-Resize_SBZx
		dc.w Resize_SBZ2-Resize_SBZx
		dc.w Resize_FZ-Resize_SBZx
; ===========================================================================

Resize_SBZ1:	; bomb machine cutscene
		move.w	#$810,($FFFFF726).w
		subq.w	#1,($FFFFFFD8).w
		bne.s	@timeleft
		jmp	Exit_BombMachineCutscene
@timeleft:
		rts
; ===========================================================================

Resize_SBZ2:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	off_7252(pc,d0.w),d0
		jmp	off_7252(pc,d0.w)
; ===========================================================================
off_7252:	dc.w Resize_SBZ2main-off_7252
		dc.w Resize_SBZ2boss-off_7252
		dc.w Resize_SBZ2boss2-off_7252
		dc.w Resize_SBZ2end-off_7252
; ===========================================================================

Resize_SBZ2main:
		move.w	#$710,($FFFFF726).w
		cmpi.w	#$1200,($FFFFF700).w
		bcs.s	locret_727A
		move.w	#$420,($FFFFF726).w

locret_727A:
		rts	
; ===========================================================================

Resize_SBZ2boss:
		cmpi.w	#$1EB0,($FFFFF700).w
		bcs.s	locret_7298
		jsr	SingleObjLoad
		bne.s	locret_7298
		move.b	#$83,(a1)	; load collapsing block	object
		addq.b	#2,($FFFFF742).w
		moveq	#$1E,d0
		bra.w	LoadPLC		; load SBZ2 Eggman patterns
; ===========================================================================

locret_7298:
		rts	
; ===========================================================================

Resize_SBZ2boss2:
		cmpi.w	#$1F60,($FFFFF700).w
		bcs.s	loc_72B6
		jsr	SingleObjLoad
		bne.s	loc_72B0
		move.b	#$82,(a1)	; load SBZ2 Eggman object
		addq.b	#2,($FFFFF742).w

loc_72B0:
		move.b	#1,($FFFFF7AA).w ; lock	screen

loc_72B6:
		bra.s	loc_72C2
; ===========================================================================

Resize_SBZ2end:
		cmpi.w	#$2050,($FFFFF700).w
		bcs.s	loc_72C2
		rts	
; ===========================================================================

loc_72C2:
		move.w	($FFFFF700).w,($FFFFF728).w
		rts	
; ===========================================================================

Resize_FZ:
		moveq	#0,d0
		move.b	($FFFFF742).w,d0
		move.w	ResizeFZ_Index(pc,d0.w),d0
		jmp	ResizeFZ_Index(pc,d0.w)
; ===========================================================================
ResizeFZ_Index:	dc.w Resize_FZmain-ResizeFZ_Index, Resize_FZboss-ResizeFZ_Index
		dc.w Resize_FZend-ResizeFZ_Index, Resize_FZAddBombs-ResizeFZ_Index
		dc.w locret_7322-ResizeFZ_Index

		dc.w Resize_FZend2-ResizeFZ_Index
		dc.w Resize_FZEscape_Nuke-ResizeFZ_Index
		dc.w Resize_FZEscape-ResizeFZ_Index
		dc.w Resize_FZEscape2-ResizeFZ_Index
		dc.w Resize_FZEscape3-ResizeFZ_Index
		dc.w Resize_FZEscape4-ResizeFZ_Index
; ===========================================================================

Resize_FZmain:
		move.w	#$510,($FFFFF726).w

		move.b	#0,(HUD_BossHealth).w

		cmpi.w	#$2148,($FFFFF700).w
		bcs.s	loc_72F4
		addq.b	#2,($FFFFF742).w
	;	moveq	#$1F,d0
	;	bsr	LoadPLC		; load FZ boss patterns

loc_72F4:
		rts	; don't lock screen until you're at the boss
		bra.w	loc_72C2
; ===========================================================================

Resize_FZboss:
		cmpi.w	#$2300,($FFFFF700).w
		bcs.s	loc_7312
		jsr	SingleObjLoad
		bne.s	loc_7312
		move.b	#$85,(a1)	; load FZ boss object
		addq.b	#2,($FFFFF742).w
		move.b	#1,($FFFFF7AA).w ; lock	screen

loc_7312:
		bra.s	loc_72C2
; ===========================================================================

Resize_FZAddBombs:
		tst.b	(HUD_BossHealth).w
		beq.s	@End
		
		bra.w	@Continue	; as cool as these are, sprite limit :(

		cmpi.b	#10,(HUD_BossHealth).w
		bgt.s	@Continue

		move.b	($FFFFFE05).w,d0
		andi.b 	#%00011111, d0
		tst.b 	d0
		bne.s 	@Continue

		; create bomb objects
		jsr 	SingleObjLoad
		move.b 	#$23, (a1)
		move.w	#$2586, obX(a1)
		move.w	#$053C, obY(a1)
		
		jsr 	RandomNumber
		andi.w 	#%0000000011111111, d0
		neg.w 	d0
		move.w	d0, obVelX(a1)

		bra.s 	@Continue

@End:
		addq.b	#2,($FFFFF742).w
		bra.s 	locret_7322

@Continue:
		bra.w	loc_72C2
 

Resize_FZend:
		cmpi.w	#$2450,($FFFFF700).w
		bcs.s	loc_7320
		addq.b	#2,($FFFFF742).w

loc_7320:
		bra.w	loc_72C2
; ===========================================================================

locret_7322:
		rts	
; ===========================================================================

FZEscape equ $FFFFF734

Resize_FZend2:
		clr.b	($FFFFFE1E).w		; stop time counter

		tst.b	(FZEscape).w		; has escape sequence flag been set? (Eggman object deleted after crash)
		beq.w	@waitforeggmantodielol	; if not, branch
		addq.b	#2,($FFFFF742).w	; go to nuke wait code
		lea	(PLC_FZNuke).l,a1	; load nuke patterns
		jsr	LoadPLC_Direct

@waitforeggmantodielol:
		bra.w	loc_72C2
; ===========================================================================

Resize_FZEscape_Nuke:
		move.w	#$28C0,($FFFFF72A).w		; set right boundary

		cmpi.w	#$27C0,($FFFFF700).w
		bhi.w	@waitprison
		tst.w	($FFFFF73A).w
		bne.s	@waitprison
		addi.w	#1,($FFFFF700).w
		
@waitprison:
		move.w	($FFFFF700).w,($FFFFF728).w	; lock left boundary as you walk right

		tst.b	($FFFFFFA5).w		; egg prison opened?
		beq.w	@prisonnotyetopen	; if not, branch
		addq.b	#2,($FFFFF742).w	; go to next routine	

@prisonnotyetopen:
		rts
; ===========================================================================

Resize_FZEscape:
		addq.b	#2,($FFFFF742).w	; go to next routine

		move.b	#2,(FZEscape).w		; enable exploding scenery and the rest of the escape logic

		move.w	#0,($FFFFF72C).w	; unlock controls
		move.b	#1,($FFFFFE2E).w	; speed up the BG music
		move.w	#180*60,($FFFFD034).w	; give Sonic speed shoes to make the walking-left part less tedious
	;	move.b	#1,($FFFFFE2D).w	; make sonic invincible to prevent some bullshit deaths
		addq.w	#1,($FFFFFE20).w	; screw that, instead add 1 insurance ring (without updating rings counter)

		move.b	#7,(CameraShake_Intensity).w

		; escape timer
		move.l	#(1*$10000)|(83*$100)|00,d0	; set escape time (casual - 182s)
		frantic
		beq.s	@notfrantic
		move.l	#(1*$10000)|(51*$100)|00,d0	; set escape time (frantic - 150s but triple speed means 50s effective)
@notfrantic:	move.l	d0,($FFFFFE22).w	; set escape time
		move.b	#1,($FFFFFE1E).w	; start time counter

		; update level stuff
		move.w	#$0A00,d0		; replace laser barrier chunk
		move.w	#$0500,d1
		move.b	#$46,d2
		jsr	Sub_ChangeChunk
		move.w	#$2C1,($FFFFF728).w	; set left level boundary (hide skip tutorial)
		move.w	#$510,($FFFFF726).w	; set bottom level boundary
		
		; move Sonic left after explosion
		move.b	#4,($FFFFD024).w
		move.b	#$1A,($FFFFD01C).w
		bset	#1,($FFFFD022).w
		move.w	#-$480,($FFFFD012).w
		move.w	#-$800,($FFFFD010).w
		
		; double boost when you're right of the prison
		; so you don't get catapulted into the bottomless pit lol
		move.w	($FFFFD008).w,d0
		cmpi.w	#$2960,d0
		blo.s	@nodoubleboost
		move.w	#-$1000,($FFFFD010).w

@nodoubleboost:
		move.w	#$90,d0
		jmp	PlaySound		; play GHP music (originally a placeholder, now gonna stay cause it's epic)
; ===========================================================================	

Resize_FZEscape2:
		cmpi.w	#$1000,($FFFFF700).w	; near the falling pit?
		bhi.w	@notnearpit		; if not yet, branch
		addq.b	#2,($FFFFF742).w	; next routine
		move.w	#$A10,($FFFFF726).w	; lower level boundary
		move.w	#$1100,($FFFFF72A).w	; prevent going back right
		move.w	#0,($FFFFF72C).w	; set upper level boundary
		lea	(PLC_FZEscape).l,a1	; load FZEscape patterns
		jmp	LoadPLC_Direct		; (mostly tutorial objects)

@notnearpit:
		move.w	($FFFFF700).w,($FFFFF72A).w	; lock right boundary as you walk left
		rts
; ===========================================================================	
	
Resize_FZEscape3:
		move.w	#$A25,($FFFFF726).w	; lower level boundary
		cmpi.w	#$500,($FFFFD00C).w	; is Sonic above the FZ section?
		blo.s	@0			; if not, branch
		move.w	#$2460,($FFFFF72A).w	; right boundary
		addq.b	#2,($FFFFF742).w	; next routine

@0:
		rts

; ===========================================================================	
; <3 1A
;
; X = not in bounds
; O = in bounds
;
; OOOOOO|XX
; OOOOOO|XX
; OOOOOO|XX
; ------/XX
; XXXXXXXXX

Resize_FZEscape4:
		; Y check
		cmpi.w 	#$04AC, ($FFFFD00C).w
		bgt.s 	@Return

		; X check
		cmpi.w 	#$1800, ($FFFFD00A).w
		bgt.s 	@Return

		move.w	#$00D0, ($FFFFF728).w	; set left level boundary
		move.w	#$0400,($FFFFF726).w	; set lower level boundary

@Return:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
PLC_FZNuke:
		dc.l ArtKospM_Prison
		dc.w $6000
		dc.l ArtKospM_Nuke
		dc.w $8000
		dc.l ArtKospM_FlamePipe
		dc.w $5A00
		dc.w -1
; ---------------------------------------------------------------------------
PLC_FZEscape:
		dc.l ArtKospM_HSpring
		dc.w $A460
		dc.l ArtKospM_HardPS_Tut
		dc.w $6C00
		dc.l ArtKospM_Switch
		dc.w $70A0
		dc.w -1
; ---------------------------------------------------------------------------
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Ending sequence dynamic screen resizing
; ---------------------------------------------------------------------------

Resize_Ending:				; XREF: Resize_Index
		move.w	#$0000,($FFFFF72C).w
		move.w	#$0320,($FFFFF726).w

		tst.b	($FFFFFF78).w		; pit flag already set?
		bne.s	@end			; if yes, branch
		cmp.w	#$0A29,($FFFFD008).w	; is Sonic near the pit?
		bhs.s	@end			; if not, branch

		move.b	#1,($FFFFFF78).w	; set pit flag
		move.b	#$D3,d0			; play charge sound
		jsr	PlaySound_Special
		move.w	#-$1000,($FFFFD014).w	; speed boost over the pit
		jsr	SingleObjLoad
		bne.s	@end
		move.b	#$02,(a1)		; load U Mad Bro object

@end:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 11 - GHZ bridge
; ---------------------------------------------------------------------------

Obj11:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj11_Index(pc,d0.w),d1
		jmp	Obj11_Index(pc,d1.w)
; ===========================================================================
Obj11_Index:	dc.w Obj11_Main-Obj11_Index, Obj11_Action-Obj11_Index
		dc.w Obj11_Action2-Obj11_Index,	Obj11_Delete2-Obj11_Index
		dc.w Obj11_Delete2-Obj11_Index,	Obj11_Display2-Obj11_Index
; ===========================================================================

Obj11_Main:				; XREF: Obj11_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj11,obMap(a0)
		move.w	#$438E,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$80,obActWid(a0)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		move.b	0(a0),d4	; copy object number ($11) to d4
		lea	obSubtype(a0),a2	; copy bridge subtype to a2
		moveq	#0,d1
		move.b	(a2),d1		; copy a2 to d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		bcs.s	Obj11_Action

Obj11_MakeBdg:
		jsr	SingleObjLoad
		bne.s	Obj11_Action
		addq.b	#1,obSubtype(a0)
		cmp.w	obX(a0),d3
		bne.s	loc_73B8
		addi.w	#$10,d3
		move.w	d2,obY(a0)
		move.w	d2,$3C(a0)
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		addq.b	#1,obSubtype(a0)

loc_73B8:
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,obRoutine(a1)
		move.b	d4,0(a1)	; load bridge object (d4 = $11)
		move.w	d2,obY(a1)
		move.w	d2,$3C(a1)
		move.w	d3,obX(a1)
		move.l	#Map_obj11,obMap(a1)
		move.w	#$438E,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#3,obPriority(a1)
		move.b	#8,obActWid(a1)
		addi.w	#$10,d3
		dbf	d1,Obj11_MakeBdg ; repeat d1 times (length of bridge)

Obj11_Action:				; XREF: Obj11_Index
		bsr.s	Obj11_Solid
		tst.b	$3E(a0)
		beq.s	Obj11_Display
		subq.b	#4,$3E(a0)
		jsr	obj11_Bend

Obj11_Display:
		bra.w	Obj11_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Solid:				; XREF: Obj11_Action
		moveq	#0,d1
		move.b	obSubtype(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		add.w	d2,d2
		lea	($FFFFD000).w,a1
		tst.w	obVelY(a1)
		bmi.w	locret_751E
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		cmp.w	d2,d0
		bcc.w	locret_751E
		bra.s	Platform2
; End of function Obj11_Solid

; ---------------------------------------------------------------------------
; Platform subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


PlatformObject:
		lea	($FFFFD000).w,a1
		tst.w	obVelY(a1)
		bmi.w	locret_751E
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.w	locret_751E

Platform2:
		move.w	obY(a0),d0
		subq.w	#8,d0

Platform3:
		move.w	obY(a1),d2
		move.b	obHeight(a1),d1
		ext.w	d1
		add.w	d2,d1
		addq.w	#4,d1
		sub.w	d1,d0
		bhi.w	locret_751E
		cmpi.w	#-$10,d0
		bcs.w	locret_751E
		tst.b	($FFFFF7C8).w
		bmi.w	locret_751E
		cmpi.b	#6,obRoutine(a1)
		bcc.w	locret_751E
		add.w	d0,d2
		addq.w	#3,d2
		move.w	d2,obY(a1)
		addq.b	#2,obRoutine(a0)

loc_74AE:
		btst	#3,obStatus(a1)
		beq.s	loc_74DC
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a2
		bclr	#3,obStatus(a2)
		clr.b	ob2ndRout(a2)
		cmpi.b	#4,obRoutine(a2)
		bne.s	loc_74DC
		subq.b	#2,obRoutine(a2)

loc_74DC:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		move.b	#0,obAngle(a1)
		move.w	#0,obVelY(a1)
		move.w	obVelX(a1),obInertia(a1)
		btst	#1,obStatus(a1)
		beq.s	loc_7512
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	Sonic_ResetOnFloor
		movea.l	(sp)+,a0

loc_7512:
		bset	#3,obStatus(a1)
		bset	#3,obStatus(a0)

locret_751E:
		rts	
; End of function PlatformObject

; ---------------------------------------------------------------------------
; Sloped platform subroutine (GHZ collapsing ledges and	SLZ seesaws)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SlopeObject:				; XREF: Obj1A_Slope; Obj5E_Slope
		lea	($FFFFD000).w,a1
		tst.w	obVelY(a1)
		bmi.w	locret_751E
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.s	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.s	locret_751E
		btst	#0,obRender(a0)
		beq.s	loc_754A
		not.w	d0
		add.w	d1,d0

loc_754A:
		lsr.w	#1,d0
		moveq	#0,d3
		move.b	(a2,d0.w),d3
		move.w	obY(a0),d0
		sub.w	d3,d0
		bra.w	Platform3
; End of function SlopeObject


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Solid:				; XREF: Obj15_SetSolid
		lea	($FFFFD000).w,a1
		tst.w	obVelY(a1)
		bmi.w	locret_751E
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.w	locret_751E
		add.w	d1,d1
		cmp.w	d1,d0
		bcc.w	locret_751E
		move.w	obY(a0),d0
		sub.w	d3,d0
		bra.w	Platform3
; End of function Obj15_Solid

; ===========================================================================

Obj11_Action2:				; XREF: Obj11_Index
		bsr.s	Obj11_WalkOff
		bra.w	Obj11_ChkDel

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk off a bridge
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_WalkOff:				; XREF: Obj11_Action2
		moveq	#0,d1
		move.b	obSubtype(a0),d1
		lsl.w	#3,d1
		move.w	d1,d2
		addq.w	#8,d1
		bsr.s	ExitPlatform2
		bcc.s	locret_75BE
		lsr.w	#4,d0
		move.b	d0,$3F(a0)
		move.b	$3E(a0),d0
		cmpi.b	#$40,d0
		beq.s	loc_75B6
		addq.b	#4,$3E(a0)

loc_75B6:
		jsr	obj11_Bend
		jsr	obj11_MoveSonic

locret_75BE:
		rts	
; End of function Obj11_WalkOff

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk or jump off	a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ExitPlatform:
		move.w	d1,d2

ExitPlatform2:
		add.w	d2,d2
		lea	($FFFFD000).w,a1
		btst	#1,obStatus(a1)
		bne.s	loc_75E0
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.s	loc_75E0
		cmp.w	d2,d0
		bcs.s	locret_75F2

loc_75E0:
		bclr	#3,obStatus(a1)
		move.b	#2,obRoutine(a0)
		bclr	#3,obStatus(a0)

locret_75F2:
		rts	
; End of function ExitPlatform


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_MoveSonic:			; XREF: Obj11_WalkOff
		moveq	#0,d0
		move.b	$3F(a0),d0
		move.b	$29(a0,d0.w),d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a2
		lea	($FFFFD000).w,a1
		move.w	obY(a2),d0
		subq.w	#8,d0
		moveq	#0,d1
		move.b	obHeight(a1),d1
		sub.w	d1,d0
		move.w	d0,obY(a1)	; change Sonic's position on y-axis
		rts	
; End of function Obj11_MoveSonic


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj11_Bend:				; XREF: Obj11_Action; Obj11_WalkOff
		move.b	$3E(a0),d0
		bsr	CalcSine
		move.w	d0,d4
		lea	(Obj11_BendData2).l,a4
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsl.w	#4,d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		move.w	d3,d2
		add.w	d0,d3
		moveq	#0,d5
		lea	(Obj11_BendData).l,a5
		move.b	(a5,d3.w),d5
		andi.w	#$F,d3
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		lea	$29(a0),a2

loc_765C:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	(a3)+,d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a1),d0
		move.w	d0,obY(a1)
		dbf	d2,loc_765C
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		moveq	#0,d3
		move.b	$3F(a0),d3
		addq.b	#1,d3
		sub.b	d0,d3
		neg.b	d3
		bmi.s	locret_76CA
		move.w	d3,d2
		lsl.w	#4,d3
		lea	(a4,d3.w),a3
		adda.w	d2,a3
		subq.w	#1,d2
		bcs.s	locret_76CA

loc_76A4:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		moveq	#0,d0
		move.b	-(a3),d0
		addq.w	#1,d0
		mulu.w	d5,d0
		mulu.w	d4,d0
		swap	d0
		add.w	$3C(a1),d0
		move.w	d0,obY(a1)
		dbf	d2,loc_76A4

locret_76CA:
		rts	
; End of function Obj11_Bend

; ===========================================================================
; ---------------------------------------------------------------------------
; GHZ bridge-bending data
; (Defines how the bridge bends	when Sonic walks across	it)
; ---------------------------------------------------------------------------
Obj11_BendData:	incbin	misc\ghzbend1.bin
		even
Obj11_BendData2:incbin	misc\ghzbend2.bin
		even

; ===========================================================================

Obj11_ChkDel:				; XREF: Obj11_Display; Obj11_Action2
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj11_DelAll
		bra.w	DisplaySprite
; ===========================================================================

Obj11_DelAll:				; XREF: Obj11_ChkDel
		moveq	#0,d2
		lea	obSubtype(a0),a2	; load bridge length
		move.b	(a2)+,d2	; move bridge length to	d2
		subq.b	#1,d2		; subtract 1
		bcs.s	Obj11_Delete

Obj11_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		cmp.w	a0,d0
		beq.s	loc_791E
		jsr	DeleteObject2

loc_791E:
		dbf	d2,Obj11_DelLoop ; repeat d2 times (bridge length)

Obj11_Delete:
		jsr	DeleteObject
		rts
; ===========================================================================

Obj11_Delete2:				; XREF: Obj11_Index
		jsr	DeleteObject
		rts
; ===========================================================================

Obj11_Display2:				; XREF: Obj11_Index
		jsr	DisplaySprite
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	bridge
; ---------------------------------------------------------------------------
Map_obj11:
		include	"_maps\obj11.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 15 - swinging platforms (GHZ, MZ, SLZ)
;	    - spiked ball on a chain (SBZ)
; ---------------------------------------------------------------------------

Obj15:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj15_Index(pc,d0.w),d1
		jmp	Obj15_Index(pc,d1.w)
; ===========================================================================
Obj15_Index:	dc.w Obj15_Main-Obj15_Index, Obj15_SetSolid-Obj15_Index
		dc.w Obj15_Action2-Obj15_Index,	Obj15_Delete-Obj15_Index
		dc.w Obj15_Delete-Obj15_Index, Obj15_Display-Obj15_Index
		dc.w Obj15_Action-Obj15_Index
; ===========================================================================

Obj15_Main:				; XREF: Obj15_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj15,obMap(a0) ; GHZ and MZ specific code
		move.w	#$4380,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$18,obActWid(a0)
		move.b	#8,obHeight(a0)
		move.w	obY(a0),$38(a0)
		move.w	obX(a0),$3A(a0)
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	Obj15_NotSLZ
		move.l	#Map_obj15a,obMap(a0) ; SLZ	specific code
		move.w	#$43DC,obGfx(a0)
		move.b	#$20,obActWid(a0)
		move.b	#$10,obHeight(a0)
		move.b	#$99,obColType(a0)

Obj15_NotSLZ:
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		bne.s	Obj15_SetLength
		move.l	#Map_obj15b,obMap(a0) ; SBZ	specific code
		move.w	#$391,obGfx(a0)
		move.b	#$18,obActWid(a0)
		move.b	#$18,obHeight(a0)
		move.b	#$86,obColType(a0)
		move.b	#$C,obRoutine(a0)

Obj15_SetLength:
		move.b	0(a0),d4
		moveq	#0,d1
		lea	obSubtype(a0),a2	; move chain length to a2
		move.b	(a2),d1		; move a2 to d1
		move.w	d1,-(sp)
		andi.w	#$F,d1
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		addq.b	#8,d3
		move.b	d3,$3C(a0)
		subq.b	#8,d3
		tst.b	obFrame(a0)
		beq.s	Obj15_MakeChain
		addq.b	#8,d3
		subq.w	#1,d1

Obj15_MakeChain:
		jsr	SingleObjLoad
		bne.s	loc_7A92
		addq.b	#1,obSubtype(a0)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#$A,obRoutine(a1)
		move.b	d4,0(a1)	; load swinging	object
		move.l	obMap(a0),obMap(a1)
		move.w	obGfx(a0),obGfx(a1)
		bclr	#6,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#4,obPriority(a1)
		move.b	#8,obActWid(a1)
		move.b	#1,obFrame(a1)
		move.b	d3,$3C(a1)
		subi.b	#$10,d3
		bcc.s	loc_7A8E
		move.b	#2,obFrame(a1)
		move.b	#3,obPriority(a1)
		bset	#6,obGfx(a1)

loc_7A8E:
		dbf	d1,Obj15_MakeChain ; repeat d1 times (chain length)

loc_7A92:
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.w	#$4080,obAngle(a0)
		move.w	#-$200,$3E(a0)
		move.w	(sp)+,d1
		btst	#4,d1		; is object type $8X ?
		beq.s	loc_7AD4	; if not, branch
		move.l	#Map_obj48,obMap(a0) ; use GHZ ball	mappings
		move.w	#$43AA,obGfx(a0)
		move.b	#1,obFrame(a0)
		move.b	#2,obPriority(a0)
		move.b	#$81,obColType(a0)	; make object hurt when	touched

loc_7AD4:
		cmpi.b	#5,($FFFFFE10).w ; is zone SBZ?
		beq.s	Obj15_Action	; if yes, branch

Obj15_SetSolid:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		moveq	#0,d3
		move.b	obHeight(a0),d3
		jsr	obj15_Solid

Obj15_Action:				; XREF: Obj15_Index
		jsr	obj15_Move
		bsr	DisplaySprite
		bra.w	Obj15_ChkDel
; ===========================================================================

Obj15_Action2:				; XREF: Obj15_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		bsr	ExitPlatform
		move.w	obX(a0),-(sp)
		jsr	obj15_Move
		move.w	(sp)+,d2
		moveq	#0,d3
		move.b	obHeight(a0),d3
		addq.b	#1,d3
		bsr	MvSonicOnPtfm
		bsr	DisplaySprite
		bra.w	Obj15_ChkDel

		rts

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's position with a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MvSonicOnPtfm:
		lea	($FFFFD000).w,a1
		move.w	obY(a0),d0
		sub.w	d3,d0
		bra.s	MvSonic2
; End of function MvSonicOnPtfm

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's position with a platform
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


MvSonicOnPtfm2:
		lea	($FFFFD000).w,a1
		move.w	obY(a0),d0
		subi.w	#9,d0

MvSonic2:
		tst.b	($FFFFF7C8).w
		bmi.s	locret_7B62
		cmpi.b	#6,($FFFFD024).w
		bcc.s	locret_7B62
		tst.w	($FFFFFE08).w
		bne.s	locret_7B62
		moveq	#0,d1
		move.b	obHeight(a1),d1
		sub.w	d1,d0
		move.w	d0,obY(a1)
		sub.w	obX(a0),d2
		sub.w	d2,obX(a1)

locret_7B62:
		rts	
; End of function MvSonicOnPtfm2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move:				; XREF: Obj15_Action; Obj15_Action2
		move.b	($FFFFFE78).w,d0
		move.w	#$80,d1
		btst	#0,obStatus(a0)
		beq.s	loc_7B78
		neg.w	d0
		add.w	d1,d0

loc_7B78:
		bra.s	Obj15_Move2
; End of function Obj15_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj48_Move:				; XREF: Obj48_Display2
		tst.b	$3D(a0)
		bne.s	loc_7B9C
		move.w	$3E(a0),d0
		addq.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,obAngle(a0)
		cmpi.w	#$200,d0
		bne.s	loc_7BB6
		move.b	#1,$3D(a0)
		bra.s	loc_7BB6
; ===========================================================================

loc_7B9C:
		move.w	$3E(a0),d0
		subq.w	#8,d0
		move.w	d0,$3E(a0)
		add.w	d0,obAngle(a0)
		cmpi.w	#-$200,d0
		bne.s	loc_7BB6
		move.b	#0,$3D(a0)

loc_7BB6:
		move.b	obAngle(a0),d0
; End of function Obj48_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj15_Move2:				; XREF: Obj15_Move; Obj48_Display
		bsr	CalcSine
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		lea	obSubtype(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

loc_7BCE:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFD000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	$3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,obY(a1)
		move.w	d5,obX(a1)
		dbf	d6,loc_7BCE
		rts	
; End of function Obj15_Move2

; ===========================================================================

Obj15_ChkDel:				; XREF: Obj15_Action; Obj15_Action2
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj15_DelAll
		rts	
; ===========================================================================

Obj15_DelAll:				; XREF: Obj15_ChkDel
		moveq	#0,d2
		lea	obSubtype(a0),a2
		move.b	(a2)+,d2

Obj15_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr	DeleteObject2
		dbf	d2,Obj15_DelLoop ; repeat for length of	chain
		rts	
; ===========================================================================

Obj15_Delete:				; XREF: Obj15_Index
		bsr	DeleteObject
		rts	
; ===========================================================================

Obj15_Display:				; XREF: Obj15_Index
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	and MZ swinging	platforms
; ---------------------------------------------------------------------------
Map_obj15:
		include	"_maps\obj15ghz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - SLZ	swinging platforms
; ---------------------------------------------------------------------------
Map_obj15a:
		include	"_maps\obj15slz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 17 - helix of spikes on a pole	(GHZ)
; ---------------------------------------------------------------------------

Obj17:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj17_Index(pc,d0.w),d1
		jmp	Obj17_Index(pc,d1.w)
; ===========================================================================
Obj17_Index:	dc.w Obj17_Main-Obj17_Index
		dc.w Obj17_Action-Obj17_Index
		dc.w Obj17_Action-Obj17_Index
		dc.w Obj17_Delete-Obj17_Index
		dc.w Obj17_Display-Obj17_Index
; ===========================================================================

Obj17_Main:				; XREF: Obj17_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj17,obMap(a0)
		move.w	#$4398,obGfx(a0)
		move.b	#7,obStatus(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#8,obActWid(a0)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		move.b	0(a0),d4
		lea	obSubtype(a0),a2	; move helix length to a2
		moveq	#0,d1
		move.b	(a2),d1		; move a2 to d1
		move.b	#0,(a2)+
		move.w	d1,d0
		lsr.w	#1,d0
		lsl.w	#4,d0
		sub.w	d0,d3
		subq.b	#2,d1
		bcs.s	Obj17_Action
		moveq	#0,d6

Obj17_MakeHelix:
		jsr	SingleObjLoad
		bne.s	Obj17_Action
		addq.b	#1,obSubtype(a0)
		move.w	a1,d5
		subi.w	#$D000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#8,obRoutine(a1)
		move.b	d4,0(a1)
		move.w	d2,obY(a1)
		move.w	d3,obX(a1)
		move.l	obMap(a0),obMap(a1)
		move.w	#$4398,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#3,obPriority(a1)
		move.b	#8,obActWid(a1)
		move.b	d6,$3E(a1)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		cmp.w	obX(a0),d3
		bne.s	loc_7D78
		move.b	d6,$3E(a0)
		addq.b	#1,d6
		andi.b	#7,d6
		addi.w	#$10,d3
		addq.b	#1,obSubtype(a0)

loc_7D78:
		dbf	d1,Obj17_MakeHelix ; repeat d1 times (helix length)

Obj17_Action:				; XREF: Obj17_Index
		jsr	obj17_RotateSpikes
		bsr	DisplaySprite
		bra.w	Obj17_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj17_RotateSpikes:			; XREF: Obj17_Action; Obj17_Display
		move.b	($FFFFFEC1).w,d0
		move.b	#0,obColType(a0)	; make object harmless
		add.b	$3E(a0),d0
		andi.b	#7,d0
		move.b	d0,obFrame(a0)	; change current frame
		bne.s	locret_7DA6
		move.b	#$84,obColType(a0)	; make object harmful

locret_7DA6:
		rts	
; End of function Obj17_RotateSpikes

; ===========================================================================

Obj17_ChkDel:				; XREF: Obj17_Action
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj17_DelAll
		rts	
; ===========================================================================

Obj17_DelAll:				; XREF: Obj17_ChkDel
		moveq	#0,d2
		lea	obSubtype(a0),a2	; move helix length to a2
		move.b	(a2)+,d2	; move a2 to d2
		subq.b	#2,d2
		bcs.s	Obj17_Delete

Obj17_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr	DeleteObject2	; delete object
		dbf	d2,Obj17_DelLoop ; repeat d2 times (helix length)

Obj17_Delete:				; XREF: Obj17_Index
		bsr	DeleteObject
		rts	
; ===========================================================================

Obj17_Display:				; XREF: Obj17_Index
		jsr	obj17_RotateSpikes
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - helix of spikes on a pole (GHZ)
; ---------------------------------------------------------------------------
Map_obj17:
		include	"_maps\obj17.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 18 - floating platforms (GHZ, SYZ, SLZ)
; ---------------------------------------------------------------------------

Obj18:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj18_Index(pc,d0.w),d1
		jmp	Obj18_Index(pc,d1.w)
; ===========================================================================
Obj18_Index:	dc.w Obj18_Main-Obj18_Index
		dc.w Obj18_Solid-Obj18_Index
		dc.w Obj18_OnPlatform-Obj18_Index
		dc.w Obj18_Delete-Obj18_Index
		dc.w Obj18_Action-Obj18_Index
		dc.w Obj18_Arrows-Obj18_Index
; ===========================================================================

Obj18_Main:				; XREF: Obj18_Index
		addq.b	#2,obRoutine(a0)
		move.w	#$4000,obGfx(a0)
		move.l	#Map_obj18,obMap(a0)
		move.b	#$20,obActWid(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	Obj18_NotLZ
		move.l	#Map_obj18c,obMap(a0)
		move.b	#0,$3C(a0)

Obj18_NotLZ:
		cmpi.b	#4,($FFFFFE10).w ; check if level is SYZ
		bne.w	Obj18_NotSYZ
		move.l	#Map_obj18a,obMap(a0) ; SYZ specific code
		move.w	#$4000+($A660/$20),obGfx(a0)
		move.b	#$90,obActWid(a0)	; make platforms SUPER wide for easy access
		addq.w	#1,obY(a0)	; fix vertical pixel offset

		; glowing yellow arrows when stepping on platform in Uberhub
		jsr	SingleObjLoad
		move.b	#$18,(a1)
		move.b	#$A,obRoutine(a1)	; set to arrow routine
		move.l	#Map_obj18a,obMap(a1) ; SYZ specific code
		move.w	#$6533,obGfx(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),d0
		addi.w	#5,d0		; adjust Y pos
		move.w	d0,obY(a1)
		move.b	#1,obFrame(a1)
		move.b	#$30,obActWid(a1)
		move.b	#4,obRender(a1)
		move.b	#3,obPriority(a1)	; set priority
		move.w	obY(a0),$2C(a1)
		move.w	obY(a0),$34(a1)
		move.w	obX(a0),$32(a1)
		move.w	#$80,obAngle(a1)
		move.l	a0,$36(a1)

		tst.b	obSubtype(a0)
		bpl.s	Obj18_NotSYZ
		move.b	#2,obFrame(a1)		; vertically flip
		subi.w	#$A0,obY(a1)

Obj18_NotSYZ:
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	Obj18_NotSLZ
		move.l	#Map_obj18b,obMap(a0) ; SLZ	specific code
	;	move.b	#$20,obActWid(a0)
		move.w	#$44E0,obGfx(a0)
	;	move.b	#3,obSubtype(a0)

Obj18_NotSLZ:
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.w	obY(a0),$2C(a0)
		move.w	obY(a0),$34(a0)
		move.w	obX(a0),$32(a0)
		move.w	#$80,obAngle(a0)
		moveq	#0,d1
		move.b	obSubtype(a0),d0
		cmpi.b	#$A,d0		; is object type $A (large platform)?
		bne.s	Obj18_SetFrame	; if not, branch
		addq.b	#1,d1		; use frame #1
		move.b	#$20,obActWid(a0)	; set width

Obj18_SetFrame:
		move.b	d1,obFrame(a0)	; set frame to d1

Obj18_Solid:				; XREF: Obj18_Index
		tst.b	$38(a0)
		beq.s	loc_7EE0
		subq.b	#4,$38(a0)

loc_7EE0:
		moveq	#0,d1
		move.b	obActWid(a0),d1
		bsr	PlatformObject

Obj18_Action:				; XREF: Obj18_Index
		jsr	obj18_Move
		jsr	obj18_Nudge
		moveq	#1,d2
		bra.w	Obj18_ChkDel
; ===========================================================================

Obj18_Arrows:
		movea.l	$36(a0),a1
		tst.b	$3F(a1)
		beq.s	@cont
		
	;	move.w	($FFFFD008).w,obX(a0)

		move.b	$3E(a0),d0
		addq.b	#3,$3E(a0)
		jsr	(CalcSine).l
		asr.w	#2,d0
		move.w	d0,obVelY(a0)
		jsr     SpeedToPos

		moveq	#0,d2
		move.b	obRoutine(a1),d0
		cmpi.b	#4,d0
		bne.s	@cont
		moveq	#1,d2
@cont:
		bra.w	Obj18_ChkDel
; ===========================================================================

Obj18_OnPlatform:				; XREF: Obj18_Index
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ1?
		bne.w	Obj18_NotSYZX

		move.b	#1,$3F(a0)		; show arrows

		tst.b	obSubtype(a0)		; is this the platform to go back up?
		bmi.s	@gobackup		; if yes, branch
		
		btst	#1,($FFFFF603).w	; down pressed?
		beq.s	Obj18_NotSYZX		; if not, branch
		move.w	#$800,($FFFFD012).w	; shoot Sonic down
		move.b	#2,($FFFFD01C).w	; rolling animation
		bra.s	@platformgoboom

@gobackup:
		btst	#0,($FFFFF603).w	; up pressed?
		beq.s	Obj18_NotSYZX		; if not, branch
		move.w	#-$1000,($FFFFD012).w	; shoot Sonic up

		subi.w	#$50,($FFFFD00C).w
		move.b	#$10,($FFFFD01C).w	; use "bouncing" animation


@platformgoboom:
		ori.b	#10,(CameraShake).w	; camera shaking
		move.w	obX(a0),($FFFFD008).w	; force Sonic to center of platform
		clr.w	($FFFFD010).w		; clear Sonic's X speed
		
		bsr	SingleObjLoad		; load explosion object
		bne.s	Obj18_SYZEnd
		move.b	#$3F,(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		bclr	#3,($FFFFD022).w
		bset	#1,($FFFFD022).w
		move.b	#1,($FFFFFFAD).w	; set jumpdash flag
		move.w	obY(a0),d0
		move.b	#30,$3C(a0)

Obj18_SYZEnd:
		rts

Obj18_NotSYZX:
		cmpi.w	#$101,($FFFFFE10).w	; is level LZ2?
		beq.s	Obj18_LZ2		; if yes, branch
		cmpi.w	#$201,($FFFFFE10).w	; is level MZ2?
		bne.s	Obj18_NoMovingPlatforms	; if not, branch

Obj18_LZ2:
		tst.w	($FFFFFE08).w		; is debug mode	being used?
		bne.w	Obj18_NoMovingPlatforms	; if yes, ignore platform
		move.w	($FFFFD008).w,obX(a0)	; set platforms X-location to Sonic's one
		move.w	($FFFFD00C).w,obY(a0)	; set platforms Y-location to Sonic's one, but...
		add.w	#20,obY(a0)		; ...add 20 more pixels to it

Obj18_NoMovingPlatforms:
		cmpi.w	#$302,($FFFFFE10).w	; is level SAP?
		bne.s	Obj18_NoCheckpoint	; if not, branch
		tst.b	obFrame(a0)		; has checkpoint already been touched?
		bne.s	Obj18_NoCheckpoint	; if yes, branch
		move.b	#1,obFrame(a0)		; set checkpoint flag
		move.b	#$A1,d0			; play checkpoint sound
		jsr	PlaySound_Special
		move.b	#0,($FFFFF7CC).w	; unlock controls

@notfirstcheckpoint:
		move.w	obX(a0),($FFFFFF86).w	; save Sonic's X-position
		move.w	obY(a0),($FFFFFF88).w	; save Sonic's Y-position
		subi.w	#$1C,($FFFFFF88).w

Obj18_NoCheckpoint:
		cmpi.b	#$40,$38(a0)
		beq.s	loc_7F06
		addq.b	#4,$38(a0)

loc_7F06:
		tst.b	$3C(a0)
		beq.s	@0
		bmi.s	@0
		subq.b	#1,$3C(a0)
		bsr	ExitPlatform
		bra.w	DisplaySprite

@0:
		clr.b	$3C(a0)
		moveq	#0,d1
		move.b	obActWid(a0),d1
		bsr	ExitPlatform
		move.w	obX(a0),-(sp)
		jsr	obj18_Move
		jsr	obj18_Nudge
		move.w	(sp)+,d2
		bsr	MvSonicOnPtfm2
		moveq	#1,d2
		bra.w	Obj18_ChkDel

; ---------------------------------------------------------------------------
; Subroutine to	move platform slightly when you	stand on it
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Nudge:				; XREF: Obj18_Action; Obj18_OnPlatform
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ1?
		beq.s	Obj18_NoNudge		; if yes, branch
		move.b	$38(a0),d0
		bsr	CalcSine
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	$2C(a0),d0
		move.w	d0,obY(a0)

Obj18_NoNudge:
		rts	
; End of function Obj18_Nudge

; ---------------------------------------------------------------------------
; Subroutine to	move platforms
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj18_Move:				; XREF: Obj18_Action; Obj18_OnPlatform
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj18_TypeIndex(pc,d0.w),d1
		jmp	Obj18_TypeIndex(pc,d1.w)
; End of function Obj18_Move

; ===========================================================================
Obj18_TypeIndex:dc.w Obj18_Type00-Obj18_TypeIndex, Obj18_Type01-Obj18_TypeIndex
		dc.w Obj18_Type02-Obj18_TypeIndex, Obj18_Type03-Obj18_TypeIndex
		dc.w Obj18_Type04-Obj18_TypeIndex, Obj18_Type05-Obj18_TypeIndex
		dc.w Obj18_Type06-Obj18_TypeIndex, Obj18_Type07-Obj18_TypeIndex
		dc.w Obj18_Type08-Obj18_TypeIndex, Obj18_Type00-Obj18_TypeIndex
		dc.w Obj18_Type0A-Obj18_TypeIndex, Obj18_Type0B-Obj18_TypeIndex
		dc.w Obj18_Type0C-Obj18_TypeIndex, Obj18_Type0D-Obj18_TypeIndex
; ===========================================================================

Obj18_Type00:
		rts			; platform 00 doesn't move
; ===========================================================================

Obj18_Type05:
		move.w	$32(a0),d0
		move.b	obAngle(a0),d1	; load platform-motion variable
		neg.b	d1		; reverse platform-motion
		addi.b	#$40,d1
		bra.s	Obj18_01_Move
; ===========================================================================

Obj18_Type01:
		move.w	$32(a0),d0
		move.b	obAngle(a0),d1	; load platform-motion variable
		subi.b	#$40,d1

Obj18_01_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,obX(a0)	; change position on x-axis
		bra.w	Obj18_ChgMotion
; ===========================================================================

Obj18_Type0C:
		move.w	$34(a0),d0
		move.b	($FFFFFE6C).w,d1 ; load	platform-motion	variable
		neg.b	d1		; reverse platform-motion
		addi.b	#$30,d1
		bra.s	Obj18_02_Move
; ===========================================================================

Obj18_Type0B:
		move.w	$34(a0),d0
		move.b	($FFFFFE6C).w,d1 ; load	platform-motion	variable
		subi.b	#$30,d1
		bra.s	Obj18_02_Move
; ===========================================================================

Obj18_Type06:
		move.w	$34(a0),d0
		move.b	obAngle(a0),d1	; load platform-motion variable
		neg.b	d1		; reverse platform-motion
		addi.b	#$40,d1
		bra.s	Obj18_02_Move
; ===========================================================================

Obj18_Type02:
		move.w	$34(a0),d0
		move.b	obAngle(a0),d1	; load platform-motion variable
		subi.b	#$40,d1

Obj18_02_Move:
		ext.w	d1
		add.w	d1,d0
		move.w	d0,$2C(a0)	; change position on y-axis
		bra.w	Obj18_ChgMotion
; ===========================================================================

Obj18_Type03:
		tst.w	$3A(a0)		; is time delay	set?
		bne.s	Obj18_03_Wait	; if yes, branch
		btst	#3,obStatus(a0)	; is Sonic standing on the platform?
		beq.s	Obj18_03_NoMove	; if not, branch
		move.w	#30,$3A(a0)	; set time delay to 0.5	seconds

Obj18_03_NoMove:
		rts	
; ===========================================================================

Obj18_03_Wait:
		subq.w	#1,$3A(a0)	; subtract 1 from time
		bne.s	Obj18_03_NoMove	; if time is > 0, branch
		move.w	#32,$3A(a0)
		addq.b	#1,obSubtype(a0)	; change to type 04 (falling)
		rts	
; ===========================================================================

Obj18_Type04:
		tst.w	$3A(a0)
		beq.s	loc_8048
		subq.w	#1,$3A(a0)
		bne.s	loc_8048
		btst	#3,obStatus(a0)
		beq.s	loc_8042
		bset	#1,obStatus(a1)
		bclr	#3,obStatus(a1)
		move.b	#2,obRoutine(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)
		move.w	obVelY(a0),obVelY(a1)

loc_8042:
		move.b	#8,obRoutine(a0)

loc_8048:
		move.l	$2C(a0),d3
		move.w	obVelY(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,$2C(a0)
		addi.w	#$38,obVelY(a0)
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$2C(a0),d0
		bcc.s	locret_8074
		move.b	#6,obRoutine(a0)

locret_8074:
		rts	
; ===========================================================================

Obj18_Type0D:
		tst.w	$3A(a0)
		beq.s	loc_8048x
		subq.w	#1,$3A(a0)
		bne.s	loc_8048x
		btst	#3,obStatus(a0)
		beq.s	loc_8042x
		bset	#1,obStatus(a1)
		bclr	#3,obStatus(a1)
		move.b	#2,obRoutine(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)
		move.w	obVelY(a0),obVelY(a1)

loc_8042x:
		move.b	#8,obRoutine(a0)

loc_8048x:
		move.l	$2C(a0),d3
		move.w	obVelY(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d3,$2C(a0)
		subi.w	#$38,obVelY(a0)
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	$2C(a0),d0
		bcc.s	locret_8074x
		move.b	#6,obRoutine(a0)

locret_8074x:
		rts	
; ===========================================================================

Obj18_Type07:
		tst.w	$3A(a0)		; is time delay	set?
		bne.s	Obj18_07_Wait	; if yes, branch
		lea	($FFFFF7E0).w,a2 ; load	switch statuses
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; move object type ($x7) to d0
		lsr.w	#4,d0		; divide d0 by 8, round	down
		tst.b	(a2,d0.w)	; has switch no. d0 been pressed?
		beq.s	Obj18_07_NoMove	; if not, branch
		move.w	#60,$3A(a0)	; set time delay to 1 second

Obj18_07_NoMove:
		rts	
; ===========================================================================

Obj18_07_Wait:
		subq.w	#1,$3A(a0)	; subtract 1 from time delay
		bne.s	Obj18_07_NoMove	; if time is > 0, branch
		addq.b	#1,obSubtype(a0)	; change to type 08
		rts	
; ===========================================================================

Obj18_Type08:
		subq.w	#2,$2C(a0)	; move platform	up
		move.w	$34(a0),d0
		subi.w	#$200,d0
		cmp.w	$2C(a0),d0	; has platform moved $200 pixels?
		bne.s	Obj18_08_NoStop	; if not, branch
		clr.b	obSubtype(a0)		; change to type 00 (stop moving)

Obj18_08_NoStop:
		rts	
; ===========================================================================

Obj18_Type0A:
		move.w	$34(a0),d0
		move.b	obAngle(a0),d1	; load platform-motion variable
		subi.b	#$40,d1
		ext.w	d1
		asr.w	#1,d1
		add.w	d1,d0
		move.w	d0,$2C(a0)	; change position on y-axis

Obj18_ChgMotion:
		move.b	($FFFFFE78).w,obAngle(a0) ;	update platform-movement variable
		rts	
; ===========================================================================

Obj18_ChkDel:				; XREF: Obj18_Action; Obj18_OnPlatform
		cmpi.w	#$302,($FFFFFE10).w	; are we in SAP?
		beq.s	@nodelete		; if yes, don't delete platforms

		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj18_Delete
@nodelete:
		tst.b	d2			; is platform set to be displayed?
		beq.s	@nodisplay		; if not, branch
		bra.w	DisplaySprite
@nodisplay:
		rts	
; ===========================================================================

Obj18_Delete:				; XREF: Obj18_Index
		bra.w	DeleteObject

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - unused
; ---------------------------------------------------------------------------
Map_obj18x:
		include	"_maps\obj18x.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	platforms
; ---------------------------------------------------------------------------
Map_obj18:
		include	"_maps\obj18ghz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - SYZ	platforms
; ---------------------------------------------------------------------------
Map_obj18a:
		include	"_maps\SYZPlatform.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - SLZ	platforms
; ---------------------------------------------------------------------------
Map_obj18b:
		include	"_maps\obj18slz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - LZ	platforms
; ---------------------------------------------------------------------------
Map_obj18c:
		include	"_maps\obj18lz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 19 - After Image
; ---------------------------------------------------------------------------

Obj19:
		cmpi.b	#6,($FFFFD024).w	; is sonic dying?
		beq.w	DeleteObject		; if yes, delete the object
		moveq	#0,d0			; clear d0
		move.b	obRoutine(a0),d0		; move routine counte to d0
		move.w	Obj19_Index(pc,d0.w),d1 ; move the index to d1
		jmp	Obj19_Index(pc,d1.w)	; find out the current position in the index
; ===========================================================================
Obj19_Index:
		dc.w Obj19_Increase-Obj19_Index ; repeat all this 2 times
		dc.w Obj19_DoAfter-Obj19_Index
		dc.w Obj19_Increase-Obj19_Index
		dc.w Obj19_DoAfter-Obj19_Index
		dc.w Obj19_Remove-Obj19_Index	; remove the afterimage sprite
; ===========================================================================

Obj19_Increase:
		addq.b	#2,obRoutine(a0)		; increase routine counter

Obj19_Return:
		rts				; return
; ===========================================================================

Obj19_DoAfter:
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	Obj19_Remove		; if yes, branch

		addq.b	#2,obRoutine(a0)		; increase routine counter
		move.b	($FFFFFE05).w,d0	; copy the game frame timer to d0
		and.b	$30(a0),d0		; and it by the number in $30(a0) (each after image sprite is flashing a bit more than the rest)
		bne.s	Obj19_Return		; branch, if the frame timer is too big
		addq.b	#1,$30(a0)		; increase this counter
		move.l	($FFFFD004).w,obMap(a0)	; load Sonic's mappings
		move.w	#$780,obGfx(a0)		; set starting art block to $780 (Sonic art)
 		move.l	($FFFFD01A).w,obFrame(a0)	; copy Sonic's current frame
 		move.b	($FFFFD001).w,obRender(a0)	; copy Sonic's render flag
		jmp	DisplaySprite		; display our afterimaged frame
; ===========================================================================

Obj19_Remove:
		jmp	DeleteObject		; delete the afterimaged sprite when the time is over
		
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - swinging ball on a chain from GHZ boss
; ---------------------------------------------------------------------------
Map_obj48:
		include	"_maps\obj48.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1A - GHZ collapsing ledge
; ---------------------------------------------------------------------------

Obj1A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj1A_Index(pc,d0.w),d1
		jmp	Obj1A_Index(pc,d1.w)
; ===========================================================================
Obj1A_Index:	dc.w Obj1A_Main-Obj1A_Index, Obj1A_ChkTouch-Obj1A_Index
		dc.w Obj1A_Touch-Obj1A_Index, Obj1A_Display-Obj1A_Index
		dc.w Obj1A_Delete-Obj1A_Index, Obj1A_WalkOff-Obj1A_Index
; ===========================================================================

Obj1A_Main:				; XREF: Obj1A_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj1A,obMap(a0)
		move.w	#$4000,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#7,$38(a0)	; set time delay for collapse
		move.b	#$64,obActWid(a0)
		move.b	obSubtype(a0),obFrame(a0)
		move.b	#$38,obHeight(a0)
		bset	#4,obRender(a0)

Obj1A_ChkTouch:				; XREF: Obj1A_Index
		tst.b	$3A(a0)		; has Sonic touched the	platform?
		beq.s	Obj1A_Slope	; if not, branch
		tst.b	$38(a0)		; has time reached zero?
		beq.w	Obj1A_Collapse	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time

Obj1A_Slope:
		move.w	#$30,d1
		lea	(Obj1A_SlopeData).l,a2
		bsr	SlopeObject
		jmp	MarkObjGone
; ===========================================================================

Obj1A_Touch:				; XREF: Obj1A_Index
		tst.b	$38(a0)
		beq.w	loc_847A
		move.b	#1,$3A(a0)	; set object as	"touched"
		subq.b	#1,$38(a0)

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1A_WalkOff:				; XREF: Obj1A_Index
		move.w	#$30,d1
		bsr	ExitPlatform
		move.w	#$30,d1
		lea	(Obj1A_SlopeData).l,a2
		move.w	obX(a0),d2
		bsr	SlopeObject2
		jmp	MarkObjGone
; End of function Obj1A_WalkOff

; ===========================================================================

Obj1A_Display:				; XREF: Obj1A_Index
		tst.b	$38(a0)		; has time delay reached zero?
		beq.s	Obj1A_TimeZero	; if yes, branch
		tst.b	$3A(a0)		; has Sonic touched the	object?
		bne.w	loc_82D0	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time
		bra.w	DisplaySprite
; ===========================================================================

loc_82D0:				; XREF: Obj1A_Display
		subq.b	#1,$38(a0)
		jsr	obj1A_WalkOff
		lea	($FFFFD000).w,a1
		btst	#3,obStatus(a1)
		beq.s	loc_82FC
		tst.b	$38(a0)
		bne.s	locret_8308
		bclr	#3,obStatus(a1)
		bclr	#5,obStatus(a1)
		move.b	#1,obNextAni(a1)

loc_82FC:
		move.b	#0,$3A(a0)
		move.b	#6,obRoutine(a0)	; run "Obj1A_Display" routine

locret_8308:
		rts	
; ===========================================================================

Obj1A_TimeZero:				; XREF: Obj1A_Display
		bsr	ObjectFall
		tst.b	obRender(a0)
		bpl.s	Obj1A_Delete
		bsr	DisplaySprite
		rts	
; ===========================================================================

Obj1A_Delete:				; XREF: Obj1A_Index
		bsr	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 53 - collapsing floors	(MZ, SLZ, SBZ)
; ---------------------------------------------------------------------------

Obj53:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj53_Index(pc,d0.w),d1
		jmp	Obj53_Index(pc,d1.w)
; ===========================================================================
Obj53_Index:	dc.w Obj53_Main-Obj53_Index, Obj53_ChkTouch-Obj53_Index
		dc.w Obj53_Touch-Obj53_Index, Obj53_Display-Obj53_Index
		dc.w Obj53_Delete-Obj53_Index, Obj53_WalkOff-Obj53_Index
; ===========================================================================

Obj53_Main:				; XREF: Obj53_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj53,obMap(a0)
		move.w	#$42B8,obGfx(a0)
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	Obj53_NotSLZ
		move.w	#$44E0,obGfx(a0)	; SLZ specific code
		addq.b	#2,obFrame(a0)

Obj53_NotSLZ:
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		bne.s	Obj53_NotSBZ
		move.w	#$43F5,obGfx(a0)	; SBZ specific code

Obj53_NotSBZ:
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#7,$38(a0)
		move.b	#$44,obActWid(a0)

Obj53_ChkTouch:				; XREF: Obj53_Index
		tst.b	$3A(a0)		; has Sonic touched the	object?
		beq.s	Obj53_Solid	; if not, branch
		tst.b	$38(a0)		; has time delay reached zero?
		beq.w	Obj53_Collapse	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time

Obj53_Solid:
		move.w	#$20,d1
		bsr	PlatformObject
		tst.b	obSubtype(a0)
		bpl.s	Obj53_MarkAsGone
		btst	#3,obStatus(a1)
		beq.s	Obj53_MarkAsGone
		bclr	#0,obRender(a0)
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		bcc.s	Obj53_MarkAsGone
		bset	#0,obRender(a0)

Obj53_MarkAsGone:
		jmp	MarkObjGone
; ===========================================================================

Obj53_Touch:				; XREF: Obj53_Index
		tst.b	$38(a0)
		beq.w	loc_8458
		move.b	#1,$3A(a0)	; set object as	"touched"
		subq.b	#1,$38(a0)

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj53_WalkOff:				; XREF: Obj53_Index
		move.w	#$20,d1
		bsr	ExitPlatform
		move.w	obX(a0),d2
		bsr	MvSonicOnPtfm2
		jmp	MarkObjGone
; End of function Obj53_WalkOff

; ===========================================================================

Obj53_Display:				; XREF: Obj53_Index
		tst.b	$38(a0)		; has time delay reached zero?
		beq.s	Obj53_TimeZero	; if yes, branch
		tst.b	$3A(a0)		; has Sonic touched the	object?
		bne.w	loc_8402	; if yes, branch
		subq.b	#1,$38(a0)	; subtract 1 from time
		bra.w	DisplaySprite
; ===========================================================================

loc_8402:
		subq.b	#1,$38(a0)
		jsr	obj53_WalkOff
		lea	($FFFFD000).w,a1
		btst	#3,obStatus(a1)
		beq.s	loc_842E
		tst.b	$38(a0)
		bne.s	locret_843A
		bclr	#3,obStatus(a1)
		bclr	#5,obStatus(a1)
		move.b	#1,obNextAni(a1)

loc_842E:
		move.b	#0,$3A(a0)
		move.b	#6,obRoutine(a0)	; run "Obj53_Display" routine

locret_843A:
		rts	
; ===========================================================================

Obj53_TimeZero:				; XREF: Obj53_Display
		bsr	ObjectFall
		bsr	DisplaySprite
		tst.b	obRender(a0)
		bpl.s	Obj53_Delete
		rts	
; ===========================================================================

Obj53_Delete:				; XREF: Obj53_Index
		bsr	DeleteObject
		rts	
; ===========================================================================

Obj53_Collapse:				; XREF: Obj53_ChkTouch
		move.b	#0,$3A(a0)

loc_8458:				; XREF: Obj53_Touch
		lea	(Obj53_Data2).l,a4
		btst	#0,obSubtype(a0)
		beq.s	loc_846C
		lea	(Obj53_Data3).l,a4

loc_846C:
		moveq	#7,d1
		addq.b	#1,obFrame(a0)
		bra.s	loc_8486
; ===========================================================================

Obj1A_Collapse:				; XREF: Obj1A_ChkTouch
		move.b	#0,$3A(a0)

loc_847A:				; XREF: Obj1A_Touch
		lea	(Obj53_Data1).l,a4
		moveq	#$18,d1
		addq.b	#2,obFrame(a0)

loc_8486:				; XREF: Obj53_Collapse
		moveq	#0,d0
		move.b	obFrame(a0),d0
		add.w	d0,d0
		movea.l	obMap(a0),a3
		adda.w	(a3,d0.w),a3
		addq.w	#1,a3
		bset	#5,obRender(a0)
		move.b	0(a0),d4
		move.b	obRender(a0),d5
		movea.l	a0,a1
		bra.s	loc_84B2
; ===========================================================================

loc_84AA:
		bsr	SingleObjLoad
		bne.s	loc_84F2
		addq.w	#5,a3

loc_84B2:
		move.b	#6,obRoutine(a1)
		move.b	d4,0(a1)
		move.l	a3,obMap(a1)
		move.b	d5,obRender(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	obGfx(a0),obGfx(a1)
		move.b	obPriority(a0),obPriority(a1)
		move.b	obActWid(a0),obActWid(a1)
		move.b	(a4)+,$38(a1)
		cmpa.l	a0,a1
		bcc.s	loc_84EE
		bsr	DisplaySprite2

loc_84EE:
		dbf	d1,loc_84AA

loc_84F2:
		bsr	DisplaySprite
		move.w	#$B9,d0
		jmp	(PlaySound_Special).l ;	play collapsing	sound
; ===========================================================================
; ---------------------------------------------------------------------------
; Disintegration data for collapsing ledges (MZ, SLZ, SBZ)
; ---------------------------------------------------------------------------
Obj53_Data1:	dc.b $1C, $18, $14, $10, $1A, $16, $12,	$E, $A,	6, $18,	$14, $10, $C, 8, 4
		dc.b $16, $12, $E, $A, 6, 2, $14, $10, $C, 0
Obj53_Data2:	dc.b $1E, $16, $E, 6, $1A, $12,	$A, 2
Obj53_Data3:	dc.b $16, $1E, $1A, $12, 6, $E,	$A, 2

; ---------------------------------------------------------------------------
; Sloped platform subroutine (GHZ collapsing ledges and	MZ platforms)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SlopeObject2:				; XREF: Obj1A_WalkOff; et al
		lea	($FFFFD000).w,a1
		btst	#3,obStatus(a1)
		beq.s	locret_856E
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		lsr.w	#1,d0
		btst	#0,obRender(a0)
		beq.s	loc_854E
		not.w	d0
		add.w	d1,d0

loc_854E:
		moveq	#0,d1
		move.b	(a2,d0.w),d1
		move.w	obY(a0),d0
		sub.w	d1,d0
		moveq	#0,d1
		move.b	obHeight(a1),d1
		sub.w	d1,d0
		move.w	d0,obY(a1)
		sub.w	obX(a0),d2
		sub.w	d2,obX(a1)

locret_856E:
		rts	
; End of function SlopeObject2

; ===========================================================================
; ---------------------------------------------------------------------------
; Collision data for GHZ collapsing ledge
; ---------------------------------------------------------------------------
Obj1A_SlopeData:
		incbin	misc\ghzledge.bin
		even

; ---------------------------------------------------------------------------
; Sprite mappings - GHZ	collapsing ledge
; ---------------------------------------------------------------------------
Map_obj1A:
		include	"_maps\obj1A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - collapsing floors (MZ, SLZ,	SBZ)
; ---------------------------------------------------------------------------
Map_obj53:
		include	"_maps\obj53.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1C - scenery (GHZ bridge stump, SAP A and C buttons)
; ---------------------------------------------------------------------------

Obj1C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj1C_Index(pc,d0.w),d1
		jmp	Obj1C_Index(pc,d1.w)
; ===========================================================================
Obj1C_Index:	dc.w Obj1C_Main-Obj1C_Index
		dc.w Obj1C_ChkDel-Obj1C_Index
; ===========================================================================

Obj1C_Main:				; XREF: Obj1C_Index
		addq.b	#2,obRoutine(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; copy object type to d0
		mulu.w	#$A,d0		; multiply by $A
		lea	Obj1C_Var(pc,d0.w),a1
		move.l	(a1)+,obMap(a0)
		move.w	(a1)+,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	(a1)+,obFrame(a0)
		move.b	(a1)+,obActWid(a0)
		move.b	(a1)+,obPriority(a0)
		move.b	(a1)+,obColType(a0)

		; used for the sway
		move.w	obY(a0),$32(a0)

Obj1C_ChkDel:				; XREF: Obj1C_Index
		; sway
		tst.b	($FFFFFE10).w	; are we in GHZ?
		beq.s	@chkdel		; if yes, no sway
		move.w	($FFFFFE0E).w,d0
		add.w	obX(a0),d0
		add.w	d0,d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$32(a0),d0
		move.w	d0,obY(a0)

@chkdel:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Variables for	object $1C are stored in an array
; ---------------------------------------------------------------------------
Obj1C_Var:	dc.l Map_obj1C		; mappings address
		dc.w $6880/$20		; VRAM setting
		dc.b 0,	8, 2, 0		; frame, width,	priority, collision response
		dc.l Map_obj1C
		dc.w ($6880+$80)/$20
		dc.b 0,	8, 2, 0
		dc.l Map_obj1C
		dc.w $44D8
		dc.b 0,	8, 2, 0
		dc.l Map_obj11
		dc.w $438E
		dc.b 1,	$10, 1,	0
; ---------------------------------------------------------------------------
; Sprite mappings - SLZ	lava thrower
; ---------------------------------------------------------------------------
Map_obj1C:
		include	"_maps\obj1C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1D - Exploding scenery object used in Finalor Place
; ---------------------------------------------------------------------------

Obj1D:					; XREF: Obj_Index
		cmpi.w	#$502,($FFFFFE10).w
		beq.s	@cont
		jmp	DeleteObject

@cont:
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj1D_Index(pc,d0.w),d1
		jmp	Obj1D_Index(pc,d1.w)
; ===========================================================================
Obj1D_Index:	dc.w Obj1D_Main-Obj1D_Index
		dc.w Obj1D_Action-Obj1D_Index
; ===========================================================================

Obj1D_Main:				; XREF: Obj1D_Index
		addq.b	#2,obRoutine(a0)

		clr.b	$34(a0)			; clear flag
		move.b	obSubtype(a0),d0	; is this the following-Sonic object?
		bpl.s	@0			; if not, branch
		move.b	#1,$34(a0)		; set flag
@0:
		andi.b	#$F,d0			; remove extra crap
		move.b	d0,obSubtype(a0)	; store new subtype

		move.b	d0,d1		; get object subtype (range: 0-A)
		moveq	#30,d0		; set base cooldown time to 30 frames
		add.b	d1,d1		; multiply it by 2
		sub.b	d1,d0		; substract from cooldown time
		move.b	d0,$30(a0)	; backup value
		move.b	d0,$32(a0)	; backup value

Obj1D_Action:
		tst.b	$34(a0)			; is this the following-Sonic object?
		beq.s	@0			; if not, branch
		cmpi.b	#2,(FZEscape).w		; is escape sequence already set?
		bhs.s	@updatepos		; if yes, branch
		rts

@updatepos:
		move.w	($FFFFD008).w,obX(a0)	; copy Sonic's X position
		move.w	($FFFFD00C).w,obY(a0)	; copy Sonic's Y position
		bra.s	@1

@0:
		tst.b	$34(a0)			; is this the following-Sonic object?
		bne.s	@1			; if yes, branch
		tst.b	(FZEscape).w		; is escape sequence already set?
		bne.s	@1			; if yes, branch
		jmp	DeleteObject		; delete the static scenery objects before the escape
		
@1:
		subq.b	#1,$32(a0)	; substract 1 from cooldown timer
		bpl.s	Obj1D_ChkDelete	; has the time run out? if not, branch
		move.b	$30(a0),$32(a0)	; reset cooldown

		ori.b	#$FF,(CameraShake).w		; infinite camera shake hooray

		bsr	SingleObjLoad
		bne.s	Obj1D_ChkDelete
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		
		; random deviation
		jsr	(RandomNumber).l
		moveq	#0,d1
		move.b	d0,d1
		subi.w	#$80,d1
		lsr.w	#8,d0
		subi.w	#$50,d0
		btst	#0,($FFFFFE05).w
		beq.s	@set
		asl.w	#1,d1
		asl.w	#1,d0
@set:
		add.w	d1,obX(a1)
		add.w	d0,obY(a1)
	
Obj1D_ChkDelete:				; XREF: Obj1D_Index
		tst.b	$34(a0)			; is this the following-Sonic object?
		bne.s	@0			; if yes, don't delete
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
@0:
		rts
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2A - doors (SYZ/SBZ)
; ---------------------------------------------------------------------------

Obj2A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj2A_Index(pc,d0.w),d1
		jmp	Obj2A_Index(pc,d1.w)
; ===========================================================================
Obj2A_Index:	dc.w Obj2A_Main-Obj2A_Index
		dc.w Obj2A_OpenShut-Obj2A_Index
		dc.w Obj2A_OpenShutTutorial-Obj2A_Index
; ===========================================================================

Obj2A_Main:				; XREF: Obj2A_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj2A,obMap(a0)
		move.w	#$4000+($5500/$20),obGfx(a0)	; VLADIK => Pointer fixed
		ori.b	#4,obRender(a0)
		move.b	#8,obActWid(a0)
		move.b	#0,obPriority(a0)

		cmpi.w	#$400,($FFFFFE10).w	; is level Uberhub?
		bne.s	@nosoundstopper		; if not, branch
		tst.b	obSubtype(a0)		; is this the door leading to the blackout challenge?
		bpl.s	@nosoundstopper		; if not, branch
		jsr	Check_BlackoutUnlocked	; check if all levels are beaten in frantic
		beq.s	@nosoundstopper		; if not, don't load sound stopper

		bsr	SingleObjLoad
		bne.s	@nosoundstopper
		move.b	#$7D,0(a1)		; load emblem object
		move.b	#4,obRoutine(a1)	; set to "sound stopper" mode
		move.w	obX(a0),d0		; copy X coordinate of door
		subi.w	#$30,d0			; move a few pixels to the left
		move.w	d0,obX(a1)		; write to thingy
		move.w	obY(a0),obY(a1)		; copy Y coordinate of door
		move.l	a0,$30(a1)		; make the stopper remember the location of this door

@nosoundstopper:
		cmpi.w	#$501,($FFFFFE10).w	; is this the tutorial?
		bne.s	Obj2A_OpenShut		; if not, branch
		tst.b	obSubtype(a0)		; "don't appear in tutorial" flag set?
		bne.s 	@Delete			; if yes, branch

		addq.b	#2,obRoutine(a0)
		move.b	#1,obAnim(a0)
		move.w	#$4000+($9800/$20),obGfx(a0)
		bra.w	Obj2A_OpenShutTutorial

@Delete:
		jmp 	DeleteObject

Obj2A_OpenShut:				; XREF: Obj2A_Index
		tst.b	(FZEscape).w
		beq.s	@0
		cmpi.w	#$246A,obX(a0)
		bne.s	@0
		move.b	#$3F,(a0)
		move.b	#0,obRoutine(a0)
		move.b	#0,$31(a0)
		rts
@0:
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ1 (overworld)?
		bne.w	Obj2A_NotUberhub		; if not, branch

	if DoorsAlwaysOpen=1
		bra.w	Obj2A_Green
	endif

Obj2A_Red:
		move.w	#$0800+($6100/$20),obGfx(a0)	; use red light art
		tst.b	obSubtype(a0)			; is this the door leading to the blackout challenge?
		bpl.s	@notblackoutdoor		; if not, branch
		jsr	Check_BlackoutUnlocked		; check if all levels in frantic are beaten
		beq.w	Obj2A_Animate			; if not, keep door locked
		tst.b	$30(a0)				; has sound stopper been passed?
		beq.s	Obj2A_Green			; if not, keep door open
		clr.b	obAnim(a0)			; shut door behind Sonic
		bra.w	Obj2A_Animate			; force door to be red

@notblackoutdoor:
		moveq	#0,d0
		move.b	obSubtype(a0),d0		; and it by subtype of door (always a single bit)
		cmpi.b	#6,d0				; is this the final door (FP|end)?
		bne.s	@notfinaldoor			; if not, branch
		jsr	Check_AllLevelsBeaten_Current	; only unlock final door after all levels have been legitimately beaten
		bne.s	Obj2A_Green			; if all levels are beaten, unlock door
		bra.w	Obj2A_Animate			; otherwise, keep door locked
		
@notfinaldoor:
		jsr	Check_LevelBeaten_Casual	; check if the level is beaten (casual or frantic)
		beq.s	Obj2A_Animate			; if the required level hasn't been beaten, keep door locked

Obj2A_Green:
		move.w	#$4800+($6000/$20),obGfx(a0)	; use green light art

		move.w	#$40,d1		; set minimum distance between door and Sonic
		clr.b	obAnim(a0)		; use "closing"	animation
		move.w	($FFFFD008).w,d0
		add.w	d1,d0
		cmp.w	obX(a0),d0
		bcs.s	Obj2A_Animate
		sub.w	d1,d0
		sub.w	d1,d0

		cmp.w	obX(a0),d0
		bcc.s	Obj2A_Animate

Obj2A_SYZ1:
		add.w	d1,d0
		cmp.w	obX(a0),d0
		bcc.s	loc_899A
		btst	#0,obStatus(a0)
		bne.s	Obj2A_Animate
		bra.s	Obj2A_Open
; ===========================================================================

Obj2A_NotUberhub:
		move.w	#$40,d1
		clr.b	obAnim(a0)		; use "closing"	animation
		move.w	($FFFFD008).w,d0
		add.w	d1,d0
		cmp.w	obX(a0),d0
		bcs.s	Obj2A_Animate
		sub.w	d1,d0
		sub.w	d1,d0
		cmp.w	obX(a0),d0
		bcc.s	Obj2A_Animate
		add.w	d1,d0
		cmp.w	obX(a0),d0
		bcc.s	loc_899A
		btst	#0,obStatus(a0)
		bne.s	Obj2A_Animate
		bra.s	Obj2A_Open
; ===========================================================================

loc_899A:				; XREF: Obj2A_OpenShut
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ1 (overworld)?
		beq.s	Obj2A_Open		; if yes, branch

Obj2A_Open_SBZ:
		btst	#0,obStatus(a0)
		beq.s	Obj2A_Animate

Obj2A_Open:				; XREF: Obj2A_OpenShut
		move.b	#1,obAnim(a0)	; use "opening"	animation

Obj2A_Animate:				; XREF: Obj2A_OpenShut; loc_899A
		lea	(Ani_obj2A).l,a1
		bsr.w	AnimateSprite
		tst.b	obFrame(a0)		; is the door open?
		bne.s	Obj2A_MarkAsUsed ; if yes, branch
		move.w	#$11,d1
		move.w	#$20,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		jsr	SolidObject

Obj2A_MarkAsUsed:
		jmp	MarkObjGone
; ===========================================================================

Obj2A_OpenShutTutorial:
		tst.b	obSubtype(a0)		; is this the door for the escape sequence?
		bmi.s	@tutshut		; if yes, force shut
		move.w	($FFFFD008).w,d0
		cmp.w	obX(a0),d0
		blt.s	Obj2A_Open
@tutshut:	move.b	#0,obAnim(a0)		; use "closing"	animation
		bra.s	Obj2A_Animate

; ===========================================================================
Ani_obj2A:
		include	"_anim\obj2A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - doors (SBZ)
; ---------------------------------------------------------------------------
Map_obj2A:
		include	"_maps\obj2A.asm"

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall:			; XREF: Obj44_Solid
		jsr	obj44_SolidWall2
		beq.s	loc_8AA8
		bmi.w	loc_8AC4
		tst.w	d0
		beq.w	loc_8A92
		bmi.s	loc_8A7C
		tst.w	obVelX(a1)
		bmi.s	loc_8A92
		bra.s	loc_8A82
; ===========================================================================

loc_8A7C:
		tst.w	obVelX(a1)
		bpl.s	loc_8A92

loc_8A82:
		sub.w	d0,obX(a1)
		move.w	#0,obInertia(a1)
		move.w	#0,obVelX(a1)

loc_8A92:
		btst	#1,obStatus(a1)
		bne.s	loc_8AB6
		bset	#5,obStatus(a1)
		bset	#5,obStatus(a0)
		rts	
; ===========================================================================

loc_8AA8:
		btst	#5,obStatus(a0)
		beq.s	locret_8AC2
		move.w	#1,obAnim(a1)

loc_8AB6:
		bclr	#5,obStatus(a0)
		bclr	#5,obStatus(a1)

locret_8AC2:
		rts	
; ===========================================================================

loc_8AC4:
		tst.w	obVelY(a1)
		bpl.s	locret_8AD8
		tst.w	d3
		bpl.s	locret_8AD8
		sub.w	d3,obY(a1)
		move.w	#0,obVelY(a1)

locret_8AD8:
		rts	
; End of function Obj44_SolidWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj44_SolidWall2:			; XREF: Obj44_SolidWall
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.s	loc_8B48
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.s	loc_8B48
		move.b	obHeight(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	obY(a1),d3
		sub.w	obY(a0),d3
		add.w	d2,d3
		bmi.s	loc_8B48
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.s	loc_8B48
		tst.b	($FFFFF7C8).w
		bmi.s	loc_8B48
		cmpi.b	#6,($FFFFD024).w
		bcc.s	loc_8B48
		tst.w	($FFFFFE08).w
		bne.s	loc_8B48
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_8B30
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_8B30:
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_8B3C
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_8B3C:
		cmp.w	d1,d5
		bhi.s	loc_8B44
		moveq	#1,d4
		rts	
; ===========================================================================

loc_8B44:
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_8B48:
		moveq	#0,d4
		rts	
; End of function Obj44_SolidWall2

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1E - Ball Hog enemy (SBZ)
; ---------------------------------------------------------------------------

Obj1E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj1E_Index(pc,d0.w),d1
		jmp	Obj1E_Index(pc,d1.w)
; ===========================================================================
Obj1E_Index:	dc.w Obj1E_Main-Obj1E_Index
		dc.w Obj1E_Action-Obj1E_Index
		dc.w Obj1E_Delete-Obj1E_Index	
; ===========================================================================

Obj1E_Main:				; XREF: Obj1E_Index
		move.b	#$13,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.l	#Map_obj1E,obMap(a0)
		move.w	#$2302,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#5,obColType(a0)
		move.b	#$C,obActWid(a0)
		bsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_8BAC
		add.w	d1,obY(a0)
		move.w	#0,obVelY(a0)
		addq.b	#2,obRoutine(a0)

locret_8BAC:
		rts	
; ===========================================================================

Obj1E_Action:				; XREF: Obj1E_Index
		tst.b	($FFFFFFB1).w
		bmi.s	Obj1E_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj1E_NotInhumanCrush
		move.b	#4,obRoutine(a0)		
		bsr	SingleObjLoad
		bne.s	Obj1E_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj1E_NotInhumanCrush:
		lea	(Ani_obj1E).l,a1
		bsr	AnimateSprite
		cmpi.b	#1,obFrame(a0)	; is final frame (01) displayed?
		bne.s	Obj1E_SetBall	; if not, branch
		tst.b	$32(a0)		; is it	set to launch cannonball?
		beq.s	Obj1E_MakeBall	; if yes, branch
		bra.s	Obj1E_MarkAsGone
; ===========================================================================

Obj1E_SetBall:				; XREF: Obj1E_Action
		clr.b	$32(a0)		; set to launch	cannonball

Obj1E_MarkAsGone:			; XREF: Obj1E_Action
		jmp	MarkObjGone
; ===========================================================================

Obj1E_MakeBall:				; XREF: Obj1E_Action
		move.b	#1,$32(a0)
		bsr	SingleObjLoad
		bne.s	loc_8C1A
		move.b	#$20,0(a1)	; load cannonball object ($20)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	#-$100,obVelX(a1)	; cannonball bounces to	the left
		move.w	#0,obVelY(a1)
		moveq	#-4,d0
		btst	#0,obStatus(a0)	; is Ball Hog facing right?
		beq.s	loc_8C0A	; if not, branch
		neg.w	d0
		neg.w	obVelX(a1)		; cannonball bounces to	the right

loc_8C0A:
		add.w	d0,obX(a1)
		addi.w	#$C,obY(a1)
		move.b	obSubtype(a0),obSubtype(a1)	; copy object type from	Ball Hog

loc_8C1A:
		bra.s	Obj1E_MarkAsGone
; ===========================================================================

Obj1E_Delete:
		bsr	DeleteObject
		rts
; ===========================================================================		
; ---------------------------------------------------------------------------
; Object 20 - cannonball that Ball Hog throws (SBZ)
; ---------------------------------------------------------------------------

Obj20:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj20_Index(pc,d0.w),d1
		jmp	Obj20_Index(pc,d1.w)
; ===========================================================================
Obj20_Index:	dc.w Obj20_Main-Obj20_Index
		dc.w Obj20_Bounce-Obj20_Index
; ===========================================================================

Obj20_Main:				; XREF: Obj20_Index
		addq.b	#2,obRoutine(a0)
		move.b	#7,obHeight(a0)
		move.l	#Map_obj1E,obMap(a0)
		move.w	#$2302,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$87,obColType(a0)
		move.b	#8,obActWid(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; move object type to d0
		mulu.w	#60,d0		; multiply by 60 frames	(1 second)
		move.w	d0,$30(a0)	; set explosion	time
		move.b	#4,obFrame(a0)

Obj20_Bounce:				; XREF: Obj20_Index
		bsr	ObjectFall
		tst.w	obVelY(a0)
		bmi.s	Obj20_ChkExplode
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	Obj20_ChkExplode
		add.w	d1,obY(a0)
		move.w	#-$300,obVelY(a0)
		tst.b	d3
		beq.s	Obj20_ChkExplode
		bmi.s	loc_8CA4
		tst.w	obVelX(a0)
		bpl.s	Obj20_ChkExplode
		neg.w	obVelX(a0)
		bra.s	Obj20_ChkExplode
; ===========================================================================

loc_8CA4:				; XREF: Obj20_Bounce
		tst.w	obVelX(a0)
		bmi.s	Obj20_ChkExplode
		neg.w	obVelX(a0)

Obj20_ChkExplode:			; XREF: Obj20_Bounce
		subq.w	#1,$30(a0)	; subtract 1 from explosion time
		bpl.s	Obj20_Animate	; if time is > 0, branch
		move.b	#$24,0(a0)
		move.b	#$3F,0(a0)	; change object	to an explosion	($3F)
		move.b	#0,obRoutine(a0)	; reset	routine	counter
		bra.w	Obj3F		; jump to explosion code
; ===========================================================================

Obj20_Animate:				; XREF: Obj20_ChkExplode
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from frame	duration
		bpl.s	Obj20_Display
		move.b	#5,obTimeFrame(a0)	; set frame duration to	5 frames
		bchg	#0,obFrame(a0)	; change frame

Obj20_Display:
		bsr	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	obY(a0),d0	; has object fallen off	the level?
		bcs.w	DeleteObject	; if yes, branch
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 24 - explosion	from a destroyed monitor
; ---------------------------------------------------------------------------

Obj24:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj24_Index(pc,d0.w),d1
		jmp	Obj24_Index(pc,d1.w)
; ===========================================================================
Obj24_Index:	dc.w Obj24_Main-Obj24_Index
		dc.w Obj24_Animate-Obj24_Index
; ===========================================================================

Obj24_Main:				; XREF: Obj24_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj24,obMap(a0)
		move.w	#$41C,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#0,obColType(a0)
		move.b	#$C,obActWid(a0)
		move.b	#9,obTimeFrame(a0)
		move.b	#0,obFrame(a0)
		move.w	#$A5,d0
		jsr	(PlaySound_Special).l ;	play explosion sound
		moveq	#100,d0		; add 1000 ...
		jsr	AddPoints	; ... points

Obj24_Animate:				; XREF: Obj24_Index
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from frame	duration
		bpl.s	Obj24_Display
		move.b	#9,obTimeFrame(a0)	; set frame duration to	9 frames
		addq.b	#1,obFrame(a0)	; next frame
		cmpi.b	#4,obFrame(a0)	; is the final frame (04) displayed?
		beq.w	DeleteObject	; if yes, branch

Obj24_Display:
		bra.w	DisplaySprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 27 - explosion	from a destroyed enemy
; ---------------------------------------------------------------------------

Obj27:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj27_Index(pc,d0.w),d1
		jmp	Obj27_Index(pc,d1.w)
; ===========================================================================
Obj27_Index:	dc.w Obj27_Main-Obj27_Index
		dc.w Obj27_Animate-Obj27_Index
; ===========================================================================

Obj27_Main:				; XREF: Obj27_Index
		cmpi.w	#$101,($FFFFFE10).w	; are we in LZ?
		bne.s	@notlz			; if not, branch
		cmpi.b	#82,$36(a0)		; did we come here because of Jaws?
		bne.s	@notlz			; if not, branch
		tst.b 	($FFFFFFF9).w		; final section flag already enabled?
		bne.s 	@notlz			; if yes, branch
		move.b 	#1,($FFFFFFF9).w	; set final section flag

		movem.l	d0-a3,-(sp)
		jsr 	Pal_FadeOut 	; i guess this works????
		moveq	#$17,d0
		jsr	PalLoad3_Water	; load toxic water palette
		jsr 	WhiteFlash3
		
		move.w	#$E4,d0			; set song $E0
		jsr	PlaySound		; fade out music
		
		move.w	#$800,d0		; immediately make the water disappear to give the player some time to escape before the flooding
		move.w	d0,($FFFFF646).w	; current water level
		move.w	d0,($FFFFF648).w	; average water level
		move.w	d0,($FFFFF64A).w	; target water level
		
		movem.l	(sp)+,d0-a3
		bra.s	Obj27_FinishSetup

@notlz:
		addq.b	#2,obRoutine(a0)

		; spawn bonus rings (and check which levels do not include this)
		cmpi.w	#$302,($FFFFFE10).w
		beq.s	Obj27_FinishSetup
		cmpi.w	#$501,($FFFFFE10).w
		beq.s	Obj27_FinishSetup
		cmpi.w	#$502,($FFFFFE10).w
		beq.s	Obj27_FinishSetup
		cmpi.w	#$001,($FFFFFE10).w
		beq.s	Obj27_FinishSetup
		cmpi.w	#$101,($FFFFFE10).w
		beq.s	Obj27_FinishSetup

		bsr	SingleObjLoad
		bne.s	Obj27_FinishSetup
		move.b	#$37,0(a1)	; load bouncing ring object
		move.w	obX(a0),obX(a1)	; load X position to a1
		moveq	#0,d0		; clear d0
		move.w	obY(a0),d0	; move Y position to d0
		move.w	d0,obY(a1)	; load Y position to a1
		move.b	#1,$35(a1)	; set flag that this was spawned from a destroyed enemy

Obj27_FinishSetup:				; XREF: Obj27_Index
		move.l	#Map_obj27,obMap(a0)
		move.w	#$5A0,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)

		bsr	RandomDirection

		move.b	#0,obColType(a0)
		move.b	#$C,obActWid(a0)
		move.b	#4,obTimeFrame(a0)	; set frame duration to	7 frames
		move.b	#0,obFrame(a0)
		move.w	#$C1,d0
		jsr	(PlaySound_Special).l ;	play breaking enemy sound
		
		ori.b	#10,(CameraShake).w     	; normal camera shake
		tst.b	($FFFFFFF9).w
		beq.s	Obj27_Animate
		ori.b	#180,(CameraShake).w	; intense camera shaking

Obj27_Animate:				; XREF: Obj27_Index
		jsr	SpeedToPos
		subi.w	#$10,obVelY(a0)

	;	tst.b	obRender(a0)
	;	bpl.w	Obj27_Delete
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from frame	duration
		bpl.s	Obj27_Display
		move.b	#4,obTimeFrame(a0)	; set frame duration to	7 frames
		addq.b	#1,obFrame(a0)	; next frame
		cmpi.b	#6,obFrame(a0)	; is the final frame (05) displayed?
		beq.s	Obj27_Delete	; if yes, branch

Obj27_Display:
		bra.w	DisplaySprite

Obj27_Delete:
		bra.w	DeleteObject	; if yes, branch
; ===========================================================================

RandomDirection:
		bsr	RandomNumber
		andi.l	#$01FF01FF,d0
		subi.w	#$FF,d0
		move.w	d0,obVelX(a0)
		swap	d0
		subi.w	#$FF,d0
		move.w	d0,obVelY(a0)
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3F - Explosions.
; ---------------------------------------------------------------------------

Obj3F_SoundType = 1

Obj3F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj3F_Index(pc,d0.w),d1
		jmp	Obj3F_Index(pc,d1.w)
; ===========================================================================
Obj3F_Index:	dc.w Obj3F_Main-Obj3F_Index
		dc.w Obj3F_Main2-Obj3F_Index
		dc.w Obj3F_Animate-Obj3F_Index
		dc.w Obj3F_Pathetic-Obj3F_Index
		dc.w Obj3F_Animate_NoMove-Obj3F_Index
; ===========================================================================

Obj3F_Main:				; XREF: Obj3F_Index
		cmpi.w	#$502,($FFFFFE10).w	; is level FZ?
		bne.s	@cont			; if not, branch
		tst.b	(FZEscape).w
		bne.s	@cont
		move.w	($FFFFF700).w,d0
		cmpi.w	#$2400,d0
		bhs.s	Obj3F_Main2		; reduced explosions during FP boss fight (sprite limit)
@cont:
		bsr	SingleObjLoad
		bne.s	Obj3F_Main2
		move.b	#$3F,0(a1)	; load another explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	$3E(a0),$3E(a1)
		move.b	#2,obRoutine(a1)
		move.b	$30(a0),$30(a1)	; copy harm state
		move.b	#1,$31(a1)	; set mute flag
		
		btst	#0,($FFFFFE05).w	; are we on an odd frame?
		bne.s	Obj3F_Main2		; if yes, don't load a third explosion
		bsr	SingleObjLoad2
		bne.s	Obj3F_Main2
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	$3E(a0),$3E(a1)
		move.b	#2,obRoutine(a1)
		move.b	$30(a0),$30(a1)	; copy harm state
		move.b	#1,$31(a1)	; set mute flag
; ---------------------------------------------------------------------------

Obj3F_Main2:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj3F,obMap(a0)
		move.w	#$5A0,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#0,obColType(a0)

		bsr	RandomDirection

		cmpi.w	#$502,($FFFFFE10).w
		bne.s	@cont2
		tst.b	($FFFFF7AA).w
		bne.s	@cont2
		move.b	#7,obPriority(a0)

@cont2:
		tst.b	($FFFFF7AA).w		; is boss mode on?
		bne.s	Obj3F_NotHarmful	; if yes, branch
		tst.b	$30(a0)			; is explosion set to be harmful?
		bne.s	Obj3F_NotHarmful	; if not, branch
		cmpi.w	#$001,($FFFFFE10).w
		beq.s	@cont
		cmpi.b	#1,($FFFFFFAA).w
		beq.s	Obj3F_NotHarmful
@cont:		move.b	#$84,obColType(a0)
		moveq	#10,d0		; add 100 ...
		jsr	AddPoints	; ... points

Obj3F_NotHarmful:
		move.b	#$C,obActWid(a0)
		move.b	#4,obTimeFrame(a0)
		move.b	#0,obFrame(a0)
		
		tst.b	$30(a0)
		bne.s	@nocamshaking
		ori.b	#10,(CameraShake).w
@nocamshaking:
		tst.b	$31(a0)		; was mute flag set?
		bne.s	Obj3F_NoSound	; if yes, branch

Obj3F_PlaySound:
	if Obj3F_SoundType=1
		move.w	#$C4,d0			; play default explosion sound (MZ block smash)
	else
		move.w	#$D7,d0			; play boring ass baby explosion sound
	endif
		jmp	(PlaySound_Special).l

Obj3F_NoSound:
		rts			; return (don't play sound)
; ===========================================================================

Obj3F_Animate:				; XREF: Obj3F_Index
		jsr	SpeedToPos
		subi.w	#$10,obVelY(a0)

Obj3F_Animate_NoMove:
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from frame	duration
		bpl.s	Obj3F_Display
		move.b	#4,obTimeFrame(a0)	; set frame duration to	7 frames
		addq.b	#1,obFrame(a0)	; next frame
		cmpi.b	#6,obFrame(a0)	; is the final frame (05) displayed?
		beq.s	Obj3F_Delete	; if yes, branch

Obj3F_Display:
		bra.w	DisplaySprite

Obj3F_Delete:
		bra.w	DeleteObject
; ===========================================================================

Obj3F_Pathetic:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj27,obMap(a0)	; use gray clouds
		move.w	#$5A0,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#0,obColType(a0)
		move.b	#$C,obActWid(a0)
		move.b	#4,obTimeFrame(a0)
		move.b	#0,obFrame(a0)
		move.w	#$D7,d0			; play boring ass baby explosion sound
		jmp	(PlaySound_Special).l
; ===========================================================================

Ani_obj1E:
		include	"_anim\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Ball Hog enemy (SBZ)
; ---------------------------------------------------------------------------
Map_obj1E:
		include	"_maps\obj1E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion
; ---------------------------------------------------------------------------
Map_obj24:
		include	"_maps\obj24.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion
; ---------------------------------------------------------------------------
Map_obj27:
		include	"_maps\obj27.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - explosion from when	a boss is destroyed
; ---------------------------------------------------------------------------
Map_obj3F:
		include	"_maps\obj3F.asm"
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 28 - animals
; ---------------------------------------------------------------------------

Obj28:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj28_Index(pc,d0.w),d1
		jmp	Obj28_Index(pc,d1.w)
; ===========================================================================
Obj28_Index:	dc.w Obj28_Ending-Obj28_Index, loc_912A-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9184-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_91C0-Obj28_Index
		dc.w loc_9184-Obj28_Index, loc_9240-Obj28_Index
		dc.w loc_9260-Obj28_Index, loc_9260-Obj28_Index
		dc.w loc_9280-Obj28_Index, loc_92BA-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9332-Obj28_Index
		dc.w loc_9314-Obj28_Index, loc_9370-Obj28_Index
		dc.w loc_92D6-Obj28_Index

Obj28_VarIndex:	dc.b 0,	5, 2, 3, 6, 3, 4, 5, 4,	1, 0, 1

Obj28_Variables:dc.w $FE00, $FC00
		dc.l Map_obj28
		dc.w $FE00, $FD00	; horizontal speed, vertical speed
		dc.l Map_obj28a		; mappings address
		dc.w $FE80, $FD00
		dc.l Map_obj28
		dc.w $FEC0, $FE80
		dc.l Map_obj28a
		dc.w $FE40, $FD00
		dc.l Map_obj28b
		dc.w $FD00, $FC00
		dc.l Map_obj28a
		dc.w $FD80, $FC80
		dc.l Map_obj28b

Obj28_EndSpeed:	dc.w $FBC0, $FC00, $FBC0, $FC00, $FBC0,	$FC00, $FD00, $FC00
		dc.w $FD00, $FC00, $FE80, $FD00, $FE80,	$FD00, $FEC0, $FE80
		dc.w $FE40, $FD00, $FE00, $FD00, $FD80,	$FC80

Obj28_EndMap:	dc.l Map_obj28a, Map_obj28a, Map_obj28a, Map_obj28, Map_obj28
		dc.l Map_obj28,	Map_obj28, Map_obj28a, Map_obj28b, Map_obj28a
		dc.l Map_obj28b

Obj28_EndVram:	dc.w $5A5, $5A5, $5A5, $553, $553, $573, $573, $585, $593
		dc.w $565, $5B3
; ===========================================================================

Obj28_Ending:				; XREF: Obj28_Index
		tst.b	obSubtype(a0)		; did animal come from a destroyed enemy?
		beq.w	Obj28_FromEnemy	; if yes, branch
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; move object type to d0
		add.w	d0,d0		; multiply d0 by 2
		move.b	d0,obRoutine(a0)	; move d0 to routine counter
		subi.w	#$14,d0
		move.w	Obj28_EndVram(pc,d0.w),obGfx(a0)
		add.w	d0,d0
		move.l	Obj28_EndMap(pc,d0.w),obMap(a0)
		lea	Obj28_EndSpeed(pc),a1
		move.w	(a1,d0.w),$32(a0) ; load horizontal speed
		move.w	(a1,d0.w),obVelX(a0)
		move.w	obGfx(a1,d0.w),$34(a0) ; load vertical speed
		move.w	obGfx(a1,d0.w),obVelY(a0)
		move.b	#$C,obHeight(a0)
		move.b	#4,obRender(a0)
		bset	#0,obRender(a0)
		move.b	#6,obPriority(a0)
		move.b	#8,obActWid(a0)
		move.b	#7,obTimeFrame(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj28_FromEnemy:			; XREF: Obj28_Ending
		addq.b	#2,obRoutine(a0)
		jsr	RandomNumber
		andi.w	#1,d0
		moveq	#0,d1
		move.b	($FFFFFE10).w,d1
		add.w	d1,d1
		add.w	d0,d1
		lea	Obj28_VarIndex(pc),a1
		move.b	(a1,d1.w),d0
		move.b	d0,$30(a0)
		lsl.w	#3,d0
		lea	Obj28_Variables(pc),a1
		adda.w	d0,a1
		move.w	(a1)+,$32(a0)	; load horizontal speed
		move.w	(a1)+,$34(a0)	; load vertical	speed
		move.l	(a1)+,obMap(a0)	; load mappings
		move.w	#$580,obGfx(a0)	; VRAM setting for 1st animal
		btst	#0,$30(a0)	; is 1st animal	used?
		beq.s	loc_90C0	; if yes, branch
		move.w	#$592,obGfx(a0)	; VRAM setting for 2nd animal

loc_90C0:
		move.b	#$C,obHeight(a0)
		move.b	#4,obRender(a0)
		bset	#0,obRender(a0)
		move.b	#6,obPriority(a0)
		move.b	#8,obActWid(a0)
		move.b	#7,obTimeFrame(a0)
		move.b	#2,obFrame(a0)
		move.w	#-$400,obVelY(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_911C
		bsr	SingleObjLoad
		bne.s	Obj28_Display
		move.b	#$29,0(a1)	; load points object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	$3E(a0),d0
		lsr.w	#1,d0
		move.b	d0,obFrame(a1)

Obj28_Display:
		bra.w	DisplaySprite
; ===========================================================================

loc_911C:
		move.b	#$12,obRoutine(a0)
		clr.w	obVelX(a0)
		bra.w	DisplaySprite
; ===========================================================================

loc_912A:				; XREF: Obj28_Index
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		bsr	ObjectFall
		tst.w	obVelY(a0)
		bmi.s	loc_9180
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9180
		add.w	d1,obY(a0)
		move.w	$32(a0),obVelX(a0)
		move.w	$34(a0),obVelY(a0)
		move.b	#1,obFrame(a0)
		move.b	$30(a0),d0
		add.b	d0,d0
		addq.b	#4,d0
		move.b	d0,obRoutine(a0)
		tst.b	($FFFFF7A7).w
		beq.s	loc_9180
		btst	#4,($FFFFFE05).w
		beq.s	loc_9180
		neg.w	obVelX(a0)
		bchg	#0,obRender(a0)

loc_9180:
		bra.w	DisplaySprite
; ===========================================================================

loc_9184:				; XREF: Obj28_Index
		bsr	ObjectFall
		move.b	#1,obFrame(a0)
		tst.w	obVelY(a0)
		bmi.s	loc_91AE
		move.b	#0,obFrame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91AE
		add.w	d1,obY(a0)
		move.w	$34(a0),obVelY(a0)

loc_91AE:
		tst.b	obSubtype(a0)
		bne.s	loc_9224
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_91C0:				; XREF: Obj28_Index
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)
		tst.w	obVelY(a0)
		bmi.s	loc_91FC
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_91FC
		add.w	d1,obY(a0)
		move.w	$34(a0),obVelY(a0)
		tst.b	obSubtype(a0)
		beq.s	loc_91FC
		cmpi.b	#$A,obSubtype(a0)
		beq.s	loc_91FC
		neg.w	obVelX(a0)
		bchg	#0,obRender(a0)

loc_91FC:
		subq.b	#1,obTimeFrame(a0)
		bpl.s	loc_9212
		move.b	#1,obTimeFrame(a0)
		addq.b	#1,obFrame(a0)
		andi.b	#1,obFrame(a0)

loc_9212:
		tst.b	obSubtype(a0)
		bne.s	loc_9224
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

loc_9224:				; XREF: Obj28_Index
		move.w	obX(a0),d0
		sub.w	($FFFFD008).w,d0
		bcs.s	loc_923C
		subi.w	#$180,d0
		bpl.s	loc_923C
		tst.b	obRender(a0)
		bpl.w	DeleteObject

loc_923C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9240:				; XREF: Obj28_Index
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		subq.w	#1,$36(a0)
		bne.w	loc_925C
		move.b	#2,obRoutine(a0)
		move.b	#3,obPriority(a0)

loc_925C:
		bra.w	DisplaySprite
; ===========================================================================

loc_9260:				; XREF: Obj28_Index
		bsr	sub_9404
		bcc.s	loc_927C
		move.w	$32(a0),obVelX(a0)
		move.w	$34(a0),obVelY(a0)
		move.b	#$E,obRoutine(a0)
		bra.w	loc_91C0
; ===========================================================================

loc_927C:
		bra.w	loc_9224
; ===========================================================================

loc_9280:				; XREF: Obj28_Index
		bsr	sub_9404
		bpl.s	loc_92B6
		clr.w	obVelX(a0)
		clr.w	$32(a0)
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)
		bsr	loc_93C4
		bsr	loc_93EC
		subq.b	#1,obTimeFrame(a0)
		bpl.s	loc_92B6
		move.b	#1,obTimeFrame(a0)
		addq.b	#1,obFrame(a0)
		andi.b	#1,obFrame(a0)

loc_92B6:
		bra.w	loc_9224
; ===========================================================================

loc_92BA:				; XREF: Obj28_Index
		bsr	sub_9404
		bpl.s	loc_9310
		move.w	$32(a0),obVelX(a0)
		move.w	$34(a0),obVelY(a0)
		move.b	#4,obRoutine(a0)
		bra.w	loc_9184
; ===========================================================================

loc_92D6:				; XREF: Obj28_Index
		bsr	ObjectFall
		move.b	#1,obFrame(a0)
		tst.w	obVelY(a0)
		bmi.s	loc_9310
		move.b	#0,obFrame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_9310
		not.b	$29(a0)
		bne.s	loc_9306
		neg.w	obVelX(a0)
		bchg	#0,obRender(a0)

loc_9306:
		add.w	d1,obY(a0)
		move.w	$34(a0),obVelY(a0)

loc_9310:
		bra.w	loc_9224
; ===========================================================================

loc_9314:				; XREF: Obj28_Index
		bsr	sub_9404
		bpl.s	loc_932E
		clr.w	obVelX(a0)
		clr.w	$32(a0)
		bsr	ObjectFall
		bsr	loc_93C4
		bsr	loc_93EC

loc_932E:
		bra.w	loc_9224
; ===========================================================================

loc_9332:				; XREF: Obj28_Index
		bsr	sub_9404
		bpl.s	loc_936C
		bsr	ObjectFall
		move.b	#1,obFrame(a0)
		tst.w	obVelY(a0)
		bmi.s	loc_936C
		move.b	#0,obFrame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_936C
		neg.w	obVelX(a0)
		bchg	#0,obRender(a0)
		add.w	d1,obY(a0)
		move.w	$34(a0),obVelY(a0)

loc_936C:
		bra.w	loc_9224
; ===========================================================================

loc_9370:				; XREF: Obj28_Index
		bsr	sub_9404
		bpl.s	loc_93C0
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)
		tst.w	obVelY(a0)
		bmi.s	loc_93AA
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_93AA
		not.b	$29(a0)
		bne.s	loc_93A0
		neg.w	obVelX(a0)
		bchg	#0,obRender(a0)

loc_93A0:
		add.w	d1,obY(a0)
		move.w	$34(a0),obVelY(a0)

loc_93AA:
		subq.b	#1,obTimeFrame(a0)
		bpl.s	loc_93C0
		move.b	#1,obTimeFrame(a0)
		addq.b	#1,obFrame(a0)
		andi.b	#1,obFrame(a0)

loc_93C0:
		bra.w	loc_9224
; ===========================================================================

loc_93C4:
		move.b	#1,obFrame(a0)
		tst.w	obVelY(a0)
		bmi.s	locret_93EA
		move.b	#0,obFrame(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_93EA
		add.w	d1,obY(a0)
		move.w	$34(a0),obVelY(a0)

locret_93EA:
		rts	
; ===========================================================================

loc_93EC:
		bset	#0,obRender(a0)
		move.w	obX(a0),d0
		sub.w	($FFFFD008).w,d0
		bcc.s	locret_9402
		bclr	#0,obRender(a0)

locret_9402:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_9404:
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		subi.w	#$B8,d0
		rts	
; End of function sub_9404

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 29 - points that appear when you destroy something
; ---------------------------------------------------------------------------

Obj29:					; XREF: Obj_Index
		bra.w	DeleteObject
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj29_Index(pc,d0.w),d1
		jsr	obj29_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj29_Index:	dc.w Obj29_Main-Obj29_Index
		dc.w Obj29_Slower-Obj29_Index
; ===========================================================================

Obj29_Main:				; XREF: Obj29_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj29,obMap(a0)
		move.w	#$2797,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#8,obActWid(a0)
		move.w	#-$300,obVelY(a0)	; move object upwards

Obj29_Slower:				; XREF: Obj29_Index
		tst.w	obVelY(a0)		; is object moving?
		bpl.w	DeleteObject	; if not, branch
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)	; reduce object	speed
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - animals
; ---------------------------------------------------------------------------
Map_obj28:
		include	"_maps\obj28.asm"

Map_obj28a:
		include	"_maps\obj28a.asm"

Map_obj28b:
		include	"_maps\obj28b.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - points that	appear when you	destroy	something
; ---------------------------------------------------------------------------
Map_obj29:
		include	"_maps\obj29.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1F - Crabmeat enemy (GHZ, SYZ) -- Crabmeat Boss (GHZ1)
; ---------------------------------------------------------------------------
;===================================
;Speed
; Speed for the Crabmeat
CMSpeed = $120
;===================================

Obj1F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj1F_Index(pc,d0.w),d1
		jmp	Obj1F_Index(pc,d1.w)
; ===========================================================================
Obj1F_Index:	dc.w Obj1F_Main-Obj1F_Index
		dc.w Obj1F_Action-Obj1F_Index
		dc.w Obj1F_Delete-Obj1F_Index
		dc.w Obj1F_BallMain-Obj1F_Index
		dc.w Obj1F_BallMove-Obj1F_Index
; ===========================================================================

Obj1F_Main:				; XREF: Obj1F_Index
		move.b	#$10,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.l	#Map_obj1F,obMap(a0)
		move.w	#$400,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		
		move.b	#6,obColType(a0)		; use normal touch response
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	Obj01_NotGHZ1_Main2	; if not, branch
		clr.b	($FFFFFFD5).w
		move.b	#$F,obColType(a0)		; use boss touch response
	if LowBossHP=1
		move.b	#1,obColProp(a0)		; set number of	hits to	1
	else
		move.b	#12,obColProp(a0)		; set number of	hits to	12
	endif
		move.b	obColProp(a0),(HUD_BossHealth).w

Obj01_NotGHZ1_Main2:
		move.b	#$15,obActWid(a0)
		bsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_955A
		add.w	d1,obY(a0)
		move.b	d3,obAngle(a0)
		move.w	#0,obVelY(a0)
		addq.b	#2,obRoutine(a0)

locret_955A:
		rts
; ===========================================================================

Obj1F_Action:				; XREF: Obj1F_Index
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
	;	beq.s	Obj1F_NoHome		; if yes, branch
		beq.s	Obj1F_NotInhumanCrush	; if yes, branch

Obj1F_NoHome:
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		bne.s	Obj1F_NotInhumanCrush	; if not, branch
		tst.b	($FFFFFFB1).w		; is inhuman crush counter empty?
		bmi.s	Obj1F_NotInhumanCrush	; if yes, branch
		tst.b	obRender(a0)			; is the crabmeat on-screen?
		bpl.b	Obj1F_NotInhumanCrush	; if not, branch
		move.b	#4,obRoutine(a0)		; set to delete
		bsr	SingleObjLoad		; load from SingleObjLoad
		bne.s	Obj1F_NotInhumanCrush	; if it's in use, branch
		move.b	#$3F,0(a1)		; load explosion from a destroyed enemy
		move.w	obX(a0),obX(a1)		; set X-pos
		move.w	obY(a0),obY(a1)		; set Y-pos
		move.b	#0,$31(a1)

Obj1F_NotInhumanCrush:
		cmpi.b	#$1E,$3E(a0)			; set flashing timer
		bne.s	@cont
	;	subq.b	#1,obColProp(a0)			; sub 1 from lives (for SOME really stupid reason, this is done somewhere else. gah.)
		move.b	obColProp(a0),(HUD_BossHealth).w
		tst.b	obColProp(a0)
		bhi.s	@cont
		cmpi.b	#4,ob2ndRout(a0)
		bge.s	@cont
		ori.b	#10,(CameraShake).w		; camera shaking
		move.b	#4,ob2ndRout(a0)		; set to boss defeated
		move.w	#200,$3C(a0)			; set destroying timer
		move.b	#8,obAnim(a0)			; start kill animation (anim ID 8-$13)
@cont:
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj1F_Index2(pc,d0.w),d1
		jsr	obj1F_Index2(pc,d1.w)
		lea	(Ani_obj1F).l,a1
		bsr	AnimateSprite
		cmpi.w	#$000,($FFFFFE10).w		; is level GHZ1?
		bne.w	MarkObjGone			; if not, branch
		bra.w	DisplaySprite
; ===========================================================================
Obj1F_Index2:	dc.w Obj1F_WaitFire-Obj1F_Index2	; $00
		dc.w Obj1F_WalkOnFloor-Obj1F_Index2	; $02
		dc.w Obj1F_BossDefeated-Obj1F_Index2	; $04
		dc.w Obj1F_BossDefeated-Obj1F_Index2	; $06
		dc.w Obj1F_LevelTransition-Obj1F_Index2	; $08
; ===========================================================================

Obj1F_WaitFire:			; XREF: Obj1F_Index2
		cmpi.w	#$000,($FFFFFE10).w		; is level GHZ1?
		bne.w	Obj1F_NotGHZ1_WF		; if not, branch anything
		tst.b	($FFFFFFAA).w			; is flag 1 set?
		bne.w	Obj1F_CheckDefeated		; if yes, branch
		tst.b	($FFFFFFAB).w			; is flag 2 set?
		beq.w	locret_95B6			; if not, branch
		move.w	obX(a0),d0			; load object's X pos
		sub.w	($FFFFD008).w,d0		; minus sonic's X pos from it
		bpl.w	Obj1F_XChk			; if answer is possitive, branch
		neg.w	d0				; reverse d0

Obj1F_XChk:
		cmpi.w	#$0069,d0			; is sonic within 55 pixels of the object?
		blt.w	Obj1F_Timesup			; if yes, branch
		move.w	#-$80,obVelX(a0)			; move Crabmeat	to the left
		addq.b	#2,ob2ndRout(a0)			; increse routine counter
		jsr	obj1F_SetAni			; set correct animation
		addq.b	#3,d0				; add 3 to it
		move.b	d0,obAnim(a0)			; set anim
		bchg	#0,obStatus(a0)			; change direction
		rts					; return
; ===========================================================================

Obj1F_Timesup:
		move.b	#4,($FFFFD024).w
		move.b	#$1A,($FFFFD01C).w
		bset	#1,($FFFFD022).w
		move.w	#-$200,($FFFFD010).w
		move.w	#-$400,($FFFFD012).w
		move.b	#1,($FFFFFF72).w

		move.b	#$98,d0				; set boss music
		jsr	PlaySound			; play it
		jsr	obj1F_MakeFire			; make fire

		ori.b	#10,(CameraShake).w

		move.b	#1,($FFFFFFAA).w		; set flag 1
		clr.b	($FFFFF7C8).w			; unlock controls 1
		clr.b	($FFFFF7CC).w			; unlock controls 2
		bset	#0,obStatus(a0)			; make sure crabmeat walks to the correct direction
		rts					; return
; ===========================================================================

Obj1F_BossDefeated:
		move.b	#1,($FFFFF7CC).w		; lock controls
		clr.b	($FFFFFFEB).w
		clr.l	($FFFFF602).w			; clear any remaining button presses

		tst.b	($FFFFFFD5).w			; first time this routine gets run?
		bne.s	@0				; if not, branch
		move.b	#1,($FFFFFFD5).w		; set flag 3
		move.b	#$E0,d0				; fade out music
		jsr	PlaySound			; play it

		bset	#0,($FFFFD022).w
		move.w	($FFFFD008).w,d0
		cmp.w	obX(a0),d0
		bcc.s	@0
		bclr	#0,($FFFFD022).w

@0:
		clr.w	obVelX(a0)			; clear X-speed
		cmpi.b	#8,obAnim(a0)			; is the correct animation set?
		bge.s	@conxt				; if yes, branch
		move.b	#8,obAnim(a0)

@conxt:
		cmpi.b	#$12,obAnim(a0)
		beq.s	@ToLevelTransition		; if it's empty, delete boss
		bsr	BossDefeated2			; otherwise let it explode
		move.b	#1,($FFFFFFD4).w		; set flag 4
		rts					; return

@ToLevelTransition:
		move.b	#8,ob2ndRout(a0)		; => "Obj1F_LevelTransition"
		move.b	#150,4(a0)			; set timer
		
; ===========================================================================
Obj1F_LevelTransition:
		subq.b	#1,4(a0)
		beq.s	Obj1F_BossDelete
		
		cmpi.b	#60,4(a0)
		bne.s	@0
		move.b	#$A9,d0			; play blip sound
		jsr	PlaySound
@0:		rts

Obj1F_BossDelete:
		clr.b	(HUD_BossHealth).w			; revert lives counter to normal
		ori.b	#1,($FFFFFE1C).w		; update lives counter (to reset it from the boss)
		clr.l	($FFFFFE22).w			; clear time
		ori.b	#1,($FFFFFE1E).w 		; update time counter
		clr.b	($FFFFFE2C).w			; clear shield

		move.b	#2,($FFFFFFD4).w		; set flag 4, 2
		move.b	#0,($FFFFF7AA).w		; unlock screen
		move.b	#2,($FFFFFFAA).w		; set flag 1, 2
		move.w	#$25C5,($FFFFF728).w		; set new left boundary
		move.w	#$5060,($FFFFF72A).w		; set new right boundary

		move.b	#$DB,d0			; play epic explosion sound
		jsr	PlaySound
		move.l	#10000,d0		; add 100000 ...
		jsr	AddPoints	; ... points

		; part two of the transition is (cruedly) done in Obj34 itself
		lea	($FFFFD000).w,a1
		move.w	#$3700,obX(a1)
		move.w	#$0060,obY(a1)
		move.w	#-$C80,obVelX(a1)	; weeeeeee
		move.w	#0,obVelY(a1)
		addq.w	#8,obY(a1)
		bclr	#0,obStatus(a1) ; face right
		bset	#1,obStatus(a1) ; in air
		bset	#2,obStatus(a1) ; rolling
		bclr	#3,obStatus(a1) ; not standing
		move.b	#$25,obAnim(a1)	; use inhuman rotate animation
		move.b	#2,obRoutine(a1)
		move.b	#1,($FFFFFFEB).w	; set jumpdash flag
		move.b	#1,(RedrawEverything).w

		clr.w	($FFFFFE30).w		; clear any set level checkpoints

		move.b	#$34,($FFFFD080).w 		; load title card object
		move.b	#100,($FFFFD080+$30).w		; set delay before loading title cards
		move.b	#1,($FFFFD080+$31).w		; set title card patterns load flag

		movem.l	d0-d7/a1-a3,-(sp)
		moveq	#3,d0
		jsr	PalLoad2		; load Sonic palette
		moveq	#$C,d0
		jsr	PalLoad2	; load GHZ palette
		jsr	WhiteFlash3			; make white flash
		movem.l	(sp)+,d0-d7/a1-a3
		
		move.b	#4,obRoutine(a0)		; delete crabmeat boss
		rts
; ===========================================================================

Obj1F_CheckDefeated:
		tst.b	obColType(a0)				; is crabmeat having any touch response?
		bne.w	Obj1F_NotGHZ1_WF		; if yes, branch
		tst.b	$3E(a0)				; is timer empty?
		bne.s	loc_17F70X			; if not, branch
	;	move.b	obColProp(a0),(HUD_BossHealth).w
	;	subq.b	#1,obColProp(a0)			; sub 1 from lives
		bra.s	loc_17F70XY			; if he still has lives left, branch
		move.b	#4,ob2ndRout(a0)			; set to boss defeated
		ori.b	#10,(CameraShake).w		; camera shaking
		move.w	#200,$3C(a0)			; set timer
		move.b	#8,obAnim(a0)
		bra.w	Obj1F_NotGHZ1_WF		; skip
; ===========================================================================

loc_17F70XY:
		move.w	obX(a0),d1			; load X-pos to d1
		move.w	obY(a0),d2			; load Y-pos to d2
		sub.w	($FFFFD008).w,d1		; sub Sonic's X-pos from it
		sub.w	($FFFFD00C).w,d2		; sub Sonic's Y-pos from it
		jsr	(CalcAngle).l			; calc angle
		jsr	(CalcSine).l			; calc sine
		muls.w	#-$700,d1			; multiple it by -$700
		asr.l	#8,d1				; asl by 8
		sub.w	#$50,d1				; sub $50 from it
		move.w	d1,($FFFFD010).w		; bounce Sonic away
		muls.w	#-$700,d0			; multiple it by -$700
		asr.l	#8,d0				; asr by 8
		move.w	d0,($FFFFD012).w		; bounce Sonic away
		move.b	#$20,$3E(a0)			; set flashing timer
		move.w	#$AC,d0				; set sound
		jsr	(PlaySound_Special).l 		; play boss damage sound
		moveq	#10,d0		; add 100 ...
		jsr	AddPoints	; ... points

loc_17F70X:
		cmpi.b	#2,obColProp(a0)			; only having 2 lives left?
		bra.s	Obj1F_Flashing			; if more, branch
		move.b	#4,ob2ndRout(a0)			; set to boss defeated
		move.w	#200,$3C(a0)			; set destroying timer
		move.b	#8,obAnim(a0)
		bra.w	Obj1F_BossDefeated		; branch
; ===========================================================================

Obj1F_Flashing:
		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		beq.s	Obj1F_NoFlash		; if not, no flash
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	Obj1F_NoFlash		; if yes, don't do palette flashing to avoid seizues

		lea	($FFFFFB02).w,a1		; load second colour
		moveq	#0,d1				; make sure d1 is empty
		tst.w	(a1)				; is colour empty?
		bne.s	loc_17F7EX			; if not, branch
		move.w	#$EEE,d1			; set flashing to white

loc_17F7EX:
		move.w	d1,(a1)				; set colour

Obj1F_NoFlash:
		subq.b	#1,$3E(a0)			; sub 1 from flashing timer
		bne.s	Obj1F_NotGHZ1_WF		; if it isn't empty, branch
		move.b	#$F,obColType(a0)			; set normal touch response
	;	subq.b	#1,obColProp(a0)			; sub 1 from lives
	;	move.b	obColProp(a0),(HUD_BossHealth).w
		cmpi.b	#2,obColProp(a0)			; only having 2 lives left?
		bra.s	Obj1F_NotGHZ1_WF		; if more, branch
		move.b	#4,ob2ndRout(a0)			; set to boss defeated
		move.w	#200,$3C(a0)			; set destroying timer
		move.b	#8,obAnim(a0)
; ===========================================================================

Obj1F_NotGHZ1_WF:
		subq.w	#1,$30(a0)			; subtract 1 from time delay
		bpl.s	locret_95B6			; if it's not empty, branch
		tst.b	obRender(a0)				; is crabmeat on-screen?
		bpl.s	Obj1F_Move			; if not, branch
		bchg	#1,$32(a0)			; is normal crabmeat set to fire?
		bne.s	Obj1F_MakeFire			; if bit is set, branch

Obj1F_Move:
		addq.b	#2,ob2ndRout(a0)			; increase counter
		move.w	#10,$30(a0)			; set time delay to approx 10 frames
		move.w	#CMSpeed,obVelX(a0)		; move Crabmeat	to the right		
		cmpi.w	#$000,($FFFFFE10).w		; is level GHZ1?
		bne.s	Obj1F_NotGHZ1_Move		; if not, branch
		move.w	#50,$30(a0)			; set timer to 50
		move.w	#-$400,obVelX(a0)			; move Crabmeat	to the right (GHZ1 speed)
		
Obj1F_NotGHZ1_Move:
		jsr	obj1F_SetAni			; set correct anim
		addq.b	#3,d0				; add 3
		move.b	d0,obAnim(a0)			; set anim
		bchg	#0,obStatus(a0)			; change direction
		bne.s	locret_95B6			; if it's right, branch
		neg.w	obVelX(a0)				; negate speed

locret_95B6:
		rts					; return
; ===========================================================================

Obj1F_MakeFire:
		move.w	#$3B,$30(a0)			; set timer to $3B

Obj1F_MakeFire_2:
		move.b	#6,obAnim(a0)			; use firing animation
		move.w	#$C4,d0				; set sound
		jsr	(PlaySound_Special).l		; play exploding bomb sound

		bsr	SingleObjLoad			; load from SingleObjLoad
		bne.s	Obj1F_MakeFire2			; if it's in use, branch
		move.b	#$1F,0(a1)			; load left fireball
		move.b	#6,obRoutine(a1)		; set to fireball
		move.w	obX(a0),obX(a1)			; set X-pos
		subi.w	#$10,obX(a1)			; sub $10 from it
		move.w	obY(a0),obY(a1)			; set Y-pos
		move.w	#-$190,obVelX(a1)		; set normal X-speed
		move.b	#1,$31(a1)			; set split ball flag
		cmpi.w	#$000,($FFFFFE10).w		; is current level GHZ 1?
		bne.s	Obj1F_MakeFire2			; if not, branch
		move.w	#-$230,obVelX(a1)		; load GHZ1 X-speed

Obj1F_MakeFire2:
		bsr	SingleObjLoad2			; load from SingleObjLoad
		bne.s	locret_9618			; if it's in use, branch
		move.b	#$1F,0(a1)			; load right fireball
		move.b	#6,obRoutine(a1)		; set to fireball
		move.w	obX(a0),obX(a1)			; set X-pos
		addi.w	#$10,obX(a1)			; add $10 to it
		move.w	obY(a0),obY(a1)			; set Y-pos
		move.w	#$190,obVelX(a1)		; set normal X-speed
		move.b	#1,$31(a1)			; set split ball flag
		cmpi.w	#$000,($FFFFFE10).w		; is current level GHZ 1?
		bne.s	locret_9618			; if not, branch
		move.w	#$230,obVelX(a1)		; load GHZ1 X-speed

locret_9618:
		rts					; return
; ===========================================================================

Obj1F_WalkOnFloor:			; XREF: Obj1F_Index2
		subq.w	#1,$30(a0)			; sub 1 from timer
		bmi.w	loc_966E			; if it's empty, branch
		tst.b	obColType(a0)				; any touch response?
		bne.w	Obj1F_NotGHZ1_WFX		; if yes, branch
		tst.b	$3E(a0)				; is flashing timer empty?
		bne.s	loc_17F70XX			; if not, branch
		move.w	obX(a0),d1			; load X-pos to d1
		move.w	obY(a0),d2			; load Y-pos to d2
		sub.w	($FFFFD008).w,d1		; sub Sonic's X-pos from it
		sub.w	($FFFFD00C).w,d2		; sub Sonic's Y-pos from it
		jsr	(CalcAngle).l			; calc angle
		jsr	(CalcSine).l			; calc sine
		muls.w	#-$700,d1			; multiple it by -$700
		asr.l	#8,d1				; asl by 8
		sub.w	#$50,d1				; sub $50 from it
		move.w	d1,($FFFFD010).w		; bounce Sonic away
		muls.w	#-$700,d0			; multiple it by -$700
		asr.l	#8,d0				; asr by 8
		move.w	d0,($FFFFD012).w		; bounce Sonic away
		move.b	#$20,$3E(a0)			; set flashing timer
		move.w	#$AC,d0				; set sound
		jsr	(PlaySound_Special).l 		; play boss damage sound
		moveq	#100,d0		; add 1000 ...
		jsr	AddPoints	; ... points
		

loc_17F70XX:
		cmpi.b	#2,obColProp(a0)			; only having 2 lives left?
		bra.s	Obj1F_Flashing2			; if more, branch
		move.b	#4,ob2ndRout(a0)			; set to boss defeated
		move.w	#200,$3C(a0)			; set destroying timer
		move.b	#8,obAnim(a0)
		bra.w	Obj1F_BossDefeated		; branch
; ===========================================================================

Obj1F_Flashing2:
		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		beq.s	Obj1F_NoFlash2		; if not, no flash
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	Obj1F_NoFlash2		; if yes, don't do palette flashing to avoid seizues

		lea	($FFFFFB02).w,a1		; load second colour
		moveq	#0,d1				; make sure d1 is empty
		tst.w	(a1)				; is colour empty?
		bne.s	loc_17F7EXX			; if not, branch
		move.w	#$EEE,d1			; set flashing to white

loc_17F7EXX:
		move.w	d1,(a1)				; set colour

Obj1F_NoFlash2:
		subq.b	#1,$3E(a0)			; sub 1 from flashing timer
		bne.s	Obj1F_NotGHZ1_WFX		; if it isn't empty, branch
		move.b	#$F,obColType(a0)			; set normal touch response
	;	subq.b	#1,obColProp(a0)			; sub 1 from lives
	;	move.b	obColProp(a0),(HUD_BossHealth).w
		cmpi.b	#2,obColProp(a0)			; only having 2 lives left?
		bra.s	Obj1F_NotGHZ1_WFX		; if more, branch
		move.b	#4,ob2ndRout(a0)			; set to boss defeated
		move.w	#200,$3C(a0)			; set destroying timer
		move.b	#8,obAnim(a0)


Obj1F_NotGHZ1_WFX:
		bsr	SpeedToPos			; set position
		bchg	#0,$32(a0)			; unkown
		bne.s	loc_9654			; if bit is set, branch
		move.w	obX(a0),d3			; move X-pos to d3
		addi.w	#$10,d3				; add $10 to it
		btst	#0,obStatus(a0)			; test direction
		beq.s	loc_9640			; if it's left, branch
		subi.w	#$20,d3				; sub $20 from it

loc_9640:
		jsr	ObjHitFloor2			; load from ObjHitFloor2
		cmpi.w	#-8,d1				; is it -8 from that position?
		blt.s	loc_966E			; if anything below, branch
		cmpi.w	#$C,d1				; is it $C from that position?
		bge.s	loc_966E			; if anything above, branch
		rts					; return
; ===========================================================================

loc_9654:				; XREF: Obj1F_WalkOnFloor
		jsr	ObjHitFloor
		add.w	d1,obY(a0)
		move.b	d3,obAngle(a0)
		jsr	obj1F_SetAni
		addq.b	#3,d0
		move.b	d0,obAnim(a0)
		rts	
; ===========================================================================

loc_966E:				; XREF: Obj1F_WalkOnFloor
		subq.b	#2,ob2ndRout(a0)
		move.w	#10,$30(a0)
		jsr	obj1F_SetAni
		move.b	d0,obAnim(a0)
		rts		
; ---------------------------------------------------------------------------
; Subroutine to	set the	correct	animation for a	Crabmeat
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj1F_SetAni:				; XREF: loc_966E
		moveq	#0,d0
		move.b	obAngle(a0),d3
		bmi.s	loc_96A4
		cmpi.b	#6,d3
		bcs.s	locret_96A2
		moveq	#1,d0
		btst	#0,obStatus(a0)
		bne.s	locret_96A2
		moveq	#2,d0

locret_96A2:
		rts	
; ===========================================================================

loc_96A4:				; XREF: Obj1F_SetAni
		cmpi.b	#-6,d3
		bhi.s	locret_96B6
		moveq	#2,d0
		btst	#0,obStatus(a0)
		bne.s	locret_96B6
		moveq	#1,d0

locret_96B6:
		rts	
; End of function Obj1F_SetAni

; ===========================================================================

Obj1F_Delete:				; XREF: Obj1F_Index
		bsr	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sub-object - missile that the	Crabmeat throws
; ---------------------------------------------------------------------------
;===================================
;Balls on ground distance
; If a ball touched the ground,
; how big should the distance be?
; Standart = 5 pixels
CMBallsOnGroundDist = 5
;===================================

Obj1F_BallMain:				; XREF: Obj1F_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj1F,obMap(a0)
		move.w	#$400,obGfx(a0)		
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$87,obColType(a0)
		move.b	#8,obActWid(a0)
		move.b	#$FF,$30(a0)
		tst.b	obSubtype(a0)
		bne.s	Obj1F_NotGHZ1
		tst.b	$31(a0)		; is this the split ball?
		beq.s	Obj1F_NotGHZ1	; if ot, branch
		move.w	#-$550,obVelY(a0)
		cmpi.w	#$000,($FFFFFE10).w ; is current level GHZ 1?
		bne.s	Obj1F_NotGHZ1		; if not, branch
		move.w	#-$700,obVelY(a0)
		move.b	#$3E,$30(a0)
		
Obj1F_NotGHZ1:
		move.b	#7,obAnim(a0)
; ===========================================================================

Obj1F_BallMove:
		cmpi.w	#$000,($FFFFFE10).w ; is current level GHZ 1?
		bne.s	Obj1F_NotGHZ1_3		; if not, branch
		tst.b	($FFFFFFD5).w
		bne.w	Obj1F_Delete4

Obj1F_NotGHZ1_3:
		subq.b	#1,$30(a0)		; sub 1 from ball remaining life timer
		bls.w	Obj1F_BallExpired	; if expired, branch

		bsr	ObjectFall		; move the ball down

Obj1F_CheckBallOnGround:
		jsr	ObjHitFloor		; load from ObjHitFloor
		sub.w	#CMBallsOnGroundDist,d1	; sub 5 pixels from it (otherwise it would be stuck in the ground)
		tst.w	d1			; was this location passed by the ball?
		bpl.s	Obj1F_BallNotOnGround	; if not, branch
		bra.s	Obj1F_DestroyBall	; destroy the ball

Obj1F_BallNotOnGround:
		move.w	($FFFFF72E).w,d0	; load Y-limit of the act into d0
		addi.w	#$E0,d0			; add a little bit to it ($E0 = below the screen)
		cmp.w	obY(a0),d0		; has object moved below the level boundary?
		bcs.s	Obj1F_Delete2		; if yes, delete object
		
		lea	(Ani_obj1F).l,a1	; load the animation for the balls
		bsr	AnimateSprite		; animate them
		bsr	DisplaySprite		; show the ball (better said, don't delete it)		
		rts				; return
; ===========================================================================

Obj1F_Delete2:
		bra.w	DeleteObject		; delete ball object
; ===========================================================================

Obj1F_DestroyBall:
		tst.b	obSubtype(a0)
		bne.w	Obj1F_Delete4
		bsr	SingleObjLoad		; load from SingleObjLoad
		bne.s	Obj1F_Delete2		; if it's in use, branch
		move.b	#$3F,0(a1)		; explosion object
		move.w	obX(a0),obX(a1)		; set X-location
		move.w	obY(a0),obY(a1)		; set Y-location
		move.b	#2,obRoutine(a1)	; only load one explosion per ball to avoid sprite flicker
		move.b	#0,$31(a1)

		cmpi.w	#$000,($FFFFFE10).w ; is current level GHZ 1?
		bne.s	Obj1F_NotGHZ1_2
		tst.b	$31(a0)			; is this the split ball?
		beq.w	Obj1F_Delete2		; if not, delete it right away
		tst.b	obRender(a0)
		bpl.w	Obj1F_Delete2

		moveq	#0,d0
		move.w	obVelY(a0),d0
		tst.w	d0
		bpl.s	Obj1F_SpeedPosi
		sub.w	#$40,d0
Obj1F_SpeedPosi
		add.w	#$20,d0
		neg.w	d0
		move.w	d0,obVelY(a0)
		rts

Obj1F_NotGHZ1_2:
		tst.w	obVelX(a0)			; is X-speed negative?
		bmi.s	Obj1F_MoveLeft		; if yes, branch
		sub.w	#$20,obVelX(a0)		; move ball to the right
		bra.s	Obj1F_MoveUp		; branch

Obj1F_MoveLeft:
		add.w	#$20,obVelX(a0)		; move ball to the left
		
Obj1F_MoveUp:
		move.w	#-$450,obVelY(a0)		; move ball upwards
	;	rts				; return
; ===========================================================================

Obj1F_BallExpired:
		cmpi.w	#$000,($FFFFFE10).w	; are we in GHZ1?
		bne.s	Obj1F_Delete4		; if not, just turn into explosion
		tst.b	$31(a0)			; is this the split ball?
		beq.s	Obj1F_Delete4		; if not, just turn into explosion

		; split ball
		moveq	#4-1,d1			; load 4 balls
		lea	(Obj1F_BallSpeeds).l,a2
		frantic
		beq.s	@loadballs
		addq.b	#2,d1			; add more balls
@loadballs:
		bsr	SingleObjLoad		; load from SingleObjLoad
		bne.s	Obj1F_Delete4		; if it's in use, branch
		move.b	#$1F,0(a1)		; load another ball
		move.b	#6,obRoutine(a1)
		move.w	obX(a0),obX(a1)		; set X-location
		move.w	obY(a0),obY(a1)		; set Y-location
		move.w	(a2)+,obVelX(a1)	; set X speed for current ball
		move.w	(a2)+,obVelY(a1)	; set Y speed for current ball
		clr.b	$31(a1)
		dbf	d1,@loadballs		; loop till all balls are done

		bra.s	Obj1F_Delete4		; turn current ball into explosion
; ===========================================================================
Obj1F_BallSpeeds:
		dc.w -$0200, -$0400
		dc.w -$00C0, -$0450
		dc.w  $00C0, -$0450
		dc.w  $0200, -$0400
		
		; frantic only
		dc.w -$0400, -$0600
		dc.w  $0400, -$0600
		even
; ===========================================================================

Obj1F_Delete4:
		move.b	#$3F,0(a0)		; change ball into explosion object
		move.b	#0,obRoutine(a0)
		move.b	#0,$31(a0)
		rts
; ===========================================================================
Ani_obj1F:
		include	"_anim\obj1F.asm"	; animation script for the Crabmeat
; ---------------------------------------------------------------------------
; Sprite mappings - Crabmeat enemy (GHZ, SYZ)
; ---------------------------------------------------------------------------
Map_obj1F:
		include	"_maps\obj1F.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 22 - Buzz Bomber enemy	(GHZ, MZ, SYZ)
; ---------------------------------------------------------------------------
;===================================
;Delay
; The delay for the buzz bomber
; before he fires a missle
BBDelay = 50
;===================================
;Speed
; The speed for the buzz bomber
BBSpeed = $400
;-----------------------------------
; The speed for the missile
BBMissileSpeedX = $370
BBMissileSpeedY = $600
;===================================
;Exploding sound
; 0 - Disbled
; 1 - Enabled
ExplodingSound = 1
;===================================

Obj22:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj22_Index(pc,d0.w),d1
		jmp	Obj22_Index(pc,d1.w)
; ===========================================================================
Obj22_Index:	dc.w Obj22_Main-Obj22_Index
		dc.w Obj22_Action-Obj22_Index
		dc.w Obj22_Delete-Obj22_Index
; ===========================================================================

Obj22_Main:				; XREF: Obj22_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj22,obMap(a0)
		move.w	#$444,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
	;	move.b	#8,obColType(a0)
		move.b	#$18,obActWid(a0)
		move.b	#20,$32(a0)
		
		clr.l	$36(a0)
		cmpi.w	#$001,($FFFFFE10).w
		beq.s	Obj22_Action
		move.w	obX(a0),$36(a0)	; remember original X position
		move.w	obY(a0),$38(a0)	; remember original Y position

Obj22_Action:				; XREF: Obj22_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj22_Index2(pc,d0.w),d1
		jsr	obj22_Index2(pc,d1.w)
		lea	(Ani_obj22).l,a1
		bsr.w	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj22_Index2:	dc.w Obj22_Move-Obj22_Index2
		dc.w Obj22_ChkNrSonic-Obj22_Index2
; ===========================================================================

Obj22_Move:				; XREF: Obj22_Index2
		cmpi.w	#$001,($FFFFFE10).w	; is level GHZ2 (intro cutscene)?
		bne.w	Obj22_NotGHZ2		; if not, branch
		cmpi.w	#$1240,obX(a0)		; was location $1240 passed by the bomber? (the second alternate move before the spikes (first one is the forward moving))
		bpl.s	Obj22_MoveBuzzDown	; if yes, branch
		move.b	$3F(a0),d0		; ^ make buzz bomber hovering
		jsr	(CalcSine).l		; | copied
		asr.w	#5,d0			; | from
		add.w	$38(a0),d0		; | Obj3D
		move.w	d0,obY(a0)		; | (GHZ-boss)
		addq.b	#2,$3F(a0)		; v
		add.w	#$142,obY(a0)		; for some reason, I gotta bring the buzz bomber down a little bit manually
		bra.s	Obj22_DontMoveDown	; skip
; ===========================================================================

Obj22_MoveBuzzDown:
		add.w	#1,obY(a0)		; make buzz bomber move a little bit downwarsd step by step

Obj22_DontMoveDown:
		cmpi.w	#$1331,obX(a0)		; was location $1331 passed by the bomber? (location of the spikes)
		bmi.s	Obj22_SpikesNotPassed	; if not, branch
		move.b	#4,obRoutine(a0)		; set buzz bomber to get deleted
		bsr	SingleObjLoad		; load from SingleObjLoad
		bne.w	Obj22_Return		; if it's in use, just branch
		move.b	#$3F,0(a1)		; load explosion object
		move.w	obX(a0),obX(a1)		; set X-pos to the buzz bomber's one
		move.w	obY(a0),obY(a1)		; set Y-pos to the buzz bomber's one
		move.b	#0,$31(a1)
		move.b	#1,($FFFFFFD8).w	; set flag for other purposes that the buzz bomber has been destroyed (like camera)
		rts				; return
; ===========================================================================

Obj22_SpikesNotPassed:
		moveq	#0,d0			; make sure d0 is empty
		move.w	($FFFFD008).w,d0	; move Sonic's X-pos to d0
		sub.w	#$78,d0			; substract $78 from it
		sub.w	$30(a0),d0		; substract the number in $30(a0) from it (look at Obj22_ReturnXX)
		move.w	d0,obX(a0)		; set new location for the buzz bomber
		bset	#0,obStatus(a0)		; make buzz bomber facing right, constantly
		tst.b	($FFFFFFB4).w		; has Sonic touched the first spring yet?
		beq.w	Obj22_Return		; if not, branch
		subq.b	#1,$32(a0)		; substract 1 from shooting delay
		bpl.s	Obj22_Return		; if time remains, branch
		bsr.w	SingleObjLoad		; load from SingleObjLoad
		bne.s	Obj22_SOLFail		; if it's in use, branch
		move.b	#$23,0(a1)		; load missile object
		move.w	obX(a0),obX(a1)		; set X-pos to the buzz bomber's one
		move.w	obY(a0),obY(a1)		; set Y-pos to the buzz bomber's one
		addi.w	#$1C,obY(a1)		; additionaly add $1C to that position
		move.w	#$400,obVelY(a1)		; move missile downwards
		move.w	#$C00,obVelX(a1)		; move missile to the right
		move.l	a0,$3C(a1)		; make missles getting removed when buzz bomber is getting destroyed

Obj22_SOLFail:
		move.b	#20,$32(a0)		; reset shooting timer
		cmpi.w	#$0F74,obX(a0)		; was location $0F74 passed by the bomber? (some location before the spikes)
		bmi.s	Obj22_Return		; if not, branch
		subq.w	#4,$30(a0)		; substract 4 from $30(a0) (make buzz bomber move a little bit forward each step)

Obj22_Return:
		rts				; return
; ===========================================================================
; ===========================================================================
; ===========================================================================

Obj22_NotGHZ2:
		tst.b	($FFFFFFB9).w		; is white flash flag set? (aka, falling into the teleporting pit)
		beq.s	@noresetposition	; if not, branch
		move.w	$36(a0),obX(a0)		; restore original X position
		move.w	$38(a0),obY(a0)		; restore original Y position

@noresetposition:
		tst.b	($FFFFFFB1).w		; is inhuman crush timer filled?
		bmi.s	Obj22_NotInhumanCrush	; if not, branch
		tst.b	obRender(a0)			; is buzz bomber on-screen?
		bpl.b	Obj22_NotInhumanCrush	; if not, branch
		move.b	#4,obRoutine(a0)		; set buzz bomber to delete
		bsr	SingleObjLoad		; load from SingleObjLoad
		bne.s	Obj22_NotInhumanCrush	; if it is in use, branch
		move.b	#$3F,0(a1)		; load explosion object
		move.w	obX(a0),obX(a1)		; set X-pos to the explosion's one
		move.w	obY(a0),obY(a1)		; set Y-pos to the explosion's one
		move.b	#0,$31(a1)

Obj22_NotInhumanCrush:
	
		; Night Hill Place waterfall buzzbombers
		move.b	#0,obColType(a0)	; make the buzz bomber not destroyable
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	Obj22_NotGHZ1		; if not, branch
		move.w	#$0444,obGfx(a0)	; use default palette line
		cmpi.w	#$13C0,obX(a0)		; is buzz bomber before $13C0?
		bmi.s	Obj22_NotGHZ1		; if yes, branch
		cmpi.w	#$1800,obX(a0)		; is buzz bomber after $1800?
		bpl.s	Obj22_NotGHZ1		; if yes, branch
		
		; buzz bomber is in waterfall section
		move.b	#0,obColType(a0)	; make the buzz bomber not destroyable
		move.b	($FFFFFE05).w,d0
		btst	#1,d0			; every other pair of frames
		beq.s	@0
		move.w	#$6444,obGfx(a0)	; use fourth palette line
		btst	#0,d0			; every third frame
		beq.s	@0
		move.w	#$2444,obGfx(a0)	; use second palette line
@0:
	;	frantic				; are we in Frantic mode?
	;	beq.w	Obj22_MoveEnd		; if not, disable movement
		
		tst.b	($FFFFFE2D).w		; is sonic invincible?
		bne.s	Obj22_NotGHZ1		; if yes, make buzz bombers deststroyable
		bra.s	Obj22_NotHigher		; otherwise, these bad boys are vincible (is that a word?)
; ===========================================================================

Obj22_NotGHZ1:
		move.b	#8,obColType(a0)	; make buzz bomber destroyable

Obj22_NotHigher:
		tst.w	($FFFFFE08).w		; is debug mode	on?
		bne.w	Obj22_Return3		; if yes, make buzz bomber ignore you

		moveq	#0,d0			; clear d0
		move.w	($FFFFD008).w,d0	; move Sonic's X-pos to d0
		sub.w	obX(a0),d0		; substract the one from the buzz bomber from it
		bpl.s	Obj22_MoveRight		; is it positive? branch
		sub.w	#1,obX(a0)		; move buzz bomber to the left
		bclr	#0,obStatus(a0)		; make it facing left
		bra.s	Obj22_ChkUpDown		; skip
; ===========================================================================

Obj22_MoveRight:
		bset	#0,obStatus(a0)		; otherwise make it facing right
		add.w	#1,obX(a0)		; move it to the right

Obj22_ChkUpDown:
		move.w	($FFFFD00C).w,d0	; move Sonic's Y-pos to d0
		sub.w	obY(a0),d0		; substract the one from the buzz bomber from it
		bpl.s	Obj22_MoveDown		; is it positive? branch
		sub.w	#1,obY(a0)		; move buzz bomber upwards
		bra.s	Obj22_MoveEnd		; skip
; ===========================================================================

Obj22_MoveDown: 
		add.w	#1,obY(a0)		; otherwise make buzz bomber moving downwards
; ---------------------------------------------------------------------------

Obj22_MoveEnd:
		moveq	#0,d0			; clear d0
		moveq	#0,d1			; clear d1
		move.w	obX(a0),d0		; load object's X pos
		sub.w	($FFFFD008).w,d0	; minus sonic's X pos from it
		bpl.w	Obj22_XChk		; if answer is positive, branch
		neg.w	d0			; negate d0

Obj22_XChk:
		cmpi.w	#$15,d0			; is sonic within $15 pixels of the object?
		bge.w	Obj22_End		; if not, branch

		move.w	obY(a0),d1		; load object's Y pos
		sub.w	($FFFFD00C).w,d1	; minus sonic's Y pos from it
		bpl.w	Obj22_YChk		; if answer is positive, branch
		neg.w	d1			; negate d1

Obj22_YChk:
		cmpi.w	#$15,d1			; is sonic within $15 pixels of the object?
		bge.w	Obj22_End		; if not, branch
	;	bsr	BossDefeated3		; load random explosion (harmful)

		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	Obj22_Return2
		bsr	SingleObjLoad
		bne.s	Obj22_Return2
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)
	;	move.b	#1,$30(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,obY(a1)

Obj22_Return2:
		rts				; return
; ===========================================================================

Obj22_End:
		move.b	#1,obAnim(a0)		; use "firing" animation throughout
		btst	#0,obStatus(a0)		; is Buzz Bomber facing	left?
		bne.s	Obj22_Return3		; if not, branch
		neg.w	obVelX(a0)			; move Buzz Bomber to the left

Obj22_Return3:
		rts				; return
; ===========================================================================

Obj22_Fire:				; XREF: Obj22_Move
	if ExplodingSound=1
		move.w	#$C4,d0
		jsr	(PlaySound_Special).l ;	play exploding bomb sound
	endif
		bsr.w	SingleObjLoad			; load from SingleObjLoad
		bne.s	locret_98D0			; if it's already in use, don't do anything
		move.b	#$23,0(a1)			; load missile object
		move.w	obX(a0),obX(a1)			; at Sonic's X-pos
		move.w	obY(a0),obY(a1)			; at Sonic's Y-pos
		addi.w	#$1C,obY(a1)			; a little bit lower
		move.w	#BBMissileSpeedX,obVelX(a1)	; X-speed for missile
		move.w	#BBMissileSpeedY,obVelY(a1)	; Y-speed for missile
		move.w	#$18,d0				; a little bit to the right, preperation
		btst	#0,obStatus(a0)			; is Buzz Bomber facing	left?
		bne.s	loc_98AA			; if not, branch
		neg.w	d0				; negate this "to the right thing" for "to the left"
		neg.w	obVelX(a1)				; negate X-speed for missile
loc_98AA:
		add.w	d0,obX(a1)			; a little bit to the left/right

		move.w	#$E,$32(a1)
		move.l	a0,$3C(a1)
		move.b	#1,$34(a0)	; set to "already fired" to prevent refiring
		move.w	#$3B,$32(a0)
		move.b	#2,obAnim(a0)	; use "firing" animation

locret_98D0:
		rts	
; ===========================================================================

Obj22_ChkNrSonic:			; XREF: Obj22_Index2
		subq.w	#1,$32(a0)	; subtract 1 from time delay
		bmi.s	Obj22_ChgDir
		bsr.w	SpeedToPos
		tst.b	$34(a0)
		bne.s	locret_992A
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bpl.s	Obj22_SetNrSonic
		neg.w	d0

Obj22_SetNrSonic:
		cmpi.w	#$60,d0		; is Buzz Bomber within	$60 pixels of Sonic?
		bcc.s	locret_992A	; if not, branch
		tst.b	obRender(a0)
		bpl.s	locret_992A
		move.b	#2,$34(a0)	; set Buzz Bomber to "near Sonic"
		move.w	#0,$32(a0)	; set time delay to half a second 29
		bra.s	Obj22_Stop
; ===========================================================================

Obj22_ChgDir:				; XREF: Obj22_ChkNrSonic
		move.b	#0,$34(a0)	; set Buzz Bomber to "normal"
		bchg	#0,obStatus(a0)	; change direction
		move.w	#10,$32(a0)
	
Obj22_Stop:				; XREF: Obj22_SetNrSonic
		subq.b	#2,ob2ndRout(a0)	; run "Obj22_Fire" routine
	;	move.w	#0,obVelX(a0)	; stop Buzz Bomber moving
		move.b	#2,obAnim(a0)	; use "hovering" animation

locret_992A:
		rts	
; ===========================================================================

Obj22_Delete:				; XREF: Obj22_Index
		bsr.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 23 - missile that Buzz	Bomber throws + Inhuman Mode bullets
; ---------------------------------------------------------------------------

Obj23:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj23_Index(pc,d0.w),d1
		jmp	Obj23_Index(pc,d1.w)
; ===========================================================================
Obj23_Index:	dc.w Obj23_Main-Obj23_Index
		dc.w Obj23_Animate-Obj23_Index
		dc.w Obj23_FromBuzz-Obj23_Index
		dc.w Obj23_Delete-Obj23_Index
		dc.w Obj23_FromNewt-Obj23_Index
; ===========================================================================

Obj23_Main:				; XREF: Obj23_Index
		move.b	#30,$30(a0)	; set time limit
		subq.w	#1,$32(a0)
		bpl.s	Obj23_ChkCancel
		addq.b	#4,obRoutine(a0)
		move.l	#Map_obj23,obMap(a0)
		move.w	#($D700/$20),obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#8,obActWid(a0)
		andi.b	#3,obStatus(a0)
		tst.b	obSubtype(a0)		; was object created by	a Newtron?
		beq.s	Obj23_Animate	; if not, branch
		move.b	#8,obRoutine(a0)	; run "Obj23_FromNewt" routine
		move.b	#$87,obColType(a0)
		move.b	#1,obAnim(a0)
		bra.w	Obj23_Animate2
; ===========================================================================

Obj23_Animate:				; XREF: Obj23_Index
		bsr.s	Obj23_ChkCancel
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		move.b	#4,obRoutine(a0)		
		rts
; ---------------------------------------------------------------------------
; Subroutine to	check if the Buzz Bomber which fired the missile has been
; destroyed, and if it has, then cancel	the missile
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj23_ChkCancel:			; XREF: Obj23_Main
		movea.l	$3C(a0),a1
		cmpi.b	#$27,0(a1)	; has Buzz Bomber been destroyed?
		beq.w	Obj23_Delete	; if yes, branch
		rts
; End of function Obj23_ChkCancel		
; ===========================================================================

Obj23_FromBuzz:				; XREF: Obj23_Index
		cmpi.w	#$0502,($FFFFFE10).w
		bne.w	@Check2

		jsr 	ObjectFall
		bra.s 	@Continue

@Check2:
		cmpi.w	#$001,($FFFFFE10).w
		bne.w	Obj23_FromBuzz_Normal

@Continue
		subq.b	#1,$30(a0)	; sub 1 from time limit
		bmi.w	Obj23_Explode	; if there's no time left, branch
		moveq	#0,d1
		jsr	ObjHitFloor		; load from ObjHitFloor
		sub.w	#5,d1			; sub 5 pixels from it (otherwise it would be stuck in the ground)
		tst.w	d1			; was this location passed by the ball?
		bpl.s	Obj23_BallNotOnGround	; if yes, branch

Obj23_DestroyBall:
		bsr	SingleObjLoad		; load from SingleObjLoad
		bne.w	Obj23_Delete		; if it's in use, branch
		move.b	#$3F,0(a1)		; explosion object
		move.w	obX(a0),obX(a1)		; set X-location
		move.w	obY(a0),obY(a1)		; set Y-location
		move.b	#0,$31(a1)
		
		bra.w	Obj23_Delete		; delete ball object
; ===========================================================================

Obj23_BallNotOnGround:
		btst	#7,obStatus(a0)
		bne.w	Obj23_Explode
		move.b	#$87,obColType(a0)
		move.b	#1,obAnim(a0)
		bsr	SpeedToPos
		lea	(Ani_obj23).l,a1
		bsr	AnimateSprite
		bsr	DisplaySprite
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	obY(a0),d0	; has object moved below the level boundary?
		bcs.w	Obj23_Delete	; if yes, branch
		rts	
; ===========================================================================

Obj23_FromBuzz_Normal:
		subq.b	#1,$30(a0)	; sub 1 from time limit
		bmi.w	Obj23_Explode	; if there's no time left, branch
		move.b	#1,obAnim(a0)
		btst	#7,obStatus(a0)
		bne.w	Obj23_Explode
		move.b	#$87,obColType(a0)
		bsr.w	SpeedToPos
		lea	(Ani_obj23).l,a1
		bsr.w	AnimateSprite
		bsr.w	DisplaySprite
		
 		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0		; <-- Distance out of screen
		bhi.w	DeleteObject

		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	obY(a0),d0	; has object moved below the level boundary?
		bcs.s	Obj23_Delete	; if yes, branch
		rts
; ===========================================================================

Obj23_Explode:				; XREF: Obj23_FromBuzz
		ori.b	#10,(CameraShake).w		; camera shaking

		bsr	SingleObjLoad
		bne.s	Obj23_NoExplode
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		bsr	DeleteObject

Obj23_NoExplode:
		rts
; ===========================================================================

Obj23_Delete:				; XREF: Obj23_Index
		bsr	DeleteObject
		rts	
; ===========================================================================

Obj23_FromNewt:				; XREF: Obj23_Index
		tst.b	obRender(a0)
		bpl.s	Obj23_Delete
		bsr	SpeedToPos

Obj23_Animate2:				; XREF: Obj23_Main
		lea	(Ani_obj23).l,a1
		bsr	AnimateSprite
		bsr	DisplaySprite
		rts	
; ===========================================================================
Ani_obj22:
		include	"_anim\obj22.asm"

Ani_obj23:
		include	"_anim\obj23.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Buzz Bomber	enemy
; ---------------------------------------------------------------------------
Map_obj22:
		include	"_maps\obj22.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - missile that Buzz Bomber throws
; ---------------------------------------------------------------------------
Map_obj23:
		include	"_maps\obj23.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 25 - rings
; ---------------------------------------------------------------------------

Obj25:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj25_Index(pc,d0.w),d1
		jmp	Obj25_Index(pc,d1.w)
; ===========================================================================
Obj25_Index:	dc.w Obj25_Main-Obj25_Index
		dc.w Obj25_Animate-Obj25_Index
		dc.w Obj25_Collect-Obj25_Index
		dc.w Obj25_Sparkle-Obj25_Index
		dc.w Obj25_Delete-Obj25_Index
; ---------------------------------------------------------------------------
; Distances between rings (format: horizontal, vertical)
; ---------------------------------------------------------------------------
Obj25_PosData:	dc.b $10, 0		; horizontal tight
		dc.b $18, 0		; horizontal normal
		dc.b $20, 0		; horizontal wide
		dc.b 0,	$10		; vertical tight
		dc.b 0,	$18		; vertical normal
		dc.b 0,	$20		; vertical wide
		dc.b $10, $10		; diagonal
		dc.b $18, $18
		dc.b $20, $20
		dc.b $F0, $10
		dc.b $E8, $18
		dc.b $E0, $20
		dc.b $10, 8
		dc.b $18, $10
		dc.b $F0, 8
		dc.b $E8, $10
; ===========================================================================

Obj25_Main:				; XREF: Obj25_Index
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		lea	obGfx(a2,d0.w),a2
		move.b	(a2),d4
		move.b	obSubtype(a0),d1
		move.b	d1,d0
		andi.w	#7,d1
		cmpi.w	#7,d1
		bne.s	loc_9B80
		moveq	#6,d1

loc_9B80:
		swap	d1
		move.w	#0,d1
		lsr.b	#4,d0
		add.w	d0,d0
		move.b	Obj25_PosData(pc,d0.w),d5 ; load ring spacing data
		ext.w	d5
		move.b	Obj25_PosData+obRender(pc,d0.w),d6
		ext.w	d6
		movea.l	a0,a1
		move.w	obX(a0),d2
		move.w	obY(a0),d3
		lsr.b	#1,d4
		bcs.s	loc_9C02
		bclr	#7,(a2)
		bra.s	loc_9BBA
; ===========================================================================

Obj25_MakeRings:
		swap	d1
		lsr.b	#1,d4
		bcs.s	loc_9C02
		bclr	#7,(a2)
		bsr	SingleObjLoad
		bne.s	loc_9C0E

loc_9BBA:				; XREF: Obj25_Main
		move.b	#$25,0(a1)	; load ring object
		addq.b	#2,obRoutine(a1)
		move.w	d2,obX(a1)	; set x-axis position based on d2
		move.w	obX(a0),$32(a1)
		move.w	d3,obY(a1)	; set y-axis position based on d3
		move.l	#Map_obj25,obMap(a1)
		move.w	#$27B2,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#2,obPriority(a1)
		move.b	#$47,obColType(a1)
		move.b	#8,obActWid(a1)
		move.b	obRespawnNo(a0),obRespawnNo(a1)
		move.b	d1,$34(a1)

loc_9C02:
		addq.w	#1,d1
		add.w	d5,d2		; add ring spacing value to d2
		add.w	d6,d3		; add ring spacing value to d3
		swap	d1
		dbf	d1,Obj25_MakeRings ; repeat for	number of rings

loc_9C0E:
		btst	#0,(a2)
		bne.w	DeleteObject
; ---------------------------------------------------------------------------

Obj25_Animate:				; XREF: Obj25_Index
		tst.b	($FFFFFE2C).w		; do we have a shield?
		beq.s	Obj25_NoRingMove	; if not, branch
		bsr	AttractedRing_Check	; check if we're near enough for attraction
		tst.b	$29(a0)			; test flag
		beq.s	Obj25_NoRingMove	; if it wasn't set, we weren't near enough
		move.b	#$37,0(a0)		; change ring object to bouncing ring object, to give this decent effect
		move.b	#2,obRoutine(a0)	; make sure the ring just bounces, we don't want to loose 10 rings
		move.b	#1,$29(a0)		; set attraction flag
		bsr.s	Obj25_MarkGone		; make sure ring doesn't respawn (if it moves offscreen, tough luck buddy)
 
 Obj25_NoRingMove:
		move.b	($FFFFFEC3).w,obFrame(a0) ;	set frame

		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj25_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj25_Collect:				; XREF: Obj25_Index
		addq.b	#2,obRoutine(a0)
		moveq	#10,d0		; add 100 ...
		jsr	AddPoints	; ... points
		move.b	#0,obColType(a0)
		move.b	#1,obPriority(a0)
		bsr	CollectRing
		bsr.s	Obj25_MarkGone

Obj25_Sparkle:				; XREF: Obj25_Index
		lea	(Ani_obj25).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj25_MarkGone:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		move.b	$34(a0),d1
		bset	d1,obGfx(a2,d0.w)
		rts
; ===========================================================================

Obj25_Delete:				; XREF: Obj25_Index
		bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


CollectRing:				; XREF: Obj25_Collect
		addq.w	#1,($FFFFFE20).w ; add 1 to rings
		ori.b	#1,($FFFFFE1D).w ; update the rings counter
		move.w	#$B5,d0		; play ring sound
		jmp	(PlaySound_Special).l

LoseRing:
		subq.w	#1,($FFFFFE20).w ; sub 1 from rings
		bpl.s	@0
		move.w	#0,($FFFFFE20).w ; prevent underflow
@0:
		ori.b	#1,($FFFFFE1D).w ; update the rings counter
		move.w	#$A9,d0		; play blip sound
		jmp	(PlaySound_Special).l
; End of function CollectRing


; ---------------------------------------------------------------------------
; Subroutine to move a ring to Sonic's position
; ---------------------------------------------------------------------------
;=============================================
;Speed for the rings, once they are moving
AttractedRing_Speed = 3
;=============================================
;Required distance for a ring to get attracted
AttractedRing_Dist = $60
;=============================================

AttractedRing_Check:
		move.w	obX(a0),d0		; load object's X pos
		sub.w	($FFFFD008).w,d0	; minus sonic's X pos from it
		bpl.w	Ring_XChk		; if answer is possitive, branch
		neg.w	d0			; reverse d0
Ring_XChk:	cmpi.w	#AttractedRing_Dist,d0	; is sonic within XX pixels of the ring?
		bge.s	NoRingMove		; if not, branch

		move.w	obY(a0),d1		; load object's Y pos
		sub.w	($FFFFD00C).w,d1	; minus sonic's Y pos from it
		bpl.w	Ring_YChk		; if answer is possitive, branch
		neg.w	d1			; reverse d1
Ring_YChk:	cmpi.w	#AttractedRing_Dist,d1	; is sonic within XX pixels of the object?
		bge.s	NoRingMove		; if not, branch

		move.b	#1,$29(a0)		; set attraction flag

NoRingMove:
		rts
; ===========================================================================

AttractedRing_Move:
		move.w	($FFFFD008).w,d1	; load Sonic's X-pos into d1
		sub.w	obX(a0),d1		; sub ring's X-pos from it
		move.w	($FFFFD00C).w,d2	; load Sonic's Y-pos into d2
		sub.w	obY(a0),d2		; sub ring's Y-pos from it
		jsr	CalcAngle		; calculate the angle
		jsr	CalcSine		; calculate the sine
		asl.w	#AttractedRing_Speed,d0
		asl.w	#AttractedRing_Speed,d1
		
		move.w	d1,obVelX(a0)		; move the final calculated speed to ring's Y-speed
		move.w	d0,obVelY(a0)		; move the final calculated speed to ring's Y-speed
		jmp	SpeedToPos		; let SpeedToPos do the rest
; End of function AttractedRing_Move

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 37 - rings flying out of Sonic	when he's hit
; ---------------------------------------------------------------------------
BouncyRingValue = $288
; ---------------------------------------------------------------------------

Obj37:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj37_Index(pc,d0.w),d1
		jmp	Obj37_Index(pc,d1.w)
; ===========================================================================
Obj37_Index:	dc.w Obj37_CountRings-Obj37_Index
		dc.w Obj37_MainLoop-Obj37_Index
		dc.w Obj37_Collect-Obj37_Index
		dc.w Obj37_Sparkle-Obj37_Index
		dc.w Obj37_Delete-Obj37_Index
; ===========================================================================

Obj37_CountRings:			; XREF: Obj37_Index
		movea.l	a0,a1		; no need to load in one more ring when the current object already is one
		move.w	#BouncyRingValue,d4	; used for the bouncy angle

		moveq	#6,d5		; set ring bounce count to 6 for destroyed objects
		tst.b	$35(a0)		; was object loaded by destroying a monitor or badnik?
		bne.s	Obj37_Start	; if yes, branch

		move.w	($FFFFFE20).w,d5 ; use number of rings you got as amount
		cmpi.w	#16,d5		; do you have 16 rings or more?
		bcs.s	Obj37_Start	; if not, branch
		moveq	#16,d5		; if yes, set d5 to 16
Obj37_Start:	subq.w	#1,d5		; adjusgt for loop
		bra.s	Obj37_MakeRings
; ===========================================================================

Obj37_Loop:
		bsr	SingleObjLoad
		bne.w	Obj37_ResetCounter

Obj37_MakeRings:			; XREF: Obj37_CountRings
		move.b	#$37,0(a1)	; load another bouncing ring object
		addq.b	#2,obRoutine(a1)
		move.b	#8,obHeight(a1)
		move.b	#8,obWidth(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.l	#Map_obj25,obMap(a1)
		move.w	#$27B2,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#3,obPriority(a1)
		move.b	#$47,obColType(a1)
		move.b	#8,obActWid(a1)
		move.w	#$FF,$30(a1)		; despawn timer
		move.b	#0,$36(a1)
		move.b	#0,$29(a1)

		tst.b	$35(a0)			; was object loaded by destroying a monitor or badnik?
		bne.s	@calcmultibounce	; if yes, branch
		cmpi.w	#1,($FFFFFE20).w	; have you lost exactly 1 ring?
		bne.s	@calcmultibounce	; if not, branch
		clr.w	obVelX(a1)		; force single lost ring to fly straight up without any horizontal movement
		move.w	#-$480,obVelY(a1)
		bra.s	Obj37_ResetCounter

@calcmultibounce:
		tst.w	d4
		bmi.s	loc_9D62
		move.w	d4,d0
		jsr	CalcSine
		move.w	d4,d2
		lsr.w	#8,d2
		asl.w	d2,d0
		asl.w	d2,d1
		move.w	d0,d2
		move.w	d1,d3
		addi.b	#$10,d4
		bcc.s	loc_9D62
		subi.w	#$80,d4
		bcc.s	loc_9D62
		move.w	#BouncyRingValue,d4
loc_9D62:	move.w	d2,obVelX(a1)
		move.w	d3,obVelY(a1)
		neg.w	d2
		neg.w	d4
		dbf	d5,Obj37_Loop		; repeat for number of rings (max 10)

Obj37_ResetCounter:
		move.b	#-1,($FFFFFEC6).w	; Move d0 to old timer (for animated purposes)

		tst.b	$35(a0)			; was object loaded by destroying a monitor or badnik?
		bne.s	Obj37_MainLoop		; if yes, skip ring loss
		moveq	#0,d0			; set new rings to 0
		move.w	($FFFFFE20).w,d1	; move current rings to d1
		cmpi.w	#20,d1			; do you have at least 20 rings?
		bls.s	@setnewrings		; if less than 20, branch
		subi.w	#20,d1		 	; substract 20 of rings you have
		move.w	d1,d0			; move new rings to d0
@setnewrings:	move.w	d0,($FFFFFE20).w	; update rings
		ori.b	#1,($FFFFFE1D).w 	; update ring counter	
		move.w	#$C6,d0			; move $C6 to d0
		jsr	(PlaySound_Special).l 	; play ring loss sound
; ---------------------------------------------------------------------------

Obj37_MainLoop:				; XREF: Obj37_Index
		move.b	($FFFFFEC7).w,obFrame(a0)	; update frame (custom frame timer)
	;	move.b	($FFFFFEC3).w,obFrame(a0)	; update frame (Obj25)

		tst.b	$29(a0)			; was ring already set to follow you?
		bne.s	@continueattract	; if yes, branch
		tst.b	($FFFFFE2C).w		; is Sonic having a shield?
		beq.s	Obj37_NoRingsMove	; if not, branch
		cmpi.w	#$100,$30(a0)		; is it a very high despawn timer?
		bhs.s	@moveanyway		; if yes, move anyway
		cmpi.w	#$FF-20,$30(a0)		; bit of delay before...
		bhi.s	Obj37_NoRingsMove	; ...collecting rings of smashed objects
@moveanyway:	bsr	AttractedRing_Check
		bra.s	Obj37_NoRingsMove
@continueattract:
		tst.b	($FFFFFE2C).w		; is Sonic still having a shield?
		beq.s	Obj37_NoRingsMove	; if not, branch
		bsr	AttractedRing_Move	; move the ring
		bra.w	Obj37_ChkDel

Obj37_NoRingsMove:
		; ceiling limitation in mini boss arenas
		cmpi.w	#$301,($FFFFFE10).w	; is level SLZ2?
		bne.s	@notslz			; if not, branch
		tst.b	($FFFFFFA9).w		; is Sonic fighting against the walking bomb?
		beq.s	@notslz			; if not, branch	
		move.w	#$308,d1		; set ceiling height
		bra.s	@checkceiling
@notslz:	cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	@noceiling		; if not, branch
		cmpi.b	#1,($FFFFFFAA).w	; is Sonic fighting against the crabmeat?
		bne.s	@noceiling		; if not, branch
		move.w	#$440,d1		; set ceiling height
@checkceiling:	move.w	obY(a0),d0		; get Y position of ring
		cmp.w	d1,d0			; is it above Y pos? (ceiling position of the arena)
		bge.s	@noceiling		; if not, branch
		clr.w	obVelY(a0)		; if yes, make the rings fall down so they don't get stuck in the ceiling		
@noceiling:

		tst.b	$36(a0)			; has ring already stopped bouncing?
		bne.w	Obj37_ChkDel		; if yes, branch

		addi.w	#$18,obVelY(a0)		; regular gravity for rings

		; ring bounce
		tst.w	obVelY(a0)		; is ring falling up?
		bmi.s	@updatepos		; if yes, no colission check

		cmpi.w	#$200,obVelY(a0)	; is ring falling fast?
		bhi.s	@fastring		; if yes, accept performance loss
		move.b	($FFFFFE05).w,d0	; only check for colission every fourth frame
		add.b	d7,d0
		andi.b	#3,d0
		bne.s	@updatepos
@fastring:	jsr	ObjHitFloor
		tst.w	d1
		bpl.s	@updatepos

		; floor hit
		cmpi.w	#$200,obVelY(a0)	; is ring falling slowly?
		bhi.s	@nofloorcap		; if not, branch
		move.b	#1,$36(a0)		; set floor cap flag
		andi.w	#$FFF8,obY(a0)		; make sure it doesn't get stuck in the floor
		bra.s	Obj37_ChkDel		; skip
@nofloorcap:
		add.w	d1,obY(a0)		; set Y pos to matcch the floor

		move.w	obVelY(a0),d0		; get Y velocity at time of impact
		neg.w	d0			; negate it
		asr.w	#1,d0			; half the bounce speed
		move.w	d0,obVelY(a0)		; write new Y speed

@updatepos:
		bsr	SpeedToPos		; update position

Obj37_ChkDel:				; XREF: Obj37_MainLoop
		subq.w	#1,$30(a0)	; sub 1 from timer
		beq.s	Obj37_Delete	; despawn ring after timer expired

		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	obY(a0),d0	; has object moved below level boundary?
		bcs.s	Obj37_Delete	; if yes, branch
		bra.w	DisplaySprite
; ===========================================================================

Obj37_Collect:				; XREF: Obj37_Index
		addq.b	#2,obRoutine(a0)
		moveq	#10,d0		; add 100 ...
		jsr	AddPoints	; ... points
		move.b	#0,obColType(a0)
		move.b	#1,obPriority(a0)
		bsr	CollectRing

Obj37_Sparkle:				; XREF: Obj37_Index
		lea	(Ani_obj25).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj37_Delete:				; XREF: Obj37_Index
		bra.w	DeleteObject


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4B - giant rings
; ---------------------------------------------------------------------------
; Subtypes for the rings in Uberhub:
GRing_NightHill  = 1
GRing_GreenHill  = 2
GRing_Special    = 3
GRing_Ruined     = 4
GRing_Labyrinthy = 5
GRing_Unreal     = 6
GRing_ScarNight  = 7
GRing_StarAgony  = 8
GRing_Finalor    = 9
GRing_NightHill_First  = $11
GRing_ScarNight_First  = $17
GRing_Options    = $81
GRing_Tutorial   = $82
GRing_Blackout   = $83
GRing_Intro      = $84
GRing_Ending     = $85
; ---------------------------------------------------------------------------

Obj4B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj4B_Index(pc,d0.w),d1
		jmp	Obj4B_Index(pc,d1.w)
; ===========================================================================
Obj4B_Index:	dc.w Obj4B_Main-Obj4B_Index
		dc.w Obj4B_Animate-Obj4B_Index
		dc.w Obj4B_Collect-Obj4B_Index
		dc.w Obj4B_MoveOffScreen-Obj4B_Index
; ===========================================================================

Obj4B_Main:				; XREF: Obj4B_Index
		cmpi.b	#GRing_Intro,obSubtype(a0)	; is this the intro ring in uberhub?
		bne.s	@notintroring			; if not, branch
		tst.b	($FFFFFF7F).w			; intro sequence done?
		bne.s	@notintroring			; if yes, branch
		rts					; otherwise, hide ring to avoid visual quirks in frantic fast spawn

@notintroring:
		cmpi.w	#$502,($FFFFFE10).w
		bne.s	@notfzescape
		tst.b	(FZEscape).w
		beq.s	@delete
		tst.b	obSubtype(a0)	; is this the skip ring?
		bmi.s	@notfzescape	; if not, branch
@delete:
		jmp	DeleteObject
@notfzescape:
		addq.b	#2,obRoutine(a0)
		move.w	obY(a0),$34(a0)
		move.b	#5,$37(a0)
		move.b	#5,$38(a0)
		move.l	#Map_obj4B,obMap(a0)

		ori.w	#1,($FFFFF7BE).w		; load giant ring patterns (AniArt_GiantRing)
		cmpi.w	#$302,($FFFFFE10).w		; is this Star Agony Place? (easter egg ring)
		bne.s	@notsap				; if not, branch
		ori.w	#2,($FFFFF7BE).w		; skip loading giant ring patterns (collides otherwise)
@notsap:
		move.w	#$2000|($8000/$20),obGfx(a0)	; use default offset
		cmpi.w	#$400,($FFFFFE10).w		; is level Uberhub?
		bne.w	Obj4B_Main_Cont			; if not, branch
		move.w	#$2000|($8E00/$20),obGfx(a0)	; use uberhub specific offset

		move.b	obSubtype(a0),d1		; get ring subtype

		cmpi.b	#GRing_Blackout,d1		; is this the blackout challenge ring?
		bne.s	@checkbonusrings		; if not, branch
		move.w	#$0000|($8E00/$20),obGfx(a0)	; use red palette

@checkbonusrings:
	if DoorsAlwaysOpen=0
		cmpi.b	#GRing_NightHill,d1	; is this a ring leading to Night Hill Place (NHP act 1)?
		beq.s	@chknhp			; if yes, branch
		cmpi.b	#GRing_GreenHill,d1	; is this a ring leading to Green Hill Place (NHP act 2)?
		bne.s	@firstnhpring		; if not, branch
@chknhp:	moveq	#0,d0			; has the player beaten this level before?
		jsr	Check_LevelBeaten_Current
		bne.s	Obj4B_Main_Cont		; if yes, show both rings
		jmp	DeleteObject		; otherwise, delete this ring
@firstnhpring:
		cmpi.b	#GRing_NightHill_First,d1 ; is this the first ring leading to Night Hill Place?
		bne.s	@snprings		; if not, branch
		moveq	#0,d0			; has the player beaten this level before?
		bra.s	@adjustfirst		; further checks down below
@snprings:
		cmpi.b	#GRing_ScarNight,d1	; is this a ring leading to Scar Night Place (SNP act 1)?
		beq.s	@chksnp			; if yes, branch
		cmpi.b	#GRing_StarAgony,d1	; is this a ring leading to Star Agony Place (SNP act 2)?
		bne.s	@firstsnpring		; if not, branch
@chksnp:	moveq	#5,d0			; has the player beaten this level before?
		jsr	Check_LevelBeaten_Current
		bne.s	Obj4B_Main_Cont		; if yes, show both rings
		jmp	DeleteObject		; otherwise, delete this ring

@firstsnpring:
		cmpi.b	#GRing_ScarNight_First,d1 ; is this the first ring leading to Scar Night Place?
		bne.s	@chkend			; if not, branch
		moveq	#5,d0			; has the player beaten this level before?
@adjustfirst:	andi.b	#$F,obSubtype(a0)
		jsr	Check_LevelBeaten_Current
		beq.s	Obj4B_Main_Cont		; if not, display this ring instead of the other two
		jmp	DeleteObject		; otherwise, delete this ring

@chkend:
		cmpi.b	#GRing_Ending,d1	; is this the first ring leading to the ending sequence?
		bne.s	@notend			; if not, branch
		jsr	Check_AllLevelsBeaten_Current
		beq.s	@okcool
		bra.s	Obj4B_Main_Cont
@notend:
		cmpi.b	#GRing_Blackout,d1	; is this the first ring leading to the blackout challenge?
		bne.s	Obj4B_Main_Cont		; if not, branch
		jsr	Check_BlackoutUnlocked
		bne.s	Obj4B_Main_Cont
@okcool:
		move.b	#7,(a0)			; idk how you made it here but gg
		move.b	#0,obRoutine(a0)	; set to init routine
		rts				; don't show ring
	else
		cmpi.b	#GRing_NightHill_First,d1 ; is this the first ring leading to Night Hill Place?
		beq.s	@deletering		; if yes, branch
		cmpi.b	#GRing_ScarNight_First,d1 ; is this the first ring leading to Scar Night Place?
		bne.s	Obj4B_Main_Cont		; if not, branch
@deletering:	jmp	DeleteObject		; otherwise, delete this ring
	endif

Obj4B_Main_Cont:
		ori.b	#4,obRender(a0)
		move.b	#$40,obActWid(a0)
		tst.b	obRender(a0)
		bpl.w	Obj4B_Animate
		move.b	#2,obPriority(a0)

	;	cmpi.w	#$400,($FFFFFE10).w	; are we in Uberhub?
	;	beq.w	Obj4B_Animate		; if yes, branch
	;	move.w	#$C40,($FFFFF7BE).w	; load giant ring patterns
	;	move.w	#0,($FFFFF7BE).w	; don't load giant ring patterns systematically, because they're preloaded from PLC
; ---------------------------------------------------------------------------

Obj4B_Animate:				; XREF: Obj4B_Index
		subq.b	#1,$37(a0)
		bpl.s	@cont
		move.b	$38(a0),$37(a0)
		addq.b	#1,$36(a0)
		cmpi.b	#4,$36(a0)
		bne.s	@cont
		move.b	#0,$36(a0)

@cont:
		move.b	$36(a0),obFrame(a0)

		tst.b	$3C(a0)
		bne.w	Obj4B_DontCollect
		tst.w	($FFFFFE08).w
		bne.w	Obj4B_DontCollect

		move.w	obX(a0),d0
		sub.w	($FFFFD008).w,d0
		bpl.s	Obj4B_XPositive
		neg.w	d0

Obj4B_XPositive:
		cmpi.w	#$20,d0
		bgt.w	Obj4B_DontCollect

		move.w	obY(a0),d0
		sub.w	($FFFFD00C).w,d0
		bpl.s	Obj4B_YPositive
		neg.w	d0

Obj4B_YPositive:
		cmpi.w	#$20,d0
		bgt.w	Obj4B_DontCollect

		; new censored easter egg (replaced the old naughty one)
		cmpi.w	#$302,($FFFFFE10).w	; is this Star Agony Place? (easter egg ring)
		bne.s	@notsap			; if not, branch
		jsr	DeleteObject		; delete easter egg ring
		clr.w	($FFFFD010).w		; clear Sonic's X speed
		clr.w	($FFFFD012).w		; clear Sonic's Y speed

		jsr	SAP_LoadSonicPal	; force text color to be consistent (cause it happens to share Sonic's antigrav line)
		move.w	#$222,($FFFFFB36).w	; keep textbox background color gray
		move.b	#$9D,d0			; play funni music
		jsr	PlaySound

		move.b	#0,($FFFFD400).w	; delete rings HUD

		move.b	#$C,d0			; VLADIK => Load hint number based on subtype
		jsr	Tutorial_DisplayHint	; VLADIK => Display hint

		moveq	#$A,d0			; reload SLZ patterns overwritten by the textbox
		jsr	(LoadPLC).l		; (this is slow and inefficient as fuck lmao -- UPDATE: not anymore thanks to vlad!)
		moveq	#$B,d0			; reload the other SLZ patterns overwritten by the textbox
		jsr	(LoadPLC).l		; ye

		jsr	SAP_LoadSonicPal	; reload Sonic's antigrav palette

		move.b	#$21,($FFFFD400).w	; reload HUD object
		move.b	#0,($FFFFD424).w	; set to routine 0
		move.b	#2,($FFFFD430).w	; set to rings HUD

		move.w	#999,($FFFFFE20).w	; here's a little something for you
		ori.b	#1,($FFFFFE1D).w	; update rings counter
		
		move.b	#$96,d0			; restart regular music
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	@play			; if not, branch
		move.b	#$84,d0			; restart lame default music	
@play:		jmp	PlaySound
; ===========================================================================

@notsap:
		cmpi.b	#GRing_Blackout,obSubtype(a0)	; is this the blackout challenge ring?
		bne.s	@contnotredaircheck	; if not, branch
		btst	#1,($FFFFD022).w	; is Sonic in air?
		beq.s	Obj4B_DontCollect	; if not, don't collect
		
		move.b	#1,($FFFFFFD0).w	; FUZZY: I feel very light-headed...
		ori.b	#$FF,(CameraShake).w	; ...and dizzy...

@contnotredaircheck:
		move.b	#4,obRoutine(a0)	; mark ring as collected
		move.b	#1,$3C(a0)		; disable interaction with ring

Obj4B_DontCollect:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject

		cmpi.w	#$302,($FFFFFE10).w	; is this Star Agony Place? (easter egg ring)
		beq.s	@dontdisplay		; if yes, make it invisible
		move.w	($FFFFF7BE).w,d0	; get giant ring patterns art loading state
		andi.w	#%10,d0			; only look at the completion bit
		beq.s	@dontdisplay		; if it's not set, don't display
		bra.w	DisplaySprite		; display ring
@dontdisplay:	rts				; otherwise, don't display yet to avoid garbled rings

; ===========================================================================

Obj4B_Collect:				; XREF: Obj4B_Index
		cmpi.b	#GRing_Blackout,obSubtype(a0)	; is this the blackout challenge ring?
		bne.s	@contnotred		; if not, branch
		move.b	#60,($FFFFFF7D).w	; wait for a bit
	@contnotred:
		cmpi.w	#$000,($FFFFFE10).w
		bne.s	Obj4B_NotGHZ1
		subq.b	#2,obRoutine(a0)
		bra.w	Obj4B_Animate
; ===========================================================================

Obj4B_NotGHZ1:
		subq.b	#2,obRoutine(a0)
		move.b	#0,obColType(a0)
		cmpi.w	#$001,($FFFFFE10).w	; is this the intro cutscene?
		bne.s	Obj4B_NotGHZ2		; if not, branch
		clr.w	($FFFFF73A).w		; reset BG deformation
		jsr	WhiteFlash3		; make white flash

Obj4B_NotGHZ2:
		clr.b	($FFFFFFE7).w
		bsr	SingleObjLoad
		bne.w	Obj4B_PlaySnd
		move.b	#$7C,0(a1)	; load giant ring flash	object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.l	a0,$3C(a1)
		move.w	($FFFFD008).w,d0
		cmp.w	obX(a0),d0	; has Sonic come from the left?
		bcs.s	Obj4B_PlaySnd	; if yes, branch
		bset	#0,obRender(a1)	; reverse flash	object

Obj4B_PlaySnd:
		clr.b	($FFFFFE1E).w		; stop time counter

		move.w	#$C3,d0			; play giant ring sound
		jsr	(PlaySound).l
		cmpi.b	#GRing_Blackout,obSubtype(a0)	; is this the blackout challenge ring?
		bne.s	@contnotredx		; if not, branch
		move.w	#$B0,d0			; play SBZ sawblade sound (for extra spoop)
		jsr	(PlaySound_Special).l
		move.w	#$200,obVelY(a0)	; give a bit of start speed
	@contnotredx:
		bra.w	Obj4B_Animate
; ===========================================================================

Obj4B_MoveOffScreen:			; XREF: Obj4B_Index
		bsr.w	Obj4B_Animate		; still animate ring

		cmpi.b	#GRing_Blackout,obSubtype(a0)	; is this the blackout challenge ring?
		bne.s	@contnotred		; if not, branch
		move.b	#0,$38(a0)		; spin fast
		addi.w	#$20,obVelY(a0)		; move ring down
		jsr	SpeedToPos		; update position
		move.w	obY(a0),d0		; get current Y pos
		cmpi.w	#$200,d0		; did ring move below $200?
		bhi.w	Obj4B_Exit		; if yes, start Blackout Challenge
		rts				; wait until ring is off-screen

@contnotred:
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	@NoPaletteChange	; don't change the palette
		cmp.b	#4,($FFFFFE10).w	; we in uberhub?
		bne.s	@NoPaletteChange	; if not, don't change the palette
		lea	(Pal_SYZGray).l,a3
		lea 	($FFFFFB20).w,a4
		moveq	#$30-1,d0
@PaletteLoop:	move.w 	(a3)+,(a4)+
		dbf 	d0,@PaletteLoop

@NoPaletteChange:
		tst.b	($FFFFFF7D).w		; is ring moving up?
		bne.s	@goinup			; if yes, branch
		addi.w	#$10,obVelY(a0)		; move ring down
		move.b	#2,$38(a0)		; spin slow
		cmpi.w	#$340,obVelY(a0)	; has a certain downward velocity been reached?
		bmi.s	@updatepos		; if not, branch
		move.b	#1,($FFFFFF7D).w	; make ring move upwards
@goinup:
		subi.w	#$50,obVelY(a0)		; move ring upwards
		move.b	#0,$38(a0)		; spin fast
@updatepos:
		jsr	SpeedToPos		; move giant ring

		move.w	($FFFFF704).w,d0	; get Y camera position (screen is currently locked)
		subi.w	#$100,d0		; adjust upper offset
		cmp.w	obY(a0),d0		; did ring move out of the top screen yet?
		bge.w	Obj4B_Exit		; if yes, branch
		rts				; wait until ring is offscreen
; ===========================================================================

Obj4B_Exit:
		cmpi.w	#$502,($FFFFFE10).w	; are we in FP?
		bne.s	@exitfromring		; if not, branch
		tst.b	(FZEscape).w		; is this also the Finalor escape sequence?
		beq.s	@exitfromring		; if not, branch (double check just in case)
		bsr.s	FZEscape_ScreenBoom	; hooray you've escaped

@exitfromring:
		moveq	#0,d0			; clear d0
		move.b	obSubtype(a0),d0	; copy the ring we came from to d0
		jmp	Exit_GiantRing		; run exit logic to start the level
; ---------------------------------------------------------------------------

FZEscape_ScreenBoom:
		move.w	#$DD,d0			; play super massive boom sound
		jsr	PlaySound_Special	; yea

		move.l	a0,-(sp)		; backup to stack
		jsr	Pal_CutToWhite		; instantly turn screen white
		move.l	(sp)+,a0		; restore from stack

		move.w	#120,d5			; delay for two seconds
@WaitLoop:	move.b	#$12,VBlankRoutine
		jsr	DelayProgram
		dbf	d5,@WaitLoop
		rts

; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7C - flash effect when	you collect the	giant ring
; ---------------------------------------------------------------------------

Obj7C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj7C_Index(pc,d0.w),d1
		jmp	Obj7C_Index(pc,d1.w)
; ===========================================================================
Obj7C_Index:	dc.w Obj7C_Main-Obj7C_Index
		dc.w Obj7C_ChkDel-Obj7C_Index
		dc.w Obj7C_Delete-Obj7C_Index
; ---------------------------------------------------------------------------
		dc.w Obj7C_FakeFlash-Obj7C_Index
		dc.w Obj7C_FakeFlash_Animate-Obj7C_Index
; ===========================================================================

Obj7C_Main:				; XREF: Obj7C_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj7C,obMap(a0)
		move.w	#$2462,obGfx(a0)
		cmpi.w	#$400,($FFFFFE10).w
		bne.s	@cont
		move.w	#$2000|(($8E00+$C40)/$20),obGfx(a0)
@cont:
		ori.b	#4,obRender(a0)
		move.b	#0,obPriority(a0)
		move.b	#$20,obActWid(a0)
		move.b	#$FF,obFrame(a0)

Obj7C_ChkDel:				; XREF: Obj7C_Index
		bsr.s	Obj7C_Collect
		jmp	MarkObjGone
		
; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj7C_Collect:				; XREF: Obj7C_ChkDel
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ 1?
		beq.s	Obj7C_SYZ1		; if yes, branch

		subq.b	#1,obTimeFrame(a0)
		bpl.s	locret_9F76
		move.b	#1,obTimeFrame(a0)

Obj7C_SYZ1:
		addq.b	#1,obFrame(a0)
		cmpi.b	#8,obFrame(a0)	; has animation	finished?
		bcc.s	Obj7C_End	; if yes, branch
		cmpi.b	#3,obFrame(a0)	; is 3rd frame displayed?
		bne.s	locret_9F76	; if not, branch
		movea.l	$3C(a0),a1
		move.b	#6,obRoutine(a1)	; delete giant ring object (Obj4B)

		move.b	#1,($FFFFF7CC).w
		move.w	#0,($FFFFD000).w ; remove Sonic	object
		move.w	obX(a1),($FFFFD008).w
		
		move.b	#$1C,($FFFFD01C).w ; make Sonic	invisible
		move.b	#1,($FFFFF7CD).w ; stop	Sonic getting bonuses
		clr.b	($FFFFFE2D).w	; remove invincibility
		clr.b	($FFFFFE2C).w	; remove shield
	;	clr.b	($FFFFFFFC).w

locret_9F76:
		rts	
; ===========================================================================

Obj7C_End:				; XREF: Obj7C_Collect
		addq.b	#2,obRoutine(a0)
		addq.l	#4,sp
		rts	
; End of function Obj7C_Collect

; ===========================================================================

Obj7C_Delete:				; XREF: Obj7C_Index
		bra.w	DeleteObject
; ===========================================================================
; ===========================================================================

Obj7C_FakeFlash:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj7C,obMap(a0)
		move.w	#$2462,obGfx(a0)
		cmpi.w	#$400,($FFFFFE10).w
		bne.s	@cont
		move.w	#$2484,obGfx(a0)
@cont:
		ori.b	#4,obRender(a0)
		move.b	#0,obPriority(a0)
		move.b	#$20,obActWid(a0)
		move.b	#$FF,obFrame(a0)
		move.w	#$C3,d0			; play giant ring sound
		jsr	(PlaySound).l

Obj7C_FakeFlash_Animate:				; XREF: Obj7C_Index
		addq.b	#1,obFrame(a0)
		cmpi.b	#8,obFrame(a0)	; has animation	finished?
		bcc.s	Obj7C_Delete	; if yes, branch
		jmp	DisplaySprite
; ===========================================================================

; ---------------------------------------------------------------------------
; Sprite mappings - rings
; ---------------------------------------------------------------------------
Map_obj25:
		include	"_maps\obj25.asm"

Ani_obj25:
		include	"_anim\obj25.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - giant ring
; ---------------------------------------------------------------------------
Map_obj4B:
		include	"_maps\obj4B.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flash effect when you collect the giant ring
; ---------------------------------------------------------------------------
Map_obj7C:
		include	"_maps\obj7C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 26 - monitors
; ---------------------------------------------------------------------------

Obj26:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj26_Index(pc,d0.w),d1
		jmp	Obj26_Index(pc,d1.w)
; ===========================================================================
Obj26_Index:	dc.w Obj26_Main-Obj26_Index
		dc.w Obj26_Solid-Obj26_Index
		dc.w Obj26_BreakOpen-Obj26_Index
		dc.w Obj26_Animate-Obj26_Index
		dc.w Obj26_Display-Obj26_Index
; ===========================================================================

Obj26_Main:				; XREF: Obj26_Index
		; blow up P monitor in frantic FP
		frantic
		beq.s	@notfrantic
		cmpi.w	#$502,($FFFFFE10).w
		bne.s	@notfrantic
		cmpi.b	#8,obSubtype(a0)
		bne.s	@notfrantic
		move.b	#$3F,(a0)
		move.b	#1,$30(a0)
		move.b	#0,$31(a0)
		rts

@notfrantic:
		addq.b	#2,obRoutine(a0)
		move.b	#$E,obHeight(a0)
		move.b	#$E,obWidth(a0)
		move.l	#Map_obj26,obMap(a0)
		move.w	#$680,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$F,obActWid(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		bclr	#7,obGfx(a2,d0.w)
		btst	#0,obGfx(a2,d0.w)	; has monitor been broken?
		beq.s	Obj26_NotBroken	; if not, branch
		move.b	#8,obRoutine(a0)	; run "Obj26_Display" routine
		move.b	#$B,obFrame(a0)	; use broken monitor frame
		rts	
; ===========================================================================

Obj26_NotBroken:			; XREF: Obj26_Main
		move.b	#$46,obColType(a0)		; normal monitor type
		move.b	obSubtype(a0),obAnim(a0)	; copy subtype to animation

Obj26_Solid:				; XREF: Obj26_Index
		move.b	ob2ndRout(a0),d0	; is monitor set to fall?
		beq.s	loc_A1EC	; if not, branch
		subq.b	#2,d0
		bne.s	Obj26_Fall
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		bsr	ExitPlatform
		btst	#3,obStatus(a1)
		bne.w	loc_A1BC
		clr.b	ob2ndRout(a0)
		bra.w	Obj26_Animate
; ===========================================================================

loc_A1BC:				; XREF: Obj26_Solid
		move.w	#$10,d3
		move.w	obX(a0),d2
		bsr	MvSonicOnPtfm
		bra.w	Obj26_Animate
; ===========================================================================

Obj26_Fall:				; XREF: Obj26_Solid
		bsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	Obj26_Animate
		add.w	d1,obY(a0)
		clr.w	obVelY(a0)
		clr.b	ob2ndRout(a0)
		bra.w	Obj26_Animate
; ===========================================================================

loc_A1EC:				; XREF: Obj26_Solid
		move.w	#$1A,d1
		move.w	#$F,d2
		jsr	obj26_SolidSides
		beq.w	loc_A25C
		tst.w	obVelY(a1)
		bmi.s	loc_A20A
	;	tst.b	($FFFFFFE7).w
	;	bne.s	loc_A25C
		tst.b	($FFFFFFEB).w	; test for active jumpdash
		bne.s	loc_A25C	; if we are going to destroy it with a jumpdash, branch
		cmpi.b	#2,obAnim(a1)	; is Sonic rolling?
		beq.s	loc_A25C	; if yes, branch
		cmp.b	#$1F,obAnim(a1)	; is Sonic spin-dashing?
		beq.w	loc_A25C	; if yes, branch
		
loc_A20A:
		tst.w	d1
		bpl.s	loc_A220
		sub.w	d3,obY(a1)
		bsr	loc_74AE
		move.b	#2,ob2ndRout(a0)	; no idea why I originally commented this out, cause without it Sonic is glued to the monitor and can walk on air
		bra.w	Obj26_Animate
; ===========================================================================

loc_A220:
		tst.w	d0
		beq.w	loc_A246
		bmi.s	loc_A230
		tst.w	obVelX(a1)
		bmi.s	loc_A246
		bra.s	loc_A236
; ===========================================================================

loc_A230:
		tst.w	obVelX(a1)
		bpl.s	loc_A246

loc_A236:
		sub.w	d0,obX(a1)
		move.w	#0,obInertia(a1)
		move.w	#0,obVelX(a1)

loc_A246:
		btst	#1,obStatus(a1)
		bne.s	loc_A26A
		bset	#5,obStatus(a1)
		bset	#5,obStatus(a0)
		bra.s	Obj26_Animate
; ===========================================================================

loc_A25C:
		btst	#5,obStatus(a0)
		beq.s	Obj26_Animate
		cmp.b	#2,obAnim(a1)	; check if in jumping/rolling animation
		beq.s	loc_A26A
		cmp.b	#$17,obAnim(a1)	; check if in drowning animation
		beq.s	loc_A26A
		move.w	#1,obAnim(a1)

loc_A26A:
		bclr	#5,obStatus(a0)
		bclr	#5,obStatus(a1)

Obj26_Animate:				; XREF: Obj26_Index
		lea	(Ani_obj26).l,a1
		bsr	AnimateSprite

Obj26_Display:				; XREF: Obj26_Index
		cmpi.w	#$302,($FFFFFE10).w
		beq.s	@cont
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
@cont:
		bra.w	DisplaySprite
; ===========================================================================

Obj26_BreakOpen:			; XREF: Obj26_Index
		bclr	#3,obStatus(a0)
		addq.b	#2,obRoutine(a0)
		move.b	#0,obColType(a0)
		bsr	SingleObjLoad
		bne.s	Obj26_Explode
		move.b	#$2E,0(a1)	; load monitor contents	object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	obAnim(a0),obAnim(a1)

Obj26_Explode:
		bsr	SingleObjLoad
		bne.s	Obj26_SetBroken
		move.b	#$27,0(a1)	; load explosion object
	;	addq.b	#2,obRoutine(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj26_SetBroken:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		bset	#0,obGfx(a2,d0.w)
		move.b	#9,obAnim(a0)	; set monitor type to broken	
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2E - contents of monitors
; ---------------------------------------------------------------------------

Obj2E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj2E_Index(pc,d0.w),d1
		jsr	obj2E_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj2E_Index:	dc.w Obj2E_Main-Obj2E_Index
		dc.w Obj2E_Move-Obj2E_Index
		dc.w Obj2E_Original2-Obj2E_Index
		dc.w Obj2E_Delete-Obj2E_Index
; ===========================================================================

Obj2E_Main:				; XREF: Obj2E_Index
		addq.b	#2,obRoutine(a0)
		move.w	#$680,obGfx(a0)
		move.b	#$24,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#8,obActWid(a0)
		move.w	#-$300,obVelY(a0)
		moveq	#0,d0
		move.b	obAnim(a0),d0
		addq.b	#2,d0
		move.b	d0,obFrame(a0)
		movea.l	#Map_obj26,a1
		add.b	d0,d0
		adda.w	(a1,d0.w),a1
		addq.w	#1,a1
		move.l	a1,obMap(a0)
		move.b	#80,$30(a0)		; set maximun delay
		cmpi.w	#$302,($FFFFFE10).w
		bne.s	@cont
		move.b	#1,$30(a0)

@cont:
		btst	#1,($FFFFD022).w	; was Sonic on the ground as the monitor broke open?
		bne.s	Obj2E_Move		; if not, branch
		move.b	#1,$3F(a0)		; set flag

Obj2E_Move:				; XREF: Obj2E_Index
		cmpi.b	#1,obAnim(a0)		; is the eggman monitor?
		beq.s	@flag			; if yes, branch
		cmpi.b	#8,obAnim(a0)		; is the P-monitor?
		bne.s	@conty			; if not, branch
@flag:		move.b	#1,($FFFFFF73).w	; re-enable spindash ability

@conty:
		tst.b	$3F(a0)			; was flag set?
		bne.s	Obj2E_Original		; if yes, branch
		cmpi.b	#7,obAnim(a0)		; is that a S monitor?
		beq.s	Obj2E_Original		; if yes, use original stuff

@cont:
		btst	#1,($FFFFD022).w	; is Sonic on the ground?
		beq.s	Obj2E_Start		; if yes, branch
		subq.b	#1,$30(a0)		; sub 1 from maximun delay
		bmi.s	Obj2E_Start		; if time is over, branch
		move.w	($FFFFD008).w,obX(a0)	; set X-pos to Sonic's one
		moveq	#0,d0			; clear d0
		move.w	($FFFFD00C).w,d0	; move Sonic's Y-pos to d0
		sub.w	#30,d0			; sub 30 from it
		move.w	d0,obY(a0)		; set Y-pos to the calculated one
		rts				; return
; ===========================================================================

Obj2E_Original:
		move.b	#1,$3F(a0)	; set flag
		tst.w	obVelY(a0)		; is object moving?
		bpl.w	Obj2E_Start	; if not, branch
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)	; reduce object	speed
		rts	
; ===========================================================================

Obj2E_Original2:
		tst.w	obVelY(a0)		; is object moving?
		bpl.w	Obj2E_Delete	; if not, branch
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)	; reduce object	speed
		rts	
; ===========================================================================

Obj2E_Start:			; XREF: Obj2E_Move
		addq.b	#2,obRoutine(a0)
		move.w	#29,obTimeFrame(a0)
		move.b	obAnim(a0),d0
; ---------------------------------------------------------------------------

Obj2E_ChkEggman:
		cmpi.b	#1,d0		; does monitor contain Eggman?
		bne.s	Obj2E_ChkSonic
		lea	($FFFFD000).w,a0
		jmp	KillSonic	; kill Sonic lmao (except in inhuman mode)
; ===========================================================================

Obj2E_ChkSonic: ; =P monitors
		cmpi.b	#2,d0		; does monitor contain Sonic?
		bne.w	Obj2E_ChkShoes

		move.w	#$1E,($FFFFFE14).w	; set precise remaining air time to get comedic timing right
		move.b	#1,($FFFFFFFE).w	; set =P monitor flag true

		move.w	#$AD,d0
		jsr	(PlaySound_Special).l	; play air bubble sound

		move.w	#$8B,d0
		jmp	(PlaySound).l	; play the old ending sequence music for maximum troll
; ===========================================================================

; ---------------------------------------------------------------------------
; Sonic speed values
; (I put them here cause this is the first instance in the code)
Sonic_TopSpeed 			= $A00
Sonic_Acceleration		= $F
Sonic_Deceleration		= $80

Sonic_TopSpeed_Water 		= Sonic_TopSpeed / 2
Sonic_Acceleration_Water	= Sonic_Acceleration / 2
Sonic_Deceleration_Water	= Sonic_Deceleration / 2

Sonic_TopSpeed_Shoes		= Sonic_TopSpeed + $680
Sonic_Acceleration_Shoes	= Sonic_Acceleration * 2
Sonic_Deceleration_Shoes	= Sonic_Deceleration * 2
; ---------------------------------------------------------------------------

Obj2E_ChkShoes:
		cmpi.b	#3,d0		; does monitor contain speed shoes?
		bne.s	Obj2E_ChkShield
		move.b	#1,($FFFFFE2E).w ; speed up the	BG music
		move.w	#20*60,($FFFFD034).w ; time limit for the power-up (20 seconds)
		
		move.w	#Sonic_TopSpeed_Shoes,($FFFFF760).w ; change Sonic's top speed
		move.w	#Sonic_Acceleration_Shoes,($FFFFF762).w
		move.w	#Sonic_Deceleration_Shoes,($FFFFF764).w

		move.w	#$E2,d0
		jmp	(PlaySound).l	; change music
; ===========================================================================

Obj2E_ChkShield:
		cmpi.b	#4,d0		; does monitor contain a shield?
		bne.s	Obj2E_ChkInvinc
		tst.b	($FFFFFFE7).w	; has sonic destroyed a S monitor?
		bne.s	Obj2E_ChkInvinc	; if yes, don't give sonic a shield
		move.w	#$AF,d0			; play shield sound
		tst.b	($FFFFFE2C).w		; is sonic already having a shield?
		beq.s	Obj2E_Shield_NoBonus	; if not, branch
		addi.w	#30,($FFFFFE20).w	; give 30 bonus rings
		ori.b	#1,($FFFFFE1D).w	; update the ring counter
		move.w	#$C5,d0			; play ka-ching sound

Obj2E_Shield_NoBonus:
		move.b	#1,($FFFFFE2C).w ; give	Sonic a	shield	
		move.b	#$38,($FFFFD180).w ; load shield object	($38)
		jmp	(PlaySound).l	; play shield sound
; ===========================================================================

Obj2E_ChkInvinc:
		cmpi.b	#5,d0		; does monitor contain invincibility?
		bne.s	Obj2E_ChkRings
		tst.b	($FFFFFFE7).w	; has sonic destroyed a S monitor?
		bne.s	Obj2E_ChkRings	; if yes, don't give sonic invinciblility
		move.b	#1,($FFFFFE2D).w ; make	Sonic invincible
		move.w	#20*60,($FFFFD032).w ; time limit for the power-up (20 seconds)

		move.b	#$38,($FFFFD200).w ; load stars	object ($3801)
		move.b	#1,($FFFFD21C).w
		move.b	#$38,($FFFFD240).w ; load stars	object ($3802)
		move.b	#2,($FFFFD25C).w
		move.b	#$38,($FFFFD280).w ; load stars	object ($3803)
		move.b	#3,($FFFFD29C).w
		move.b	#$38,($FFFFD2C0).w ; load stars	object ($3804)
		move.b	#4,($FFFFD2DC).w

		tst.b	($FFFFF7AA).w	; is boss mode on?
		bne.s	Obj2E_NoMusic	; if yes, branch
		move.w	#$91,d0
		jmp	(PlaySound).l	; play invincibility music
; ===========================================================================

Obj2E_NoMusic:
		rts	
; ===========================================================================

Obj2E_ChkRings:
		cmpi.b	#6,d0		; does monitor contain 10 rings?
		bne.w	Obj2E_ChkS
		addi.w	#$A,($FFFFFE20).w ; add	10 rings to the	number of rings	you have
		ori.b	#1,($FFFFFE1D).w ; update the ring counter

		move.w	#$B5,d0
		jmp	(PlaySound).l	; play ring sound
; ===========================================================================

Obj2E_ChkS:
		cmpi.b	#7,d0		; does monitor contain 'S'
		bne.w	Obj2E_ChkP

	;	tst.b	($FFFFFFE7).w		; has a S monitor already been broken?
	;	bne.w	Obj2E_ChkEnd		; if yes, branch

		move.b	#$38,($FFFFD280).w ; load stars	object ($3803)
		move.b	#1,($FFFFD29C).w
		move.b	#$38,($FFFFD2C0).w ; load stars	object ($3804)
		move.b	#3,($FFFFD2DC).w

		cmpi.w	#$200,($FFFFFE10).w	; is this Ruined Place?
		bne.s	@notruinedplace		; if not, branch

		cmpi.w	#100,($FFFFFE20).w	; do you have at least 100 rings?
		bhs.s	@notanoob		; if yes, branch
		move.w	#100,($FFFFFE20).w	; give 100 rings (you'll probably still die, but at least it isn't instant)
		ori.b	#1,($FFFFFE1D).w	; update rings counter
@notanoob:
		; block off a chunk offscreen
		movem.l	d0-a1,-(sp)		; backup

		move.w	#$1000,d0
		move.w	#$0300,d1
		move.b	#$20,d2
		jsr	Sub_ChangeChunk
		
		; load bloody spikes art now
		lea	Obj2E_SpikesBlood, a1
		jsr	LoadPLC_Direct

		movem.l	(sp)+,d0-a1		; restore

@notruinedplace:
		move.b	#1,($FFFFFFE7).w ; make sonic immortal

		clr.b	($FFFFFE2D).w	; remove invinceblity
		clr.b	($FFFFFE2C).w	; remove shield
		cmpi.w	#$200,($FFFFFE10).w	; are we in Ruined Place?
		beq.s	Obj2E_RuinedPlace	; if yes, branch
		move.w	#$C3,d0			; play special stage entry sound
		jmp	(PlaySound).l

Obj2E_RuinedPlace:
		move.w	#$9F,d0		; set song $9F
		jmp	PlaySound	; play inhuman mode music


Obj2E_SpikesBlood:
	dc.l	ArtKospM_SpikesBlood
	dc.w	$A360
	dc.w	-1
; ===========================================================================

; Obj2E_ChkGoggles:
Obj2E_ChkP:
		cmpi.b	#8,d0		; does monitor contain goggles?
		bne.w	Obj2E_ChkEnd	; if not, branch

		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		bne.s	@checkslz		; if not, branch
		move.w	#$D1,d0			; set spinadsh sound
		jmp	(PlaySound).l		; play spindash sound

@checkslz:
		cmpi.b	#3,($FFFFFE10).w	; is zone SLZ?
		bne.s	@doringfall	; if not, branch
		move.b	#1,($FFFFFFE1).w	; disable blockers (both the fan in SNP and the barrier in SAP)
		cmpi.w	#$302,($FFFFFE10).w	; are we specifically in SAP?
		bne.s	@doringfall	; if not, branch

		; disable blocker chunk in SAP
		movem.l	d0-a1,-(sp)
		move.w	#$1480,d0
		move.w	#$0380,d1
		move.b	#$31,d2
		jsr	Sub_ChangeChunk
		movem.l	(sp)+,d0-a1
		move.w	#$A9,d0
		jmp	(PlaySound).l	; play blubb sound

@doringfall:
		frantic
		beq.s	@notfrantic
		cmpi.w	#$502,($FFFFFE10).w
		bne.s	@notfrantic
		move.w	#$A9,d0
		jmp	(PlaySound).l	; play blubb sound

@notfrantic:
		move.l	a0,-(sp)
		lea	($FFFFD800).w,a0	; set a1 to level object RAM
		moveq	#$60-1,d2		; set d2 to $5F ($D800 to $F000 = $60 objects)
@findrings:
		cmpi.b	#$25,(a0)		; is object a ring?
		bne.s	@next			; if not, branch
		jsr	Obj25_MarkGone		; make sure ring doesn't respawn (if it moves offscreen, tough luck buddy)
		move.b	#$37,(a0)		; change object into bouncing ring
		move.w	#10*60,$30(a0)		; set full despawn timer
		move.b	#0,$29(a0)
		move.b	#0,$36(a0)
		move.b	#2,obRoutine(a0)	; make sure the ring just bounces, we don't want to loose 10 rings
@next:		adda.w	#$40,a0			; go to next object in RAM
		dbf	d2,@findrings		; loop
		move.l	(sp)+,a0

		move.b	#-1,($FFFFFEC6).w	; reset bouncy ring animation timer
		move.b	#180,(CameraShake).w	; 3 seconds of camera shake
		move.w	#$B7,d0			; play rumble sound
		jmp	(PlaySound).l
; ===========================================================================

Obj2E_ChkEnd:
		rts
; ===========================================================================

Obj2E_Delete:				; XREF: Obj2E_Index
		subq.w	#1,obTimeFrame(a0)
		bmi.w	DeleteObject
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	make the sides of a monitor solid
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj26_SolidSides:			; XREF: loc_A1EC
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.s	loc_A4E6
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.s	loc_A4E6
		move.b	obHeight(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	obY(a1),d3
		sub.w	obY(a0),d3
		add.w	d2,d3
		bmi.s	loc_A4E6
		add.w	d2,d2
		cmp.w	d2,d3
		bcc.s	loc_A4E6
		tst.b	($FFFFF7C8).w
		bmi.s	loc_A4E6
		cmpi.b	#6,($FFFFD024).w
		bcc.s	loc_A4E6
		tst.w	($FFFFFE08).w
		bne.s	loc_A4E6
		cmp.w	d0,d1
		bcc.s	loc_A4DC
		add.w	d1,d1
		sub.w	d1,d0

loc_A4DC:
		cmpi.w	#$10,d3
		bcs.s	loc_A4EA

loc_A4E2:
		moveq	#1,d1
		rts	
; ===========================================================================

loc_A4E6:
		moveq	#0,d1
		rts	
; ===========================================================================

loc_A4EA:
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addq.w	#4,d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	obX(a1),d1
		sub.w	obX(a0),d1
		bmi.s	loc_A4E2
		cmp.w	d2,d1
		bcc.s	loc_A4E2
		moveq	#-1,d1
		rts	
; End of function Obj26_SolidSides

; ===========================================================================
Ani_obj26:
		include	"_anim\obj26.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - monitors
; ---------------------------------------------------------------------------
Map_obj26:
		include	"_maps\obj26.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0E - Sonic on the title screen
; ---------------------------------------------------------------------------

Obj0E:					; XREF: Obj_Index
		bset	#0,obStatus(a0)
		bset	#1,obStatus(a0)
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj0E_Index(pc,d0.w),d1
		jmp	Obj0E_Index(pc,d1.w)
; ===========================================================================
Obj0E_Index:	dc.w Obj0E_Main-Obj0E_Index
		dc.w Obj0E_Delay-Obj0E_Index
		dc.w Obj0E_Move-Obj0E_Index
		dc.w Obj0E_AnimateX-Obj0E_Index
; ===========================================================================

Obj0E_Main:				; XREF: Obj0E_Index
		addq.b	#2,obRoutine(a0)
		move.w	#$150,obX(a0)
	;	move.w	#$DE,obScreenY(a0)
		move.w	#0,obScreenY(a0)
		move.l	#Map_obj0E,obMap(a0)
		move.w	#$2300,obGfx(a0)
	;	move.b	#1,obPriority(a0)
		move.b	#29,obDelayAni(a0)	; set time delay to 0.5	seconds
		lea	(Ani_obj0E).l,a1
		bsr	AnimateSprite

Obj0E_Delay:				; XREF: Obj0E_Index
		subq.b	#1,obDelayAni(a0)	; subtract 1 from time delay
		bpl.s	Obj0E_Wait	; if time remains, branch
		addq.b	#2,obRoutine(a0)	; go to	next routine
		bra.w	DisplaySprite
; ===========================================================================

Obj0E_Wait:				; XREF: Obj0E_Delay
		rts	
; ===========================================================================

Obj0E_Move:				; XREF: Obj0E_Index
		addq.w	#8,obScreenY(a0)
		cmpi.w	#$D0,obScreenY(a0)
		bne.s	Obj0E_Display
		addq.b	#2,obRoutine(a0)

Obj0E_Display:
		bra.w	DisplaySprite
; ===========================================================================

Obj0E_AnimateX:
		move.b	$3F(a0),d0		; ^ make Sonic hovering
		jsr	(CalcSine).l		; | copied
		asr.w	#5,d0			; | from
		add.w	$38(a0),d0		; | Obj3D
		move.w	d0,obScreenY(a0)		; | (GHZ-boss)
		addq.b	#2,$3F(a0)		; v
		add.w	#$D0,obScreenY(a0)		; for some reason, I gotta bring Sonic down a little bit manually

Obj0E_Animate:				; XREF: Obj0E_Index
		cmpi.w	#$100,($FFFFF614).w
		bgt.s	@cont
		move.b	#6,obFrame(a0)
		bra.w	DisplaySprite

@cont:
		lea	(Ani_obj0E).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Ani_obj0E:
		include	"_anim\obj0E.asm"


; ---------------------------------------------------------------------------
; Object 0F - "PRESS START BUTTON" from title screen
; ---------------------------------------------------------------------------

Obj0F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj0F_Index(pc,d0.w),d1
		jsr	obj0F_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj0F_Index:	dc.w Obj0F_Main-Obj0F_Index
		dc.w Obj0F_PrsStart1-Obj0F_Index
		dc.w Obj0F_PrsStart2-Obj0F_Index
		dc.w locret_A6F8-Obj0F_Index
; ===========================================================================

Obj0F_Main:				; XREF: Obj0F_Index
		addq.b	#2,obRoutine(a0)
		move.w	#$D8,obX(a0)
		move.w	#$138,obScreenY(a0)
		move.l	#Map_obj0F,obMap(a0)
		move.w	#$200,obGfx(a0)
		move.b	#$3E,$30(a0)

locret_A6F8:				; XREF: Obj0F_Index
		rts	
; ===========================================================================

Obj0F_PrsStart1:			; XREF: Obj0F_Index
		addq.w	#4,obX(a0)	; move object across the screen
		cmpi.w	#$170,obX(a0)
		blt.s	Obj0F_Animate
		addq.b	#2,obRoutine(a0)
		bra.s	Obj0F_Animate
; ---------------------------------------------------------------------------

Obj0F_PrsStart2:			; XREF: Obj0F_Index
		subq.w	#4,obX(a0)	; move object across the screen
		cmpi.w	#$40,obX(a0)
		bgt.s	Obj0F_Animate
		subq.b	#2,obRoutine(a0)
; ---------------------------------------------------------------------------

Obj0F_Animate:
		lea	(Ani_obj0F).l,a1
		bra.s	AnimateSprite
; ===========================================================================

Ani_obj0F:
		include	"_anim\obj0F.asm"

; ---------------------------------------------------------------------------
; Subroutine to	animate	a sprite using an animation script
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AnimateSprite:
		moveq	#0,d0
		move.b	obAnim(a0),d0	; move animation number	to d0
		cmp.b	obNextAni(a0),d0	; is animation set to restart?
		beq.s	Anim_Run	; if not, branch
		move.b	d0,obNextAni(a0)	; set to "no restart"
		move.b	#0,obAniFrame(a0)	; reset	animation
		move.b	#0,obTimeFrame(a0)	; reset	frame duration

Anim_Run:
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from frame	duration
		bpl.s	Anim_Wait	; if time remains, branch
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),obTimeFrame(a0)	; load frame duration
		moveq	#0,d1
		move.b	obAniFrame(a0),d1	; load current frame number
		move.b	obRender(a1,d1.w),d0	; read sprite number from script
		bmi.s	Anim_End_FF	; if animation is complete, branch

Anim_Next:
		move.b	d0,d1
		andi.b	#$1F,d0
		move.b	d0,obFrame(a0)	; load sprite number
		move.b	obStatus(a0),d0
		rol.b	#3,d1
		eor.b	d0,d1
		andi.b	#3,d1
		andi.b	#$FC,obRender(a0)
		or.b	d1,obRender(a0)
		addq.b	#1,obAniFrame(a0)	; next frame number

Anim_Wait:
		rts	
; ===========================================================================

Anim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	Anim_End_FE	; if not, branch
		move.b	#0,obAniFrame(a0)	; restart the animation
		move.b	obRender(a1),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	Anim_End_FD	; if not, branch
		move.b	obGfx(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,obAniFrame(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	obRender(a1,d1.w),d0	; read sprite number
		bra.s	Anim_Next
; ===========================================================================

Anim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	Anim_End_FC	; if not, branch
		move.b	obGfx(a1,d1.w),obAnim(a0) ; read next byte, run that animation

Anim_End_FC:
		addq.b	#1,d0		; is the end flag = $FC	?
		bne.s	Anim_End_FB	; if not, branch
		addq.b	#2,obRoutine(a0)	; jump to next routine

Anim_End_FB:
		addq.b	#1,d0		; is the end flag = $FB	?
		bne.s	Anim_End_FA	; if not, branch
		move.b	#0,obAniFrame(a0)	; reset	animation
		clr.b	ob2ndRout(a0)		; reset	2nd routine counter

Anim_End_FA:
		addq.b	#1,d0		; is the end flag = $FA	?
		bne.s	Anim_End	; if not, branch
		addq.b	#2,ob2ndRout(a0)	; jump to next routine

Anim_End:
		rts	
; End of function AnimateSprite

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - "PRESS START BUTTON" and "TM" from title screen
; ---------------------------------------------------------------------------
Map_obj0F:
		include	"_maps\obj0F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Sonic on the title screen
; ---------------------------------------------------------------------------
Map_obj0E:
		include	"_maps\obj0E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2B - Chopper enemy (GHZ)
; ---------------------------------------------------------------------------

Obj2B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj2B_Index(pc,d0.w),d1
		jsr	obj2B_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj2B_Index:	dc.w Obj2B_Main-Obj2B_Index
		dc.w Obj2B_ChgSpeed-Obj2B_Index
		dc.w Obj2B_Delete-Obj2B_Index
; ===========================================================================

Obj2B_Main:				; XREF: Obj2B_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj2B,obMap(a0)
		move.w	#$47B,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#9,obColType(a0)
		move.b	#$10,obActWid(a0)
		move.w	#-$700,obVelY(a0)	; set vertical speed
		move.w	obY(a0),$30(a0)	

Obj2B_ChgSpeed:				; XREF: Obj2B_Index	
		lea	(Ani_obj2B).l,a1
		bsr	AnimateSprite
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)	; reduce speed
		move.w	$30(a0),d0
		cmp.w	obY(a0),d0
		bcc.s	Obj2B_ChgAni
		move.w	d0,obY(a0)
		move.w	#-$700,obVelY(a0)	; set vertical speed	

Obj2B_ChgAni:
		tst.b	($FFFFFFB1).w
		bmi.s	Obj2B_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj2B_NotInhumanCrush
		move.b	#4,obRoutine(a0)		
		bsr	SingleObjLoad
		bne.s	Obj2B_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)

Obj2B_NotInhumanCrush:
		move.b	#1,obAnim(a0)	; use fast animation

		cmpi.w	#$000,($FFFFFE10).w	; is level still NHP?
		beq.s	locret_ABB6		; if yes, don't do explosions yet
		bsr	BossDefeated4		; fishy go boom
	
locret_ABB6:
		rts	
; ===========================================================================

Obj2B_Delete:
		bsr	DeleteObject
		rts
; ===========================================================================
Ani_obj2B:
		include	"_anim\obj2B.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Chopper enemy (GHZ)
; ---------------------------------------------------------------------------
Map_obj2B:
		include	"_maps\obj2B.asm"
		
; ===========================================================================
BossDefeated2:
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	locret_178A22
		bsr	SingleObjLoad
		bne.s	locret_178A22
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,obY(a1)

locret_178A22:
		rts	
; End of function BossDefeated

BossDefeated3:
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	locret_178A22XX
		bsr	SingleObjLoad
		bne.s	locret_178A22XX
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)
	;	move.b	#1,$30(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,obY(a1)

locret_178A22XX:
		rts	
; End of function BossDefeated

BossDefeated4:
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	locret_178A22XXX
		bsr	SingleObjLoad
		bne.s	locret_178A22XX
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#2,obRoutine(a1)
		move.b	#0,$31(a1)
	;	jsr	(RandomNumber).l
	;	move.w	d0,d1
	;	moveq	#0,d1
	;	move.b	d0,d1
	;	lsr.b	#2,d1
	;	subi.w	#$20,d1
	;	add.w	d1,obX(a1)
	;	lsr.w	#8,d0
	;	lsr.b	#3,d0
	;	add.w	d0,obY(a1)

locret_178A22XXX:
		rts	


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2C - Jaws enemy (LZ)
; ---------------------------------------------------------------------------

Obj2C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj2C_Index(pc,d0.w),d1
		jmp	Obj2C_Index(pc,d1.w)

; ===========================================================================
Obj2C_Index:	dc.w Obj2C_Main-Obj2C_Index
		dc.w Obj2C_Bounce-Obj2C_Index
		dc.w Obj2C_Delete-Obj2C_Index
; ===========================================================================

Obj2C_Main:				; XREF: Obj2C_Index
		move.b	#82,$36(a0)
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj2C,obMap(a0)
		move.w	#$2486,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$A,obColType(a0)
		move.b	#4,obPriority(a0)
		move.b	#$10,obActWid(a0)
		move.w	#-$60,obVelX(a0)	; move Jaws to the left

Obj2C_Bounce:				; XREF: Obj2C_Index
		bsr.w	SpeedToPos
		jsr	(ObjHitFloor).l
		cmpi.w	#6,d1
		ble.s	@Bounce
		bsr.w	ObjectFall
		bra.s	Obj2C_Animate
		
@Bounce:
		move.b	#$A9,d0			; play blip sound
		jsr	PlaySound_Special

		move.w	#-$200,obVelY(a0)	; bounce up
		neg.w 	obVelX(a0)		; reverse direction
		move.b	#1,obAnim(a0)		; reset animation

		bclr	#0,obStatus(a0)		; make Jaws face the direction he's bouncing toward
		tst.w	obVelX(a0)
		bmi.s	Obj2C_Animate
		bset	#0,obStatus(a0)

Obj2C_Animate:
		bclr	#1,obStatus(a0)		; vertically flip Jaws for a brief moment as he touches the ground
		tst.b	obAnim(a0)
		beq.s	@1
		bset	#1,obStatus(a0)
@1:
		lea	(Ani_obj2C).l,a1
		bsr	AnimateSprite
		bsr	SpeedToPos
		bra.w	MarkObjGone
; ===========================================================================

Obj2C_Delete:
		bsr	DeleteObject
		rts
; ===========================================================================		
Ani_obj2C:
		include	"_anim\obj2C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Jaws enemy (LZ)
; ---------------------------------------------------------------------------
Map_obj2C:
		include	"_maps\obj2C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2D - Burrobot enemy (LZ)
; ---------------------------------------------------------------------------

Obj2D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj2D_Index(pc,d0.w),d1
		jmp	Obj2D_Index(pc,d1.w)
; ===========================================================================
Obj2D_Index:	dc.w Obj2D_Main-Obj2D_Index
		dc.w Obj2D_Action-Obj2D_Index
		dc.w Obj2D_Delete-Obj2D_Index
; ===========================================================================

Obj2D_Main:				; XREF: Obj2D_Index
		addq.b	#2,obRoutine(a0)
		move.b	#$13,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.l	#Map_obj2D,obMap(a0)
		move.w	#$4A6,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#5,obColType(a0)
		move.b	#$C,obActWid(a0)
		addq.b	#6,ob2ndRout(a0)	; run "Obj2D_ChkSonic" routine
		move.b	#2,obAnim(a0)

Obj2D_Action:				; XREF: Obj2D_Index
		tst.b	($FFFFFFB1).w
		bmi.s	Obj2D_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj2D_NotInhumanCrush
		move.b	#4,obRoutine(a0)		
		bsr	SingleObjLoad
		bne.s	Obj2D_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj2D_NotInhumanCrush:
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj2D_Index2(pc,d0.w),d1
		jsr	obj2D_Index2(pc,d1.w)
		lea	(Ani_obj2D).l,a1
		bsr	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj2D_Index2:	dc.w Obj2D_ChgDir-Obj2D_Index2
		dc.w Obj2D_Move-Obj2D_Index2
		dc.w Obj2D_Jump-Obj2D_Index2
		dc.w Obj2D_ChkSonic-Obj2D_Index2
; ===========================================================================

Obj2D_ChgDir:				; XREF: Obj2D_Index2
		subq.w	#1,$30(a0)
		bpl.s	locret_AD42
		addq.b	#2,ob2ndRout(a0)
		move.w	#$FF,$30(a0)
		move.w	#$80,obVelX(a0)
		move.b	#1,obAnim(a0)
		bchg	#0,obStatus(a0)	; change direction the Burrobot	is facing
		beq.s	locret_AD42
		neg.w	obVelX(a0)		; change direction the Burrobot	is moving

locret_AD42:
		rts	
; ===========================================================================

Obj2D_Move:				; XREF: Obj2D_Index2
		subq.w	#1,$30(a0)
		bmi.s	loc_AD84
		bsr	SpeedToPos
		bchg	#0,$32(a0)
		bne.s	loc_AD78
		move.w	obX(a0),d3
		addi.w	#$C,d3
		btst	#0,obStatus(a0)
		bne.s	loc_AD6A
		subi.w	#$18,d3

loc_AD6A:
		jsr	ObjHitFloor2
		cmpi.w	#$C,d1
		bge.s	loc_AD84
		rts	
; ===========================================================================

loc_AD78:				; XREF: Obj2D_Move
		jsr	ObjHitFloor
		add.w	d1,obY(a0)
		rts	
; ===========================================================================

loc_AD84:				; XREF: Obj2D_Move
		btst	#2,($FFFFFE05).w
		beq.s	loc_ADA4
		subq.b	#2,ob2ndRout(a0)
		move.w	#$3B,$30(a0)
		move.w	#0,obVelX(a0)
		move.b	#0,obAnim(a0)
		rts	
; ===========================================================================

loc_ADA4:
		addq.b	#2,ob2ndRout(a0)
		move.w	#-$400,obVelY(a0)
		move.b	#2,obAnim(a0)
		rts	
; ===========================================================================

Obj2D_Jump:				; XREF: Obj2D_Index2
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)
		bmi.s	locret_ADF0
		move.b	#3,obAnim(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_ADF0
		add.w	d1,obY(a0)
		move.w	#0,obVelY(a0)
		move.b	#1,obAnim(a0)
		move.w	#$FF,$30(a0)
		subq.b	#2,ob2ndRout(a0)
		jsr	obj2D_ChkSonic2

locret_ADF0:
		rts	
; ===========================================================================

Obj2D_ChkSonic:				; XREF: Obj2D_Index2
		move.w	#$60,d2
		jsr	obj2D_ChkSonic2
		bcc.s	locret_AE20
		move.w	($FFFFD00C).w,d0
		sub.w	obY(a0),d0
		bcc.s	locret_AE20
		cmpi.w	#-$80,d0
		bcs.s	locret_AE20
		tst.w	($FFFFFE08).w
		bne.s	locret_AE20
		subq.b	#2,ob2ndRout(a0)
		move.w	d1,obVelX(a0)
		move.w	#-$400,obVelY(a0)

locret_AE20:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj2D_ChkSonic2:			; XREF: Obj2D_ChkSonic
		move.w	#$80,d1
		bset	#0,obStatus(a0)
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_AE40
		neg.w	d0
		neg.w	d1
		bclr	#0,obStatus(a0)

loc_AE40:
		cmp.w	d2,d0
		rts	
; End of function Obj2D_ChkSonic2

; ===========================================================================
Obj2D_Delete:
		bsr	DeleteObject
		rts
; ===========================================================================		
Ani_obj2D:
		include	"_anim\obj2D.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Burrobot enemy (LZ)
; ---------------------------------------------------------------------------
Map_obj2D:
		include	"_maps\obj2D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 2F - large moving platforms (MZ)
; ---------------------------------------------------------------------------

Obj2F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj2F_Index(pc,d0.w),d1
		jmp	Obj2F_Index(pc,d1.w)
; ===========================================================================
Obj2F_Index:	dc.w Obj2F_Main-Obj2F_Index
		dc.w Obj2F_Action-Obj2F_Index

Obj2F_Data:	dc.w Obj2F_Data1-Obj2F_Data 	; collision angle data
		dc.b 0,	$40			; frame	number,	platform width
		dc.w Obj2F_Data3-Obj2F_Data
		dc.b 1,	$40
		dc.w Obj2F_Data2-Obj2F_Data
		dc.b 2,	$20
; ===========================================================================

Obj2F_Main:				; XREF: Obj2F_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj2F,obMap(a0)
		move.w	#$C000,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#5,obPriority(a0)
		move.w	obY(a0),$2C(a0)
		move.w	obX(a0),$2A(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	Obj2F_Data(pc,d0.w),a1
		move.w	(a1)+,d0
		lea	Obj2F_Data(pc,d0.w),a2
		move.l	a2,$30(a0)
		move.b	(a1)+,obFrame(a0)
		move.b	(a1),obActWid(a0)
		andi.b	#$F,obSubtype(a0)
		move.b	#$40,obHeight(a0)
		bset	#4,obRender(a0)

Obj2F_Action:				; XREF: Obj2F_Index
		jsr	obj2F_Types
		tst.b	ob2ndRout(a0)
		beq.s	Obj2F_Solid
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		bsr	ExitPlatform
		btst	#3,obStatus(a1)
		bne.w	Obj2F_Slope
		clr.b	ob2ndRout(a0)
		bra.s	Obj2F_Display
; ===========================================================================

Obj2F_Slope:				; XREF: Obj2F_Action
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		movea.l	$30(a0),a2
		move.w	obX(a0),d2
		bsr	SlopeObject2
		bra.s	Obj2F_Display
; ===========================================================================

Obj2F_Solid:				; XREF: Obj2F_Action
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		move.w	#$20,d2
		cmpi.b	#2,obFrame(a0)
		bne.s	loc_AF8E
		move.w	#$30,d2

loc_AF8E:
		movea.l	$30(a0),a2
		bsr	SolidObject2F

Obj2F_Display:				; XREF: Obj2F_Action
		bsr	DisplaySprite
		bra.w	Obj2F_ChkDel

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj2F_Types:				; XREF: Obj2F_Action
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj2F_TypeIndex(pc,d0.w),d1
		jmp	Obj2F_TypeIndex(pc,d1.w)
; End of function Obj2F_Types

; ===========================================================================
Obj2F_TypeIndex:dc.w Obj2F_Type00-Obj2F_TypeIndex
		dc.w Obj2F_Type01-Obj2F_TypeIndex
		dc.w Obj2F_Type02-Obj2F_TypeIndex
		dc.w Obj2F_Type03-Obj2F_TypeIndex
		dc.w Obj2F_Type04-Obj2F_TypeIndex
		dc.w Obj2F_Type05-Obj2F_TypeIndex
; ===========================================================================

Obj2F_Type00:				; XREF: Obj2F_TypeIndex
		rts			; type 00 platform doesn't move
; ===========================================================================

Obj2F_Type01:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE60).w,d0
		move.w	#$20,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type02:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE64).w,d0
		move.w	#$30,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type03:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE68).w,d0
		move.w	#$40,d1
		bra.s	Obj2F_Move
; ===========================================================================

Obj2F_Type04:				; XREF: Obj2F_TypeIndex
		move.b	($FFFFFE6C).w,d0
		move.w	#$60,d1

Obj2F_Move:
		btst	#3,obSubtype(a0)
		beq.s	loc_AFF2
		neg.w	d0
		add.w	d1,d0

loc_AFF2:
		move.w	$2C(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)	; update position on y-axis
		rts	
; ===========================================================================

Obj2F_Type05:				; XREF: Obj2F_TypeIndex
		move.b	$34(a0),d0
		tst.b	ob2ndRout(a0)
		bne.s	loc_B010
		subq.b	#2,d0
		bcc.s	loc_B01C
		moveq	#0,d0
		bra.s	loc_B01C
; ===========================================================================

loc_B010:
		addq.b	#4,d0
		cmpi.b	#$40,d0
		bcs.s	loc_B01C
		move.b	#$40,d0

loc_B01C:
		move.b	d0,$34(a0)
		jsr	(CalcSine).l
		lsr.w	#4,d0
		move.w	d0,d1
		add.w	$2C(a0),d0
		move.w	d0,obY(a0)
		cmpi.b	#$20,$34(a0)
		bne.s	loc_B07A
		tst.b	$35(a0)
		bne.s	loc_B07A
		move.b	#1,$35(a0)
		bsr	SingleObjLoad2
		bne.s	loc_B07A
		move.b	#$35,0(a1)	; load sitting flame object
		move.w	obX(a0),obX(a1)
		move.w	$2C(a0),$2C(a1)
		addq.w	#8,$2C(a1)
		subq.w	#3,$2C(a1)
		subi.w	#$40,obX(a1)
		move.l	$30(a0),$30(a1)
		move.l	a0,$38(a1)
		movea.l	a0,a2
		bsr.s	sub_B09C

loc_B07A:
		moveq	#0,d2
		lea	$36(a0),a2
		move.b	(a2)+,d2
		subq.b	#1,d2
		bcs.s	locret_B09A

loc_B086:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.w	#-$3000,d0
		movea.w	d0,a1
		move.w	d1,$3C(a1)
		dbf	d2,loc_B086

locret_B09A:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_B09C:
		lea	$36(a2),a2
		moveq	#0,d0
		move.b	(a2),d0
		addq.b	#1,(a2)
		lea	obRender(a2,d0.w),a2
		move.w	a1,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,(a2)
		rts	
; End of function sub_B09C

; ===========================================================================

Obj2F_ChkDel:				; XREF: Obj2F_Display
		tst.b	$35(a0)
		beq.s	loc_B0C6
		tst.b	obRender(a0)
		bpl.s	Obj2F_DelFlames

loc_B0C6:
		move.w	$2A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================

Obj2F_DelFlames:			; XREF: Obj2F_ChkDel
		moveq	#0,d2

loc_B0E8:
		lea	$36(a0),a2
		move.b	(a2),d2
		clr.b	(a2)+
		subq.b	#1,d2
		bcs.s	locret_B116

loc_B0F4:
		moveq	#0,d0
		move.b	(a2),d0
		clr.b	(a2)+
		lsl.w	#6,d0
		addi.w	#-$3000,d0
		movea.w	d0,a1
		bsr	DeleteObject2
		dbf	d2,loc_B0F4
		move.b	#0,$35(a0)
		move.b	#0,$34(a0)

locret_B116:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Collision data for large moving platforms (MZ)
; ---------------------------------------------------------------------------
Obj2F_Data1:	incbin	misc\mz_pfm1.bin
		even
Obj2F_Data2:	incbin	misc\mz_pfm2.bin
		even
Obj2F_Data3:	incbin	misc\mz_pfm3.bin
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 35 - fireball that sits on the	floor (MZ)
; (appears when	you walk on sinking platforms)
; ---------------------------------------------------------------------------

Obj35:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj35_Index(pc,d0.w),d1
		jmp	Obj35_Index(pc,d1.w)
; ===========================================================================
Obj35_Index:	dc.w Obj35_Main-Obj35_Index
		dc.w loc_B238-Obj35_Index
		dc.w Obj35_Move-Obj35_Index
; ===========================================================================

Obj35_Main:				; XREF: Obj35_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj14,obMap(a0)
		move.w	#$345,obGfx(a0)
		move.w	obX(a0),$2A(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#$8B,obColType(a0)
		move.b	#8,obActWid(a0)
		move.w	#$C8,d0
		jsr	(PlaySound_Special).l ;	play flame sound
		tst.b	obSubtype(a0)
		beq.s	loc_B238
		addq.b	#2,obRoutine(a0)
		bra.w	Obj35_Move
; ===========================================================================

loc_B238:				; XREF: Obj35_Index
		movea.l	$30(a0),a1
		move.w	obX(a0),d1
		sub.w	$2A(a0),d1
		addi.w	#$C,d1
		move.w	d1,d0
		lsr.w	#1,d0
		move.b	(a1,d0.w),d0
		neg.w	d0
		add.w	$2C(a0),d0
		move.w	d0,d2
		add.w	$3C(a0),d0
		move.w	d0,obY(a0)
		cmpi.w	#$84,d1
		bcc.s	loc_B2B0
		addi.l	#$10000,obX(a0)
		cmpi.w	#$80,d1
		bcc.s	loc_B2B0
		move.l	obX(a0),d0
		addi.l	#$80000,d0
		andi.l	#$FFFFF,d0
		bne.s	loc_B2B0
		bsr	SingleObjLoad2
		bne.s	loc_B2B0
		move.b	#$35,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	d2,$2C(a1)
		move.w	$3C(a0),$3C(a1)
		move.b	#1,obSubtype(a1)
		movea.l	$38(a0),a2
		bsr	sub_B09C

loc_B2B0:
		bra.s	Obj35_Animate
; ===========================================================================

Obj35_Move:				; XREF: Obj35_Index
		move.w	$2C(a0),d0
		add.w	$3C(a0),d0
		move.w	d0,obY(a0)

Obj35_Animate:				; XREF: loc_B238
		lea	(Ani_obj35).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
Ani_obj35:
		include	"_anim\obj35.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - large moving platforms (MZ)
; ---------------------------------------------------------------------------
Map_obj2F:
		include	"_maps\obj2F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - lava balls (MZ, SLZ)
; ---------------------------------------------------------------------------
Map_obj14:
		include	"_maps\obj14.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 30 - large green glassy blocks	(MZ)
; ---------------------------------------------------------------------------

Obj30:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj30_Index(pc,d0.w),d1
		jsr	obj30_Index(pc,d1.w)
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj30_Delete
		bra.w	DisplaySprite
; ===========================================================================

Obj30_Delete:
		bra.w	DeleteObject
; ===========================================================================
Obj30_Index:	dc.w Obj30_Main-Obj30_Index
		dc.w Obj30_Block012-Obj30_Index
		dc.w Obj30_Reflect012-Obj30_Index
		dc.w Obj30_Block34-Obj30_Index
		dc.w Obj30_Reflect34-Obj30_Index

Obj30_Vars1:	dc.b 2,	0, 0	; routine num, y-axis dist from	origin,	frame num
		dc.b 4,	0, 1
Obj30_Vars2:	dc.b 6,	0, 2
		dc.b 8,	0, 1
; ===========================================================================

Obj30_Main:				; XREF: Obj30_Index
		lea	(Obj30_Vars1).l,a2
		moveq	#1,d1
		move.b	#$48,obHeight(a0)
		cmpi.b	#3,obSubtype(a0)	; is object type 0/1/2 ?
		bcs.s	loc_B40C	; if yes, branch
		lea	(Obj30_Vars2).l,a2
		moveq	#1,d1
		move.b	#$38,obHeight(a0)

loc_B40C:
		movea.l	a0,a1
		bra.s	Obj30_Load	; load main object
; ===========================================================================

Obj30_Loop:
		bsr	SingleObjLoad2
		bne.s	loc_B480

Obj30_Load:				; XREF: Obj30_Main
		move.b	(a2)+,obRoutine(a1)
		move.b	#$30,0(a1)
		move.w	obX(a0),obX(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	obY(a0),d0
		move.w	d0,obY(a1)
		move.l	#Map_obj30,obMap(a1)
		move.w	#$C38E,obGfx(a1)
		move.b	#4,obRender(a1)
		move.w	obY(a1),$30(a1)
		move.b	obSubtype(a0),obSubtype(a1)
		move.b	#$20,obActWid(a1)
		move.b	#4,obPriority(a1)
		move.b	(a2)+,obFrame(a1)
		move.l	a0,$3C(a1)
		dbf	d1,Obj30_Loop	; repeat once to load "reflection object"

		move.b	#$10,obActWid(a1)
		move.b	#3,obPriority(a1)
		addq.b	#8,obSubtype(a1)
		andi.b	#$F,obSubtype(a1)

loc_B480:
		move.w	#$90,$32(a0)
		bset	#4,obRender(a0)

Obj30_Block012:				; XREF: Obj30_Index
		jsr	obj30_Types
		move.w	#$2B,d1
		move.w	#$48,d2
		move.w	#$49,d3
		move.w	obX(a0),d4
		bra.w	SolidObject
; ===========================================================================

Obj30_Reflect012:			; XREF: Obj30_Index
		movea.l	$3C(a0),a1
		move.w	$32(a1),$32(a0)
		bra.w	Obj30_Types
; ===========================================================================

Obj30_Block34:				; XREF: Obj30_Index
		jsr	obj30_Types
		move.w	#$2B,d1
		move.w	#$38,d2
		move.w	#$39,d3
		move.w	obX(a0),d4
		bra.w	SolidObject
; ===========================================================================

Obj30_Reflect34:			; XREF: Obj30_Index
		movea.l	$3C(a0),a1
		move.w	$32(a1),$32(a0)
		move.w	obY(a1),$30(a0)
		bra.w	*+4

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj30_Types:				; XREF: Obj30_Block012; et al
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj30_TypeIndex(pc,d0.w),d1
		jmp	Obj30_TypeIndex(pc,d1.w)
; End of function Obj30_Types

; ===========================================================================
Obj30_TypeIndex:dc.w Obj30_Type00-Obj30_TypeIndex
		dc.w Obj30_Type01-Obj30_TypeIndex
		dc.w Obj30_Type02-Obj30_TypeIndex
		dc.w Obj30_Type03-Obj30_TypeIndex
		dc.w Obj30_Type04-Obj30_TypeIndex
; ===========================================================================

Obj30_Type00:				; XREF: Obj30_TypeIndex
		rts	
; ===========================================================================

Obj30_Type01:				; XREF: Obj30_TypeIndex
		move.b	($FFFFFE70).w,d0
		move.w	#$40,d1
		bra.s	loc_B514
; ===========================================================================

Obj30_Type02:				; XREF: Obj30_TypeIndex
		move.b	($FFFFFE70).w,d0
		move.w	#$40,d1
		neg.w	d0
		add.w	d1,d0

loc_B514:				; XREF: Obj30_Type01
		btst	#3,obSubtype(a0)
		beq.s	loc_B526
		neg.w	d0
		add.w	d1,d0
		lsr.b	#1,d0
		addi.w	#$20,d0

loc_B526:
		bra.w	loc_B5EE
; ===========================================================================

Obj30_Type03:				; XREF: Obj30_TypeIndex
		btst	#3,obSubtype(a0)
		beq.s	loc_B53E
		move.b	($FFFFFE70).w,d0
		subi.w	#$10,d0
		bra.w	loc_B5EE
; ===========================================================================

loc_B53E:
		btst	#3,obStatus(a0)
		bne.s	loc_B54E
		bclr	#0,$34(a0)
		bra.s	loc_B582
; ===========================================================================

loc_B54E:
		tst.b	$34(a0)
		bne.s	loc_B582
		move.b	#1,$34(a0)
		bset	#0,$35(a0)
		beq.s	loc_B582
		bset	#7,$34(a0)
		move.w	#$10,$36(a0)
		move.b	#$A,$38(a0)
		cmpi.w	#$40,$32(a0)
		bne.s	loc_B582
		move.w	#$40,$36(a0)

loc_B582:
		tst.b	$34(a0)
		bpl.s	loc_B5AA
		tst.b	$38(a0)
		beq.s	loc_B594
		subq.b	#1,$38(a0)
		bne.s	loc_B5AA

loc_B594:
		tst.w	$32(a0)
		beq.s	loc_B5A4
		subq.w	#1,$32(a0)
		subq.w	#1,$36(a0)
		bne.s	loc_B5AA

loc_B5A4:
		bclr	#7,$34(a0)

loc_B5AA:
		move.w	$32(a0),d0
		bra.s	loc_B5EE
; ===========================================================================

Obj30_Type04:				; XREF: Obj30_TypeIndex
		btst	#3,obSubtype(a0)
		beq.s	Obj30_ChkSwitch
		move.b	($FFFFFE70).w,d0
		subi.w	#$10,d0
		bra.s	loc_B5EE
; ===========================================================================

Obj30_ChkSwitch:			; XREF: Obj30_Type04
		tst.b	$34(a0)
		bne.s	loc_B5E0
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; load object type number
		lsr.w	#4,d0		; read only the	first nybble
		tst.b	(a2,d0.w)	; has switch number d0 been pressed?
		beq.s	loc_B5EA	; if not, branch
		move.b	#1,$34(a0)

loc_B5E0:
		tst.w	$32(a0)
		beq.s	loc_B5EA
		subq.w	#2,$32(a0)

loc_B5EA:
		move.w	$32(a0),d0

loc_B5EE:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - large green	glassy blocks (MZ)
; ---------------------------------------------------------------------------
Map_obj30:
		include	"_maps\obj30.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 31 - stomping metal blocks on chains with spikes (MZ)
; ---------------------------------------------------------------------------

Obj31:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj31_Index(pc,d0.w),d1
		jmp	Obj31_Index(pc,d1.w)
; ===========================================================================
Obj31_Index:	dc.w Obj31_Main-Obj31_Index
		dc.w loc_B798-Obj31_Index
		dc.w loc_B7FE-Obj31_Index
		dc.w Obj31_ChkDel-Obj31_Index
		dc.w loc_B7E2-Obj31_Index

Obj31_SwchNums:	dc.b 0,	0		; switch number, obj number
		dc.b 1,	0

Obj31_Var:	dc.b 2,	0, 0
		dc.b 4,	$1C, 1		; routine number, y-position, frame number
		dc.b 8,	$CC, 3
		dc.b 6,	$F0, 2

word_B6A4:	dc.w $7000, $A000
		dc.w $5000, $7800
		dc.w $3800, $5800
		dc.w $B800
; ===========================================================================

Obj31_Main:				; XREF: Obj31_Index
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		bpl.s	loc_B6CE	
		andi.w	#$7F,d0
		add.w	d0,d0
		lea	Obj31_SwchNums(pc,d0.w),a2
		move.b	(a2)+,$3A(a0)
		move.b	(a2)+,d0
		move.b	d0,obSubtype(a0)

loc_B6CE:
		andi.b	#$F,d0
		add.w	d0,d0
		move.w	word_B6A4(pc,d0.w),d2
		tst.w	d0
		bne.s	loc_B6E0
		move.w	d2,$32(a0)

loc_B6E0:
		lea	(Obj31_Var).l,a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj31_MakeStomper
; ===========================================================================

Obj31_Loop:
		bsr	SingleObjLoad2
		bne.w	Obj31_SetSize

Obj31_MakeStomper:			; XREF: Obj31_Main
		move.b	(a2)+,obRoutine(a1)
		move.b	#$31,0(a1)
		move.w	obX(a0),obX(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	obY(a0),d0
		move.w	d0,obY(a1)
		move.l	#Map_obj31,obMap(a1)
		move.w	#$300,obGfx(a1)
		move.b	#4,obRender(a1)
		move.w	obY(a1),$30(a1)
		move.b	obSubtype(a0),obSubtype(a1)
		move.b	#$10,obActWid(a1)
		move.w	d2,$34(a1)
		move.b	#4,obPriority(a1)
		move.b	(a2)+,obFrame(a1)
		cmpi.b	#1,obFrame(a1)
		bne.s	loc_B76A
		subq.w	#1,d1
		move.b	obSubtype(a0),d0
		andi.w	#$F0,d0
		cmpi.w	#$20,d0
		beq.s	Obj31_MakeStomper
		move.b	#$38,obActWid(a1)
		move.b	#$90,obColType(a1)
		addq.w	#1,d1
		tst.b	($FFFFFFE7).w
		beq.s	loc_B76A		; if not, branch
		ori.w	#$6000,obGfx(a1)	; use palette line four from now now

loc_B76A:
		move.l	a0,$3C(a1)
		dbf	d1,Obj31_Loop

		move.b	#3,obPriority(a1)

Obj31_SetSize:
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsr.w	#3,d0
		andi.b	#$E,d0
		lea	Obj31_Var2(pc,d0.w),a2
		move.b	(a2)+,obActWid(a0)
		move.b	(a2)+,obFrame(a0)
		bra.s	loc_B798
; ===========================================================================
Obj31_Var2:	dc.b $38, 0		; width, frame number
		dc.b $30, 9
		dc.b $10, $A
; ===========================================================================

loc_B798:				; XREF: Obj31_Index
		jsr	obj31_Types
		move.w	obY(a0),($FFFFF7A4).w
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		move.w	#$C,d2
		move.w	#$D,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		btst	#3,obStatus(a0)
		beq.s	Obj31_Display
		cmpi.b	#$10,$32(a0)
		bcc.s	Obj31_Display
		movea.l	a0,a2
		lea	($FFFFD000).w,a0
		jsr	KillSonic
		movea.l	a2,a0

Obj31_Display:
		bra.w	Obj31_ChkDel
; ===========================================================================

loc_B7E2:				; XREF: Obj31_Index
		move.b	#$80,obHeight(a0)
		bset	#4,obRender(a0)
		movea.l	$3C(a0),a1
		move.b	$32(a1),d0
		lsr.b	#5,d0
		addq.b	#3,d0
		move.b	d0,obFrame(a0)

loc_B7FE:				; XREF: Obj31_Index
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$32(a1),d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)

Obj31_ChkDel:				; XREF: Obj31_Display
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bsr	DisplaySprite
		rts	
; ===========================================================================

Obj31_Types:				; XREF: loc_B798
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj31_TypeIndex(pc,d0.w),d1
		jmp	Obj31_TypeIndex(pc,d1.w)
; ===========================================================================
Obj31_TypeIndex:dc.w Obj31_Type00-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type03-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
		dc.w Obj31_Type03-Obj31_TypeIndex
		dc.w Obj31_Type01-Obj31_TypeIndex
; ===========================================================================

Obj31_Type00:				; XREF: Obj31_TypeIndex
		lea	($FFFFF7E0).w,a2 ; load	switch statuses
		moveq	#0,d0
		move.b	$3A(a0),d0	; move number 0	or 1 to	d0
		tst.b	(a2,d0.w)	; has switch (d0) been pressed?
		bne.s	@cont		; if yes, branch
		
		tst.b	($FFFFFF73).w		; has P monitor been broken in Ruined Place?
		bne.s	@cont			; if yes, branch
		btst	#0,($FFFFFF6C).w	; has switch 1 been pressed?
		beq.s	loc_B8A8		; if not, branch

@cont:
		tst.w	($FFFFF7A4).w
		bpl.s	loc_B872
		cmpi.b	#$10,$32(a0)
		beq.s	loc_B8A0

loc_B872:
		tst.w	$32(a0)
		beq.s	loc_B8A0
		move.b	($FFFFFE05).w,d0
		andi.b	#$F,d0
		bne.s	loc_B892
		tst.b	obRender(a0)
		bpl.s	loc_B892
		move.w	#$C7,d0
		jsr	(PlaySound_Special).l ;	play rising chain sound

loc_B892:
		subi.w	#$100,$32(a0)
		bcc.s	Obj31_Restart
		move.w	#0,$32(a0)

loc_B8A0:
		move.w	#0,obVelY(a0)
		bra.s	Obj31_Restart
; ===========================================================================

loc_B8A8:				; XREF: Obj31_Type00
		move.w	$34(a0),d1
		cmp.w	$32(a0),d1
		beq.s	Obj31_Restart
		move.w	obVelY(a0),d0
		addi.w	#$70,obVelY(a0)	; make object fall
		add.w	d0,$32(a0)
		cmp.w	$32(a0),d1
		bhi.s	Obj31_Restart
		move.w	d1,$32(a0)
		move.w	#0,obVelY(a0)	; stop object falling
		tst.b	obRender(a0)
		bpl.s	Obj31_Restart
		ori.b	#10,(CameraShake).w
		move.w	#$BD,d0
		jsr	(PlaySound_Special).l ;	play stomping sound

Obj31_Restart:
		moveq	#0,d0
		move.b	$32(a0),d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		rts	
; ===========================================================================

Obj31_Type01:				; XREF: Obj31_TypeIndex
		tst.w	$36(a0)
		beq.s	loc_B938
		tst.w	$38(a0)
		beq.s	loc_B902
		subq.w	#1,$38(a0)
		bra.w	loc_B97C
; ===========================================================================

loc_B902:
		move.b	($FFFFFE05).w,d0
		andi.b	#$F,d0
		bne.s	loc_B91C
		tst.b	obRender(a0)
		bpl.s	loc_B91C
		move.w	#$C7,d0
		jsr	(PlaySound_Special).l ;	play rising chain sound

loc_B91C:
		subi.w	#$80,$32(a0)
		bcc.s	loc_B97C
		move.w	#0,$32(a0)
		move.w	#0,obVelY(a0)
		move.w	#0,$36(a0)
		bra.s	loc_B97C
; ===========================================================================

loc_B938:				; XREF: Obj31_Type01
		move.w	$34(a0),d1
		cmp.w	$32(a0),d1
		beq.s	loc_B97C
		move.w	obVelY(a0),d0
		addi.w	#$70,obVelY(a0)	; make object fall
		add.w	d0,$32(a0)
		cmp.w	$32(a0),d1
		bhi.s	loc_B97C
		move.w	d1,$32(a0)
		move.w	#0,obVelY(a0)	; stop object falling
		move.w	#1,$36(a0)
		move.w	#$3C,$38(a0)
		tst.b	obRender(a0)
		bpl.s	loc_B97C
		ori.b	#10,(CameraShake).w
		move.w	#$BD,d0
		jsr	(PlaySound_Special).l ;	play stomping sound

loc_B97C:
		bra.w	Obj31_Restart
; ===========================================================================

Obj31_Type03:				; XREF: Obj31_TypeIndex
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_B98C
		neg.w	d0

loc_B98C:
		cmpi.w	#$90,d0
		bcc.s	loc_B996
		addq.b	#1,obSubtype(a0)

loc_B996:
		bra.w	Obj31_Restart
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 45 - spiked sideways metal block from beta version (MZ)
; ---------------------------------------------------------------------------

Obj45:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj45_Index(pc,d0.w),d1
		jmp	Obj45_Index(pc,d1.w)
; ===========================================================================
Obj45_Index:	dc.w Obj45_Main-Obj45_Index
		dc.w Obj45_Solid-Obj45_Index
		dc.w loc_BA8E-Obj45_Index
		dc.w Obj45_ChkDel-Obj45_Index
		dc.w loc_BA7A-Obj45_Index

Obj45_Var:	dc.b	2,   4,	  0	; routine number, x-position, frame number
		dc.b	4, $E4,	  1
		dc.b	8, $34,	  3
		dc.b	6, $28,	  2

word_B9BE:	dc.w $3800
		dc.w $A000
		dc.w $5000
; ===========================================================================

Obj45_Main:				; XREF: Obj45_Index
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		move.w	word_B9BE(pc,d0.w),d2
		lea	(Obj45_Var).l,a2
		movea.l	a0,a1
		moveq	#1,d1
		bra.s	Obj45_Load
; ===========================================================================

Obj45_Loop:
		bsr	SingleObjLoad2
		bne.s	loc_BA52

Obj45_Load:				; XREF: Obj45_Main
		move.b	(a2)+,obRoutine(a1)
		move.b	#$45,0(a1)
		move.w	obY(a0),obY(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	obX(a0),d0
		move.w	d0,obX(a1)
		move.l	#Map_obj45,obMap(a1)
		move.w	#$300,obGfx(a1)
		move.b	#4,obRender(a1)
		move.w	obX(a1),$30(a1)
		move.w	obX(a0),$3A(a1)
		move.b	obSubtype(a0),obSubtype(a1)
		move.b	#$20,obActWid(a1)
		move.w	d2,$34(a1)
		move.b	#4,obPriority(a1)
		cmpi.b	#1,(a2)
		bne.s	loc_BA40
		move.b	#$91,obColType(a1)
		ori.w	#$6000,obGfx(a1)	; use palette line four from now now

loc_BA40:
		move.b	(a2)+,obFrame(a1)
		move.l	a0,$3C(a1)
		dbf	d1,Obj45_Loop	; repeat 3 times
		

		move.b	#3,obPriority(a1)

loc_BA52:
		move.b	#$10,obActWid(a0)

Obj45_Solid:				; XREF: Obj45_Index
		move.w	obX(a0),-(sp)
		jsr	obj45_Move
		move.w	#$17,d1
		move.w	#$20,d2
		move.w	#$20,d3
		move.w	(sp)+,d4
		bsr	SolidObject
		bra.w	Obj45_ChkDel
; ===========================================================================

loc_BA7A:				; XREF: Obj45_Index
		movea.l	$3C(a0),a1
		move.b	$32(a1),d0
		addi.b	#$10,d0
		lsr.b	#5,d0
		addq.b	#3,d0
		move.b	d0,obFrame(a0)

loc_BA8E:				; XREF: Obj45_Index
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$32(a1),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,obX(a0)

Obj45_ChkDel:				; XREF: Obj45_Solid
		btst	#2,($FFFFFF6C).w ; was switch in MZ pressed?
		beq.s	@cont		; if not, branch
		bra.w	DeleteObject	; delete object
		
@cont:
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj45_Move:				; XREF: Obj45_Solid
		rts	; no movement
		
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		move.w	off_BAD6(pc,d0.w),d1
		jmp	off_BAD6(pc,d1.w)
; End of function Obj45_Move

; ===========================================================================
off_BAD6:	dc.w loc_BADA-off_BAD6
		dc.w loc_BADA-off_BAD6
; ===========================================================================

loc_BADA:				; XREF: off_BAD6
		tst.w	$36(a0)
		beq.s	loc_BB08
		tst.w	$38(a0)
		beq.s	loc_BAEC
		subq.w	#1,$38(a0)
		bra.s	loc_BB3C
; ===========================================================================

loc_BAEC:
		subi.w	#$80,$32(a0)
		bcc.s	loc_BB3C
		move.w	#0,$32(a0)
		move.w	#0,obVelX(a0)
		move.w	#0,$36(a0)
		bra.s	loc_BB3C
; ===========================================================================

loc_BB08:				; XREF: loc_BADA
		move.w	$34(a0),d1
		cmp.w	$32(a0),d1
		beq.s	loc_BB3C
		move.w	obVelX(a0),d0
		addi.w	#$70,obVelX(a0)
		add.w	d0,$32(a0)
		cmp.w	$32(a0),d1
		bhi.s	loc_BB3C
		move.w	d1,$32(a0)
		move.w	#0,obVelX(a0)
		move.w	#1,$36(a0)
		move.w	#$3C,$38(a0)

loc_BB3C:
		moveq	#0,d0
		move.b	$32(a0),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,obX(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - metal stomping blocks on chains (MZ)
; ---------------------------------------------------------------------------
Map_obj31:
		include	"_maps\obj31.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked metal block from beta version (MZ)
; ---------------------------------------------------------------------------
Map_obj45:
		include	"_maps\obj45.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 32 - switches (MZ, SYZ, LZ, SBZ) Buttons / Button
; ---------------------------------------------------------------------------

Obj32:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj32_Index(pc,d0.w),d1
		jmp	Obj32_Index(pc,d1.w)
; ===========================================================================
Obj32_Index:	dc.w Obj32_Main-Obj32_Index
		dc.w Obj32_Pressed-Obj32_Index
; ===========================================================================

Obj32_Main:				; XREF: Obj32_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj32,obMap(a0)

		move.w	#$513,obGfx(a0)		; default maps
		
		cmpi.b	#5,($FFFFFE10).w	; is level SBZ?
		bne.s	@switchcheckmz		; if not, branch
		move.w	#($7120/$20),obGfx(a0)	; SBZ maps
@switchcheckmz:
		cmpi.b	#2,($FFFFFE10).w	; is level MZ?
		bne.s	@switchchecklz		; if not, branch
		move.w	#$4513,obGfx(a0)		; MZ maps
@switchchecklz:	
		cmpi.b	#1,($FFFFFE10).w	; is level LZ?
		bne.s	@switchcheckslz		; if not, branch
		move.w	#$513,obGfx(a0)		; LZ maps
@switchcheckslz:
		cmpi.b	#3,($FFFFFE10).w	; is level SLZ?
		bne.s	@switchcheckend		; if not, branch
		move.w	#$480,obGfx(a0)		; SLZ maps

@switchcheckend:
		move.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#4,obPriority(a0)
		addq.w	#3,obY(a0)
; ---------------------------------------------------------------------------

Obj32_Pressed:				; XREF: Obj32_Index
		tst.b	obRender(a0)
		bpl.w	Obj32_Display
		move.w	#$1B,d1
		move.w	#5,d2
		move.w	#5,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		bclr	#0,obFrame(a0)	; use "unpressed" frame
		cmpi.b	#$3,($FFFFFE10).w
		bne.s	@cont
		move.b	#1,obFrame(a0)
@cont:
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		lea	($FFFFF7E0).w,a3
		lea	(a3,d0.w),a3
		moveq	#0,d3
		btst	#6,obSubtype(a0)
		beq.s	loc_BDB2
		moveq	#7,d3

loc_BDB2:
		tst.b	obSubtype(a0)
		bpl.s	loc_BDBE
		jsr	obj32_MZBlock
		bne.s	loc_BDC8

loc_BDBE:
		tst.b	ob2ndRout(a0)
		bne.s	loc_BDC8
		bclr	d3,(a3)
		bra.w	Obj32_Display
; ===========================================================================

loc_BDC8:
		cmpi.w	#$502,($FFFFFE10).w	; is level FP?
		beq.w	loc_BDD6		; if yes, branch
		tst.b	(a3)			; has switch already been pressed in the previous frame?
		bne.w	Obj32_ShowPressed	; if yes, branch
		move.w	#$CD,d0			; play switch sound
		jsr	(PlaySound).l

loc_BDD6:
		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		bne.s	@notmzswitch		; if not, branch
		cmpi.b	#$81,obSubtype(a0)		; was first switch pressed? (for spiked girder)
		bne.s	@cont1
		bset	#0,($FFFFFF6C).w	; set the "switch in MZ was pressed flag" 1
		bra.w	Obj32_ShowPressed
@cont1:
		cmpi.b	#$82,obSubtype(a0)		; was second switch pressed? (for smashable blocks)
		bne.s	@cont2
		btst	#1,($FFFFFF6C).w	; is flag already set?
		bne.s	@PlaySound			; don't change palette
		bset	#1,($FFFFFF6C).w	; set the "switch in MZ was pressed flag" 2
		jsr 	ChangePaletteRP

@PlaySound:
		move.w	#$C3,d0			; play giant ring sound (this is when you get the stars)
		jsr	(PlaySound).l
		bra.w	Obj32_ShowPressed
@cont2:
		cmpi.b	#$83,obSubtype(a0)		; was third switch pressed? (for horizontal stomper)
		bne.s	@notmzswitch
		btst	#2,($FFFFFF6C).w	; is flag already set?
		bne.s	@PlaySound2

		bset	#2,($FFFFFF6C).w	; set the "switch in MZ was pressed flag" 3
		jsr 	ChangePaletteRP

@PlaySound2:
		; move.w	#$B7,d0			; play LZ rumbling sound
		move.w	#$C3,d0			; play giant ring sound
		jsr	(PlaySound).l
		bra.w	Obj32_ShowPressed
; ---------------------------------------------------------------------------

@notmzswitch:
		cmpi.b	#$5,($FFFFFE10).w	; is this the tutorial or FP?
		bne.s	@nottutorialswitch	; if not, branch
		move.w	#-$1800,d1		; set first launch speed for escape sequence switch
		cmpi.b	#$2,($FFFFFE11).w	; specifically FP?
		beq.w	@Explode		; if yes, branch

		tst.b	($FFFFFF77).w		; is antigrav already enabled?
		bne.w	Obj32_ShowPressed	; if yes, branch
		move.b	#1,($FFFFFF77).w	; enable antigrav ability
		tst.b	($FFFFFFE7).w		; did the player make it here with inhuman still enabled?
		beq.s	@notinhuman		; if not, branch
		clr.b	($FFFFFFE7).w		; disable inhuman mode
		movem.l	d7/a1-a3,-(sp)
		moveq	#3,d0
		jsr	PalLoad2		; load Sonic palette
		
		movem.l	(sp)+,d7/a1-a3
@notinhuman:
		move.b	#$A8,d0			; play upgrade sound
		jsr	PlaySound_Special
		bra.w	Obj32_ShowPressed
; ---------------------------------------------------------------------------

@nottutorialswitch:
		cmpi.w	#$302,($FFFFFE10).w	; is this Star Agony Place?
		bne.w	Obj32_ShowPressed	; if not, branch
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	@notnonstopinhuman	; if not, branch	
		move.b	#$3F,0(a0)		; change switch into explodion (no double fun allowed, sorry)
		move.b	#0,obRoutine(a0)	; set to initial routine
		move.b	#0,$31(a0)
		rts				; don't do anything else

@notnonstopinhuman:
		move.w	#-$1000,d1		; default speed
		move.b	#0,($FFFFF7CC).w	; unlock controls
		tst.b	($FFFFFF77).w		; is antigrav already enabled?
		bne.w	@Explode		; if yes, branch
		move.b	#1,($FFFFFF77).w	; enable antigrav ability
		move.b	#1,($FFFFF7CC).w	; lock controls
		clr.w	($FFFFD010).w		; shoot sonic straight up
		clr.l	($FFFFF602).w		; clear any remaining button presses
		move.b	#$96,d0			; play the sick music
		jsr	PlaySound		; hell yea
		move.w	#-$1800,d1		; set first launch speed (needs to be different cause of the alternate gravity)
		jsr	SAP_LoadSonicPal	; load Sonic's antigrav palette

@nopal:
		frantic				; is frantic mode enabled?
		beq.s	@loadwarningsign	; if not, branch
		addi.w	#100,($FFFFFE20).w	; be generous and give the brave troopers 100 extra rings
		cmpi.w	#999,($FFFFFE20).w	; did we exceed the maximum?
		bls.s	@nocap			; if not, branch
		move.w	#999,($FFFFFE20).w	; cap rings
@nocap:		ori.b	#1,($FFFFFE1D).w	; update rings counter

@loadwarningsign:
		; tried this first, looked super annoying and distracting
		; so now it's just static level objects
	;	jsr	SingleObjLoad
	;	bne.s	@Explode
	;	move.b	#$4F,(a1)	; load yellow warning sign object for bottomless pits
@Explode:
		lea	$FFFFD000,a1
		move.w	d1,obVelY(a1)	; move Sonic upwards
		addq.w	#8,obY(a1)
		bset	#1,obStatus(a1) ; in air
		bset	#2,obStatus(a1) ; rolling
		bclr	#3,obStatus(a1) ; not standing
		move.b	#$25,obAnim(a1)	; use inhuman rotate animation
		move.b	#2,obRoutine(a1)
		move.b	#1,($FFFFFFEB).w	; set jumpdash flag

		move.b	#$DB,d0			; play epic explosion sound
		jsr	PlaySound_Special
		jsr	WhiteFlash2

		move.w	($FFFFD108).w,d0
		cmp.w	($FFFFD130).w,d0 ; has title card sequence finished?
		bne.s	@skipexplosions	; if not, branch
		jsr	SingleObjLoad
		bne.s	@endboom
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$31(a1)	; mute explosion sound (to not override the epic one)

@skipexplosions:
		cmpi.w	#$502,($FFFFFE10).w	; is this FP specifically?
		bne.s	@endboom		; if not, branch
		jmp	DeleteObject		; only boom once
@endboom:
		rts
; ---------------------------------------------------------------------------

Obj32_ShowPressed:
		bset	d3,(a3)
		bset	#0,obFrame(a0)	; use "pressed"	frame
		cmpi.b	#$3,($FFFFFE10).w
		bne.s	Obj32_Display
		move.b	#4,obFrame(a0)

Obj32_Display:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

ChangePaletteRP:
		btst	#3, OptionsBits		; is cinematic HUD enabled?
		bne.s 	@FuckNo				; accomodate for piss filter

		lea 	($FFFFFB48).w, a2
		moveq 	#3, d0

@SubtractGraysLoop:
		subi.w 	#$0222, (a2)+
		dbf 	d0, @SubtractGraysLoop

		lea 	($FFFFFB72).w, a2
		moveq	#2, d0

@SubtractBluesLoop:
		subi.w 	#$0200, (a2)+
		dbf 	d0, @SubtractBluesLoop

		subi.b 	#2,($FFFFFB7C).w ; cloud extra
		subi.b 	#2,($FFFFFB40).w ; sky
		move.w	#$0008,($FFFFFB6A).w ; lava
		move.w	#$004E,($FFFFFB6C).w ; lava

		jsr		WhiteFlash2

@FuckNo:
		rts

; ===========================================================================

RestorePaletteRP:
		lea 	($FFFFFB48).w, a2
		moveq 	#3, d0

@SubtractGraysLoop:
		addi.w 	#$0222, (a2)+
		dbf 	d0, @SubtractGraysLoop

		lea 	($FFFFFB72).w, a2
		moveq	#2, d0

@SubtractBluesLoop:
		addi.w 	#$0200, (a2)+
		dbf 	d0, @SubtractBluesLoop

		addi.b 	#2,($FFFFFB7C).w ; cloud extra
		addi.b 	#2,($FFFFFB40).w ; sky
		move.w	#$0228,($FFFFFB6A).w ; lava
		move.w	#$026C,($FFFFFB6C).w ; lava

		jsr	WhiteFlash2

		rts
; ===========================================================================


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj32_MZBlock:				; XREF: Obj32_Pressed
		move.w	d3,-(sp)
		move.w	obX(a0),d2
		move.w	obY(a0),d3
		subi.w	#$10,d2
		subq.w	#8,d3
		move.w	#$20,d4
		move.w	#$10,d5
		lea	($FFFFD800).w,a1 ; begin checking object RAM
		move.w	#$5F,d6

Obj32_MZLoop:
		tst.b	obRender(a1)
		bpl.s	loc_BE4E
		cmpi.b	#$33,(a1)	; is the object	a green	MZ block?
		beq.s	loc_BE5E	; if yes, branch

loc_BE4E:
		lea	$40(a1),a1	; check	next object
		dbf	d6,Obj32_MZLoop	; repeat $5F times

		move.w	(sp)+,d3
		moveq	#0,d0

locret_BE5A:
		rts	
; ===========================================================================
Obj32_MZData:	dc.b $10, $10
; ===========================================================================

loc_BE5E:				; XREF: Obj32_MZBlock
		moveq	#1,d0
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	Obj32_MZData-obGfx(pc,d0.w),a2
		move.b	(a2)+,d1
		ext.w	d1
		move.w	obX(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_BE80
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_BE84
		bra.s	loc_BE4E
; ===========================================================================

loc_BE80:
		cmp.w	d4,d0
		bhi.s	loc_BE4E

loc_BE84:
		move.b	(a2)+,d1
		ext.w	d1
		move.w	obY(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_BE9A
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	loc_BE9E
		bra.s	loc_BE4E
; ===========================================================================

loc_BE9A:
		cmp.w	d5,d0
		bhi.s	loc_BE4E

loc_BE9E:
		move.w	(sp)+,d3
		moveq	#1,d0
		rts	
; End of function Obj32_MZBlock

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - switches (MZ, SYZ, LZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj32:
		include	"_maps\obj32.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 33 - pushable blocks (MZ, LZ)
; ---------------------------------------------------------------------------

Obj33:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj33_Index(pc,d0.w),d1
		jmp	Obj33_Index(pc,d1.w)
; ===========================================================================
Obj33_Index:	dc.w Obj33_Main-Obj33_Index
		dc.w loc_BF6E-Obj33_Index
		dc.w loc_C02C-Obj33_Index

Obj33_Var:	dc.b $10, 0	; object width,	frame number
		dc.b $40, 1
; ===========================================================================

Obj33_Main:				; XREF: Obj33_Index
		addq.b	#2,obRoutine(a0)
		move.b	#$F,obHeight(a0)
		move.b	#$F,obWidth(a0)
		move.l	#Map_obj33,obMap(a0)
		move.w	#$42B8,obGfx(a0)	; MZ specific code
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_BF16
		move.w	#$43DE,obGfx(a0)	; LZ specific code

loc_BF16:
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.w	obX(a0),$34(a0)
		move.w	obY(a0),$36(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		andi.w	#$E,d0
		lea	Obj33_Var(pc,d0.w),a2
		move.b	(a2)+,obActWid(a0)
		move.b	(a2)+,obFrame(a0)
		tst.b	obSubtype(a0)
		beq.s	Obj33_ChkGone
		move.w	#$C2B8,obGfx(a0)

Obj33_ChkGone:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_BF6E
		bclr	#7,obGfx(a2,d0.w)
		bset	#0,obGfx(a2,d0.w)
		bne.w	DeleteObject

loc_BF6E:				; XREF: Obj33_Index
		tst.b	$32(a0)
		bne.w	loc_C046
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	obX(a0),d4
		bsr	loc_C186
		cmpi.w	#$200,($FFFFFE10).w ; is the level MZ act 1?
		bne.s	loc_BFC6	; if not, branch
		bclr	#7,obSubtype(a0)
		move.w	obX(a0),d0
		cmpi.w	#$A20,d0
		bcs.s	loc_BFC6
		cmpi.w	#$AA1,d0
		bcc.s	loc_BFC6
		move.w	($FFFFF7A4).w,d0
		subi.w	#$1C,d0
		move.w	d0,obY(a0)
		bset	#7,($FFFFF7A4).w
		bset	#7,obSubtype(a0)

loc_BFC6:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_BFE6
		bra.w	DisplaySprite
; ===========================================================================

loc_BFE6:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_C016
		move.w	$34(a0),obX(a0)
		move.w	$36(a0),obY(a0)
		move.b	#4,obRoutine(a0)
		bra.s	loc_C02C
; ===========================================================================

loc_C016:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_C028
		bclr	#0,obGfx(a2,d0.w)

loc_C028:
		bra.w	DeleteObject
; ===========================================================================

loc_C02C:				; XREF: Obj33_Index
		bsr	ChkObjOnScreen2
		beq.s	locret_C044
		move.b	#2,obRoutine(a0)
		clr.b	$32(a0)
		clr.w	obVelX(a0)
		clr.w	obVelY(a0)

locret_C044:
		rts	
; ===========================================================================

loc_C046:				; XREF: loc_BF6E
		move.w	obX(a0),-(sp)
		cmpi.b	#4,ob2ndRout(a0)
		bcc.s	loc_C056
		bsr	SpeedToPos

loc_C056:
		btst	#1,obStatus(a0)
		beq.s	loc_C0A0
		addi.w	#$18,obVelY(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	loc_C09E
		add.w	d1,obY(a0)
		clr.w	obVelY(a0)
		bclr	#1,obStatus(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$16A,d0
		bcs.s	loc_C09E
		move.w	$30(a0),d0
		asr.w	#3,d0
		move.w	d0,obVelX(a0)
		move.b	#1,$32(a0)
		clr.w	$E(a0)

loc_C09E:
		bra.s	loc_C0E6
; ===========================================================================

loc_C0A0:
		tst.w	obVelX(a0)
		beq.w	loc_C0D6
		bmi.s	loc_C0BC
		moveq	#0,d3
		move.b	obActWid(a0),d3
		jsr	ObjHitWallRight
		tst.w	d1		; has block touched a wall?
		bmi.s	Obj33_StopPush	; if yes, branch
		bra.s	loc_C0E6
; ===========================================================================

loc_C0BC:
		moveq	#0,d3
		move.b	obActWid(a0),d3
		not.w	d3
		jsr	ObjHitWallLeft
		tst.w	d1		; has block touched a wall?
		bmi.s	Obj33_StopPush	; if yes, branch
		bra.s	loc_C0E6
; ===========================================================================

Obj33_StopPush:
		clr.w	obVelX(a0)		; stop block moving
		bra.s	loc_C0E6
; ===========================================================================

loc_C0D6:
		addi.l	#$2001,obY(a0)
		cmpi.b	#-$60,$F(a0)
		bcc.s	loc_C104

loc_C0E6:
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	(sp)+,d4
		bsr	loc_C186
		bsr.s	Obj33_ChkLava
		bra.w	loc_BFC6
; ===========================================================================

loc_C104:
		move.w	(sp)+,d4
		lea	($FFFFD000).w,a1
		bclr	#3,obStatus(a1)
		bclr	#3,obStatus(a0)
		bra.w	loc_BFE6
; ===========================================================================

Obj33_ChkLava:
		cmpi.w	#$201,($FFFFFE10).w ; is the level MZ act 2?
		bne.s	Obj33_ChkLava2	; if not, branch
		move.w	#-$20,d2
		cmpi.w	#$DD0,obX(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$CC0,obX(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$BA0,obX(a0)
		beq.s	Obj33_LoadLava
		rts	
; ===========================================================================

Obj33_ChkLava2:
		cmpi.w	#$202,($FFFFFE10).w ; is the level MZ act 3?
		bne.s	Obj33_NoLava	; if not, branch
		move.w	#$20,d2
		cmpi.w	#$560,obX(a0)
		beq.s	Obj33_LoadLava
		cmpi.w	#$5C0,obX(a0)
		beq.s	Obj33_LoadLava

Obj33_NoLava:
		rts	
; ===========================================================================

Obj33_LoadLava:
		bsr	SingleObjLoad
		bne.s	locret_C184
		move.b	#$4C,0(a1)	; load lava geyser object
		move.w	obX(a0),obX(a1)
		add.w	d2,obX(a1)
		move.w	obY(a0),obY(a1)
		addi.w	#$10,obY(a1)
		move.l	a0,$3C(a1)

locret_C184:
		rts	
; ===========================================================================

loc_C186:				; XREF: loc_BF6E
		move.b	ob2ndRout(a0),d0
		beq.w	loc_C218
		subq.b	#2,d0
		bne.s	loc_C1AA
		bsr	ExitPlatform
		btst	#3,obStatus(a1)
		bne.s	loc_C1A4
		clr.b	ob2ndRout(a0)
		rts	
; ===========================================================================

loc_C1A4:
		move.w	d4,d2
		bra.w	MvSonicOnPtfm
; ===========================================================================

loc_C1AA:
		subq.b	#2,d0
		bne.s	loc_C1F2
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_C1F0
		add.w	d1,obY(a0)
		clr.w	obVelY(a0)
		clr.b	ob2ndRout(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$16A,d0
		bcs.s	locret_C1F0
		move.w	$30(a0),d0
		asr.w	#3,d0
		move.w	d0,obVelX(a0)
		move.b	#1,$32(a0)
		clr.w	$E(a0)

locret_C1F0:
		rts	
; ===========================================================================

loc_C1F2:
		bsr	SpeedToPos
		move.w	obX(a0),d0
		andi.w	#$C,d0
		bne.w	locret_C2E4
		andi.w	#-$10,obX(a0)
		move.w	obVelX(a0),$30(a0)
		clr.w	obVelX(a0)
		subq.b	#2,ob2ndRout(a0)
		rts	
; ===========================================================================

loc_C218:
		bsr	loc_FAC8
		tst.w	d4
		beq.w	locret_C2E4
		bmi.w	locret_C2E4
		tst.b	$32(a0)
		beq.s	loc_C230
		bra.w	locret_C2E4
; ===========================================================================

loc_C230:
		tst.w	d0
		beq.w	locret_C2E4
		bmi.s	loc_C268
		btst	#0,obStatus(a1)
		bne.w	locret_C2E4
		move.w	d0,-(sp)
		moveq	#0,d3
		move.b	obActWid(a0),d3
		jsr	ObjHitWallRight
		move.w	(sp)+,d0
		tst.w	d1
		bmi.w	locret_C2E4
		addi.l	#$10000,obX(a0)
		moveq	#1,d0
		move.w	#$40,d1
		bra.s	loc_C294
; ===========================================================================

loc_C268:
		btst	#0,obStatus(a1)
		beq.s	locret_C2E4
		move.w	d0,-(sp)
		moveq	#0,d3
		move.b	obActWid(a0),d3
		not.w	d3
		jsr	ObjHitWallLeft
		move.w	(sp)+,d0
		tst.w	d1
		bmi.s	locret_C2E4
		subi.l	#$10000,obX(a0)
		moveq	#-1,d0
		move.w	#-$40,d1

loc_C294:
		lea	($FFFFD000).w,a1
		add.w	d0,obX(a1)
		move.w	d1,obInertia(a1)
		move.w	#0,obVelX(a1)
		move.w	d0,-(sp)
		move.w	#$A7,d0
		jsr	(PlaySound_Special).l ;	play pushing sound
		move.w	(sp)+,d0
		tst.b	obSubtype(a0)
		bmi.s	locret_C2E4
		move.w	d0,-(sp)
		jsr	ObjHitFloor
		move.w	(sp)+,d0
		cmpi.w	#4,d1
		ble.s	loc_C2E0
		move.w	#$400,obVelX(a0)
		tst.w	d0
		bpl.s	loc_C2D8
		neg.w	obVelX(a0)

loc_C2D8:
		move.b	#6,ob2ndRout(a0)
		bra.s	locret_C2E4
; ===========================================================================

loc_C2E0:
		add.w	d1,obY(a0)

locret_C2E4:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - pushable blocks (MZ, LZ)
; ---------------------------------------------------------------------------
Map_obj33:
		include	"_maps\obj33.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 34 - zone title cards
; ---------------------------------------------------------------------------

Obj34:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj34_Index(pc,d0.w),d1
		jmp	Obj34_Index(pc,d1.w)
; ===========================================================================
Obj34_Index:	dc.w Obj34_Setup-Obj34_Index
		dc.w Obj34_ChkPos-Obj34_Index
		dc.w Obj34_Wait-Obj34_Index
		dc.w Obj34_Wait-Obj34_Index
; ===========================================================================

Obj34_Setup:				; XREF: Obj34_Index
		cmpi.w	#$302,($FFFFFE10).w	; are we in SAP?
		beq.s	@delayafterboss		; if yes, branch
		cmpi.w	#$000,($FFFFFE10).w	; are we in NHP?
		bne.s	@regular		; if not, branch
		cmpi.b	#2,($FFFFFFAA).w	; has the crabmeat boss been defeated?
		bne.s	@regular		; if yes, do delay
		clr.w	($FFFFD012).w		; kill Sonic's gravity to prolong the scene
		jsr	FixCamera
@delayafterboss:
		tst.b	$30(a0)			; any time remaining on the delay?
		beq.s	@regular		; if not, load title cards
		
		subq.b	#1,$30(a0)
		bne.s	@waitdelay
		tst.b	$31(a0)			; are patterns set to be loaded?
		beq.s	@regular		; if not, branch

		; transition from NHP to GHP (other part in Obj1F_BossDelete)
		cmpi.w	#$000,($FFFFFE10).w	; are we in NHP?
		bne.s	@notnhp			; if not, branch	
		move.w	#$002,($FFFFFE10).w		; change level ID to GHZ3
		movem.l	d7/a0,-(sp)
		jsr	LevelLayoutLoad			; load GHZ3 layout
		movem.l	(sp)+,d7/a0
		jsr	PlayLevelMusic

@notnhp:
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	@regular		; if yes, branch
		lea	PLC_TitleCard, a1
		jsr	LoadPLC_Direct
@waitdelay:
		rts

@regular:
		movea.l	a0,a1
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0

		cmpi.w	#$501,($FFFFFE10).w ; check if level is SBZ 2
		bne.s	Obj34_NotSBZ2
		moveq	#$12,d0		; load title card number $12 (SBZ 2)

Obj34_NotSBZ2:
		cmpi.w	#$002,($FFFFFE10).w ; check if level is	GHZ 3
		bne.s	Obj34_NotGHZ3
		moveq	#5,d0		; load title card number 5 (GHZ)
		
Obj34_NotGHZ3:
		cmpi.w	#$301,($FFFFFE10).w ; check if level is	SLZ 2
		bne.s	Obj34_NotSLZ2
		moveq	#$11,d0		; load title card number $11 (SLZ)
		
Obj34_NotSLZ2:
		cmpi.w	#$302,($FFFFFE10).w ; check if level is	SLZ 3
		bne.s	Obj34_NotSLZ3
		moveq	#$14,d0		; load title card number $14 (SLZ2)
		
Obj34_NotSLZ3:
		cmpi.w	#$401,($FFFFFE10).w ; check if level is	Special Stage 2
		bne.s	Obj34_NotSS2
		tst.b	($FFFFFF5F).w	; is this the blackout blackout special stage?
		beq.s	@cont
		jmp	DeleteObject

@cont
		moveq	#$13,d0		; load title card number $13 (SS 2)
		
Obj34_NotSS2:
		move.w	d0,d2
		moveq	#4,d0		; set to SYZ config		
		cmpi.w	#$502,($FFFFFE10).w ; check if level is	FZ
		bne.s	Obj34_LoadConfig
		moveq	#6,d0		; load title card number 6 (FZ)
		moveq	#$10,d2		; use "FINAL" mappings

Obj34_LoadConfig:
		lea	(Obj34_ConData).l,a3
		lea	(Obj34_ItemData).l,a2
		moveq	#3,d1

Obj34_Loop:
		move.b	#$34,0(a1)
		move.w	(a3),obX(a1)	; load start x-position
		move.w	(a3)+,$32(a1)	; load finish x-position
		move.w	(a3)+,$30(a1)	; load main x-position
		move.w	#100,$3C(a1)	; set delay time for mid-level title cards (NHP->GHP, SNP->SAP)
		addq.b	#1,$3E(a0)
		move.b	$3E(a0),$3F(a1)	; set ID
		move.w	(a2)+,obScreenY(a1)
		move.b	(a2)+,obRoutine(a1)
		move.b	(a2)+,d0
		bne.s	Obj34_ActNumber
		move.b	d2,d0

Obj34_ActNumber:
		cmpi.b	#7,d0			; is act number on the loading schedule right now?
		bne.s	Obj34_MakeSprite	; if not, branch
		cmpi.w	#$302,($FFFFFE10).w	; check if level is SLZ 3
		bne.s	Obj34_NotSLZ3X
		addq.b	#7,d0
		bra.s	Obj34_MakeSprite
		
Obj34_NotSLZ3X:
		jsr	FakeLevelID		; check for main level and get ID
		add.b	d5,d0			; add ID to frame ID

		cmpi.w	#$502,($FFFFFE10).w	; check if level is FZ
		bne.s	Obj34_MakeSprite
		moveq	#$15,d0

		bra.s	Obj34_MakeSprite	; skip

Obj34_NoMainLevel:
		add.b	($FFFFFE11).w,d0	; add act number to frame (7=Act1, 8=Act2, 9=Act3)
		cmpi.b	#3,($FFFFFE11).w	; is current act ID = 4 (LZ 4)?
		bne.s	Obj34_MakeSprite	; if not, branch
		subq.b	#1,d0			; make it display like Act 3

Obj34_MakeSprite:
		move.b	d0,obFrame(a1)		; display frame	number d0
		
		movem.l	d0-d2/a0-a2,-(sp)	; need to read joypads now...
		jsr	ReadJoypads		; ...because at this point...
		movem.l	(sp)+,d0-d2/a0-a2	; ...controls are still locked

		cmpi.b	#$70,($FFFFF604).w	; exactly ABC held?
		bne.s	@noeasteregg		; if not, branch
		cmpi.b	#4,$3F(a1)		; is current object the Oval?
		beq.s	@noeasteregg		; if yes, branch
		move.b	#6,obFrame(a1)		; PLACE PLACE PLACE
		cmpi.b	#3,$3F(a1)		; is this the Act?
		bne.s	@noeasteregg		; if not, branch
		addi.w	#$28,$30(a1)		; adjust target X position
		subi.w	#$1A,obScreenY(a1)	; adjust Y positon
@noeasteregg:
	
		move.l	#Map_obj34,obMap(a1)
		move.w	#$855C,obGfx(a1)
		cmpi.b	#$10,($FFFFF600).w	; is current level a special stage?
		bne.s	Obj34_NotSpecial2	; if not, branch
		move.w	#$8051,obGfx(a1)	; if yes, use alternate tile offset

Obj34_NotSpecial2:
		move.b	#$78,obActWid(a1)
		move.b	#0,obRender(a1)
		move.b	#0,obPriority(a1)
		move.w	#0,obTimeFrame(a1)	; set time delay to 1 second (60)
		lea	$40(a1),a1	; next object
		dbf	d1,Obj34_Loop	; repeat sequence another 3 times
		movem.l	d0-a7,-(sp)
		moveq	#3,d0
		jsr	PalLoad2	; load Sonic's palette line
		movem.l	(sp)+,d0-a7
; ---------------------------------------------------------------------------

Obj34_ChkPos:				; XREF: Obj34_Index
		moveq	#8,d0		; set horizontal speed
		moveq	#0,d1
		move.w	obX(a0),d1	; get current X position
		cmp.w	$30(a0),d1	; sub target X position
		beq.s	Obj34_TargetOK	; if they're equal, move-in sequence is done
		bcc.s	@moveleft	; 

@moveright:
		move.w	obX(a0),d1	; get current X position
		add.w	d0,d1
		cmp.w	$30(a0),d1
		blo.s	@setnewpos
		move.w	$30(a0),d1
		bra.s	@setnewpos
		
@moveleft:
		move.w	obX(a0),d1	; get current X position
		sub.w	d0,d1
		cmp.w	$30(a0),d1
		bhi.s	@setnewpos
		move.w	$30(a0),d1
	
@setnewpos:
		move.w	d1,obX(a0)	; change item's position

Obj34_ChkPos_End:
		move.w	obX(a0),d0
		bmi.s	locret_C3D8
		cmpi.w	#$200,d0	; has item moved beyond	$200 on	x-axis?
		bcc.s	locret_C3D8	; if yes, branch
		bra.w	Obj34_Display
; ===========================================================================

Obj34_TargetOK:
		cmpi.b	#$10,($FFFFF600).w	; are we in a Special Stage?
		beq.s	@cont			; if yes, branch
		cmpi.w	#$302,($FFFFFE10).w	; is current level SAP?
		beq.s	@conto			; if yes, branch
		cmpi.w	#$002,($FFFFFE10).w	; is current level GHP?
		bne.s	Obj34_ChkPos_End	; if not, branch
		cmpi.b	#2,($FFFFFFAA).w	; has flag after Crabmeat boss been set?
		bne.s	Obj34_ChkPos_End	; if not, branch
		clr.w	($FFFFD012).w		; kill Sonic's gravity to prolong the scene
@cont:
		cmpi.b	#1,$3F(a0)		; is current element the Zone Name?
		bne.s	Obj34_ChkPos_End	; if not, branch
@conto:
		subq.w	#1,$3C(a0)		; sub 1 from delay
		bpl.s	Obj34_ChkPos_End	; if time remains, branch

		addq.b	#2,obRoutine(a0)
		addq.b	#2,$24+$40(a0)
		addq.b	#2,$24+$80(a0)
		addq.b	#2,$24+$C0(a0)

		cmpi.w	#$002,($FFFFFE10).w	; is current level GHP?
		bne.s	Obj34_ChkPos_End	; if not, branch
		cmpi.b	#2,($FFFFFFAA).w	; has flag after Crabmeat boss been set?
		bne.s	Obj34_ChkPos_End	; if not, branch
		move.b	#0,($FFFFF7CC).w	; unlock controls

		bra.s	Obj34_ChkPos_End
; ===========================================================================

locret_C3D8:
		rts	
; ===========================================================================

Obj34_Wait:				; XREF: Obj34_Index
		cmpi.w	#$000,($FFFFFE10).w
		bne.s	Obj34_NotGHZ1
		cmpi.w	#$0800,($FFFFF700).w ; has the camera reached $0A00 on x-axis?
		bcc.s	Obj34_ChkPos2	; if yes, branch
		bra.w	Obj34_Display

Obj34_NotGHZ1:
		tst.w	obTimeFrame(a0)		; is time remaining zero?
		bmi.s	Obj34_ChkPos2	; if yes, branch
		subq.w	#1,obTimeFrame(a0)	; subtract 1 from time
		bra.w	Obj34_Display
; ===========================================================================

MoveOffSpeedX = 5
MoveOffSpeedY = 1

Obj34_ChkPos2:				; XREF: Obj34_Wait
		cmpi.b	#1,$3F(a0)	; is current object Zone Name?
		bne.s	Obj34_NotIsZone	; if yes, branch
		subq.w	#MoveOffSpeedY,obScreenY(a0)
		subq.w	#MoveOffSpeedX,obX(a0)
		cmpi.w	#$40,obX(a0)
		blt.w	Obj34_ChangeArt
		bra.w	Obj34_Display

Obj34_NotIsZone:
		cmpi.b	#2,$3F(a0)	; is current object Place?
		bne.s	Obj34_NotIsPlace	; if yes, branch
		addq.w	#MoveOffSpeedY,obScreenY(a0)
		subq.w	#MoveOffSpeedX,obX(a0)
		cmpi.w	#$40,obX(a0)
		blt.w	Obj34_JustDelete
		bra.w	Obj34_Display

Obj34_NotIsPlace:
		cmpi.b	#3,$3F(a0)	; is current object Act?
		bne.s	Obj34_NotIsAct	; if not, branch
		addq.w	#MoveOffSpeedY,obScreenY(a0)
		addq.w	#MoveOffSpeedX,obX(a0)
		cmpi.w	#$200,obX(a0)
		bgt.w	Obj34_JustDelete
		bra.w	Obj34_Display

Obj34_NotIsAct:
		cmpi.b	#4,$3F(a0)	; is current object the Oval?
		bne.s	Obj34_NotIsOval	; if not, branch
		subq.w	#MoveOffSpeedY,obScreenY(a0)
		cmpi.w	#$400,($FFFFFE10).w
		beq.s	@cont1
		cmpi.w	#$501,($FFFFFE10).w
		bne.s	@cont2
@cont1:
		addq.w	#MoveOffSpeedY,obScreenY(a0)
@cont2:
		addq.w	#MoveOffSpeedX,obX(a0)
		cmpi.w	#$200,obX(a0)
		bgt.w	Obj34_JustDelete
		bra.w	Obj34_Display

Obj34_NotIsOval:
		rts
; ===========================================================================
HUDSpeed = 6

Obj34_ChangeArt:			; XREF: Obj34_ChkPos2
		cmpi.b	#4,obRoutine(a0)
		bne.s	Obj34_Delete
		bsr	Obj34_LoadPostGraphics

Obj34_Delete:
		cmpi.b	#$10,($FFFFF600).w		; is level SLZ1 (special stage)?
		beq.w	Obj34_JustDelete		; if yes, branch
		
		cmpi.w	#$501,($FFFFFE10).w
		beq	Obj34_JustDelete
		cmpi.w	#$002,($FFFFFE10).w
		bne.s	@cont
		cmpi.b	#2,($FFFFFFAA).w
		bne.s	@cont
		bra.s	Obj34_JustDelete

@cont:
		move.b	#$21,($FFFFD040).w		; load HUD object
		move.b	#1,($FFFFD070).w		; set to SCORE
		move.w	#HudSpeed,($FFFFD072).w		; set X-speed
		move.w	#HudSpeed,($FFFFD074).w		; set Y-speed
		move.b	#$21,($FFFFD400).w		; load HUD object
		move.b	#2,($FFFFD430).w		; set to RINGS
		move.w	#HUDSpeed,d3			; load HUD speed into d3
		neg.w	d3				; negate it
		move.w	d3,($FFFFD432).w		; set X-speed
		move.w	#HUDSpeed,($FFFFD434).w		; set Y-speed
		
		move.b	#$21,($FFFFD480).w		; load HUD object
		move.b	#4,($FFFFD4B0).w		; set to LIVES
		move.w	#HUDSpeed,d3			; load HUD speed into d3
		neg.w	d3				; negate it
		move.w	d3,($FFFFD4B2).w		; set X-speed
		move.w	d3,($FFFFD4B4).w		; set Y-speed

		cmpi.w	#$400,($FFFFFE10).w		; is level SYZ1 (overworld)?
		beq.s	Obj34_JustDelete		; if yes, branch

		move.b	#$21,($FFFFD440).w		; load HUD object
		move.b	#3,($FFFFD470).w		; set to TIME
		move.w	#HUDSpeed,($FFFFD472).w		; set X-speed
		move.w	#HUDSpeed,d3			; load HUD speed into d3
		neg.w	d3				; negate it
		move.w	d3,($FFFFD474).w		; set Y-speed

Obj34_JustDelete:
	;	move.b	#1,($FFFFFFD3).w		; make Sonic release the auto-peelout
		bra.w	DeleteObject
; ===========================================================================

Obj34_Display:
		cmpi.w	#$400,($FFFFFE10).w	; is current level Uberhub?
		beq.s	@notactnumber		; if yes, branch
		cmpi.w	#$501,($FFFFFE10).w	; is current level the tutorial?
		bne.s	Obj34_DoDisplay		; if not, branch
@notactnumber:	cmpi.b	#3,$3F(a0)		; is current object the Act Number?
		bne.s	Obj34_DoDisplay		; if not, branch
		rts				; otherwise don't display act number

Obj34_DoDisplay:
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		beq.s	Obj34_DoDisplayX	; if not, branch
		rts

Obj34_DoDisplayX:
		jmp	DisplaySprite		; display sprite
; ===========================================================================

Obj34_LoadPostGraphics:
		moveq	#2,d0
		jsr	(LoadPLC).l	; load explosion patterns
		moveq	#$13,d0
		jmp	(LoadPLC).l	; load star patterns

; ===========================================================================
Obj34_ItemData:
	; Zone Name (e.g. GREEN HILL)
		dc.w $D0	; y-axis position
		dc.b 2,	0	; routine number, frame	number (changes)

	; ZONE
		dc.w $E4
		dc.b 2,	6

	; Act Number
		dc.w $EA
		dc.b 2,	7

	; Oval
		dc.w $E0
		dc.b 2,	$F

		even
; ===========================================================================

; ---------------------------------------------------------------------------
; Start and finish positions
; ---------------------------------------------------------------------------
Obj34_ConData:
		dc.w $0000, $0120 ; Stage Name (e.g. NIGHT HILL)
		dc.w $0000, $0139 ; PLACE
		dc.w $0414, $0154 ; "ACT" text and Act Number
		dc.w $0214, $0154 ; Oval
		even
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 39 - Unusued (previously "GAME OVER" and "TIME OVER")
; ---------------------------------------------------------------------------

Obj39:					; XREF: Obj_Index
		jmp	DeleteObject

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3A - Bomb Machine in Eggman Cutscene
; ---------------------------------------------------------------------------

Obj3A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj3A_Index(pc,d0.w),d1
		jmp	Obj3A_Index(pc,d1.w)
; ===========================================================================
Obj3A_Index:	dc.w Obj3A_Main-Obj3A_Index
		dc.w Obj3A_Machine-Obj3A_Index
		dc.w Obj3A_Needle-Obj3A_Index
		dc.w Obj3A_Wheel-Obj3A_Index
		dc.w Obj3A_Scale-Obj3A_Index
		dc.w Obj3A_Tube-Obj3A_Index
; ===========================================================================

Obj3A_Main:				; XREF: Obj6D_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_BombMachine,obMap(a0)
		move.w	#$22B0,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#2,obPriority(a0)
		move.b	#$14,obFrame(a0)

		jsr	SingleObjLoad
		move.b	#$3A,(a1)
		move.b	#4,obRoutine(a1)
		move.b	#4,obFrame(a1)
		move.b	#0,obPriority(a1)
		move.l	#Map_BombMachine,obMap(a1)
		move.w	#$22B0,obGfx(a1)
		ori.b	#4,obRender(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,obAnim(a1)

		jsr	SingleObjLoad
		move.b	#$3A,(a1)
		move.b	#6,obRoutine(a1)
		move.b	#8,obFrame(a1)
		move.b	#0,obPriority(a1)
		move.l	#Map_BombMachine,obMap(a1)
		move.w	#$22B0,obGfx(a1)
		ori.b	#4,obRender(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#2,obAnim(a1)

		jsr	SingleObjLoad
		move.b	#$3A,(a1)
		move.b	#8,obRoutine(a1)
		move.b	#$B,obFrame(a1)
		move.b	#0,obPriority(a1)
		move.l	#Map_BombMachine,obMap(a1)
		move.w	#$22B0,obGfx(a1)
		ori.b	#4,obRender(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#3,obAnim(a1)
		move.l	a1,($FFFFFFC4).w
		rts


Obj3A_Machine:				; XREF: Obj6D_Index
		tst.b	($FFFFFFC8).w
		bne.s	@cont
		move.b	#$14,obFrame(a0)
		bra.w	DisplaySprite
@cont:
		lea	(Ani_BombMachine).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite

; ---------------------------------------------------------------------------

Obj3A_Needle:
		tst.b	($FFFFFFC8).w
		bne.s	@cont
		move.b	#4,obFrame(a0)
		bra.w	DisplaySprite
@cont:
		move.w	#$42B0,obGfx(a0)
		lea	(Ani_BombMachine).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ---------------------------------------------------------------------------

Obj3A_Wheel:
		tst.b	($FFFFFFC8).w
		bne.s	@cont
		move.b	#8,obFrame(a0)
		bra.w	DisplaySprite
@cont:
		lea	(Ani_BombMachine).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ---------------------------------------------------------------------------

Obj3A_Scale:
		lea	(Ani_BombMachine).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ---------------------------------------------------------------------------

Obj3A_Tube:
		move.b	#10,obPriority(a0)
		move.b	#$15,obFrame(a0)
		addi.w	#$18,obVelY(a0)	; increase vertical speed
		jsr	SpeedToPos

		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	@cont
		jsr	SingleObjLoad
		bne.s	@cont
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#4,d1
		addi.w	#$28,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#5,d0
		addi.w	#$28,d0
		add.w	d0,obY(a1)

@cont:
		cmpi.w	#$0240,obY(a0)
		blt.s	@contx
		jmp	DeleteObject

@contx:
		ori.b	#10,(CameraShake).w
		bra.w	DisplaySprite

; ---------------------------------------------------------------------------
; Includes - Bomb Machine
; ---------------------------------------------------------------------------
Map_BombMachine:
		include	"_maps\BombMachine.asm"

Ani_BombMachine:
		dc.w A_BM1-Ani_BombMachine
		dc.w A_BM2-Ani_BombMachine
		dc.w A_BM3-Ani_BombMachine
		dc.w A_BM4-Ani_BombMachine
A_BM1:		dc.b 4, 0, 1, 3, $FF
A_BM2:		dc.b 2, 5, 6, 7, $FF
A_BM3:		dc.b 3, 8, 9, $A, $B, $FF
A_BM4:		dc.b 3, $C, $D, $E, $F, $10, $11, $12, $13, $FE, 2
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7E - Unusued (previously special stage results screen)
; ---------------------------------------------------------------------------

Obj7E:					; XREF: Obj_Index
		jmp	DeleteObject

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7F - Unusued (previously chaos emeralds from the special stage results screen)
; ---------------------------------------------------------------------------

Obj7F:					; XREF: Obj_Index
		jmp	DeleteObject

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - zone title cards
; ---------------------------------------------------------------------------
;Map_Obj34: ; moved to the file itself for compatibility with ClownMapEd
		include	"_maps\TitleCards.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 36 - spikes
; ---------------------------------------------------------------------------

Obj36:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj36_Index(pc,d0.w),d1
		jmp	Obj36_Index(pc,d1.w)
; ===========================================================================
Obj36_Index:	dc.w Obj36_Main-Obj36_Index
		dc.w Obj36_Solid-Obj36_Index

Obj36_Var:	dc.b 0,	$14		; frame	number,	object width
		dc.b 1,	$10
		dc.b 2,	4
		dc.b 3,	$1C
		dc.b 4,	$40
		dc.b 5,	$10
; ===========================================================================

Obj36_Main:				; XREF: Obj36_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj36,obMap(a0)
		move.w	#$051B,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	obSubtype(a0),d0
		andi.b	#$F,obSubtype(a0)
		andi.w	#$F0,d0
		lea	(Obj36_Var).l,a1
		lsr.w	#3,d0
		adda.w	d0,a1
		move.b	(a1)+,obFrame(a0)
		move.b	(a1)+,obActWid(a0)
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$32(a0)

Obj36_Solid:				; XREF: Obj36_Index
	;	cmpi.w	#$502,($FFFFFE10).w	; is level FP?
	;	beq.w	Obj36_ExplodeFP		; if yes, branch
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		beq.s	Obj36_NotInhuman	; if not, branch
		cmpi.w	#$200,($FFFFFE10).w	; are we in Ruined Place?
		bne.s	Obj36_NotInhuman	; if not, branch
		ori.w	#$6000,obGfx(a0)	; use palette line four from now now

Obj36_NotInhuman:
		jsr	obj36_Type0x	; make the object move
		move.w	#4,d2
		cmpi.b	#5,obFrame(a0)	; is object type $5x ?
		beq.s	Obj36_SideWays	; if yes, branch
		cmpi.b	#1,obFrame(a0)	; is object type $1x ?
		bne.w	Obj36_Upright	; if not, branch
		move.w	#$14,d2

; Spikes types $1x and $5x face	sideways

Obj36_SideWays:				; XREF: Obj36_Solid
		move.w	#$1B,d1
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		btst	#3,obStatus(a0)
		bne.w	Obj36_Display
		cmpi.w	#1,d4
		beq.w	Obj36_Hurt
		bra.w	Obj36_Display
; ===========================================================================

Obj36_Explode:
		ori.b	#10,(CameraShake).w
		move.b	#$C4,d0				; load boost SFX
		jsr	PlaySound_Special		; play boost SFX
		jsr	SingleObjLoad
		move.b	#$3F,0(a1)			; change spike into an explosion
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		jmp	DeleteObject
; ===========================================================================

; Spikes types $0x, $2x, $3x and $4x face up or	down

Obj36_Upright:				; XREF: Obj36_Solid
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		btst	#3,obStatus(a0)
		bne.s	Obj36_Hurt
		tst.w	d4
		bpl.w	Obj36_Display

Obj36_Hurt:				; XREF: Obj36_SideWays; Obj36_Upright
		cmpi.b	#5,($FFFFFE10).w	; are we in the tutorial or FP?
		bne.s	@nottutorial		; if not, branch

		move.w	#$09E0,d1
		move.w	#$01AC,d2
		move.w	obX(a0),d0
		cmpi.w	#$1000,d0
		blo.s	@doteleport
		move.w	#$1000,d1
		move.w	#$0190,d2
		cmpi.w	#$1500,d0
		blo.s	@doteleport
		move.w	#$1420,d1
		move.w	#$03AC,d2
@doteleport:
		move.w	d1,($FFFFD008).w	; teleport Sonic on X-axis
		move.w	d2,($FFFFD00C).w	; teleport Sonic on Y-axis
		clr.w	($FFFFD010).w		; clear X-speed
		clr.w	($FFFFD012).w		; clear Y-speed
		move.w	#$C3,d0			; set giant ring sound
		jsr	PlaySound		; play it
		jsr	WhiteFlash2		; make a white flash
		move.b	#1,(RedrawEverything).w	; redraw screen after teleportation
		bra.w	Obj36_NotInhuman2

@nottutorial:
		tst.b	($FFFFFE2D).w	; is Sonic invincible?
		bne.w	Obj36_Display	; if yes, branch
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		beq.w	Obj36_NotInhuman2	; if not, branch
		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		bne.w	Obj36_NotInhuman2	; if not, branch
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		bne.w	Obj36_NotInhuman2

		frantic					; are we in frantic mode?
		beq.s	@noringdrain			; if not, branch
		ori.b	#1,($FFFFFE1D).w		; update ring counter
		cmpi.w	#10,($FFFFFE20).w		; do you have enough rings to tank the hit?
		bpl.s	@tankhit			; if yes, branch
		move.w	($FFFFFE20).w,(FranticDrain).w	; drain whatever rings remain
		jmp	KillSonic_Inhuman		; you hecking died noob
@tankhit:	move.w	#10,(FranticDrain).w		; drain 10 rings

@noringdrain:
		move.w	#$12DD,($FFFFD008).w	; teleport Sonic on X-axis
		move.w	#$008C,($FFFFD00C).w	; teleport Sonic on Y-axis
		tst.b	($FFFFFF73).w		; has P monitor been broken in Ruined Place?
		beq.s	@cont			; if not, branch
		move.w	#$14E1,($FFFFD008).w	; teleport Sonic on X-axis
		move.w	#$04CC,($FFFFD00C).w	; teleport Sonic on Y-axis
		
		cmpi.b	#2,($FFFFFF73).w	; has second checkpoint been reached?
		blt.s	@cont
		move.w	#$1950,($FFFFD008).w	; teleport Sonic on X-axis
		move.w	#$0590,($FFFFD00C).w	; teleport Sonic on Y-axis

@cont:
		cmpi.b	#2,($FFFFFF73).w	; has second checkpoint been reached?
		bhs.s	@cont2
		move.b	($FFFFFF6C).w,d0
		clr.b	($FFFFFF6C).w		; clear the "switch has been pressed" flags
		btst	#1, d0
		beq.s	@cont2
		btst	#3, OptionsBits		; is cinematic HUD enabled?
		bne.s 	@cont2				; palette never changed, branch
		jsr	RestorePaletteRP

@cont2:
		clr.w	($FFFFD010).w		; clear X-speed
		clr.w	($FFFFD012).w		; clear Y-speed
		
		clr.w	($FFFFF708).w
		clr.w	($FFFFF714).w
		clr.w	($FFFFF71C).w

		move.w	#$C3,d0			; set giant ring sound
		jsr	PlaySound		; play it
		jsr	WhiteFlash2		; make a white flash
		move.b	#1,(RedrawEverything).w	; redraw screen after teleportation

Obj36_NotInhuman2:
		tst.w	($FFFFD030).w	; +++ is Sonic invulnerable? (Spike Behavior check)
		bne.s	Obj36_Display	; +++ if yes, branch

Obj36_Hurt_Rest:
		move.l	a0,-(sp)
		movea.l	a0,a2
		lea	($FFFFD000).w,a0
		cmpi.b	#4,obRoutine(a0)
		bcc.s	loc_CF20
		move.l	obY(a0),d3
		move.w	obVelY(a0),d0
		ext.l	d0
		asl.l	#8,d0
		sub.l	d0,d3
		move.l	d3,obY(a0)
		cmpi.b	#5,($FFFFFE10).w
		bne.s	@cont
		bset	#1,($FFFFD022).w
		move.w	#-$400,($FFFFD012).w	; make Sonic bounce away from the object
		move.b	#$25,($FFFFD01C).w
		bra.s	loc_CF20

@cont:
		jsr	HurtSonic

loc_CF20:
		movea.l	(sp)+,a0

Obj36_Display:
		jmp	MarkObjGone

Obj36_ExplodeFP:
		tst.b	(FZEscape).w
		beq.w	Obj36_NotInhuman
		cmpi.b	#$12,($FFFFF742).w
		bhi.w	Obj36_NotInhuman
		bra.w	Obj36_Explode
		; make this object an explosion emitter
		; move.b	#$67, (a0)
		; nevermind lol

		; randomize timer
		; jsr 	RandomNumber
		; move.w	d0, $26(a0)
		jmp		DeleteObject
; ===========================================================================

Obj36_Type0x:				; XREF: Obj36_Solid
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		move.w	Obj36_TypeIndex(pc,d0.w),d1
		jmp	Obj36_TypeIndex(pc,d1.w)
; ===========================================================================
Obj36_TypeIndex:dc.w Obj36_Type00-Obj36_TypeIndex
		dc.w Obj36_Type01-Obj36_TypeIndex
		dc.w Obj36_Type02-Obj36_TypeIndex
; ===========================================================================

Obj36_Type00:				; XREF: Obj36_TypeIndex
		rts			; don't move the object
; ===========================================================================

Obj36_Type01:				; XREF: Obj36_TypeIndex
	;	jsr	obj36_Wait
	;	moveq	#0,d0
	;	move.w	$34(a0),d0
	;	add.w	$32(a0),d0
	;	move.w	d0,obY(a0)	; move the object vertically
		rts	
; ========================================3===================================

Obj36_Type02:				; XREF: Obj36_TypeIndex
		jsr	obj36_Wait
		moveq	#0,d0
		move.w	$34(a0),d0
		add.w	$30(a0),d0
		move.w	d0,obX(a0)	; move the object horizontally
		rts	
; ===========================================================================

Obj36_Wait:
		move.w	($FFFFFE04).w,d0
		divu.w	#45,d0
		andi.l	#$FFFF0000,d0
		bne.s	locret_CFE6
		
		moveq	#$30,d0		; set move distance to $20 pixels
		tst.w	$34(a0)
		bne.s	@0
		btst	#0,obStatus(a0)	; is spike mirrored?
		beq.s	@1
		neg.w	d0
@1:		move.w	d0,$34(a0)
		bra.s	@playsound

@0:
		clr.w	$34(a0)

@playsound:
		tst.b	obRender(a0)
		bpl.s	locret_CFE6
		move.w	#$B6,d0
		jsr	(PlaySound_Special).l ;	play "spikes moving" sound

locret_CFE6:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - spikes
; ---------------------------------------------------------------------------
Map_obj36:
		include	"_maps\obj36.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3B - purple rock (GHZ)
; ---------------------------------------------------------------------------

Obj3B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj3B_Index(pc,d0.w),d1
		jmp	Obj3B_Index(pc,d1.w)
; ===========================================================================
Obj3B_Index:	dc.w Obj3B_Main-Obj3B_Index
		dc.w Obj3B_Solid-Obj3B_Index
; ===========================================================================

Obj3B_Main:				; XREF: Obj3B_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj3B,obMap(a0)
		move.w	#$63D0,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#$13,obActWid(a0)
		move.b	#4,obPriority(a0)

Obj3B_Solid:				; XREF: Obj3B_Index
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$10,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 49 - waterfall	sound effect (GHZ)
; ---------------------------------------------------------------------------

Obj49:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj49_Index(pc,d0.w),d1
		jmp	Obj49_Index(pc,d1.w)
; ===========================================================================
Obj49_Index:	dc.w Obj49_Main-Obj49_Index
		dc.w Obj49_PlaySnd-Obj49_Index
; ===========================================================================

Obj49_Main:				; XREF: Obj49_Index
		addq.b	#2,obRoutine(a0)
		move.b	#4,obRender(a0)

Obj49_PlaySnd:				; XREF: Obj49_Index
		move.b	($FFFFFE05).w,d0
		andi.b	#$3F,d0
		bne.s	Obj49_ChkDel

		cmpi.w	#$000,($FFFFFE10).w	; is level NHP?
		bne.s	@dosfx			; if not, branch
		cmpi.b	#2,($FFFFFFAA).w	; has the crabmeat boss been defeated?
		beq.s	Obj49_ChkDel		; if yes, don't do waterfall sound
@dosfx:
		move.w	#$D0,d0
		jsr	(PlaySound_Special).l ;	play waterfall sound

Obj49_ChkDel:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - purple rock	(GHZ)
; ---------------------------------------------------------------------------
Map_obj3B:
		include	"_maps\obj3B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3C - smashable	wall (GHZ, SLZ)
; ---------------------------------------------------------------------------

Obj3C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj3C_Index(pc,d0.w),d1
		jmp	obj3C_Index(pc,d1.w)
; ===========================================================================
Obj3C_Index:	dc.w Obj3C_Main-Obj3C_Index
		dc.w Obj3C_Solid-Obj3C_Index
		dc.w Obj3C_FragMove-Obj3C_Index
; ===========================================================================

Obj3C_Main:				; XREF: Obj3C_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj3C,obMap(a0)
		move.w	#$450F,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#4,obPriority(a0)
		move.b	obSubtype(a0),obFrame(a0)

Obj3C_Solid:				; XREF: Obj3C_Index
		move.w	($FFFFD010).w,$30(a0) ;	load Sonic's horizontal speed
		move.w	#$1B,d1
		move.w	#$20,d2
		move.w	#$20,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		btst	#5,obStatus(a0)
		bne.s	Obj3C_ChkRoll

locret_D180:
		jmp	MarkObjGone
; ===========================================================================

Obj3C_ChkRoll:				; XREF: Obj3C_Solid
		tst.b	($FFFFFFE7).w
		bne.s	Obj3C_Ok
		cmpi.w	#$001,($FFFFFE10).w	; is this GHZ2 (intro level)?
		beq.s	Obj3C_Ok 		; if yes, branch
		cmpi.b	#2,obAnim(a1)	; is Sonic rolling?
		bne.s	locret_D180	; if not, branch
		move.w	$30(a0),d0
		bpl.s	Obj3C_ChkSpeed
		neg.w	d0

Obj3C_ChkSpeed:
		cmpi.w	#$480,d0	; is Sonic's speed $480 or higher?
		bcs.s	locret_D180	; if not, branch

Obj3C_OK:
		move.w	$30(a0),obVelX(a1)
		addq.w	#4,obX(a1)
		lea	(Obj3C_FragSpd1).l,a4 ;	use fragments that move	right
		move.w	obX(a0),d0
		cmp.w	obX(a1),d0	; is Sonic to the right	of the block?
		bcs.s	Obj3C_Smash	; if yes, branch
		subq.w	#8,obX(a1)
		lea	(Obj3C_FragSpd2).l,a4 ;	use fragments that move	left

Obj3C_Smash:
		move.w	obVelX(a1),obInertia(a1)
		bclr	#5,obStatus(a0)
		bclr	#5,obStatus(a1)
		moveq	#7,d1		; load 8 fragments
		move.w	#$70,d2
		bsr.s	SmashObject

Obj3C_FragMove:				; XREF: Obj3C_Index
		bsr	SpeedToPos
		addi.w	#$70,obVelY(a0)	; make fragment	fall faster
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite

; ---------------------------------------------------------------------------
; Subroutine to	smash a	block (GHZ walls and MZ	blocks)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SmashObject:				; XREF: Obj3C_Smash
		moveq	#0,d0
		move.b	obFrame(a0),d0
		add.w	d0,d0
		movea.l	obMap(a0),a3
		adda.w	(a3,d0.w),a3
		addq.w	#1,a3
		bset	#5,obRender(a0)
		move.b	0(a0),d4
		move.b	obRender(a0),d5
		movea.l	a0,a1
		bra.s	Smash_LoadFrag
; ===========================================================================

Smash_Loop:
		bsr	SingleObjLoad
		bne.s	Smash_PlaySnd
		addq.w	#5,a3

Smash_LoadFrag:				; XREF: SmashObject
		move.b	#4,obRoutine(a1)
		move.b	d4,0(a1)
		move.l	a3,obMap(a1)
		move.b	d5,obRender(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	obGfx(a0),obGfx(a1)
		move.b	obPriority(a0),obPriority(a1)
		move.b	obActWid(a0),obActWid(a1)
		move.w	(a4)+,obVelX(a1)
		move.w	(a4)+,obVelY(a1)
		cmpa.l	a0,a1
		bcc.s	loc_D268
		move.l	a0,-(sp)
		movea.l	a1,a0
		bsr	SpeedToPos
		add.w	d2,obVelY(a0)
		movea.l	(sp)+,a0
		bsr	DisplaySprite2

loc_D268:
		dbf	d1,Smash_Loop

Smash_PlaySnd:
		move.w	#$CB,d0
		jmp	(PlaySound_Special).l ;	play smashing sound
; End of function SmashObject

; ===========================================================================
; Smashed block	fragment speeds
;
Obj3C_FragSpd1:	dc.w $400, $FB00	; x-move speed,	y-move speed
		dc.w $600, $FF00
		dc.w $600, $100
		dc.w $400, $500
		dc.w $600, $FA00
		dc.w $800, $FE00
		dc.w $800, $200
		dc.w $600, $600

Obj3C_FragSpd2:	dc.w $FA00, $FA00
		dc.w $F800, $FE00
		dc.w $F800, $200
		dc.w $FA00, $600
		dc.w $FC00, $FB00
		dc.w $FA00, $FF00
		dc.w $FA00, $100
		dc.w $FC00, $500
; ---------------------------------------------------------------------------
; Sprite mappings - smashable walls (GHZ, SLZ)
; ---------------------------------------------------------------------------
Map_obj3C:
		include	"_maps\obj3C.asm"

; ---------------------------------------------------------------------------
; Object code loading subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjectsLoad:				; XREF: TitleScreen; et al
		lea	($FFFFD000).w,a0 ; set address for object RAM
		moveq	#$7F,d7
		moveq	#0,d0
		
		; disabled death check, objects now keep on running when you die (to quote Vladik: "it looks fresh")
	;	cmpi.b	#$18,($FFFFF600).w	; is this the ending sequence?
	;	beq.s	loc_D348		; if yes, branch
	;	cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
	;	bcc.s	loc_D362		; if yes, branch

loc_D348:
		move.b	(a0),d0		; load object number from RAM
		beq.s	loc_D358
		add.w	d0,d0
		add.w	d0,d0
		movea.l	Obj_Index-obMap(pc,d0.w),a1
	if TestDisplayDeleteBugs=1
		ext.l	d7		; clear upper word 
	endif
		jsr	(a1)		; run the object's code
		moveq	#0,d0

loc_D358:
		lea	$40(a0),a0	; next object
		dbf	d7,loc_D348
		rts	
; ===========================================================================

loc_D362:
		cmpi.b	#$A,($FFFFD000+$24).w	; Has Sonic drowned?
		beq.s	loc_D348		; If so, run objects a little longer
		moveq	#$1F,d7
		bsr.s	loc_D348
		moveq	#$5F,d7

loc_D368:
		moveq	#0,d0
		move.b	(a0),d0
		beq.s	loc_D378
		tst.b	obRender(a0)
		bpl.s	loc_D378
		bsr	DisplaySprite

loc_D378:
		lea	$40(a0),a0

loc_D37C:
		dbf	d7,loc_D368
		rts	
; End of function ObjectsLoad

; ===========================================================================
; ---------------------------------------------------------------------------
; Object pointers
; ---------------------------------------------------------------------------
Obj_Index:
		dc.l Obj01, Obj02, Obj03, Obj04
		dc.l Obj05, Obj06, Obj07, Obj08
		dc.l Obj09, Obj0A, Obj0B, Obj0C
		dc.l Obj0D, Obj0E, Obj0F, Obj10
		dc.l Obj11, Obj12, Obj13, Obj14
		dc.l Obj15, Obj16, Obj17, Obj18
		dc.l Obj19, Obj1A, Obj1B, Obj1C
		dc.l Obj1D, Obj1E, Obj1F, Obj20
		dc.l Obj21, Obj22, Obj23, Obj24
		dc.l Obj25, Obj26, Obj27, Obj28
		dc.l Obj29, Obj2A, Obj2B, Obj2C
		dc.l Obj2D, Obj2E, Obj2F, Obj30
		dc.l Obj31, Obj32, Obj33, Obj34
		dc.l Obj35, Obj36, Obj37, Obj38
		dc.l Obj39, Obj3A, Obj3B, Obj3C
		dc.l Obj3D, Obj3E, Obj3F, Obj40
		dc.l Obj41, Obj42, Obj43, Obj44
		dc.l Obj45, Obj46, Obj47, Obj48
		dc.l Obj49, Obj4A, Obj4B, Obj4C
		dc.l Obj4D, Obj4E, Obj4F, Obj50
		dc.l Obj51, Obj52, Obj53, Obj54
		dc.l Obj55, Obj56, Obj57, Obj58
		dc.l Obj59, Obj5A, Obj5B, Obj5C
		dc.l Obj5D, Obj5E, Obj5F, Obj60
		dc.l Obj61, Obj62, Obj63, Obj64
		dc.l Obj65, Obj66, Obj67, Obj68
		dc.l Obj69, Obj6A, Obj6B, Obj6C
		dc.l Obj6D, Obj6E, Obj6F, Obj70
		dc.l Obj71, Obj72, Obj73, Obj74
		dc.l Obj75, Obj76, Obj77, Obj78
		dc.l Obj79, Obj7A, Obj7B, Obj7C
		dc.l Obj7D, Obj7E, Obj7F, Obj80
		dc.l Obj81, Obj82, Obj83, Obj84
		dc.l Obj85, Obj86, Obj87, Obj88
		dc.l Obj89, Obj8A, Obj8B, Obj8C
		even

; ---------------------------------------------------------------------------
; Subroutine to	make an	object fall downwards, increasingly fast
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Gravity = $38

ObjectFall:
		move.w	obVelX(a0),d0
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,obX(a0)

		move.w	obVelY(a0),d0
		tst.b	($FFFFFFE5).w		; is air freeze enabled?
		beq.s	@fullgravity		; if not, use regular gravity
		subi.w	#Gravity/2,obVelY(a0)	; otherwise just half gravity
@fullgravity:
		addi.w	#Gravity,obVelY(a0)	; increase vertical speed
		ext.l	d0
		lsl.l	#8,d0
		add.l	d0,obY(a0)
		rts	
; End of function ObjectFall


; ---------------------------------------------------------------------------
; Subroutine to	handle falling physics on Sonic
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjectFall_Sonic:
		; x velocity
		move.w	obVelX(a0),d0		; get Sonic's horizontal speed
		ext.l	d0			; extend his X speed to a long
		asl.l	#8,d0			; move one byte ahead
		move.l	obX(a0),d2		; get Sonic's X position
		add.l	d0,d2			; add that new speed to Sonic's new X position
		move.l	d2,obX(a0)		; write new X coordinate for Sonic
		
		; y velocity
		move.w	obVelY(a0),d0		; get Sonic's vertical speed
		ext.l	d0			; extend Y speed to a long
		asl.l	#8,d0			; move one byte ahead
		move.l	obY(a0),d2		; get Sonic's Y positon
		add.l	d0,d2			; add that new speed to Sonic's new Y position
		move.l	d2,obY(a0)		; write new Y coordinate for Sonic

		moveq	#0,d3			; register to store this frame's velocity delta
		move.w	#Gravity,d3		; increase vertical speed (gravity)

		; OG antigrav
@OFS_ReverseGravity:
		tst.b	($FFFFFF77).w		; is antigrav enabled?
		beq.w	@OFS_FallEnd		; if not, branch
		
		subi.w	#Gravity,d3		; inverse gravity
		btst	#6,($FFFFF602).w	; is A pressed?
		beq.s	@OFS_NoA		; if not, branch
		move.b	#2,obAnim(a0)		; change to rolling animation
		move.b	#1,($FFFFFFEB).w	; set jumpdash flag (to prevent it)
		tst.w	obVelY(a0)
		bmi.s	@OFS_Negative
		subi.w	#Gravity,d3
		bra.s	@OFS_FallEnd
@OFS_Negative:
		subi.w	#Gravity/2,d3
		bra.s	@OFS_FallEnd
@OFS_NoA:
		tst.w	obVelY(a0)
		bpl.s	@OFS_Positve
		addi.w	#Gravity,d3
		bra.s	@OFS_FallEnd
@OFS_Positve:
		addi.w	#Gravity/2,d3
@OFS_FallEnd:
		add.w	d3,obVelY(a0)		; apply gravity changes
		rts				; return
; End of function ObjectFall

; ---------------------------------------------------------------------------
; Subroutine translating object	speed to update	object position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SpeedToPos:
		; Vladik's optimized code
		movem.w	obVelX(a0),d2-d3
		asl.l	#8,d2
		add.l	d2,obX(a0)
		asl.l	#8,d3
		add.l	d3,obY(a0)
		rts

SpeedToScreenPos:
        movem.w    obVelX(a0),d2-d3
        asl.l    #8,d2
        asl.l    #8,d3
        move.l    obX(a0),d0
        move.w    obY(a0),d0
        add.l    d2,d0
        move.w    d0,obY(a0)
        swap    d0
        move.w    d0,obX(a0)
        move.l    obScreenY(a0),d0
        move.w    obY+2(a0),d0
        add.l    d3,d0
        move.w    d0,obY+2(a0)
        swap    d0
        move.w    d0,obScreenY(a0)
		rts
; End of function SpeedToPos

; ---------------------------------------------------------------------------
; Subroutine to	display	a sprite/object, when a0 is the	object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DisplaySprite:
	if TestDisplayDeleteBugs=1
		tst.l	d7		; was flag already set?
		bpl.s	@0		; if not, branch
		moveq	#0,d0
		move.b	(a0),d0
		illegal			; flag was already set
@0:		ori.l	#$FFFF0000,d7
	endif

		moveq	#7, d0
		and.b	obPriority(a0), d0
		add.w	d0, d0
		movea.w	DisplaySprite_LayersPointers(pc, d0), a1
		cmpi.w	#$7E, (a1)
		bcc.s	@display_done
		addq.w	#2, (a1)
		adda.w	(a1), a1
		move.w	a0, (a1)

@display_done:
		rts
; End of function DisplaySprite

DisplaySprite_LayersPointers:
		dc.w	Sprites_Queue+0, Sprites_Queue+$80, Sprites_Queue+$100, Sprites_Queue+$180
		dc.w	Sprites_Queue+$200, Sprites_Queue+$280, Sprites_Queue+$300, Sprites_Queue+$380

; ---------------------------------------------------------------
; Subroutine to display a 2nd sprite/object
; ---------------------------------------------------------------

DisplaySprite2:
	if TestDisplayDeleteBugs=1
		tst.l	d7		; was flag already set?
		bpl.s	@0		; if not, branch
		moveq	#0,d0
		move.b	(a0),d0
		illegal			; flag was already set
@0:		ori.l	#$FFFF0000,d7
	endif

		moveq	#7, d0
		and.b	obPriority(a1), d0
		add.w	d0, d0
		movea.w	DisplaySprite_LayersPointers(pc, d0), a2
		cmpi.w	#$7E,(a2)
		bcc.s	@display_done
		addq.w	#2,(a2)
		adda.w	(a2),a2
		move.w	a1,(a2)

@display_done:
		rts
; End of function DisplaySprite2

; ---------------------------------------------------------------------------
; Subroutine to	delete an object
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


DeleteObject:
	if TestDisplayDeleteBugs=1
		tst.l	d7		; was flag already set?
		bpl.s	@0		; if not, branch
		moveq	#0,d0
		move.b	(a0),d0
		illegal			; flag was already set
@0:		ori.l	#$FFFF0000,d7
	endif

		movea.l	a0,a1

DeleteObject2:
		moveq	#0,d0
		rept	$40/4
			move.l	d0,(a1)+
		endr
		rts	
; End of function DeleteObject

; ===========================================================================
BldSpr_ScrPos:	dc.l 0			; blank
		dc.l $FFF700		; main screen x-position
		dc.l $FFF708		; background x-position	1
		dc.l $FFF718		; background x-position	2
; ---------------------------------------------------------------------------
; Subroutine to	convert	mappings (etc) to proper Megadrive sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BuildSprites:				; XREF: TitleScreen; et al
		lea	($FFFFF800).w,a2 ; set address for sprite table
		moveq	#0,d5
		lea	($FFFFAC00).w,a4
		moveq	#7,d7

loc_D66A:
		tst.w	(a4)
		beq.w	loc_D72E
		moveq	#2,d6

loc_D672:
		movea.w	(a4,d6.w),a0
		tst.b	(a0)
		beq.w	loc_D726
		bclr	#7,obRender(a0)
		move.b	obRender(a0),d0
		move.b	d0,d4
		andi.w	#$C,d0
		beq.s	loc_D6DE
		movea.l	BldSpr_ScrPos(pc,d0.w),a1
		moveq	#0,d0		; MJ: Shorter/quicker code
		move.b	obActWid(a0),d0
		move.w	d0,d1
		move.w	obX(a0),d3
		sub.w	(a1),d3

		add.w	d3,d0
		add.w	d1,d1
		addi.w	#$140,d1
		cmp.w	d1,d0
		bhi.s	loc_D726
		addi.w	#$80,d3
		btst	#4,d4
		beq.s	loc_D6E8
		moveq	#0,d0		; MJ: Shorter/quicker code
		move.b	obHeight(a0),d0
		move.w	d0,d1
		move.w	obY(a0),d2
		sub.w	obMap(a1),d2
		add.w	d2,d0
		add.w	d1,d1
		addi.w	#$E0,d1
		cmp.w	d1,d0
		bhi.s	loc_D726
		addi.w	#$80,d2
		bra.s	loc_D700
; ===========================================================================

loc_D6DE:
		move.w	obScreenY(a0),d2
		move.w	obX(a0),d3
		bra.s	loc_D700
; ===========================================================================

loc_D6E8:
		move.w	obY(a0),d2
		sub.w	obMap(a1),d2
		addi.w	#$80,d2
		cmpi.w	#$60,d2
		bcs.s	loc_D726
		cmpi.w	#$180,d2
		bcc.s	loc_D726

loc_D700:
		movea.l	obMap(a0),a1
		moveq	#0,d1
		btst	#5,d4
		bne.s	loc_D71C
		move.b	obFrame(a0),d1
		add.b	d1,d1
		adda.w	(a1,d1.w),a1
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	loc_D720

loc_D71C:
		bsr	sub_D750

loc_D720:
		bset	#7,obRender(a0)

loc_D726:
		addq.w	#2,d6
		subq.w	#2,(a4)
		bne.w	loc_D672

loc_D72E:
		lea	$80(a4),a4
		dbf	d7,loc_D66A
		move.b	d5,($FFFFF62C).w
		cmpi.b	#$50,d5
		beq.s	loc_D748
		move.l	#0,(a2)
		rts	
; ===========================================================================

loc_D748:
		move.b	#0,-5(a2)
		rts	
; End of function BuildSprites


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D750:				; XREF: BuildSprites
		movea.w	obGfx(a0),a3
		btst	#0,d4
		bne.s	loc_D796
		btst	#1,d4
		bne.w	loc_D7E4
; End of function sub_D750


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_D762:				; XREF: sub_D762; SS_ShowLayout
		cmpi.b	#$50,d5
		beq.s	locret_D794
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D78E
		addq.w	#1,d0

loc_D78E:
		move.w	d0,(a2)+
		dbf	d1,sub_D762

locret_D794:
		rts	
; End of function sub_D762

; ===========================================================================

loc_D796:
		btst	#1,d4
		bne.w	loc_D82A

loc_D79E:
		cmpi.b	#$50,d5
		beq.s	locret_D7E2
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D7DC
		addq.w	#1,d0

loc_D7DC:
		move.w	d0,(a2)+
		dbf	d1,loc_D79E

locret_D7E2:
		rts	
; ===========================================================================

loc_D7E4:				; XREF: sub_D750
		cmpi.b	#$50,d5
		beq.s	locret_D828
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$1000,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D822
		addq.w	#1,d0

loc_D822:
		move.w	d0,(a2)+
		dbf	d1,loc_D7E4

locret_D828:
		rts	
; ===========================================================================

loc_D82A:
		cmpi.b	#$50,d5
		beq.s	locret_D87C
		move.b	(a1)+,d0
		move.b	(a1),d4
		ext.w	d0
		neg.w	d0
		lsl.b	#3,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d2,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d4
		move.b	d4,(a2)+
		addq.b	#1,d5
		move.b	d5,(a2)+
		move.b	(a1)+,d0
		lsl.w	#8,d0
		move.b	(a1)+,d0
		add.w	a3,d0
		eori.w	#$1800,d0
		move.w	d0,(a2)+
		move.b	(a1)+,d0
		ext.w	d0
		neg.w	d0
		add.b	d4,d4
		andi.w	#$18,d4
		addq.w	#8,d4
		sub.w	d4,d0
		add.w	d3,d0
		andi.w	#$1FF,d0
		bne.s	loc_D876
		addq.w	#1,d0

loc_D876:
		move.w	d0,(a2)+
		dbf	d1,loc_D82A

locret_D87C:
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	check if an object is on the screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen:
		move.w	obX(a0),d0	; get object x-position
		sub.w	($FFFFF700).w,d0 ; subtract screen x-position
		bmi.s	NotOnScreen
		cmpi.w	#320,d0		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		move.w	obY(a0),d1	; get object y-position
		sub.w	($FFFFF704).w,d1 ; subtract screen y-position
		bmi.s	NotOnScreen
		cmpi.w	#224,d1		; is object on the screen?
		bge.s	NotOnScreen	; if not, branch

		moveq	#0,d0		; set flag to 0
		rts	
; ===========================================================================

NotOnScreen:				; XREF: ChkObjOnScreen
		moveq	#1,d0		; set flag to 1
		rts	
; End of function ChkObjOnScreen


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ChkObjOnScreen2:
		moveq	#0,d1
		move.b	obActWid(a0),d1
		move.w	obX(a0),d0
		sub.w	($FFFFF700).w,d0
		add.w	d1,d0
		bmi.s	NotOnScreen2
		add.w	d1,d1
		sub.w	d1,d0
		cmpi.w	#320,d0
		bge.s	NotOnScreen2

		move.w	obY(a0),d1
		sub.w	($FFFFF704).w,d1
		bmi.s	NotOnScreen2
		cmpi.w	#224,d1
		bge.s	NotOnScreen2

		moveq	#0,d0
		rts	
; ===========================================================================

NotOnScreen2:				; XREF: ChkObjOnScreen2
		moveq	#1,d0
		rts	
; End of function ChkObjOnScreen2

; ---------------------------------------------------------------------------
; Subroutine to	load a level's objects
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjPosLoad:				; XREF: Level; et al
		moveq	#0,d0
		move.b	($FFFFF76C).w,d0
		move.w	OPL_Index(pc,d0.w),d0
		jmp	OPL_Index(pc,d0.w)
; End of function ObjPosLoad

; ===========================================================================
OPL_Index:	dc.w OPL_Main-OPL_Index
		dc.w OPL_Next-OPL_Index
; ===========================================================================

OPL_Main:				; XREF: OPL_Index
		addq.b	#2,($FFFFF76C).w
		move.w	($FFFFFE10).w,d0
		lsl.b	#6,d0
		lsr.w	#4,d0
		lea	(ObjPos_Index).l,a0
		movea.l	a0,a1
		adda.w	(a0,d0.w),a0
		move.l	a0,($FFFFF770).w
		move.l	a0,($FFFFF774).w
		adda.w	obGfx(a1,d0.w),a1
		move.l	a1,($FFFFF778).w
		move.l	a1,($FFFFF77C).w
		lea	($FFFFFC00).w,a2
		move.w	#$101,(a2)+
		move.w	#$5E,d0

OPL_ClrList:
		clr.l	(a2)+
		dbf	d0,OPL_ClrList	; clear	pre-destroyed object list

		lea	($FFFFFC00).w,a2
		moveq	#0,d2
		move.w	($FFFFF700).w,d6
		subi.w	#$80,d6
		bcc.s	loc_D93C
		moveq	#0,d6

loc_D93C:
		andi.w	#$FF80,d6
		movea.l	($FFFFF770).w,a0

loc_D944:
		cmp.w	(a0),d6
		bls.s	loc_D956
		tst.b	obMap(a0)
		bpl.s	loc_D952
		move.b	(a2),d2
		addq.b	#1,(a2)

loc_D952:
		addq.w	#6,a0
		bra.s	loc_D944
; ===========================================================================

loc_D956:
		move.l	a0,($FFFFF770).w
		movea.l	($FFFFF774).w,a0
		subi.w	#$80,d6
		bcs.s	loc_D976

loc_D964:
		cmp.w	(a0),d6
		bls.s	loc_D976
		tst.b	obMap(a0)
		bpl.s	loc_D972
		addq.b	#1,obRender(a2)

loc_D972:
		addq.w	#6,a0
		bra.s	loc_D964
; ===========================================================================

loc_D976:
		move.l	a0,($FFFFF774).w
		move.w	#-1,($FFFFF76E).w

OPL_Next:				; XREF: OPL_Index
		lea	($FFFFFC00).w,a2
		moveq	#0,d2
		move.w	($FFFFF700).w,d6
		andi.w	#$FF80,d6
		cmp.w	($FFFFF76E).w,d6
		beq.w	locret_DA3A
		bge.s	loc_D9F6
		move.w	d6,($FFFFF76E).w
		movea.l	($FFFFF774).w,a0
		subi.w	#$80,d6
		bcs.s	loc_D9D2

loc_D9A6:
		cmp.w	-6(a0),d6
		bge.s	loc_D9D2
		subq.w	#6,a0
		tst.b	obMap(a0)
		bpl.s	loc_D9BC
		subq.b	#1,obRender(a2)
		move.b	obRender(a2),d2

loc_D9BC:
		bsr	loc_DA3C
		bne.s	loc_D9C6
		subq.w	#6,a0
		bra.s	loc_D9A6
; ===========================================================================

loc_D9C6:
		tst.b	obMap(a0)
		bpl.s	loc_D9D0
		addq.b	#1,obRender(a2)

loc_D9D0:
		addq.w	#6,a0

loc_D9D2:
		move.l	a0,($FFFFF774).w
		movea.l	($FFFFF770).w,a0
		addi.w	#$300,d6

loc_D9DE:
		cmp.w	-6(a0),d6
		bgt.s	loc_D9F0
		tst.b	-obGfx(a0)
		bpl.s	loc_D9EC
		subq.b	#1,(a2)

loc_D9EC:
		subq.w	#6,a0
		bra.s	loc_D9DE
; ===========================================================================

loc_D9F0:
		move.l	a0,($FFFFF770).w
		rts	
; ===========================================================================

loc_D9F6:
		move.w	d6,($FFFFF76E).w
		movea.l	($FFFFF770).w,a0
		addi.w	#$280,d6

loc_DA02:
		cmp.w	(a0),d6
		bls.s	loc_DA16
		tst.b	obMap(a0)
		bpl.s	loc_DA10
		move.b	(a2),d2
		addq.b	#1,(a2)

loc_DA10:
		bsr	loc_DA3C
		beq.s	loc_DA02
		tst.b	$04(a0)		; was this object a remember state?
		bpl.s	loc_DA16	; if not, branch
		subq.b	#1,(a2)		; move right counter back
		
loc_DA16:
		move.l	a0,($FFFFF770).w
		movea.l	($FFFFF774).w,a0
		subi.w	#$300,d6
		bcs.s	loc_DA36

loc_DA24:
		cmp.w	(a0),d6
		bls.s	loc_DA36
		tst.b	obMap(a0)
		bpl.s	loc_DA32
		addq.b	#1,obRender(a2)

loc_DA32:
		addq.w	#6,a0
		bra.s	loc_DA24
; ===========================================================================

loc_DA36:
		move.l	a0,($FFFFF774).w

locret_DA3A:
		rts	
; ===========================================================================

loc_DA3C:
		tst.b	obMap(a0)
		bpl.s	OPL_MakeItem
		btst	#7,obGfx(a2,d2.w)
		beq.s	OPL_MakeItem
		addq.w	#6,a0
		moveq	#0,d0
		rts	
; ===========================================================================

OPL_MakeItem:
		bsr	SingleObjLoad
		bne.s	locret_DA8A
		move.w	(a0)+,obX(a1)
		move.w	(a0)+,d0
		move.w	d0,d1
		andi.w	#$FFF,d0
		move.w	d0,obY(a1)
		rol.w	#2,d1
		andi.b	#3,d1
		move.b	d1,obRender(a1)
		move.b	d1,obStatus(a1)
		move.b	(a0)+,d0
		bpl.s	loc_DA80
		bset	#7,$02(a2,d2.w)		; set as removed
		andi.b	#$7F,d0
		move.b	d2,obRespawnNo(a1)

loc_DA80:
		move.b	d0,0(a1)
		move.b	(a0)+,obSubtype(a1)
		moveq	#0,d0

locret_DA8A:
		rts	
; ---------------------------------------------------------------------------
; Single object	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad:
		lea	($FFFFD800).w,a1 ; start address for object RAM
		move.w	#$5F,d0

loc_DA94:
		tst.b	(a1)		; is object RAM	slot empty?
		beq.s	locret_DAA0	; if yes, branch
		lea	$40(a1),a1	; goto next object RAM slot
		dbf	d0,loc_DA94	; repeat $5F times

locret_DAA0:
		assert.w a1, lo, #$F000
		rts	
; End of function SingleObjLoad


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SingleObjLoad2:
		movea.l	a0,a1
		move.w	#-$1000,d0
		sub.w	a0,d0
		lsr.w	#6,d0
		subq.w	#1,d0
		bcs.s	locret_DABC

loc_DAB0:
		tst.b	(a1)
		beq.s	locret_DABC
		lea	$40(a1),a1
		dbf	d0,loc_DAB0

locret_DABC:
		rts	
; End of function SingleObjLoad2

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 41 - springs
; ---------------------------------------------------------------------------

Obj41:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj41_Index(pc,d0.w),d1
		jsr	obj41_Index(pc,d1.w)
		jmp	MarkObjGone
; ===========================================================================
Obj41_Index:	dc.w Obj41_Main-Obj41_Index
		dc.w Obj41_Up-Obj41_Index
		dc.w Obj41_AniUp-Obj41_Index
		dc.w Obj41_ResetUp-Obj41_Index
		dc.w Obj41_LR-Obj41_Index
		dc.w Obj41_AniLR-Obj41_Index
		dc.w Obj41_ResetLR-Obj41_Index
		dc.w Obj41_Dwn-Obj41_Index
		dc.w Obj41_AniDwn-Obj41_Index
		dc.w Obj41_ResetDwn-Obj41_Index

;Obj41_Powers:	dc.w -$1000		; power	of red spring
	;	dc.w -$A00		; power	of yellow spring
; ===========================================================================

Obj41_Main:				; XREF: Obj41_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj41,obMap(a0)
		move.w	#$523,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#4,obPriority(a0)
		move.b	obSubtype(a0),d0
		btst	#4,d0		; does the spring face left/right?
		beq.s	loc_DB54	; if not, branch
		move.b	#8,obRoutine(a0)	; use "Obj41_LR" routine
		move.b	#1,obAnim(a0)
		move.b	#3,obFrame(a0)
		move.w	#$533,obGfx(a0)	; set standart art lcoation
		cmpi.b	#6,($FFFFFE10).w ; is this the ending sequence?
		bne.s	@cont		; if not, branch
		move.w	#$524,obGfx(a0)	; use alternate art location

@cont:
		move.b	#8,obActWid(a0)

loc_DB54:
		btst	#5,d0		; does the spring face downwards?
		beq.s	loc_DB66	; if not, branch
		move.b	#$E,obRoutine(a0)	; use "Obj41_Dwn" routine
		bset	#1,obStatus(a0)

loc_DB66:
		btst	#1,d0
		beq.s	loc_DB72
		bset	#5,obGfx(a0)

loc_DB72:
		andi.w	#$F,d0
		move.w	Obj41_Powers(pc,d0.w),$30(a0)
		rts

; ===========================================================================
Obj41_Powers:	dc.w -$1000		; power	of red spring
		dc.w -$A00		; power	of yellow spring
; ===========================================================================

Obj41_Up:				; XREF: Obj41_Index
		cmpi.w	#$501,($FFFFFE10).w
		bne.s	@cont
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0		; get Sonic's X-pos
		sub.w	obX(a0),d0		; substract the X-pos from the current object from it
		addi.w	#$10,d0			; add $10 to it
		cmpi.w	#$20,d0			; is Sonic within $10 pixels of that object?
		bhi.s	Obj41_Up_Return		; if not, branch
		move.w	obY(a1),d0		; get Sonic's X-pos
		sub.w	obY(a0),d0		; substract the X-pos from the current object from it
		addi.w	#$1C,d0			; add $10 to it
		cmpi.w	#$38,d0			; is Sonic within $10 pixels of that object?
		bhi.s	Obj41_Up_Return		; if not, branch
		jsr	sub_FC2C
		bra.s	Obj41_BounceUp

@cont:
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		tst.b	ob2ndRout(a0)		; is Sonic on top of the spring?
		bne.s	Obj41_BounceUp	; if yes, branch

Obj41_Up_Return:
		rts	
; ===========================================================================

Obj41_BounceUp:				; XREF: Obj41_Up
		addq.b	#1,($FFFFFFB4).w
		addq.b	#2,obRoutine(a0)
		addq.w	#8,obY(a1)
		move.w	$30(a0),obVelY(a1)	; move Sonic upwards
		cmpi.w	#$400,($FFFFFE10).w
		bne.s	@0
		subi.w	#$50,obY(a1)
@0:
		move.b	#1,($FFFFFFAD).w
		move.b	#1,($FFFFFF96).w
		bset	#1,obStatus(a1)
		bclr	#3,obStatus(a1)
		move.b	#$10,obAnim(a1)	; use "bouncing" animation
		move.b	#2,obRoutine(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)
		move.w	#$CC,d0
		jsr	(PlaySound_Special).l ;	play spring sound

Obj41_AniUp:				; XREF: Obj41_Index
		lea	(Ani_obj41).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_ResetUp:				; XREF: Obj41_Index
		move.b	#1,obNextAni(a0)	; reset	animation
		subq.b	#4,obRoutine(a0)	; goto "Obj41_Up" routine
		rts	
; ===========================================================================

Obj41_LR:				; XREF: Obj41_Index
		move.w	#$13,d1
		move.w	#$E,d2
		move.w	#$F,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		cmpi.b	#2,obRoutine(a0)
		bne.s	loc_DC0C
		move.b	#8,obRoutine(a0)

loc_DC0C:
		btst	#5,obStatus(a0)
		bne.s	Obj41_BounceLR
		rts	
; ===========================================================================

Obj41_BounceLR:				; XREF: Obj41_LR
		addq.b	#2,obRoutine(a0)
		move.b	#1,($FFFFFFAD).w
		move.w	$30(a0),obVelX(a1)	; move Sonic to	the left
		addq.w	#8,obX(a1)
		btst	#0,obStatus(a0)	; is object flipped?
		bne.s	loc_DC36	; if yes, branch
		subi.w	#$10,obX(a1)
		neg.w	obVelX(a1)		; move Sonic to	the right

loc_DC36:
		move.w	#$F,$3E(a1)
		move.w	obVelX(a1),obInertia(a1)
		bchg	#0,obStatus(a1)
		btst	#2,obStatus(a1)
		bne.s	loc_DC56
		move.b	#0,obAnim(a1)	; use running animation

loc_DC56:
		bclr	#5,obStatus(a0)
		bclr	#5,obStatus(a1)
		move.w	#$CC,d0
		jsr	(PlaySound_Special).l ;	play spring sound

		cmpi.b	#$18,($FFFFF600).w	; is this the ending sequence?
		bne.s	Obj41_AniLR		; if not, branch
		bset	#0,($FFFFD022).w	; make	Sonic face left

Obj41_AniLR:				; XREF: Obj41_Index
		lea	(Ani_obj41).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_ResetLR:				; XREF: Obj41_Index
		move.b	#2,obNextAni(a0)	; reset	animation
		subq.b	#4,obRoutine(a0)	; goto "Obj41_LR" routine
		rts	
; ===========================================================================

Obj41_Dwn:				; XREF: Obj41_Index
		move.w	#$1B,d1
		move.w	#8,d2
		move.w	#$10,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		cmpi.b	#2,obRoutine(a0)
		bne.s	loc_DCA4
		move.b	#$E,obRoutine(a0)

loc_DCA4:
		tst.b	ob2ndRout(a0)
		bne.s	locret_DCAE
		tst.w	d4
		bmi.s	Obj41_BounceDwn

locret_DCAE:
		rts	
; ===========================================================================

Obj41_BounceDwn:			; XREF: Obj41_Dwn
		addq.b	#2,obRoutine(a0)
		subq.w	#8,obY(a1)
		move.b	#1,($FFFFFFAD).w
		move.w	$30(a0),obVelY(a1)
		neg.w	obVelY(a1)		; move Sonic downwards
		bset	#1,obStatus(a1)
		bclr	#3,obStatus(a1)
		move.b	#2,obRoutine(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)
		move.w	#$CC,d0
		jsr	(PlaySound_Special).l ;	play spring sound

Obj41_AniDwn:				; XREF: Obj41_Index
		lea	(Ani_obj41).l,a1
		bra.w	AnimateSprite
; ===========================================================================

Obj41_ResetDwn:				; XREF: Obj41_Index
		move.b	#1,obNextAni(a0)	; reset	animation
		subq.b	#4,obRoutine(a0)	; goto "Obj41_Dwn" routine
		rts	
; ===========================================================================
Ani_obj41:
		include	"_anim\obj41.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - springs
; ---------------------------------------------------------------------------
Map_obj41:
		include	"_maps\obj41.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 42 - Newtron enemy (GHZ)
; ---------------------------------------------------------------------------
;=================================
;Speed
; The speed for the normal newtron
NSpeed = 1
;=================================

Obj42:					; XREF: Obj_Index
		jmp	DeleteObject
; ---------------------------------------------------------------------------
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj42_Index(pc,d0.w),d1
		jmp	Obj42_Index(pc,d1.w)
; ===========================================================================
Obj42_Index:	dc.w Obj42_Main-Obj42_Index
		dc.w Obj42_Action-Obj42_Index
		dc.w Obj42_Explosion-Obj42_Index
		dc.w Obj42_Delete-Obj42_Index
; ===========================================================================

Obj42_Main:				; XREF: Obj42_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj42,obMap(a0)
		move.w	#$49B,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$14,obActWid(a0)
		move.b	#$10,obHeight(a0)
		move.b	#8,obWidth(a0)

Obj42_Action:				; XREF: Obj42_Index
		tst.b	($FFFFFFE7).w
		bne.s	Obj42_NotInhumanCrush
		tst.b	($FFFFFFB1).w
		bmi.s	Obj42_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj42_NotInhumanCrush
		move.b	#4,obRoutine(a0)		
		bsr	SingleObjLoad
		bne.s	Obj42_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj42_NotInhumanCrush:
		tst.b	obSubtype(a0)		; check	object type
		bne.s	Obj42_NoFixLoc	; if type is 01, branch
		jsr	obj42_FixLoc

Obj42_NoFixLoc:
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj42_Index2(pc,d0.w),d1
		jsr	obj42_Index2(pc,d1.w)
		lea	(Ani_obj42).l,a1
		bsr	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj42_Index2:	dc.w Obj42_ChkDist-Obj42_Index2
		dc.w Obj42_Type00-Obj42_Index2
		dc.w Obj42_MatchFloor-Obj42_Index2
		dc.w Obj42_Speed-Obj42_Index2
		dc.w Obj42_Type01-Obj42_Index2
; ===========================================================================

Obj42_ChkDist:				; XREF: Obj42_Index2
		bset	#0,obStatus(a0)
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_DDEA
		neg.w	d0
		bclr	#0,obStatus(a0)

loc_DDEA:
		cmpi.w	#$80,d0		; is Sonic within $80 pixels of	the newtron?
		bcc.s	locret_DE12	; if not, branch
		addq.b	#2,ob2ndRout(a0)
		move.b	#2,obAnim(a0)
		tst.b	obSubtype(a0)		; check	object type
		beq.s	locret_DE12	; if type is 00, branch
		move.w	#$249B,obGfx(a0)
		move.b	#8,ob2ndRout(a0)	; run type 01 newtron subroutine
		move.b	#4,obAnim(a0)	; use different	animation

locret_DE12:
		rts	
; ===========================================================================

Obj42_Type00:				; XREF: Obj42_Index2
		jmp	DeleteObject	; no regular netron.

		cmpi.b	#4,obFrame(a0)	; has "appearing" animation finished?
		bcc.s	Obj42_Fall	; is yes, branch
		bset	#0,obStatus(a0)
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	locret_DE32
		bclr	#0,obStatus(a0)

locret_DE32:
		rts	
; ===========================================================================

Obj42_Fall:				; XREF: Obj42_Type00
		tst.b	obSubtype(a0)		; check	object type
		bne.s	locret_DE32	; if type is 01, branch
	;	cmpi.b	#1,obFrame(a0)
	;	bne.s	loc_DE42
	;	move.b	#$C,obColType(a0)

loc_DE42:
		bsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1		; has newtron hit the floor?
		bpl.w	locret_DE86	; if not, branch
		add.w	d1,obY(a0)
		move.w	#0,obVelY(a0)	; stop newtron falling
		addq.b	#2,ob2ndRout(a0)
		move.b	#2,obAnim(a0)
		btst	#5,obGfx(a0)
		beq.s	Obj42_Move
		move.b	#2,obAnim(a0)

Obj42_Move:
	;	move.b	#$D,obColType(a0)

Obj42_FixLoc:
		moveq	#0,d0
		moveq	#0,d1
		lea	($FFFFD000).w,a2
		move.w	$08(a2),d0
		sub.w	$08(a0),d0
		bpl.s	NewMoveRight
		sub.w	#NSpeed,$08(a0)
		bclr	#0,obStatus(a0)
		bra.s	NewMoveNoRight

NewMoveRight:
		bset	#0,obStatus(a0)
		add.w	#NSpeed,$08(a0)

NewMoveNoright:
		move.w	$0C(a2),d0
		sub.w	$0C(a0),d0
		bpl.s	NewMoveDown
		sub.w	#NSpeed,$0C(a0)
		bra.s	NewMoveEnd

NewMoveDown: 
		add.w	#NSpeed,$0C(a0)

NewMoveEnd:
		moveq	#0,d0
		moveq	#0,d1
		move.w	obX(a0),d0			; load object's X pos
		sub.w	obX(a2),d0			; minus sonic's X pos from it
		bpl.w	New_XChk			; if answer is possitive, branch
		neg.w	d0				; reverse d0

New_XChk:
		cmpi.w	#$10,d0				; is sonic within 10 pixels of the object?
		bge.w	locret_DE86			; if not, branch

		move.w	obY(a0),d1			; load object's Y pos
		sub.w	obY(a2),d1			; minus sonic's Y pos from it
		bpl.w	New_YChk			; if answer is possitive, branch
		neg.w	d1				; reverse d1

New_YChk:
		cmpi.w	#$10,d1				; is sonic within 10 pixels of the object?
		bge.w	locret_DE86			; if not, branch
	;	tst.w	($FFFFD030).w	; +++ is Sonic invulnerable? (Spike Behavior check)
	;	bne.s	locret_DE86	; +++ if yes, branch
		addq.b	#2,obRoutine(a0)
		move.b	#0,ob2ndRout(a0)
		rts
		move.w	#$200,obVelY(a0)
		move.b	#6,obAnim(a0)
		bchg	#1,obStatus(a0)
		move.b	#1,($FFFFFFA4).w
		rts					; return
	;	move.w	#NSpeed,obVelX(a0)	; move newtron horizontally
	;	btst	#0,obStatus(a0)
	;	bne.s	locret_DE86
	;	neg.w	obVelX(a0)

locret_DE86:
		rts	
; ===========================================================================

Obj42_ChkOffScreen:
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmp.w	obY(a0),d0		; has object moved below the level boundary?
		bcc.w	Obj42_NotOffScreen	; if not, branch
		clr.b	($FFFFFFA4).w
		bra.w	Obj42_Delete		; if yes, branch

Obj42_NotOffScreen:
		rts
; ===========================================================================		

Obj42_MatchFloor:			; XREF: Obj42_Index2
		rts
		bsr	SpeedToPos
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	loc_DEA2
		cmpi.w	#$C,d1
		bge.s	loc_DEA2
		add.w	d1,obY(a0)	; match	newtron's position with floor
		rts	
; ===========================================================================

loc_DEA2:
		addq.b	#2,ob2ndRout(a0)
		rts	
; ===========================================================================

Obj42_Speed:				; XREF: Obj42_Index2
		bsr	SpeedToPos
		rts	
; ===========================================================================

Obj42_Type01:				; XREF: Obj42_Index2
		cmpi.b	#1,obFrame(a0)
		bne.s	Obj42_FireMissile
		move.b	#$C,obColType(a0)

Obj42_FireMissile:
		cmpi.b	#2,obFrame(a0)
		bne.s	locret_DF14
		tst.b	$32(a0)
		bne.s	locret_DF14
		move.b	#1,$32(a0)
		bsr	SingleObjLoad
		bne.s	locret_DF14
		move.b	#$23,0(a1)	; load missile object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		subq.w	#8,obY(a1)
		move.w	#$200,obVelX(a1)
		move.w	#$14,d0
		btst	#0,obStatus(a0)
		bne.s	loc_DF04
		neg.w	d0
		neg.w	obVelX(a1)

loc_DF04:
		add.w	d0,obX(a1)
		move.b	obStatus(a0),obStatus(a1)
		move.b	#1,obSubtype(a1)

locret_DF14:
		rts	
; ===========================================================================

Obj42_Explosion:				; XREF: Obj42_Index
		tst.b	obSubtype(a0)		; check	object type
		bne.s	locret_DF14	; if type is 01, branch
		move.b	#5,d5

New_kill:
		jsr	BossDefeated
	;	dbf	d5,New_kill

		move.b	#$C4,d0				; load boost SFX
		jsr	PlaySound_Special		; play boost SFX
		jsr	SingleObjLoad
		move.b	#$3F,0(a1)			; change bomb into an explosion
		move.w	obX(a2),obX(a1)
		move.w	obY(a2),obY(a1)
		addq.b	#2,obRoutine(a0)
		rts

Obj42_Delete:
		bra.w	DeleteObject
; ===========================================================================
Ani_obj42:
		include	"_anim\obj42.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Newtron enemy (GHZ)
; ---------------------------------------------------------------------------
Map_obj42:
		include	"_maps\obj42.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 43 - Roller enemy (SYZ)
; ---------------------------------------------------------------------------

Obj43:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj43_Index(pc,d0.w),d1
		jmp	Obj43_Index(pc,d1.w)
; ===========================================================================
Obj43_Index:	dc.w Obj43_Main-Obj43_Index
		dc.w Obj43_Action-Obj43_Index
; ===========================================================================

Obj43_Main:				; XREF: Obj43_Index
		move.b	#$E,obHeight(a0)
		move.b	#8,obWidth(a0)
		bsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E052
		add.w	d1,obY(a0)	; match	roller's position with the floor
		move.w	#0,obVelY(a0)
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj43,obMap(a0)
		move.w	#$4B8,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$10,obActWid(a0)

locret_E052:
		rts	
; ===========================================================================

Obj43_Action:				; XREF: Obj43_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj43_Index2(pc,d0.w),d1
		jsr	obj43_Index2(pc,d1.w)
		lea	(Ani_obj43).l,a1
		bsr	AnimateSprite
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bgt.w	Obj43_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Obj43_ChkGone:				; XREF: Obj43_Action
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj43_Delete
		bclr	#7,obGfx(a2,d0.w)

Obj43_Delete:
		bra.w	DeleteObject
; ===========================================================================
Obj43_Index2:	dc.w Obj43_RollChk-Obj43_Index2
		dc.w Obj43_RollNoChk-Obj43_Index2
		dc.w Obj43_ChkJump-Obj43_Index2
		dc.w Obj43_MatchFloor-Obj43_Index2
; ===========================================================================

Obj43_RollChk:				; XREF: Obj43_Index2
		move.w	($FFFFD008).w,d0
		subi.w	#$100,d0
		bcs.s	loc_E0D2
		sub.w	obX(a0),d0	; check	distance between Roller	and Sonic
		bcs.s	loc_E0D2
		addq.b	#4,ob2ndRout(a0)
		move.b	#2,obAnim(a0)
		move.w	#$700,obVelX(a0)	; move Roller horizontally
		move.b	#$8E,obColType(a0)	; make Roller invincible

loc_E0D2:
		addq.l	#4,sp
		rts	
; ===========================================================================

Obj43_RollNoChk:			; XREF: Obj43_Index2
		cmpi.b	#2,obAnim(a0)
		beq.s	loc_E0F8
		subq.w	#1,$30(a0)
		bpl.s	locret_E0F6
		move.b	#1,obAnim(a0)
		move.w	#$700,obVelX(a0)
		move.b	#$8E,obColType(a0)

locret_E0F6:
		rts	
; ===========================================================================

loc_E0F8:
		addq.b	#2,ob2ndRout(a0)
		rts	
; ===========================================================================

Obj43_ChkJump:				; XREF: Obj43_Index2
		jsr	obj43_Stop
		bsr	SpeedToPos
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj43_Jump
		cmpi.w	#$C,d1
		bge.s	Obj43_Jump
		add.w	d1,obY(a0)
		rts	
; ===========================================================================

Obj43_Jump:
		addq.b	#2,ob2ndRout(a0)
		bset	#0,$32(a0)
		beq.s	locret_E12E
		move.w	#-$600,obVelY(a0)	; move Roller vertically

locret_E12E:
		rts	
; ===========================================================================

Obj43_MatchFloor:			; XREF: Obj43_Index2
		bsr	ObjectFall
		tst.w	obVelY(a0)
		bmi.s	locret_E150
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E150
		add.w	d1,obY(a0)	; match	Roller's position with the floor
		subq.b	#2,ob2ndRout(a0)
		move.w	#0,obVelY(a0)

locret_E150:
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj43_Stop:				; XREF: Obj43_ChkJump
		tst.b	$32(a0)
		bmi.s	locret_E188
		move.w	($FFFFD008).w,d0
		subi.w	#$30,d0
		sub.w	obX(a0),d0
		bcc.s	locret_E188
		move.b	#0,obAnim(a0)
		move.b	#$E,obColType(a0)
		clr.w	obVelX(a0)
		move.w	#120,$30(a0)	; set waiting time to 2	seconds
		move.b	#2,ob2ndRout(a0)
		bset	#7,$32(a0)

locret_E188:
		rts	
; End of function Obj43_Stop

; ===========================================================================
Ani_obj43:
		include	"_anim\obj43.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Roller enemy (SYZ)
; ---------------------------------------------------------------------------
Map_obj43:
		include	"_maps\obj43.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 44 - walls (GHZ)
; ---------------------------------------------------------------------------

Obj44:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj44_Index(pc,d0.w),d1
		jmp	Obj44_Index(pc,d1.w)
; ===========================================================================
Obj44_Index:	dc.w Obj44_Main-Obj44_Index
		dc.w Obj44_Solid-Obj44_Index
		dc.w Obj44_Display-Obj44_Index
; ===========================================================================

Obj44_Main:				; XREF: Obj44_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj44,obMap(a0)
		move.w	#$434C,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#8,obActWid(a0)
		move.b	#6,obPriority(a0)
		move.b	obSubtype(a0),obFrame(a0)	; copy object type number to frame number
		bclr	#4,obFrame(a0)	; clear	4th bit	(deduct	$10)
		beq.s	Obj44_Solid	; make object solid if 4th bit = 0
		addq.b	#2,obRoutine(a0)
		bra.s	Obj44_Display	; don't make it solid if 4th bit = 1
; ===========================================================================

Obj44_Solid:				; XREF: Obj44_Index
		move.w	#$13,d1
		move.w	#$28,d2
		jsr	obj44_SolidWall

Obj44_Display:				; XREF: Obj44_Index
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - walls (GHZ)
; ---------------------------------------------------------------------------
Map_obj44:
		include	"_maps\obj44.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 13 - lava ball	producer (MZ, SLZ)
; ---------------------------------------------------------------------------

Obj13:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj13_Index(pc,d0.w),d1
		jsr	obj13_Index(pc,d1.w)
		bra.w	Obj14_ChkDel
; ===========================================================================
Obj13_Index:	dc.w Obj13_Main-Obj13_Index
		dc.w Obj13_MakeLava-Obj13_Index
; ---------------------------------------------------------------------------
;
; Lava ball production rates
;
Obj13_Rates:	dc.b 30, 60, 90, 120, 150, 180
; ===========================================================================

Obj13_Main:				; XREF: Obj13_Index
		addq.b	#2,obRoutine(a0)
		move.b	obSubtype(a0),d0
		lsr.w	#4,d0
		andi.w	#$F,d0
		move.b	Obj13_Rates(pc,d0.w),obDelayAni(a0)
		move.b	obDelayAni(a0),obTimeFrame(a0)	; set time delay for lava balls
		andi.b	#$F,obSubtype(a0)

Obj13_MakeLava:				; XREF: Obj13_Index
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from time delay
		bne.s	locret_E302	; if time still	remains, branch
		move.b	obDelayAni(a0),obTimeFrame(a0)	; reset	time delay
		bsr	ChkObjOnScreen
		bne.s	locret_E302
		bsr	SingleObjLoad
		bne.s	locret_E302
		move.b	#$14,0(a1)	; load lava ball object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	obSubtype(a0),obSubtype(a1)

locret_E302:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 14 - lava balls (MZ, SLZ)
; ---------------------------------------------------------------------------

Obj14:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj14_Index(pc,d0.w),d1
		jsr	obj14_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj14_Index:	dc.w Obj14_Main-Obj14_Index
		dc.w Obj14_Action-Obj14_Index
		dc.w Obj14_Delete-Obj14_Index

Obj14_Speeds:	dc.w $FC00, $FB00, $FA00, $F900, $FE00
		dc.w $200, $FE00, $200,	0
; ===========================================================================

Obj14_Main:				; XREF: Obj14_Index
		addq.b	#2,obRoutine(a0)
		move.b	#8,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.l	#Map_obj14,obMap(a0)
		move.w	#$345,obGfx(a0)
		cmpi.b	#3,($FFFFFE10).w ; check if level is SLZ
		bne.s	loc_E35A
		move.w	#$480,obGfx(a0)	; SLZ specific code

loc_E35A:
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$8B,obColType(a0)
		move.w	obY(a0),$30(a0)
		tst.b	$29(a0)
		beq.s	Obj14_SetSpeed
		addq.b	#2,obPriority(a0)

Obj14_SetSpeed:
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		move.w	Obj14_Speeds(pc,d0.w),obVelY(a0) ;	load object speed (vertical)
		move.b	#8,obActWid(a0)
		cmpi.b	#6,obSubtype(a0)	; is object type below $6 ?
		bcs.s	Obj14_PlaySnd	; if yes, branch
		move.b	#$10,obActWid(a0)
		move.b	#2,obAnim(a0)	; use horizontal animation
		move.w	obVelY(a0),obVelX(a0)	; set horizontal speed
		move.w	#0,obVelY(a0)	; delete vertical speed

Obj14_PlaySnd:
		move.w	#$AE,d0
		jsr	(PlaySound_Special).l ;	play lava ball sound

Obj14_Action:				; XREF: Obj14_Index
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		move.w	Obj14_TypeIndex(pc,d0.w),d1
		jsr	obj14_TypeIndex(pc,d1.w)
		bsr	SpeedToPos
		lea	(Ani_obj14).l,a1
		bsr	AnimateSprite

Obj14_ChkDel:				; XREF: Obj13
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================
Obj14_TypeIndex:dc.w Obj14_Type00-Obj14_TypeIndex, Obj14_Type00-Obj14_TypeIndex
		dc.w Obj14_Type00-Obj14_TypeIndex, Obj14_Type00-Obj14_TypeIndex
		dc.w Obj14_Type04-Obj14_TypeIndex, Obj14_Type05-Obj14_TypeIndex
		dc.w Obj14_Type06-Obj14_TypeIndex, Obj14_Type07-Obj14_TypeIndex
		dc.w Obj14_Type08-Obj14_TypeIndex
; ===========================================================================
; lavaball types 00-03 fly up and fall back down

Obj14_Type00:				; XREF: Obj14_TypeIndex
		addi.w	#$18,obVelY(a0)	; increase object's downward speed
		move.w	$30(a0),d0
		cmp.w	obY(a0),d0	; has object fallen back to its	original position?
		bcc.s	loc_E41E	; if not, branch
		addq.b	#2,obRoutine(a0)	; goto "Obj14_Delete" routine

loc_E41E:
		bclr	#1,obStatus(a0)
		tst.w	obVelY(a0)
		bpl.s	locret_E430
		bset	#1,obStatus(a0)

locret_E430:
		rts	
; ===========================================================================
; lavaball type	04 flies up until it hits the ceiling

Obj14_Type04:				; XREF: Obj14_TypeIndex
		bset	#1,obStatus(a0)
		jsr	ObjHitCeiling
		tst.w	d1
		bpl.s	locret_E452
		move.b	#8,obSubtype(a0)
		move.b	#1,obAnim(a0)
		move.w	#0,obVelY(a0)	; stop the object when it touches the ceiling

locret_E452:
		rts	
; ===========================================================================
; lavaball type	05 falls down until it hits the	floor

Obj14_Type05:				; XREF: Obj14_TypeIndex
		bclr	#1,obStatus(a0)
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_E474
		move.b	#8,obSubtype(a0)
		move.b	#1,obAnim(a0)
		move.w	#0,obVelY(a0)	; stop the object when it touches the floor

locret_E474:
		rts	
; ===========================================================================
; lavaball types 06-07 move sideways

Obj14_Type06:				; XREF: Obj14_TypeIndex
		bset	#0,obStatus(a0)
		moveq	#-8,d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bpl.s	locret_E498
		move.b	#8,obSubtype(a0)
		move.b	#3,obAnim(a0)
		move.w	#0,obVelX(a0)	; stop object when it touches a	wall

locret_E498:
		rts	
; ===========================================================================

Obj14_Type07:				; XREF: Obj14_TypeIndex
		bclr	#0,obStatus(a0)
		moveq	#8,d3
		jsr	ObjHitWallRight
		tst.w	d1
		bpl.s	locret_E4BC
		move.b	#8,obSubtype(a0)
		move.b	#3,obAnim(a0)
		move.w	#0,obVelX(a0)	; stop object when it touches a	wall

locret_E4BC:
		rts	
; ===========================================================================

Obj14_Type08:				; XREF: Obj14_TypeIndex
		rts	
; ===========================================================================

Obj14_Delete:				; XREF: Obj14_Index
		bra.w	DeleteObject
; ===========================================================================
Ani_obj14:
		include	"_anim\obj14.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 46 - solid blocks and blocks that fall	from the ceiling (MZ)
; ---------------------------------------------------------------------------

Obj46:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj46_Index(pc,d0.w),d1
		jmp	Obj46_Index(pc,d1.w)
; ===========================================================================
Obj46_Index:	dc.w Obj46_Main-Obj46_Index
		dc.w Obj46_Action-Obj46_Index
; ===========================================================================

Obj46_Main:				; XREF: Obj46_Index
		addq.b	#2,obRoutine(a0)
		move.b	#$F,obHeight(a0)
		move.b	#$F,obWidth(a0)
		move.l	#Map_obj46,obMap(a0)
		move.w	#$4000,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$10,obActWid(a0)
		move.w	obY(a0),$30(a0)
		move.w	#$5C0,$32(a0)

Obj46_Action:				; XREF: Obj46_Index
		tst.b	obRender(a0)
		bpl.s	Obj46_ChkDel
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get object type
		andi.w	#7,d0		; read only the	1st digit
		add.w	d0,d0
		move.w	Obj46_TypeIndex(pc,d0.w),d1
		jsr	obj46_TypeIndex(pc,d1.w)
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	obX(a0),d4
		bsr	SolidObject

Obj46_ChkDel:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bsr	DisplaySprite
		rts	
; ===========================================================================
Obj46_TypeIndex:dc.w Obj46_Type00-Obj46_TypeIndex
		dc.w Obj46_Type01-Obj46_TypeIndex
		dc.w Obj46_Type02-Obj46_TypeIndex
		dc.w Obj46_Type03-Obj46_TypeIndex
		dc.w Obj46_Type04-Obj46_TypeIndex
; ===========================================================================

Obj46_Type00:				; XREF: Obj46_TypeIndex
		rts	
; ===========================================================================

Obj46_Type02:				; XREF: Obj46_TypeIndex
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_E888
		neg.w	d0

loc_E888:
		cmpi.w	#$90,d0		; is Sonic within $90 pixels of	the block?
		bcc.s	Obj46_Type01	; if not, resume wobbling
		move.b	#3,obSubtype(a0)	; if yes, make the block fall

Obj46_Type01:				; XREF: Obj46_TypeIndex
		moveq	#0,d0
		move.b	($FFFFFE74).w,d0
		btst	#3,obSubtype(a0)
		beq.s	loc_E8A8
		neg.w	d0
		addi.w	#$10,d0

loc_E8A8:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)	; update the block's position to make it wobble
		rts	
; ===========================================================================

Obj46_Type03:				; XREF: Obj46_TypeIndex
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)	; increase falling speed
		jsr	ObjHitFloor
		tst.w	d1		; has the block	hit the	floor?
		bpl.w	locret_E8EE	; if not, branch
		add.w	d1,obY(a0)
		clr.w	obVelY(a0)		; stop the block falling
		move.w	obY(a0),$30(a0)
		move.b	#4,obSubtype(a0)
		move.w	(a1),d0
		andi.w	#$3FF,d0
		cmpi.w	#$2E8,d0
		bcc.s	locret_E8EE
		move.b	#0,obSubtype(a0)

locret_E8EE:
		rts	
; ===========================================================================

Obj46_Type04:				; XREF: Obj46_TypeIndex
		moveq	#0,d0
		move.b	($FFFFFE70).w,d0
		lsr.w	#3,d0
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)	; make the block wobble
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - solid blocks and blocks that fall from the ceiling (MZ)
; ---------------------------------------------------------------------------
Map_obj46:
		include	"_maps\obj46.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 12 - Progress emblems/trophies in Uberhub (SYZ)
; ---------------------------------------------------------------------------
EmblemGfx_Casual  = $6000|($6C00/$20)
EmblemGfx_Frantic = $6000|($7A00/$20)
; ---------------------------------------------------------------------------

Obj12:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj12_Index(pc,d0.w),d1
		jmp	Obj12_Index(pc,d1.w)
; ===========================================================================
Obj12_Index:	dc.w Obj12_CheckGameState-Obj12_Index
		dc.w Obj12_Init-Obj12_Index
		dc.w Obj12_Animate-Obj12_Index
; ===========================================================================

Obj12_CheckGameState:
		addq.b	#2,obRoutine(a0)
		move.w	#EmblemGfx_Casual,obGfx(a0)

		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get subtype
		move.b	d0,obFrame(a0)		; set frame to display

		; trophy loading logic
		tst.b	d0			; is this the trophy after beating the blackout challenge?
		bpl.s	@normaltrophy		; if not, branch
		jsr	Check_BlackoutBeaten	; has the player beaten the blackout challenge?
		beq.s	@delete			; if not, delete
		move.b	#7,obFrame(a0)		; use skull frame
		bra.s	@ggtrophy		; display and use frantic style

@normaltrophy:
		cmpi.b	#6,d0			; is this the regular trophy for FP?
		bne.s	@notfp			; if not, branch
		jsr	Check_BlackoutBeaten	; has the player beaten the blackout challenge?
		bne.s	@delete			; if yes, delete
		bra.s	@checkbeaten
@notfp:
		cmpi.b	#$66,d0			; is this the alternate trophy for FP?
		bne.s	@checkbeaten		; if not, branch
		move.b	#6,obFrame(a0)		; set frame to display
		jsr	Check_BlackoutBeaten	; has the player beaten the blackout challenge?
		beq.s	@delete			; if not, delete

@checkbeaten:
		jsr	Check_LevelBeaten_Frantic
		beq.s	@regular		; if not, branch
@ggtrophy:	move.w	#EmblemGfx_Frantic,obGfx(a0)
		move.b	#1,$30(a0)		; use frantic frame
		bra.s	Obj12_Init		; display
@regular:
		jsr	Check_LevelBeaten_Casual
		bne.s	Obj12_Init		; if yes, branch
@delete:	jmp	DeleteObject		; not even that? you suck. no trophies for you.
; ---------------------------------------------------------------------------

Obj12_Init:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_Obj12,obMap(a0)
		move.b	#$94,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#6,obPriority(a0)
		move.b	#$40,obHeight(a0)
		move.w	obY(a0),$32(a0)			; used for the sway
; ---------------------------------------------------------------------------

Obj12_Animate:
		tst.b	($FFFFD000).w			; has Sonic already jumped into a giant ring?
		bne.s	@sonicexists			; if not, branch
		move.w	#EmblemGfx_Frantic,obGfx(a0)	; force to frantic frames cause anything else looks weird in grayscale
		bra.s	@sway				; skip

@sonicexists:
		tst.b	$30(a0)				; frantic frame set?
		beq.s	@sway				; if not, branch
		btst	#7,(OptionsBits).w		; are flashy lights enabled?
		bne.s	@doflash			; if yes, branch
		move.w	#EmblemGfx_Frantic,obGfx(a0)	; use alternate offset for frantic frames
		bra.s	@sway				; don't flash
@doflash:
		move.w	($FFFFFE04).w,d0		; get frame counter
		andi.w	#3,d0				; every fourth frame
		bne.s	@sway				; if not on fourth frame, branch
		move.w	#EmblemGfx_Frantic,obGfx(a0)
		bchg	#1,$30(a0)
		btst	#2,($FFFFFE05).w
		beq.s	@sway
		move.w	#EmblemGfx_Casual,obGfx(a0)	; use alternate offset for frantic frames

@sway:
		move.w	($FFFFFE04).w,d0		; get frame counter
		add.w	d0,d0				; double
		add.w	obX(a0),d0			; add X position to add some variance
		cmpi.b	#$66,obSubtype(a0)		; is this the alternate FP trophy?
		bne.s	@sine				; if not, branch
		subi.w	#-$28,d0			; make it match the sway pattern of the real trophy
	@sine:	jsr	(CalcSine).l			; calc sine
		asr.w	#6,d0				; dramatically reduce speed
		add.w	$32(a0),d0			; add base Y pos
		move.w	d0,obY(a0)			; write new Y pos

		jmp	MarkObjGone
; ---------------------------------------------------------------------------
; ===========================================================================
; ---------------------------------------------------------------------------
Map_Obj12:
		include	"_maps\SYZEmblems.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 47 - pinball bumper (SYZ)
; ---------------------------------------------------------------------------

Obj47:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj47_Index(pc,d0.w),d1
		jmp	Obj47_Index(pc,d1.w)
; ===========================================================================
Obj47_Index:	dc.w Obj47_Main-Obj47_Index
		dc.w Obj47_Hit-Obj47_Index
; ===========================================================================

Obj47_Main:				; XREF: Obj47_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj47,obMap(a0)
		move.w	#$380,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#1,obPriority(a0)
		move.b	#$D7,obColType(a0)

Obj47_Hit:				; XREF: Obj47_Index
		tst.b	obColProp(a0)		; has Sonic touched the	bumper?
		beq.w	Obj47_Display	; if not, branch
		clr.b	obColProp(a0)
		lea	($FFFFD000).w,a1
		move.w	obX(a0),d1
		move.w	obY(a0),d2
		sub.w	obX(a1),d1
		sub.w	obY(a1),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$700,d1
		asr.l	#8,d1
		move.w	d1,obVelX(a1)	; bounce Sonic away
		muls.w	#-$700,d0
		asr.l	#8,d0
		move.w	d0,obVelY(a1)	; bounce Sonic away
		bset	#1,obStatus(a1)
		bclr	#4,obStatus(a1)
		bclr	#5,obStatus(a1)
		clr.b	$3C(a1)
		move.b	#1,obAnim(a0)
		move.w	#$B4,d0
		jsr	(PlaySound_Special).l ;	play bumper sound
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj47_Score
		cmpi.b	#$8A,obGfx(a2,d0.w)	; has bumper been hit $8A times?
		bcc.s	Obj47_Display	; if yes, Sonic	gets no	points
		addq.b	#1,obGfx(a2,d0.w)

Obj47_Score:
		moveq	#10,d0
		jsr	AddPoints	; add 100 to score
		bsr	SingleObjLoad
		bne.s	Obj47_Display
		move.b	#$29,0(a1)	; load points object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#4,obFrame(a1)

Obj47_Display:
		lea	(Ani_obj47).l,a1
		bsr	AnimateSprite
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj47_ChkHit
		bra.w	DisplaySprite
; ===========================================================================

Obj47_ChkHit:				; XREF: Obj47_Display
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj47_Delete
		bclr	#7,obGfx(a2,d0.w)

Obj47_Delete:
		bra.w	DeleteObject
; ===========================================================================
Ani_obj47:
		include	"_anim\obj47.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - pinball bumper (SYZ)
; ---------------------------------------------------------------------------
Map_obj47:
		include	"_maps\obj47.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0D - sign post (signpost) at the end of a level
; ---------------------------------------------------------------------------

Obj0D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj0D_Index(pc,d0.w),d1
		jsr	obj0D_Index(pc,d1.w)
		jsr	Obj0D_Float
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		lea	(Ani_obj0D).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
Obj0D_Index:	dc.w Obj0D_Main-Obj0D_Index
		dc.w Obj0D_Touch-Obj0D_Index
		dc.w Obj0D_Spin-Obj0D_Index
		dc.w Obj0D_SonicRun-Obj0D_Index
		dc.w locret_ECEE-Obj0D_Index
; ===========================================================================

Obj0D_Main:				; XREF: Obj0D_Index
		bclr	#2,($FFFFFF6C).w	; restore the wall blocking you off in MZ
		move.w	obY(a0),$38(a0)
		
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj0D,obMap(a0)
		move.w	#$680,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#$18,obActWid(a0)
		move.b	#4,obPriority(a0)

Obj0D_Touch:				; XREF: Obj0D_Index
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcs.w	locret_EBBA
		cmpi.w	#$20,d0		; is Sonic within $20 pixels of	the signpost?
		bcc.w	locret_EBBA	; if not, branch

		move.b	#1,($FFFFF7CC).w ; lock	controls
		move.w	#$800,($FFFFF602).w ; make Sonic run to	the right

		move.l	#10000,d0	; add 100000 ...
		jsr	AddPoints	; ... points

		move.b	#1,($FFFFFFA5).w	; move HUD off screen
		cmpi.w	#$101,($FFFFFE10).w	; is level LZ2?
		bne.s	@notlz			; if not, branch
		tst.b 	($FFFFFFF9).w		; final section flag enabled?
		beq.s 	@notlz			; if not, branch
		move.w	#$82,d0			; resume LZ music (cause we're drowning rn)
		jsr	(PlaySound).l
		move.w	#$1E,($FFFFFE14).w	; give us enough air for Sonic to move out of the screen
		movem.l	d0-a3,-(sp)
		moveq	#$B,d0
		jsr	PalLoad3_Water		; restore regular water palette
		jsr 	WhiteFlash3
		movem.l	(sp)+,d0-a3

@notlz:
		move.w	#$CF,d0
		jsr	(PlaySound_Special).l	; play signpost	sound

		clr.b	($FFFFFE1E).w	; stop time counter
		move.w	($FFFFF72A).w,($FFFFF728).w ; lock screen position
		addq.b	#2,obRoutine(a0)
		
		cmpi.w	#$200,($FFFFFE10).w
		bne.s	@notrp
		clr.b	($FFFFFFE7).w		; disabled Inhuman Mode
		bra.s	@restorepal
@notrp:
		cmpi.w	#$302,($FFFFFE10).w
		beq.s	locret_EBBA
		move.w	#$0780,($FFFFD000+obGfx).w	; force Sonic to use palette line 2
		clr.b	($FFFFFF77).w		; disabled antigrav
@restorepal:
		move.w	d7,-(sp)		; back up d7
		moveq	#3,d0			; load Sonic's palette
		jsr	PalLoad2		; restore sonic's palette
		move.w	(sp)+,d7		; restore d7

locret_EBBA:
		rts	
; ===========================================================================

Obj0D_Spin:				; XREF: Obj0D_Index
		subq.w	#1,$30(a0)	; subtract 1 from spin time
		bpl.s	Obj0D_Sparkle	; if time remains, branch
		move.w	#60,$30(a0)	; set spin cycle time to 1 second
		addq.b	#1,obAnim(a0)	; next spin cycle
		cmpi.b	#3,obAnim(a0)	; have 3 spin cycles completed?
		bne.s	Obj0D_Sparkle	; if not, branch
		addq.b	#2,obRoutine(a0)
		move.w	#90,$30(a0)	; set after spin time to 1.5 seconds

Obj0D_Sparkle:
		subq.w	#1,$32(a0)	; subtract 1 from time delay
		bpl.s	locret_EC42	; if time remains, branch
		move.w	#3,$32(a0)	; set time between sparkles to 3 frames
		cmpi.w	#$302,($FFFFFE10).w	; are we in SAP?
		beq.s	locret_EC42		; if yes, disable sparkles (glitchy due to the palette)

		moveq	#0,d0
		move.b	$34(a0),d0
		addq.b	#2,$34(a0)
		andi.b	#$E,$34(a0)
		lea	Obj0D_SparkPos(pc,d0.w),a2 ; load sparkle position data
		bsr	SingleObjLoad
		bne.s	locret_EC42
		move.b	#$25,0(a1)		; load rings object
		move.b	#6,obRoutine(a1)	; jump to ring sparkle subroutine
		move.b	(a2)+,d0
		ext.w	d0
		add.w	obX(a0),d0
		move.w	d0,obX(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	obY(a0),d0
		move.w	d0,obY(a1)
		move.l	#Map_obj25,obMap(a1)
		move.w	#$27B2,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#2,obPriority(a1)
		move.b	#8,obActWid(a1)
		move.b	#0,obAnim(a1)
		move.b	#0,obFrame(a1)

locret_EC42:
		rts	
; ===========================================================================
Obj0D_SparkPos:	dc.b -$18,-$10		; x-position, y-position
		dc.b	8,   8
		dc.b -$10,   0
		dc.b  $18,  -8
		dc.b	0,  -8
		dc.b  $10,   0
		dc.b -$18,   8
		dc.b  $18, $10
; ===========================================================================

Obj0D_Float:
		addq.b	#1,$3F(a0)
		move.b	$3F(a0),d0
		bset	#0,d0
		jsr	(CalcSine).l
		asr.w	#5,d0
		add.w	$38(a0),d0
		move.w	d0,obY(a0)
		rts
; ===========================================================================

Obj0D_SonicRun:				; XREF: Obj0D_Index
		tst.w	$30(a0)
		beq.s	@cont
		subq.w	#1,$30(a0)
		bra.w	locret_ECEE
@cont:
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.w	locret_ECEE	; if yes, branch

		tst.b	($FFFFD000).w	; is sonic stil on the screen?
		beq.s	loc_EC86	; if yes, branch
		move.w	($FFFFD008).w,d0
		move.w	($FFFFF72A).w,d1
		addi.w	#$128,d1
		cmp.w	d1,d0
		bcs.w	locret_ECEE

loc_EC86:
		addq.b	#2,obRoutine(a0)

	if def(__BENCHMARK__)
		; Benchmark ROM exits level immediately
		move.b	#0, $FFFFF600		
		rts
	else
		jmp	Exit_Level
	endif	; def(__BENCHMARK__)=0

locret_ECEE:
		rts				; return

; ===========================================================================
Ani_obj0D:
		include	"_anim\obj0D.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - signpost
; ---------------------------------------------------------------------------
Map_obj0D:
		include	"_maps\obj0D.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4C - lava geyser / lavafall producer (MZ)
; ---------------------------------------------------------------------------

Obj4C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj4C_Index(pc,d0.w),d1
		jsr	obj4C_Index(pc,d1.w)
		bra.w	Obj4D_ChkDel
; ===========================================================================
Obj4C_Index:	dc.w Obj4C_Main-Obj4C_Index
		dc.w loc_EDCC-Obj4C_Index
		dc.w loc_EE3E-Obj4C_Index
		dc.w Obj4C_MakeLava-Obj4C_Index
		dc.w Obj4C_Display-Obj4C_Index
		dc.w Obj4C_Delete-Obj4C_Index
; ===========================================================================

Obj4C_Main:				; XREF: Obj4C_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj4C,obMap(a0)
		move.w	#$E3A8,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#$38,obActWid(a0)
		move.w	#120,$34(a0)	; set time delay to 2 seconds

loc_EDCC:				; XREF: Obj4C_Index
		subq.w	#1,$32(a0)
		bpl.s	locret_EDF0
		move.w	$34(a0),$32(a0)
		move.w	($FFFFD00C).w,d0
		move.w	obY(a0),d1
		cmp.w	d1,d0
		bcc.s	locret_EDF0
		subi.w	#$170,d1
		cmp.w	d1,d0
		bcs.s	locret_EDF0
		addq.b	#2,obRoutine(a0)

locret_EDF0:
		rts	
; ===========================================================================

Obj4C_MakeLava:				; XREF: Obj4C_Index
		addq.b	#2,obRoutine(a0)
		bsr	SingleObjLoad2
		bne.s	loc_EE18
		move.b	#$4D,0(a1)	; load lavafall	object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	obSubtype(a0),obSubtype(a1)
		move.l	a0,$3C(a1)

loc_EE18:
		move.b	#1,obAnim(a0)
		tst.b	obSubtype(a0)		; is object type 00 (geyser) ?
		beq.s	Obj4C_Type00	; if yes, branch
		move.b	#4,obAnim(a0)
		bra.s	Obj4C_Display
; ===========================================================================

Obj4C_Type00:				; XREF: Obj4C_MakeLava
		movea.l	$3C(a0),a1	; load geyser object
		bset	#1,obStatus(a1)
		move.w	#-$580,obVelY(a1)
		bra.s	Obj4C_Display
; ===========================================================================

loc_EE3E:				; XREF: Obj4C_Index
		tst.b	obSubtype(a0)		; is object type 00 (geyser) ?
		beq.s	Obj4C_Display	; if yes, branch
		addq.b	#2,obRoutine(a0)
		rts	
; ===========================================================================

Obj4C_Display:				; XREF: Obj4C_Index
		lea	(Ani_obj4C).l,a1
		bsr	AnimateSprite
		bsr	DisplaySprite
		rts	
; ===========================================================================

Obj4C_Delete:				; XREF: Obj4C_Index
		move.b	#0,obAnim(a0)
		move.b	#2,obRoutine(a0)
		tst.b	obSubtype(a0)
		beq.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4D - lava geyser / lavafall (MZ)
; ---------------------------------------------------------------------------

Obj4D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj4D_Index(pc,d0.w),d1
		jsr	obj4D_Index(pc,d1.w)
		bra.w	DisplaySprite
; ===========================================================================
Obj4D_Index:	dc.w Obj4D_Main-Obj4D_Index
		dc.w Obj4D_Action-Obj4D_Index
		dc.w loc_EFFC-Obj4D_Index
		dc.w Obj4D_Delete-Obj4D_Index

Obj4D_Speeds:	dc.w $FB00, 0
; ===========================================================================

Obj4D_Main:				; XREF: Obj4D_Index
		addq.b	#2,obRoutine(a0)
		move.w	obY(a0),$30(a0)
		tst.b	obSubtype(a0)
		beq.s	loc_EEA4
		subi.w	#$250,obY(a0)

loc_EEA4:
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		move.w	Obj4D_Speeds(pc,d0.w),obVelY(a0)
		movea.l	a0,a1
		moveq	#1,d1
		bsr.s	Obj4D_MakeLava
		bra.s	loc_EF10
; ===========================================================================

Obj4D_Loop:
		bsr	SingleObjLoad2
		bne.s	loc_EF0A

Obj4D_MakeLava:				; XREF: Obj4D_Main
		move.b	#$4D,0(a1)
		move.l	#Map_obj4C,obMap(a1)
		move.w	#$63A8,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$20,obActWid(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	obSubtype(a0),obSubtype(a1)
		move.b	#1,obPriority(a1)
		move.b	#5,obAnim(a1)
		tst.b	obSubtype(a0)
		beq.s	loc_EF0A
		move.b	#2,obAnim(a1)

loc_EF0A:
		dbf	d1,Obj4D_Loop
		rts	
; ===========================================================================

loc_EF10:				; XREF: Obj4D_Main
		addi.w	#$60,obY(a1)
		move.w	$30(a0),$30(a1)
		addi.w	#$60,$30(a1)
		move.b	#$93,obColType(a1)
		move.b	#$80,obHeight(a1)
		bset	#4,obRender(a1)
		addq.b	#4,obRoutine(a1)
		move.l	a0,$3C(a1)
		tst.b	obSubtype(a0)
		beq.s	Obj4D_PlaySnd
		moveq	#0,d1
		jsr	obj4D_Loop
		addq.b	#2,obRoutine(a1)
		bset	#4,obGfx(a1)
		addi.w	#$100,obY(a1)
		move.b	#0,obPriority(a1)
		move.w	$30(a0),$30(a1)
		move.l	$3C(a0),$3C(a1)
		move.b	#0,obSubtype(a0)

Obj4D_PlaySnd:
		move.w	#$C8,d0
		jsr	(PlaySound_Special).l ;	play flame sound

Obj4D_Action:				; XREF: Obj4D_Index
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		move.w	Obj4D_TypeIndex(pc,d0.w),d1
		jsr	obj4D_TypeIndex(pc,d1.w)
		bsr	SpeedToPos
		lea	(Ani_obj4C).l,a1
		bsr	AnimateSprite

Obj4D_ChkDel:				; XREF: Obj4C
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================
Obj4D_TypeIndex:dc.w Obj4D_Type00-Obj4D_TypeIndex
		dc.w Obj4D_Type01-Obj4D_TypeIndex
; ===========================================================================

Obj4D_Type00:				; XREF: Obj4D_TypeIndex
		addi.w	#$18,obVelY(a0)	; increase object's falling speed
		move.w	$30(a0),d0
		cmp.w	obY(a0),d0
		bcc.s	locret_EFDA
		addq.b	#4,obRoutine(a0)
		movea.l	$3C(a0),a1
		move.b	#3,obAnim(a1)

locret_EFDA:
		rts	
; ===========================================================================

Obj4D_Type01:				; XREF: Obj4D_TypeIndex
		addi.w	#$18,obVelY(a0)	; increase object's falling speed
		move.w	$30(a0),d0
		cmp.w	obY(a0),d0
		bcc.s	locret_EFFA
		addq.b	#4,obRoutine(a0)
		movea.l	$3C(a0),a1
		move.b	#1,obAnim(a1)

locret_EFFA:
		rts	
; ===========================================================================

loc_EFFC:				; XREF: Obj4D_Index
		movea.l	$3C(a0),a1
		cmpi.b	#6,obRoutine(a1)
		beq.w	Obj4D_Delete
		move.w	obY(a1),d0
		addi.w	#$60,d0
		move.w	d0,obY(a0)
		sub.w	$30(a0),d0
		neg.w	d0
		moveq	#8,d1
		cmpi.w	#$40,d0
		bge.s	loc_F026
		moveq	#$B,d1

loc_F026:
		cmpi.w	#$80,d0
		ble.s	loc_F02E
		moveq	#$E,d1

loc_F02E:
		subq.b	#1,obTimeFrame(a0)
		bpl.s	loc_F04C
		move.b	#7,obTimeFrame(a0)
		addq.b	#1,obAniFrame(a0)
		cmpi.b	#2,obAniFrame(a0)
		bcs.s	loc_F04C
		move.b	#0,obAniFrame(a0)

loc_F04C:
		move.b	obAniFrame(a0),d0
		add.b	d1,d0
		move.b	d0,obFrame(a0)
		bra.w	Obj4D_ChkDel
; ===========================================================================

Obj4D_Delete:				; XREF: Obj4D_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4E - advancing	wall of	lava (MZ)
; ---------------------------------------------------------------------------

Obj4E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj4E_Index(pc,d0.w),d1
		jmp	Obj4E_Index(pc,d1.w)
; ===========================================================================
Obj4E_Index:	dc.w Obj4E_Main-Obj4E_Index
		dc.w Obj4E_Solid-Obj4E_Index
		dc.w Obj4E_Action-Obj4E_Index
		dc.w Obj4E_Move2-Obj4E_Index
		dc.w Obj4E_Delete-Obj4E_Index
; ===========================================================================

Obj4E_Main:				; XREF: Obj4E_Index
		addq.b	#4,obRoutine(a0)
		movea.l	a0,a1
		moveq	#1,d1
		bra.s	Obj4E_Main2
; ===========================================================================

Obj4E_Loop:
		bsr	SingleObjLoad2
		bne.s	loc_F0C8

Obj4E_Main2:				; XREF: Obj4E_Main
		move.b	#$4E,0(a1)	; load object
		move.l	#Map_obj4E,obMap(a1)
		move.w	#$63A8,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$50,obActWid(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,obPriority(a1)
		move.b	#0,obAnim(a1)
		move.b	#$94,obColType(a1)
		move.l	a0,$3C(a1)

loc_F0C8:
		dbf	d1,Obj4E_Loop	; repeat sequence once

		addq.b	#6,obRoutine(a1)
		move.b	#4,obFrame(a1)

Obj4E_Action:				; XREF: Obj4E_Index
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	Obj4E_ChkSonic
		neg.w	d0

Obj4E_ChkSonic:
		cmpi.w	#$C0,d0		; is Sonic within $C0 pixels (x-axis)?
		bcc.s	Obj4E_Move	; if not, branch
		move.w	($FFFFD00C).w,d0
		sub.w	obY(a0),d0
		bcc.s	loc_F0F4
		neg.w	d0

loc_F0F4:
		cmpi.w	#$60,d0		; is Sonic within $60 pixels (y-axis)?
		bcc.s	Obj4E_Move	; if not, branch
		move.b	#1,$36(a0)	; set object to	move
		bra.s	Obj4E_Solid
; ===========================================================================

Obj4E_Move:				; XREF: Obj4E_ChkSonic
		tst.b	$36(a0)		; is object set	to move?
		beq.s	Obj4E_Solid	; if not, branch
		move.w	#$180,obVelX(a0)	; set object speed
		subq.b	#2,obRoutine(a0)

Obj4E_Solid:				; XREF: Obj4E_Index
		move.w	#$2B,d1
		move.w	#$18,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		move.b	obRoutine(a0),d0
		move.w	d0,-(sp)
		bsr	SolidObject
		move.w	(sp)+,d0
		move.b	d0,obRoutine(a0)
		cmpi.w	#$6A0,obX(a0)	; has object reached $6A0 on the x-axis?
		bne.s	Obj4E_Animate	; if not, branch
		clr.w	obVelX(a0)		; stop object moving
		clr.b	$36(a0)

Obj4E_Animate:
		lea	(Ani_obj4E).l,a1
		bsr	AnimateSprite
		cmpi.b	#4,($FFFFD024).w
		bcc.s	Obj4E_ChkDel
		bsr	SpeedToPos

Obj4E_ChkDel:
		bsr	DisplaySprite
		tst.b	$36(a0)
		bne.s	locret_F17E
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj4E_ChkGone

locret_F17E:
		rts	
; ===========================================================================

Obj4E_ChkGone:				; XREF: Obj4E_ChkDel
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		bclr	#7,obGfx(a2,d0.w)
		move.b	#8,obRoutine(a0)
		rts	
; ===========================================================================

Obj4E_Move2:				; XREF: Obj4E_Index
		movea.l	$3C(a0),a1
		cmpi.b	#8,obRoutine(a1)
		beq.s	Obj4E_Delete
		move.w	obX(a1),obX(a0)	; move rest of lava wall
		subi.w	#$80,obX(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj4E_Delete:				; XREF: Obj4E_Index
		bra.w	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 54 - invisible	lava tag (MZ)
; ---------------------------------------------------------------------------

Obj54:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj54_Index(pc,d0.w),d1
		jmp	Obj54_Index(pc,d1.w)
; ===========================================================================
Obj54_Index:	dc.w Obj54_Main-Obj54_Index
		dc.w Obj54_ChkDel-Obj54_Index

Obj54_Sizes:	dc.b $96, $94, $95, 0
; ===========================================================================

Obj54_Main:				; XREF: Obj54_Index
		addq.b	#2,obRoutine(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		move.b	Obj54_Sizes(pc,d0.w),obColType(a0)
		move.l	#Map_obj54,obMap(a0)
		move.b	#$84,obRender(a0)

Obj54_ChkDel:				; XREF: Obj54_Index
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		bmi.w	DeleteObject
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible lava tag (MZ)
; ---------------------------------------------------------------------------
Map_obj54:
		include	"_maps\obj54.asm"

Ani_obj4C:
		include	"_anim\obj4C.asm"

Ani_obj4E:
		include	"_anim\obj4E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - lava geyser / lava that falls from the ceiling (MZ)
; ---------------------------------------------------------------------------
Map_obj4C:
		include	"_maps\obj4C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - advancing wall of lava (MZ)
; ---------------------------------------------------------------------------
Map_obj4E:
		include	"_maps\obj4E.asm"

; ===========================================================================zz
; ---------------------------------------------------------------------------
; Object 40 - Moto Bug enemy (GHZ)
; ---------------------------------------------------------------------------
;==========================
;Speed
; The speed for the motobug
MotoBugSpeed = $150
;==========================

Obj40:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj40_Index(pc,d0.w),d1
		jmp	Obj40_Index(pc,d1.w)
; ===========================================================================
Obj40_Index:	dc.w Obj40_Main-Obj40_Index
		dc.w Obj40_Action-Obj40_Index
		dc.w Obj40_Animate-Obj40_Index
		dc.w Obj40_Delete-Obj40_Index
; ===========================================================================

Obj40_Main:				; XREF: Obj40_Index
		move.l	#Map_obj40,obMap(a0)
		move.w	#$4F0,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$14,obActWid(a0)
		tst.b	obAnim(a0)		; is object a smoke trail?
		bne.s	Obj40_SetSmoke	; if yes, branch
		move.b	#$E,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.b	#$C,obColType(a0)
		bsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_F68A
		add.w	d1,obY(a0)	; match	object's position with the floor
		move.w	#0,obVelY(a0)
		addq.b	#2,obRoutine(a0)
		bchg	#0,obStatus(a0)

locret_F68A:
		rts	
; ===========================================================================

Obj40_SetSmoke:				; XREF: Obj40_Main
		addq.b	#4,obRoutine(a0)
		bra.w	Obj40_Animate
; ===========================================================================

Obj40_Action:				; XREF: Obj40_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj40_Index2(pc,d0.w),d1
		jsr	obj40_Index2(pc,d1.w)
		lea	(Ani_obj40).l,a1
		bsr	AnimateSprite

; ---------------------------------------------------------------------------
; Routine to mark an enemy/monitor/ring	as destroyed
; ---------------------------------------------------------------------------

MarkObjGone:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Mark_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Mark_ChkGone:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Mark_Delete
		bclr	#7,obGfx(a2,d0.w)

Mark_Delete:
		bra.w	DeleteObject


; ===========================================================================
Obj40_Index2:	dc.w Obj40_Move-Obj40_Index2
		dc.w Obj40_FixToFloor-Obj40_Index2
; ===========================================================================

Obj40_Move:				; XREF: Obj40_Index2
	;	jsr	obj40_CheckSonicPos
		subq.w	#1,$30(a0)	; subtract 1 from pause	time
		bpl.s	locret_F70A	; if time remains, branch		
		addq.b	#2,ob2ndRout(a0)
		;move.w	#-$100,obVelX(a0)	; move object to the left
		move.b	#1,obAnim(a0)
		;bchg	#0,obStatus(a0)
		;bne.s	locret_F70A
		;neg.w	obVelX(a0)		; change direction

locret_F70A:
		rts	
; ===========================================================================

Obj40_CheckSonicPos:
		tst.w	($FFFFFE08).w	; is debug mode	on?
		beq.s	@cont		; if not, branch
		clr.w	obVelX(a0)
		bra.s	BugMoveEnd	; make Motobug ignore you
@cont:
		moveq	#0,d0
		move.w	($FFFFD008).w,d0
		sub.w	$08(a0),d0
		bpl.s	BugMoveRight
		bclr	#0,obStatus(a0)		
		move.w	#-MotoBugSpeed,obVelX(a0)	; move object to the left
		bra.s	BugMoveEnd

BugMoveRight:
		bset	#0,obStatus(a0)
		move.w	#MotoBugSpeed,obVelX(a0)	; move object to the right

BugMoveEnd:
		rts
; ===========================================================================
Obj40_FixToFloor:			; XREF: Obj40_Index2
		tst.b	($FFFFFFB1).w
		bmi.s	Obj40_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj40_NotInhumanCrush
		move.b	#6,obRoutine(a0)
		bsr	SingleObjLoad
		bne.s	Obj40_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)

Obj40_NotInhumanCrush:
		tst.b	$32(a0)
		beq.s	Obj40_DoCheck
	;	btst	#1,($FFFFD022).w
	;	bne.s	BugMoveReturn
		moveq	#0,d0
		move.w	($FFFFD008).w,d0
		sub.w	$08(a0),d0
		bpl.s	BugMoveRightX
		btst	#0,obStatus(a0)
		bne.s	Obj40_DoCheckX
		bra.s	BugMoveEndX
; ===========================================================================

BugMoveRightX:
		btst	#0,obStatus(a0)
		beq.s	Obj40_DoCheckX

BugMoveEndX:
		move.b	#0,obAnim(a0)
BugMoveReturn:
		rts
; ===========================================================================

Obj40_DoCheckX:
		move.b	#1,obAnim(a0)
		clr.b	$32(a0)

Obj40_DoCheck:
		jsr	obj40_CheckSonicPos
		bsr	SpeedToPos
		jsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj40_Pause
		cmpi.w	#$C,d1
		bge.s	Obj40_Pause
		add.w	d1,obY(a0)	; match	object's position with the floor
		subq.b	#1,$33(a0)
		bpl.s	locret_F756
		move.b	#$F,$33(a0)
		bsr	SingleObjLoad
		bne.s	locret_F756
		move.b	#$40,0(a1)	; load exhaust smoke object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	obStatus(a0),obStatus(a1)
		move.b	#2,obAnim(a1)

locret_F756:
		rts	
; ===========================================================================

Obj40_Pause:				; XREF: Obj40_FixToFloor
	;	jsr	obj40_CheckSonicPos
		subq.b	#2,ob2ndRout(a0)
		move.w	#59,$30(a0)	; set pause time to 1 second
		move.w	#0,obVelX(a0)	; stop the object moving
		move.b	#0,obAnim(a0)
		move.b	#1,$32(a0)
		rts	
; ===========================================================================

Obj40_Animate:				; XREF: Obj40_Index
	;	jsr	obj40_CheckSonicPos
		lea	(Ani_obj40).l,a1
		bsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================

Obj40_Delete:				; XREF: Obj40_Index
	;	jsr	obj40_CheckSonicPos
		bra.w	DeleteObject
; ===========================================================================
Ani_obj40:
		include	"_anim\obj40.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Moto Bug enemy (GHZ)
; ---------------------------------------------------------------------------
Map_obj40:
		include	"_maps\obj40.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 50 - Yadrin enemy (SYZ)
; ---------------------------------------------------------------------------

Obj50:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj50_Index(pc,d0.w),d1
		jmp	Obj50_Index(pc,d1.w)
; ===========================================================================
Obj50_Index:	dc.w Obj50_Main-Obj50_Index
		dc.w Obj50_Action-Obj50_Index
		dc.w Obj50_Delete-Obj50_Index
; ===========================================================================

Obj50_Main:				; XREF: Obj50_Index
		move.l	#Map_obj50,obMap(a0)
		move.w	#$247B,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$14,obActWid(a0)
		move.b	#$11,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.b	#$CC,obColType(a0)
		bsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_F89E
		add.w	d1,obY(a0)	; match	object's position with the floor
		move.w	#0,obVelY(a0)
		addq.b	#2,obRoutine(a0)
		bchg	#0,obStatus(a0)

locret_F89E:
		rts	
; ===========================================================================

Obj50_Action:				; XREF: Obj50_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj50_Index2(pc,d0.w),d1
		jsr	obj50_Index2(pc,d1.w)
		lea	(Ani_obj50).l,a1
		bsr	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj50_Index2:	dc.w Obj50_Move-Obj50_Index2
		dc.w Obj50_FixToFloor-Obj50_Index2
; ===========================================================================

Obj50_Move:				; XREF: Obj50_Index2
		subq.w	#1,$30(a0)	; subtract 1 from pause	time
		bpl.s	locret_F8E2	; if time remains, branch
		addq.b	#2,ob2ndRout(a0)
		move.w	#-$100,obVelX(a0)	; move object
		move.b	#1,obAnim(a0)
		bchg	#0,obStatus(a0)
		bne.s	locret_F8E2
		neg.w	obVelX(a0)		; change direction

locret_F8E2:
		rts	
; ===========================================================================

Obj50_FixToFloor:			; XREF: Obj50_Index2
		tst.b	($FFFFFFB1).w
		bmi.s	Obj50_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj50_NotInhumanCrush
		move.b	#4,obRoutine(a0)		
		bsr	SingleObjLoad
		bne.s	Obj50_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)

Obj50_NotInhumanCrush:
		bsr	SpeedToPos
		bsr	ObjHitFloor
		cmpi.w	#-8,d1
		blt.s	Obj50_Pause
		cmpi.w	#$C,d1
		bge.s	Obj50_Pause
		add.w	d1,obY(a0)	; match	object's position to the floor
		jsr	obj50_ChkWall
		bne.s	Obj50_Pause
		rts	
; ===========================================================================

Obj50_Pause:				; XREF: Obj50_FixToFloor
		subq.b	#2,ob2ndRout(a0)
		move.w	#59,$30(a0)	; set pause time to 1 second
		move.w	#0,obVelX(a0)
		move.b	#0,obAnim(a0)
		rts	
; ===========================================================================

Obj50_Delete:
		bsr	DeleteObject
		rts
; ===========================================================================

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj50_ChkWall:				; XREF: Obj50_FixToFloor
		move.w	($FFFFFE04).w,d0
		add.w	d7,d0
		andi.w	#3,d0
		bne.s	loc_F836
		moveq	#0,d3
		move.b	obActWid(a0),d3
		tst.w	obVelX(a0)
		bmi.s	loc_F82C
		jsr	ObjHitWallRight
		tst.w	d1
		bpl.s	loc_F836

loc_F828:
		moveq	#1,d0
		rts	
; ===========================================================================

loc_F82C:
		not.w	d3
		jsr	ObjHitWallLeft
		tst.w	d1
		bmi.s	loc_F828

loc_F836:
		moveq	#0,d0
		rts	
; End of function Obj50_ChkWall

; ===========================================================================


Ani_obj50:
		include	"_anim\obj50.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Yadrin enemy (SYZ)
; ---------------------------------------------------------------------------
Map_obj50:
		include	"_maps\obj50.asm"

; ---------------------------------------------------------------------------
; Solid	object subroutine (includes spikes, blocks, rocks etc)
;
; variables:
; d1 = width
; d2 = height /	2 (when	jumping)
; d3 = height /	2 (when	walking)
; d4 = x-axis position
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SolidObject:
		tst.b	ob2ndRout(a0)
		beq.w	loc_FAC8
		move.w	d1,d2
		add.w	d2,d2
		lea	($FFFFD000).w,a1
		btst	#1,obStatus(a1)
		bne.s	loc_F9FE
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.s	loc_F9FE
		cmp.w	d2,d0
		bcs.s	loc_FA12

loc_F9FE:
		bclr	#3,obStatus(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FA12:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; ===========================================================================

SolidObject71:				; XREF: Obj71_Solid
		tst.b	ob2ndRout(a0)
		beq.w	loc_FAD0
		move.w	d1,d2
		add.w	d2,d2
		lea	($FFFFD000).w,a1
		btst	#1,obStatus(a1)
		bne.s	loc_FA44
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.s	loc_FA44
		cmp.w	d2,d0
		bcs.s	loc_FA58

loc_FA44:
		bclr	#3,obStatus(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FA58:
		move.w	d4,d2
		jsr	MvSonicOnPtfm
		moveq	#0,d4
		rts	
; ===========================================================================

SolidObject2F:				; XREF: Obj2F_Solid
		lea	($FFFFD000).w,a1
		tst.b	obRender(a0)
		bpl.w	loc_FB92
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.w	loc_FB92
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	loc_FB92
		move.w	d0,d5
		btst	#0,obRender(a0)
		beq.s	loc_FA94
		not.w	d5
		add.w	d3,d5

loc_FA94:
		lsr.w	#1,d5
		moveq	#0,d3
		move.b	(a2,d5.w),d3
		sub.b	(a2),d3
		move.w	obY(a0),d5
		sub.w	d3,d5
		move.b	obHeight(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	obY(a1),d3
		sub.w	d5,d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	loc_FB92
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	loc_FB92
		bra.w	loc_FB0E
; ===========================================================================

loc_FAC8:
		tst.b	obRender(a0)
		bpl.w	loc_FB92

loc_FAD0:
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d1,d0
		bmi.w	loc_FB92
		move.w	d1,d3
		add.w	d3,d3
		cmp.w	d3,d0
		bhi.w	loc_FB92
		move.b	obHeight(a1),d3
		ext.w	d3
		add.w	d3,d2
		move.w	obY(a1),d3
		sub.w	obY(a0),d3
		addq.w	#4,d3
		add.w	d2,d3
		bmi.w	loc_FB92
		move.w	d2,d4
		add.w	d4,d4
		cmp.w	d4,d3
		bcc.w	loc_FB92

loc_FB0E:	tst.b	($FFFFF7C8).w
		bmi.w	loc_FB92
		cmpi.b	#6,($FFFFD024).w
		bcc.w	loc_FB92
		tst.w	($FFFFFE08).w
		bne.w	loc_FBAC
		move.w	d0,d5
		cmp.w	d0,d1
		bcc.s	loc_FB36
		add.w	d1,d1
		sub.w	d1,d0
		move.w	d0,d5
		neg.w	d5

loc_FB36:
		move.w	d3,d1
		cmp.w	d3,d2
		bcc.s	loc_FB44
		subq.w	#4,d3
		sub.w	d4,d3
		move.w	d3,d1
		neg.w	d1

loc_FB44:
		cmp.w	d1,d5
		bhi.w	loc_FBB0
		cmpi.w	#4,d1
		bls.s	loc_FB8C
		tst.w	d0
		beq.s	loc_FB70
		bmi.s	loc_FB5E
		tst.w	obVelX(a1)
		bmi.s	loc_FB70
		bra.s	loc_FB64
; ===========================================================================

loc_FB5E:
		tst.w	obVelX(a1)
		bpl.s	loc_FB70

loc_FB64:
		move.w	#0,obInertia(a1)	; stop Sonic moving
		move.w	#0,obVelX(a1)

loc_FB70:
		sub.w	d0,obX(a1)
		btst	#1,obStatus(a1)
		bne.s	loc_FB8C
		bset	#5,obStatus(a1)
		bset	#5,obStatus(a0)
		moveq	#1,d4
		rts	
; ===========================================================================

loc_FB8C:
		bsr.s	loc_FBA0
		moveq	#1,d4
		rts	
; ===========================================================================

loc_FB92:
		btst	#5,obStatus(a0)
		beq.s	loc_FBAC
		cmp.b	#2,obAnim(a1)	; check if in jumping/rolling animation
		beq.s	loc_FBA0
		cmp.b	#$17,obAnim(a1)	; check if in drowning animation
		beq.s	loc_FBA0
		cmp.b	#$1A,obAnim(a1)	; check if in hurt animation
		beq.s	loc_FBA0
		move.w	#1,obAnim(a1)	; use walking animation


loc_FBA0:
		bclr	#5,obStatus(a0)
		bclr	#5,obStatus(a1)

loc_FBAC:
		moveq	#0,d4
		rts	
; ===========================================================================

loc_FBB0:
		tst.w	d3
		bmi.s	loc_FBBC
		cmpi.w	#$10,d3
		bcs.s	loc_FBEE
		bra.s	loc_FB92
; ===========================================================================

loc_FBBC:
		tst.w	obVelY(a1)
		beq.s	loc_FBD6
		bpl.s	loc_FBD2
		tst.w	d3
		bpl.s	loc_FBD2
		sub.w	d3,obY(a1)
		move.w	#0,obVelY(a1)	; stop Sonic moving

loc_FBD2:
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FBD6:
		btst	#1,obStatus(a1)
		bne.s	loc_FBD2
		move.l	a0,-(sp)
		movea.l	a1,a0
		jsr	KillSonic
		movea.l	(sp)+,a0
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FBEE:
		subq.w	#4,d3
		moveq	#0,d1
		move.b	obActWid(a0),d1
		move.w	d1,d2
		add.w	d2,d2
		add.w	obX(a1),d1
		sub.w	obX(a0),d1
		bmi.s	loc_FC28
		cmp.w	d2,d1
		bcc.s	loc_FC28
		tst.w	obVelY(a1)
		bmi.s	loc_FC28
		sub.w	d3,obY(a1)
		subq.w	#1,obY(a1)
		bsr.s	sub_FC2C
		move.b	#2,ob2ndRout(a0)
		bset	#3,obStatus(a0)
		moveq	#-1,d4
		rts	
; ===========================================================================

loc_FC28:
		moveq	#0,d4
		rts	
; End of function SolidObject


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_FC2C:				; XREF: SolidObject
		btst	#3,obStatus(a1)
		beq.s	loc_FC4E
		moveq	#0,d0
		move.b	$3D(a1),d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a2
		bclr	#3,obStatus(a2)
		clr.b	ob2ndRout(a2)

loc_FC4E:
		move.w	a0,d0
		subi.w	#-$3000,d0
		lsr.w	#6,d0
		andi.w	#$7F,d0
		move.b	d0,$3D(a1)
		move.b	#0,obAngle(a1)
		move.w	#0,obVelY(a1)
		move.w	obVelX(a1),obInertia(a1)
		btst	#1,obStatus(a1)
		beq.s	loc_FC84
		move.l	a0,-(sp)
		movea.l	a1,a0
		bsr	Sonic_ResetOnFloor
		movea.l	(sp)+,a0

loc_FC84:
		bset	#3,obStatus(a1)
		bset	#3,obStatus(a0)
		rts	
; End of function sub_FC2C

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 51 - smashable	green block (MZ)
; ---------------------------------------------------------------------------

Obj51:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj51_Index(pc,d0.w),d1
		jmp	Obj51_Index(pc,d1.w)
; ===========================================================================
Obj51_Index:	dc.w Obj51_Main-Obj51_Index
		dc.w Obj51_Solid-Obj51_Index
		dc.w Obj51_Display-Obj51_Index
; ===========================================================================

Obj51_Main:				; XREF: Obj51_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj51,obMap(a0)

		move.w	#$42B8,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	obSubtype(a0),obFrame(a0)

Obj51_Solid:				; XREF: Obj51_Index
		tst.b	$39(a0)		; already smashed?
		beq.s	Obj51_Check	; if not, branch
		rts			; don't display

Obj51_Check:
		btst	#1,($FFFFFF6C).w	; has switch 2 been pressed?
		beq.s	@cont			; if not, branch
		moveq	#$20,d2
		move.w	d2,d3
		add.w	d3,d3
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.w	locret_FCFC
		move.w	obY(a1),d1
		sub.w	obY(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bcc.w	locret_FCFC
		bra.s	Obj51_Smash

@cont:
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	obX(a0),d4
		bsr	SolidObject

locret_FCFC:
		jmp	MarkObjGone
; ===========================================================================
Obj51_SmashExplode:
		jsr	SingleObjLoad
		bne.s	Obj51_Smash
		move.b	#$3F,0(a1)	; load explosion object
		move.b	#0,$31(a1)

Obj51_Smash:				; XREF: Obj51_Solid
		move.b	#2,($FFFFFF73).w ; set second MZ spikes section checkpoint
		move.b	#1,$39(a0)	; mark as smashed
		move.b	#1,obFrame(a0)
		lea	(Obj51_Speeds).l,a4 ; load broken fragment speed data
		moveq	#3,d1		; set number of	fragments to 4
		move.w	#$38,d2
		bsr	SmashObject

Obj51_Display:				; XREF: Obj51_Index
		bsr	SpeedToPos
		addi.w	#$38,obVelY(a0)
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj51_Speeds:	dc.w $FE00, $FE00	; x-speed, y-speed
		dc.w $FF00, $FF00
		dc.w $200, $FE00
		dc.w $100, $FF00

; ---------------------------------------------------------------------------
; Sprite mappings - smashable green block (MZ)
; ---------------------------------------------------------------------------
Map_obj51:
		include	"_maps\obj51.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 52 - moving platform blocks (MZ, LZ, SBZ)
; ---------------------------------------------------------------------------

Obj52:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj52_Index(pc,d0.w),d1
		jmp	Obj52_Index(pc,d1.w)
; ===========================================================================
Obj52_Index:	dc.w Obj52_Main-Obj52_Index
		dc.w Obj52_Platform-Obj52_Index
		dc.w Obj52_StandOn-Obj52_Index

Obj52_Var:	dc.b $10, 0		; object width,	frame number
		dc.b $20, 1
		dc.b $20, 2
		dc.b $40, 3
		dc.b $30, 4
; ===========================================================================

Obj52_Main:				; XREF: Obj52_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj52,obMap(a0)
		move.w	#$42B8,obGfx(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_FE44
		move.l	#Map_obj52a,obMap(a0) ; LZ specific	code
		move.w	#$43BC,obGfx(a0)
		move.b	#7,obHeight(a0)

loc_FE44:
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		bne.s	loc_FE60
		move.w	#$22C0,obGfx(a0)	; SBZ specific code (object 5228)
		cmpi.b	#$28,obSubtype(a0)	; is object 5228 ?
		beq.s	loc_FE60	; if yes, branch
		move.w	#$4460,obGfx(a0)	; SBZ specific code (object 523x)

loc_FE60:
		move.b	#4,obRender(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj52_Var(pc,d0.w),a2
		move.b	(a2)+,obActWid(a0)
		move.b	(a2)+,obFrame(a0)
		move.b	#4,obPriority(a0)
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$32(a0)
		andi.b	#$F,obSubtype(a0)

Obj52_Platform:				; XREF: Obj52_Index
		jsr	obj52_Move
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(PlatformObject).l
		bra.s	Obj52_ChkDel
; ===========================================================================

Obj52_StandOn:				; XREF: Obj52_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(ExitPlatform).l
		move.w	obX(a0),-(sp)
		jsr	obj52_Move
		move.w	(sp)+,d2
		jsr	(MvSonicOnPtfm2).l

Obj52_ChkDel:				; XREF: Obj52_Platform
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================

Obj52_Move:				; XREF: Obj52_Platform; Obj52_StandOn
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj52_TypeIndex(pc,d0.w),d1
		jmp	Obj52_TypeIndex(pc,d1.w)
; ===========================================================================
Obj52_TypeIndex:dc.w Obj52_Type00-Obj52_TypeIndex, Obj52_Type01-Obj52_TypeIndex
		dc.w Obj52_Type02-Obj52_TypeIndex, Obj52_Type03-Obj52_TypeIndex
		dc.w Obj52_Type02-Obj52_TypeIndex, Obj52_Type05-Obj52_TypeIndex
		dc.w Obj52_Type06-Obj52_TypeIndex, Obj52_Type07-Obj52_TypeIndex
		dc.w Obj52_Type08-Obj52_TypeIndex, Obj52_Type02-Obj52_TypeIndex
		dc.w Obj52_Type0A-Obj52_TypeIndex
; ===========================================================================

Obj52_Type00:				; XREF: Obj52_TypeIndex
		rts	
; ===========================================================================

Obj52_Type01:				; XREF: Obj52_TypeIndex
		move.b	($FFFFFE6C).w,d0
		move.w	#$60,d1
		btst	#0,obStatus(a0)
		beq.s	loc_FF26
		neg.w	d0
		add.w	d1,d0

loc_FF26:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,obX(a0)
		rts	
; ===========================================================================

Obj52_Type02:				; XREF: Obj52_TypeIndex
		cmpi.b	#4,obRoutine(a0)	; is Sonic standing on the platform?
		bne.s	Obj52_02_Wait
		addq.b	#1,obSubtype(a0)	; if yes, add 1	to type

Obj52_02_Wait:
		rts	
; ===========================================================================

Obj52_Type03:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	obActWid(a0),d3
		bsr	ObjHitWallRight
		tst.w	d1		; has the platform hit a wall?
		bmi.s	Obj52_03_End	; if yes, branch
		addq.w	#1,obX(a0)	; move platform	to the right
		move.w	obX(a0),$30(a0)
		rts	
; ===========================================================================

Obj52_03_End:
		clr.b	obSubtype(a0)		; change to type 00 (non-moving	type)
		rts	
; ===========================================================================

Obj52_Type05:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	obActWid(a0),d3
		bsr	ObjHitWallRight
		tst.w	d1		; has the platform hit a wall?
		bmi.s	Obj52_05_End	; if yes, branch
		addq.w	#1,obX(a0)	; move platform	to the right
		move.w	obX(a0),$30(a0)
		rts	
; ===========================================================================

Obj52_05_End:
		addq.b	#1,obSubtype(a0)	; change to type 06 (falling)
		rts	
; ===========================================================================

Obj52_Type06:				; XREF: Obj52_TypeIndex
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)	; make the platform fall
		bsr	ObjHitFloor
		tst.w	d1		; has platform hit the floor?
		bpl.w	locret_FFA0	; if not, branch
		add.w	d1,obY(a0)
		clr.w	obVelY(a0)		; stop platform	falling
		clr.b	obSubtype(a0)		; change to type 00 (non-moving)

locret_FFA0:
		rts	
; ===========================================================================

Obj52_Type07:				; XREF: Obj52_TypeIndex
		tst.b	($FFFFF7E2).w	; has switch number 02 been pressed?
		beq.s	Obj52_07_ChkDel
		subq.b	#3,obSubtype(a0)	; if yes, change object	type to	04

Obj52_07_ChkDel:
		addq.l	#4,sp
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================

Obj52_Type08:				; XREF: Obj52_TypeIndex
		move.b	($FFFFFE7C).w,d0
		move.w	#$80,d1
		btst	#0,obStatus(a0)
		beq.s	loc_FFE2
		neg.w	d0
		add.w	d1,d0

loc_FFE2:
		move.w	$32(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================

Obj52_Type0A:				; XREF: Obj52_TypeIndex
		moveq	#0,d3
		move.b	obActWid(a0),d3
		add.w	d3,d3
		moveq	#8,d1
		btst	#0,obStatus(a0)
		beq.s	loc_10004
		neg.w	d1
		neg.w	d3

loc_10004:
		tst.w	$36(a0)		; is platform set to move back?
		bne.s	Obj52_0A_Back	; if yes, branch
		move.w	obX(a0),d0
		sub.w	$30(a0),d0
		cmp.w	d3,d0
		beq.s	Obj52_0A_Wait
		add.w	d1,obX(a0)	; move platform
		move.w	#300,$34(a0)	; set time delay to 5 seconds
		rts	
; ===========================================================================

Obj52_0A_Wait:
		subq.w	#1,$34(a0)	; subtract 1 from time delay
		bne.s	locret_1002E	; if time remains, branch
		move.w	#1,$36(a0)	; set platform to move back to its original position

locret_1002E:
		rts	
; ===========================================================================

Obj52_0A_Back:
		move.w	obX(a0),d0
		sub.w	$30(a0),d0
		beq.s	Obj52_0A_Reset
		sub.w	d1,obX(a0)	; return platform to its original position
		rts	
; ===========================================================================

Obj52_0A_Reset:
		clr.w	$36(a0)
		subq.b	#1,obSubtype(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - moving blocks (MZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj52:
		include	"_maps\obj52mz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - moving block (LZ)
; ---------------------------------------------------------------------------
Map_obj52a:
		include	"_maps\obj52lz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 55 - Basaran (Batbrain) enemy (MZ)
; ---------------------------------------------------------------------------

Obj55:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj55_Index(pc,d0.w),d1
		jmp	Obj55_Index(pc,d1.w)
; ===========================================================================
Obj55_Index:	dc.w Obj55_Main-Obj55_Index
		dc.w Obj55_Action-Obj55_Index
		dc.w Obj55_Delete-Obj55_Index
; ===========================================================================

Obj55_Main:				; XREF: Obj55_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj55,obMap(a0)
		move.w	#$84B8,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#$C,obHeight(a0)
		move.b	#2,obPriority(a0)
		move.b	#$B,obColType(a0)
		move.b	#$10,obActWid(a0)

Obj55_Action:				; XREF: Obj55_Index
		tst.b	($FFFFFFB1).w
		bmi.s	Obj55_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj55_NotInhumanCrush
		move.b	#4,obRoutine(a0)		
		bsr	SingleObjLoad
		bne.s	Obj55_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)

Obj55_NotInhumanCrush:
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj55_Index2(pc,d0.w),d1
		jsr	obj55_Index2(pc,d1.w)
		lea	(Ani_obj55).l,a1
		bsr	AnimateSprite
		bra.w	MarkObjGone
; ===========================================================================
Obj55_Index2:	dc.w Obj55_ChkDrop-Obj55_Index2
		dc.w Obj55_DropFly-Obj55_Index2
		dc.w Obj55_PlaySnd-Obj55_Index2
		dc.w Obj55_FlyUp-Obj55_Index2
; ===========================================================================

Obj55_ChkDrop:				; XREF: Obj55_Index2
		move.w	#$80,d2
		jsr	obj55_ChkSonic
		bcc.s	Obj55_NoDrop
		move.w	($FFFFD00C).w,d0
		move.w	d0,$36(a0)
		sub.w	obY(a0),d0
		bcs.s	Obj55_NoDrop
		cmpi.w	#$80,d0		; is Sonic within $80 pixels of	basaran?
		bcc.s	Obj55_NoDrop	; if not, branch
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.s	Obj55_NoDrop	; if yes, branch
		move.b	($FFFFFE05).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	Obj55_NoDrop
		move.b	#1,obAnim(a0)
		addq.b	#2,ob2ndRout(a0)

Obj55_NoDrop:
		rts	
; ===========================================================================

Obj55_DropFly:				; XREF: Obj55_Index2
		bsr	SpeedToPos
		addi.w	#$18,obVelY(a0)	; make basaran fall
		move.w	#$80,d2
		jsr	obj55_ChkSonic
		move.w	$36(a0),d0
		sub.w	obY(a0),d0
		bcs.s	Obj55_ChkDel
		cmpi.w	#$10,d0
		bcc.s	locret_10180
		move.w	d1,obVelX(a0)	; make basaran fly horizontally
		move.w	#0,obVelY(a0)	; stop basaran falling
		move.b	#2,obAnim(a0)
		addq.b	#2,ob2ndRout(a0)

locret_10180:
		rts	
; ===========================================================================

Obj55_ChkDel:				; XREF: Obj55_DropFly
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		rts	
; ===========================================================================

Obj55_PlaySnd:				; XREF: Obj55_Index2
		move.b	($FFFFFE05).w,d0
		andi.b	#$F,d0
		bne.s	loc_101A0
		move.w	#$C0,d0
		jsr	(PlaySound_Special).l ;	play flapping sound

loc_101A0:
		bsr	SpeedToPos
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_101B0
		neg.w	d0

loc_101B0:
		cmpi.w	#$80,d0
		bcs.s	locret_101C6
		move.b	($FFFFFE05).w,d0
		add.b	d7,d0
		andi.b	#7,d0
		bne.s	locret_101C6
		addq.b	#2,ob2ndRout(a0)

locret_101C6:
		rts	
; ===========================================================================

Obj55_FlyUp:				; XREF: Obj55_Index2
		bsr	SpeedToPos
		subi.w	#$18,obVelY(a0)	; make basaran fly upwards
		bsr	ObjHitCeiling
		tst.w	d1		; has basaran hit the ceiling?
		bpl.s	locret_101F4	; if not, branch
		sub.w	d1,obY(a0)
		andi.w	#$FFF8,obX(a0)
		clr.w	obVelX(a0)		; stop basaran moving
		clr.w	obVelY(a0)
		clr.b	obAnim(a0)
		clr.b	ob2ndRout(a0)

locret_101F4:
		rts	
; ===========================================================================

Obj55_ChkSonic:				; XREF: Obj55_ChkDrop
		move.w	#$100,d1
		bset	#0,obStatus(a0)
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_10214
		neg.w	d0
		neg.w	d1
		bclr	#0,obStatus(a0)

loc_10214:
		cmp.w	d2,d0
		rts	
; ===========================================================================
		bsr	SpeedToPos
		bsr	DisplaySprite
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		rts	
; ===========================================================================

Obj55_Delete:
		bsr	DeleteObject
		rts
; ===========================================================================
Ani_obj55:
		include	"_anim\obj55.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Basaran enemy (MZ)
; ---------------------------------------------------------------------------
Map_obj55:
		include	"_maps\obj55.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 56 - moving blocks (SYZ/SLZ), large doors (LZ)
; ---------------------------------------------------------------------------

Obj56:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj56_Index(pc,d0.w),d1
		jmp	Obj56_Index(pc,d1.w)
; ===========================================================================
Obj56_Index:	dc.w Obj56_Main-Obj56_Index
		dc.w Obj56_Action-Obj56_Index

Obj56_Var:	dc.b  $10, $10		; width, height
		dc.b  $20, $20
		dc.b  $10, $20
		dc.b  $20, $1A
		dc.b  $10, $27
		dc.b  $10, $10
		dc.b	8, $20
		dc.b  $40, $10
; ===========================================================================

Obj56_Main:				; XREF: Obj56_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj56,obMap(a0)
		move.w	#$4000,obGfx(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_102C8
		move.w	#$43C4,obGfx(a0)	; LZ specific code

loc_102C8:
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	Obj56_Var(pc,d0.w),a2
		move.b	(a2)+,obActWid(a0)
		move.b	(a2),obHeight(a0)
		lsr.w	#1,d0
		move.b	d0,obFrame(a0)
		move.w	obX(a0),$34(a0)
		move.w	obY(a0),$30(a0)
		moveq	#0,d0
		move.b	(a2),d0
		add.w	d0,d0
		move.w	d0,$3A(a0)
		moveq	#0,d0
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		beq.s	loc_10332
		move.b	obSubtype(a0),d0	; SYZ/SLZ specific code
		andi.w	#$F,d0
		subq.w	#8,d0
		bcs.s	loc_10332
		lsl.w	#2,d0
		lea	($FFFFFE8A).w,a2
		lea	(a2,d0.w),a2
		tst.w	(a2)
		bpl.s	loc_10332
		bchg	#0,obStatus(a0)

loc_10332:
		move.b	obSubtype(a0),d0
		bpl.s	Obj56_Action
		andi.b	#$F,d0
		move.b	d0,$3C(a0)
		move.b	#5,obSubtype(a0)
		cmpi.b	#7,obFrame(a0)
		bne.s	Obj56_ChkGone
		move.b	#$C,obSubtype(a0)
		move.w	#$80,$3A(a0)

Obj56_ChkGone:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj56_Action
		bclr	#7,obGfx(a2,d0.w)
		btst	#0,obGfx(a2,d0.w)
		beq.s	Obj56_Action
		addq.b	#1,obSubtype(a0)
		clr.w	$3A(a0)

Obj56_Action:				; XREF: Obj56_Index
		move.w	obX(a0),-(sp)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		add.w	d0,d0
		move.w	Obj56_TypeIndex(pc,d0.w),d1
		jsr	obj56_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	obRender(a0)
		bpl.s	Obj56_ChkDel
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	obHeight(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		bsr	SolidObject

Obj56_ChkDel:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj56_TypeIndex:dc.w Obj56_Type00-Obj56_TypeIndex, Obj56_Type01-Obj56_TypeIndex
		dc.w Obj56_Type02-Obj56_TypeIndex, Obj56_Type03-Obj56_TypeIndex
		dc.w Obj56_Type04-Obj56_TypeIndex, Obj56_Type05-Obj56_TypeIndex
		dc.w Obj56_Type06-Obj56_TypeIndex, Obj56_Type07-Obj56_TypeIndex
		dc.w Obj56_Type08-Obj56_TypeIndex, Obj56_Type09-Obj56_TypeIndex
		dc.w Obj56_Type0A-Obj56_TypeIndex, Obj56_Type0B-Obj56_TypeIndex
		dc.w Obj56_Type0C-Obj56_TypeIndex, Obj56_Type0D-Obj56_TypeIndex
; ===========================================================================

Obj56_Type00:				; XREF: Obj56_TypeIndex
		rts	
; ===========================================================================

Obj56_Type01:				; XREF: Obj56_TypeIndex
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	Obj56_Move_LR
; ===========================================================================

Obj56_Type02:				; XREF: Obj56_TypeIndex
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

Obj56_Move_LR:
		btst	#0,obStatus(a0)
		beq.s	loc_10416
		neg.w	d0
		add.w	d1,d0

loc_10416:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,obX(a0)	; move object horizontally
		rts	
; ===========================================================================

Obj56_Type03:				; XREF: Obj56_TypeIndex
		move.w	#$40,d1
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		bra.s	Obj56_Move_UD
; ===========================================================================

Obj56_Type04:				; XREF: Obj56_TypeIndex
		move.w	#$80,d1
		moveq	#0,d0
		move.b	($FFFFFE7C).w,d0

Obj56_Move_UD:
		btst	#0,obStatus(a0)
		beq.s	loc_10444
		neg.w	d0
		add.w	d1,d0

loc_10444:
		move.w	$30(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)	; move object vertically
		rts	
; ===========================================================================

Obj56_Type05:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_104A4
		cmpi.w	#$100,($FFFFFE10).w ; is level LZ1 ?
		bne.s	loc_1047A	; if not, branch
		cmpi.b	#3,$3C(a0)
		bne.s	loc_1047A
		clr.b	($FFFFF7C9).w
		move.w	($FFFFD008).w,d0
		cmp.w	obX(a0),d0
		bcc.s	loc_1047A
		move.b	#1,($FFFFF7C9).w

loc_1047A:
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_104AE
		cmpi.w	#$100,($FFFFFE10).w ; is level LZ1 ?
		bne.s	loc_1049E	; if not, branch
		cmpi.b	#3,d0
		bne.s	loc_1049E
		clr.b	($FFFFF7C9).w

loc_1049E:
		move.b	#1,$38(a0)

loc_104A4:
		tst.w	$3A(a0)
		beq.s	loc_104C8
		subq.w	#2,$3A(a0)

loc_104AE:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_104BC
		neg.w	d0

loc_104BC:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================

loc_104C8:
		addq.b	#1,obSubtype(a0)
		clr.b	$38(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_104AE
		bset	#0,obGfx(a2,d0.w)
		bra.s	loc_104AE
; ===========================================================================

Obj56_Type06:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_10500
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		tst.b	(a2,d0.w)
		bpl.s	loc_10512
		move.b	#1,$38(a0)

loc_10500:
		moveq	#0,d0
		move.b	obHeight(a0),d0
		add.w	d0,d0
		cmp.w	$3A(a0),d0
		beq.s	loc_1052C
		addq.w	#2,$3A(a0)

loc_10512:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_10520
		neg.w	d0

loc_10520:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================

loc_1052C:
		subq.b	#1,obSubtype(a0)
		clr.b	$38(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_10512
		bclr	#0,obGfx(a2,d0.w)
		bra.s	loc_10512
; ===========================================================================

Obj56_Type07:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_1055E
		tst.b	($FFFFF7EF).w	; has switch number $F been pressed?
		beq.s	locret_10578
		move.b	#1,$38(a0)
		clr.w	$3A(a0)

loc_1055E:
		addq.w	#1,obX(a0)
		move.w	obX(a0),$34(a0)
		addq.w	#1,$3A(a0)
		cmpi.w	#$380,$3A(a0)
		bne.s	locret_10578
		clr.b	obSubtype(a0)

locret_10578:
		rts	
; ===========================================================================

Obj56_Type0C:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_10598
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_105A2
		move.b	#1,$38(a0)

loc_10598:
		tst.w	$3A(a0)
		beq.s	loc_105C0
		subq.w	#2,$3A(a0)

loc_105A2:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_105B4
		neg.w	d0
		addi.w	#$80,d0

loc_105B4:
		move.w	$34(a0),d1
		add.w	d0,d1
		move.w	d1,obX(a0)
		rts	
; ===========================================================================

loc_105C0:
		addq.b	#1,obSubtype(a0)
		clr.b	$38(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_105A2
		bset	#0,obGfx(a2,d0.w)
		bra.s	loc_105A2
; ===========================================================================

Obj56_Type0D:				; XREF: Obj56_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_105F8
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3C(a0),d0
		tst.b	(a2,d0.w)
		bpl.s	loc_10606
		move.b	#1,$38(a0)

loc_105F8:
		move.w	#$80,d0
		cmp.w	$3A(a0),d0
		beq.s	loc_10624
		addq.w	#2,$3A(a0)

loc_10606:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_10618
		neg.w	d0
		addi.w	#$80,d0

loc_10618:
		move.w	$34(a0),d1
		add.w	d0,d1
		move.w	d1,obX(a0)
		rts	
; ===========================================================================

loc_10624:
		subq.b	#1,obSubtype(a0)
		clr.b	$38(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_10606
		bclr	#0,obGfx(a2,d0.w)
		bra.s	loc_10606
; ===========================================================================

Obj56_Type08:				; XREF: Obj56_TypeIndex
		move.w	#$10,d1
		moveq	#0,d0
		move.b	($FFFFFE88).w,d0
		lsr.w	#1,d0
		move.w	($FFFFFE8A).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type09:				; XREF: Obj56_TypeIndex
		move.w	#$30,d1
		moveq	#0,d0
		move.b	($FFFFFE8C).w,d0
		move.w	($FFFFFE8E).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type0A:				; XREF: Obj56_TypeIndex
		move.w	#$50,d1
		moveq	#0,d0
		move.b	($FFFFFE90).w,d0
		move.w	($FFFFFE92).w,d3
		bra.s	Obj56_Move_Sqr
; ===========================================================================

Obj56_Type0B:				; XREF: Obj56_TypeIndex
		move.w	#$70,d1
		moveq	#0,d0
		move.b	($FFFFFE94).w,d0
		move.w	($FFFFFE96).w,d3

Obj56_Move_Sqr:
		tst.w	d3
		bne.s	loc_1068E
		addq.b	#1,obStatus(a0)
		andi.b	#3,obStatus(a0)

loc_1068E:
		move.b	obStatus(a0),d2
		andi.b	#3,d2
		bne.s	loc_106AE
		sub.w	d1,d0
		add.w	$34(a0),d0
		move.w	d0,obX(a0)
		neg.w	d1
		add.w	$30(a0),d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================

loc_106AE:
		subq.b	#1,d2
		bne.s	loc_106CC
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		addq.w	#1,d1
		add.w	$34(a0),d1
		move.w	d1,obX(a0)
		rts	
; ===========================================================================

loc_106CC:
		subq.b	#1,d2
		bne.s	loc_106EA
		subq.w	#1,d1
		sub.w	d1,d0
		neg.w	d0
		add.w	$34(a0),d0
		move.w	d0,obX(a0)
		addq.w	#1,d1
		add.w	$30(a0),d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================

loc_106EA:
		sub.w	d1,d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		neg.w	d1
		add.w	$34(a0),d1
		move.w	d1,obX(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - moving blocks (SYZ/SLZ/LZ)
; ---------------------------------------------------------------------------
Map_obj56:
		include	"_maps\obj56.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 57 - spiked balls (SYZ, LZ)
; ---------------------------------------------------------------------------

Obj57:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj57_Index(pc,d0.w),d1
		jmp	Obj57_Index(pc,d1.w)
; ===========================================================================
Obj57_Index:	dc.w Obj57_Main-Obj57_Index
		dc.w Obj57_Move-Obj57_Index
		dc.w Obj57_Display-Obj57_Index
; ===========================================================================

Obj57_Main:				; XREF: Obj57_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj57,obMap(a0)
		move.w	#$3BA,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#8,obActWid(a0)
		move.w	obX(a0),$3A(a0)
		move.w	obY(a0),$38(a0)
		move.b	#$98,obColType(a0)	; SYZ specific code (chain hurts Sonic)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_107E8
		move.b	#0,obColType(a0)	; LZ specific code (chain doesn't hurt)
		move.w	#$310,obGfx(a0)
		move.l	#Map_obj57a,obMap(a0)

loc_107E8:
		move.b	obSubtype(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1		; multiply by 8
		move.w	d1,$3E(a0)	; set object twirl speed
		move.b	obStatus(a0),d0
		ror.b	#2,d0
		andi.b	#-$40,d0
		move.b	d0,obAngle(a0)
		lea	$29(a0),a2
		move.b	obSubtype(a0),d1	; get object type
		andi.w	#7,d1		; read only the	2nd digit
		move.b	#0,(a2)+
		move.w	d1,d3
		lsl.w	#4,d3
		move.b	d3,$3C(a0)
		subq.w	#1,d1		; set chain length (type-1)
		bcs.s	loc_10894
		btst	#3,obSubtype(a0)
		beq.s	Obj57_MakeChain
		subq.w	#1,d1
		bcs.s	loc_10894

Obj57_MakeChain:
		bsr	SingleObjLoad
		bne.s	loc_10894
		addq.b	#1,$29(a0)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#4,obRoutine(a1)
		move.b	0(a0),0(a1)
		move.l	obMap(a0),obMap(a1)
		move.w	obGfx(a0),obGfx(a1)
		move.b	obRender(a0),obRender(a1)
		move.b	obPriority(a0),obPriority(a1)
		move.b	obActWid(a0),obActWid(a1)
		move.b	obColType(a0),obColType(a1)
		subi.b	#$10,d3
		move.b	d3,$3C(a1)
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_10890
		tst.b	d3
		bne.s	loc_10890
		move.b	#2,obFrame(a1)

loc_10890:
		dbf	d1,Obj57_MakeChain ; repeat for	length of chain

loc_10894:
		move.w	a0,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	Obj57_Move
		move.b	#$8B,obColType(a0)	; if yes, make last spikeball larger
		move.b	#1,obFrame(a0)	; use different	frame

Obj57_Move:				; XREF: Obj57_Index
		jsr	obj57_MoveSub
		bra.w	Obj57_ChkDel
; ===========================================================================

Obj57_MoveSub:				; XREF: Obj57_Move
		move.w	$3E(a0),d0
		add.w	d0,obAngle(a0)
		move.b	obAngle(a0),d0
		jsr	(CalcSine).l
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		lea	$29(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

Obj57_MoveLoop:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFD000,d4
		movea.l	d4,a1
		moveq	#0,d4
		move.b	$3C(a1),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,obY(a1)
		move.w	d5,obX(a1)
		dbf	d6,Obj57_MoveLoop
		rts	
; ===========================================================================

Obj57_ChkDel:				; XREF: Obj57_Move
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj57_Delete
		bra.w	DisplaySprite
; ===========================================================================

Obj57_Delete:				; XREF: Obj57_ChkDel
		moveq	#0,d2
		lea	$29(a0),a2
		move.b	(a2)+,d2

Obj57_DelLoop:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr	DeleteObject2
		dbf	d2,Obj57_DelLoop ; delete all pieces of	chain

		rts	
; ===========================================================================

Obj57_Display:				; XREF: Obj57_Index
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - chain of spiked balls (SYZ)
; ---------------------------------------------------------------------------
Map_obj57:
		include	"_maps\obj57syz.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spiked ball	on a chain (LZ)
; ---------------------------------------------------------------------------
Map_obj57a:
		include	"_maps\obj57lz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 58 - giant spiked balls (SYZ)
; ---------------------------------------------------------------------------

Obj58:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj58_Index(pc,d0.w),d1
		jmp	Obj58_Index(pc,d1.w)
; ===========================================================================
Obj58_Index:	dc.w Obj58_Main-Obj58_Index
		dc.w Obj58_Move-Obj58_Index
; ===========================================================================

Obj58_Main:				; XREF: Obj58_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj15b,obMap(a0)
		move.w	#$396,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$18,obActWid(a0)
		move.w	obX(a0),$3A(a0)
		move.w	obY(a0),$38(a0)
		move.b	#$86,obColType(a0)
		move.b	obSubtype(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asl.w	#3,d1		; multiply by 8
		move.w	d1,$3E(a0)	; set object speed
		move.b	obStatus(a0),d0
		ror.b	#2,d0
		andi.b	#$C0,d0
		move.b	d0,obAngle(a0)
		move.b	#$50,$3C(a0)	; set diameter of circle of rotation

Obj58_Move:				; XREF: Obj58_Index
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get object type
		andi.w	#7,d0		; read only the	2nd digit
		add.w	d0,d0
		move.w	Obj58_TypeIndex(pc,d0.w),d1
		jsr	obj58_TypeIndex(pc,d1.w)
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj58_TypeIndex:dc.w Obj58_Type00-Obj58_TypeIndex
		dc.w Obj58_Type01-Obj58_TypeIndex
		dc.w Obj58_Type02-Obj58_TypeIndex
		dc.w Obj58_Type03-Obj58_TypeIndex
; ===========================================================================

Obj58_Type00:				; XREF: Obj58_TypeIndex
		rts	
; ===========================================================================

Obj58_Type01:				; XREF: Obj58_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,obStatus(a0)
		beq.s	loc_10A38
		neg.w	d0
		add.w	d1,d0

loc_10A38:
		move.w	$3A(a0),d1
		sub.w	d0,d1
		move.w	d1,obX(a0)	; move object horizontally
		rts	
; ===========================================================================

Obj58_Type02:				; XREF: Obj58_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,obStatus(a0)
		beq.s	loc_10A5C
		neg.w	d0
		addi.w	#$80,d0

loc_10A5C:
		move.w	$38(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)	; move object vertically
		rts	
; ===========================================================================

Obj58_Type03:				; XREF: Obj58_TypeIndex
		move.w	$3E(a0),d0
		add.w	d0,obAngle(a0)
		move.b	obAngle(a0),d0
		jsr	(CalcSine).l
		move.w	$38(a0),d2
		move.w	$3A(a0),d3
		moveq	#0,d4
		move.b	$3C(a0),d4
		move.l	d4,d5
		muls.w	d0,d4
		asr.l	#8,d4
		muls.w	d1,d5
		asr.l	#8,d5
		add.w	d2,d4
		add.w	d3,d5
		move.w	d4,obY(a0)
		move.w	d5,obX(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - SBZ	spiked ball on a chain
; ---------------------------------------------------------------------------
Map_obj15b:
		include	"_maps\obj15sbz.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 59 - platforms	that move when you stand on them (SLZ)
; ---------------------------------------------------------------------------

Obj59:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj59_Index(pc,d0.w),d1
		jsr	obj59_Index(pc,d1.w)
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj59_Index:	dc.w Obj59_Main-Obj59_Index
		dc.w Obj59_Platform-Obj59_Index
		dc.w Obj59_Action-Obj59_Index
		dc.w Obj59_MakeMulti-Obj59_Index

Obj59_Var1:	dc.b $28, 0		; width, frame number

Obj59_Var2:	dc.b $10, 1		; width, action	type
		dc.b $20, 1
		dc.b $34, 1
		dc.b $10, 3
		dc.b $20, 3
		dc.b $34, 3
		dc.b $14, 1
		dc.b $24, 1
		dc.b $2C, 1
		dc.b $14, 3
		dc.b $24, 3
		dc.b $2C, 3
		dc.b $20, 5
		dc.b $20, 7
		dc.b $30, 9
; ===========================================================================

Obj59_Main:				; XREF: Obj59_Index
		addq.b	#2,obRoutine(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		bpl.s	Obj59_Main2
		addq.b	#4,obRoutine(a0)
		andi.w	#$7F,d0
		mulu.w	#6,d0
		move.w	d0,$3C(a0)
		move.w	d0,$3E(a0)
		addq.l	#4,sp
		rts	
; ===========================================================================

Obj59_Main2:
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj59_Var1(pc,d0.w),a2
		move.b	(a2)+,obActWid(a0)
		move.b	(a2)+,obFrame(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	Obj59_Var2(pc,d0.w),a2
		move.b	(a2)+,d0
		lsl.w	#2,d0
		move.w	d0,$3C(a0)
		move.b	(a2)+,obSubtype(a0)
		move.l	#Map_obj59,obMap(a0)
		move.w	#$4000,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.w	obX(a0),$32(a0)
		move.w	obY(a0),$30(a0)

Obj59_Platform:				; XREF: Obj59_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(PlatformObject).l
		bra.w	Obj59_Types
; ===========================================================================

Obj59_Action:				; XREF: Obj59_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(ExitPlatform).l
		move.w	obX(a0),-(sp)
		jsr	obj59_Types
		move.w	(sp)+,d2
		tst.b	0(a0)
		beq.s	locret_10BD4
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

locret_10BD4:
		rts	
; ===========================================================================

Obj59_Types:
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj59_TypeIndex(pc,d0.w),d1
		jmp	Obj59_TypeIndex(pc,d1.w)
; ===========================================================================
Obj59_TypeIndex:dc.w Obj59_Type00-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type02-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type04-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type06-Obj59_TypeIndex, Obj59_Type01-Obj59_TypeIndex
		dc.w Obj59_Type08-Obj59_TypeIndex, Obj59_Type09-Obj59_TypeIndex
; ===========================================================================

Obj59_Type00:				; XREF: Obj59_TypeIndex
		rts	
; ===========================================================================

Obj59_Type01:				; XREF: Obj59_TypeIndex
		cmpi.b	#4,obRoutine(a0)	; check	if Sonic is standing on	the object
		bne.s	locret_10C0C
		addq.b	#1,obSubtype(a0)	; if yes, add 1	to type

locret_10C0C:
		rts	
; ===========================================================================

Obj59_Type02:				; XREF: Obj59_TypeIndex
		jsr	obj59_Move
		move.w	$34(a0),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		rts	
; ===========================================================================

Obj59_Type04:				; XREF: Obj59_TypeIndex
		jsr	obj59_Move
		move.w	$34(a0),d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		rts	
; ===========================================================================

Obj59_Type06:				; XREF: Obj59_TypeIndex
		jsr	obj59_Move
		move.w	$34(a0),d0
		asr.w	#1,d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		move.w	$34(a0),d0
		add.w	$32(a0),d0
		move.w	d0,obX(a0)
		rts	
; ===========================================================================

Obj59_Type08:				; XREF: Obj59_TypeIndex
		jsr	obj59_Move
		move.w	$34(a0),d0
		asr.w	#1,d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		move.w	$34(a0),d0
		neg.w	d0
		add.w	$32(a0),d0
		move.w	d0,obX(a0)
		rts	
; ===========================================================================

Obj59_Type09:				; XREF: Obj59_TypeIndex
		jsr	obj59_Move
		move.w	$34(a0),d0
		neg.w	d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)
		tst.b	obSubtype(a0)
		beq.w	loc_10C94
		rts	
; ===========================================================================

loc_10C94:
		btst	#3,obStatus(a0)
		beq.s	Obj59_Delete
		bset	#1,obStatus(a1)
		bclr	#3,obStatus(a1)
		move.b	#2,obRoutine(a1)

Obj59_Delete:
		bra.w	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj59_Move:				; XREF: Obj59_Type02; et al
		move.w	$38(a0),d0
		tst.b	$3A(a0)
		bne.s	loc_10CC8
		cmpi.w	#$800,d0
		bcc.s	loc_10CD0
		addi.w	#$10,d0
		bra.s	loc_10CD0
; ===========================================================================

loc_10CC8:
		tst.w	d0
		beq.s	loc_10CD0
		subi.w	#$10,d0

loc_10CD0:
		move.w	d0,$38(a0)
		ext.l	d0
		asl.l	#8,d0
		add.l	$34(a0),d0
		move.l	d0,$34(a0)
		swap	d0
		move.w	$3C(a0),d2
		cmp.w	d2,d0
		bls.s	loc_10CF0
		move.b	#1,$3A(a0)

loc_10CF0:
		add.w	d2,d2
		cmp.w	d2,d0
		bne.s	locret_10CFA
		clr.b	obSubtype(a0)

locret_10CFA:
		rts	
; End of function Obj59_Move

; ===========================================================================

Obj59_MakeMulti:			; XREF: Obj59_Index
		subq.w	#1,$3C(a0)
		bne.s	Obj59_ChkDel
		move.w	$3E(a0),$3C(a0)
		bsr	SingleObjLoad
		bne.s	Obj59_ChkDel
		move.b	#$59,0(a1)	; duplicate the	object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#$E,obSubtype(a1)

Obj59_ChkDel:
		addq.l	#4,sp
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - platforms that move	when you stand on them (SLZ)
; ---------------------------------------------------------------------------
Map_obj59:
		include	"_maps\obj59.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5A - platforms	moving in circles (SLZ)
; ---------------------------------------------------------------------------

Obj5A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj5A_Index(pc,d0.w),d1
		jsr	obj5A_Index(pc,d1.w)
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5A_Index:	dc.w Obj5A_Main-Obj5A_Index
		dc.w Obj5A_Platform-Obj5A_Index
		dc.w Obj5A_Action-Obj5A_Index
; ===========================================================================

Obj5A_Main:				; XREF: Obj5A_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj5A,obMap(a0)
		move.w	#$4000,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$18,obActWid(a0)
		move.w	obX(a0),$32(a0)
		move.w	obY(a0),$30(a0)

Obj5A_Platform:				; XREF: Obj5A_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(PlatformObject).l
		bra.w	Obj5A_Types
; ===========================================================================

Obj5A_Action:				; XREF: Obj5A_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(ExitPlatform).l
		move.w	obX(a0),-(sp)
		jsr	obj5A_Types
		move.w	(sp)+,d2
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

Obj5A_Types:
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#$C,d0
		lsr.w	#1,d0
		move.w	Obj5A_TypeIndex(pc,d0.w),d1
		jmp	Obj5A_TypeIndex(pc,d1.w)
; ===========================================================================
Obj5A_TypeIndex:dc.w Obj5A_Type00-Obj5A_TypeIndex
		dc.w Obj5A_Type04-Obj5A_TypeIndex
; ===========================================================================

Obj5A_Type00:				; XREF: Obj5A_TypeIndex
		move.b	($FFFFFE80).w,d1
		subi.b	#$50,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		subi.b	#$50,d2
		ext.w	d2
		btst	#0,obSubtype(a0)
		beq.s	loc_10E24
		neg.w	d1
		neg.w	d2

loc_10E24:
		btst	#1,obSubtype(a0)
		beq.s	loc_10E30
		neg.w	d1
		exg	d1,d2

loc_10E30:
		add.w	$32(a0),d1
		move.w	d1,obX(a0)
		add.w	$30(a0),d2
		move.w	d2,obY(a0)
		rts	
; ===========================================================================

Obj5A_Type04:				; XREF: Obj5A_TypeIndex
		move.b	($FFFFFE80).w,d1
		subi.b	#$50,d1
		ext.w	d1
		move.b	($FFFFFE84).w,d2
		subi.b	#$50,d2
		ext.w	d2
		btst	#0,obSubtype(a0)
		beq.s	loc_10E62
		neg.w	d1
		neg.w	d2

loc_10E62:
		btst	#1,obSubtype(a0)
		beq.s	loc_10E6E
		neg.w	d1
		exg	d1,d2

loc_10E6E:
		neg.w	d1
		add.w	$32(a0),d1
		move.w	d1,obX(a0)
		add.w	$30(a0),d2
		move.w	d2,obY(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - platforms that move	in circles (SLZ)
; ---------------------------------------------------------------------------
Map_obj5A:
		include	"_maps\obj5A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5B - blocks that form a staircase (SLZ)
; ---------------------------------------------------------------------------

Obj5B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj5B_Index(pc,d0.w),d1
		jsr	obj5B_Index(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj5B_Index:	dc.w Obj5B_Main-Obj5B_Index
		dc.w Obj5B_Move-Obj5B_Index
		dc.w Obj5B_Solid-Obj5B_Index
; ===========================================================================

Obj5B_Main:				; XREF: Obj5B_Index
		addq.b	#2,obRoutine(a0)
		moveq	#$38,d3
		moveq	#1,d4
		btst	#0,obStatus(a0)
		beq.s	loc_10EDA
		moveq	#$3B,d3
		moveq	#-1,d4

loc_10EDA:
		move.w	obX(a0),d2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj5B_MakeBlocks
; ===========================================================================

Obj5B_Loop:
		bsr	SingleObjLoad2
		bne.w	Obj5B_Move
		move.b	#4,obRoutine(a1)

Obj5B_MakeBlocks:			; XREF: Obj5B_Main
		move.b	#$5B,0(a1)	; load another block object
		move.l	#Map_obj5B,obMap(a1)
		move.w	#$4000,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#3,obPriority(a1)
		move.b	#$10,obActWid(a1)
		move.b	obSubtype(a0),obSubtype(a1)
		move.w	d2,obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	obX(a0),$30(a1)
		move.w	obY(a1),$32(a1)
		addi.w	#$20,d2
		move.b	d3,$37(a1)
		move.l	a0,$3C(a1)
		add.b	d4,d3
		dbf	d1,Obj5B_Loop	; repeat sequence 3 times

Obj5B_Move:				; XREF: Obj5B_Index
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj5B_TypeIndex(pc,d0.w),d1
		jsr	obj5B_TypeIndex(pc,d1.w)

Obj5B_Solid:				; XREF: Obj5B_Index
		movea.l	$3C(a0),a2
		moveq	#0,d0
		move.b	$37(a0),d0
		move.b	(a2,d0.w),d0
		add.w	$32(a0),d0
		move.w	d0,obY(a0)
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	obX(a0),d4
		bsr	SolidObject
		tst.b	d4
		bpl.s	loc_10F92
		move.b	d4,$36(a2)

loc_10F92:
		btst	#3,obStatus(a0)
		beq.s	locret_10FA0
		move.b	#1,$36(a2)

locret_10FA0:
		rts	
; ===========================================================================
Obj5B_TypeIndex:dc.w Obj5B_Type00-Obj5B_TypeIndex
		dc.w Obj5B_Type01-Obj5B_TypeIndex
		dc.w Obj5B_Type02-Obj5B_TypeIndex
		dc.w Obj5B_Type01-Obj5B_TypeIndex
; ===========================================================================

Obj5B_Type00:				; XREF: Obj5B_TypeIndex
		tst.w	$34(a0)
		bne.s	loc_10FC0
		cmpi.b	#1,$36(a0)
		bne.s	locret_10FBE
		move.w	#$1E,$34(a0)

locret_10FBE:
		rts	
; ===========================================================================

loc_10FC0:
		subq.w	#1,$34(a0)
		bne.s	locret_10FBE
		addq.b	#1,obSubtype(a0)	; add 1	to type
		rts	
; ===========================================================================

Obj5B_Type02:				; XREF: Obj5B_TypeIndex
		tst.w	$34(a0)
		bne.s	loc_10FE0
		tst.b	$36(a0)
		bpl.s	locret_10FDE
		move.w	#$3C,$34(a0)

locret_10FDE:
		rts	
; ===========================================================================

loc_10FE0:
		subq.w	#1,$34(a0)
		bne.s	loc_10FEC
		addq.b	#1,obSubtype(a0)	; add 1	to type
		rts	
; ===========================================================================

loc_10FEC:
		lea	$38(a0),a1
		move.w	$34(a0),d0
		lsr.b	#2,d0
		andi.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		eori.b	#1,d0
		move.b	d0,(a1)+
		rts	
; ===========================================================================

Obj5B_Type01:				; XREF: Obj5B_TypeIndex
		lea	$38(a0),a1
		cmpi.b	#$80,(a1)
		beq.s	locret_11038
		addq.b	#1,(a1)
		moveq	#0,d1
		move.b	(a1)+,d1
		swap	d1
		lsr.l	#1,d1
		move.l	d1,d2
		lsr.l	#1,d1
		move.l	d1,d3
		add.l	d2,d3
		swap	d1
		swap	d2
		swap	d3
		move.b	d3,(a1)+
		move.b	d2,(a1)+
		move.b	d1,(a1)+

locret_11038:
		rts	
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - blocks that	form a staircase (SLZ)
; ---------------------------------------------------------------------------
Map_obj5B:
		include	"_maps\obj5B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5C - metal girders in foreground (SLZ)
; ---------------------------------------------------------------------------

Obj5C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj5C_Index(pc,d0.w),d1
		jmp	Obj5C_Index(pc,d1.w)
; ===========================================================================
Obj5C_Index:	dc.w Obj5C_Main-Obj5C_Index
		dc.w Obj5C_GirderLarge-Obj5C_Index
		dc.w Obj5C_Main2-Obj5C_Index
		dc.w Obj5C_GirderSmall-Obj5C_Index
; ===========================================================================

Obj5C_Main:				; XREF: Obj5C_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj5C,obMap(a0)
		move.w	#$83CC,obGfx(a0)
		move.b	#$10,obActWid(a0)
		jsr	SingleObjLoad
		move.b	#$5C,(a1)
		move.b	#4,obRoutine(a1)		

Obj5C_GirderLarge:			; XREF: Obj5C_Index
		move.l	($FFFFF700).w,d1
		add.l	d1,d1
		swap	d1
		neg.w	d1
		move.w	d1,obX(a0)

		move.l	($FFFFF704).w,d1
		add.l	d1,d1
		swap	d1

		move.w	d1,d2
		move.w	d1,d3
		lsr.w	#1,d2
		lsr.w	#2,d3
		add.w	d3,d2
		add.w	d2,d1

		andi.w	#$3F,d1
		neg.w	d1
		addi.w	#$100,d1
		move.w	d1,obScreenY(a0)

		bra.w	Obj5C_Display
; ===========================================================================

Obj5C_Main2:				; XREF: Obj5C_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj5C,obMap(a0)
		move.w	#$83CC,obGfx(a0)
		move.b	#$10,obActWid(a0)
		move.b	#1,obFrame(a0)

Obj5C_GirderSmall:			; XREF: Obj5C_Index
		move.l	($FFFFF700).w,d1
		add.l	d1,d1
		swap	d1
		move.w	d1,d2
		lsr.w	#2,d2
		sub.w	d2,d1
		neg.w	d1
		move.w	d1,obX(a0)

		move.l	($FFFFF704).w,d1
		add.l	d1,d1
		swap	d1

		move.w	d1,d2
		move.w	d1,d3
		lsr.w	#3,d2
		sub.w	d2,d1

		andi.w	#$3F,d1
		neg.w	d1
		addi.w	#$100,d1
		move.w	d1,obScreenY(a0)
; ---------------------------------------------------------------------------

Obj5C_Display:
		cmpi.w	#$1D18,($FFFFF700).w	; maximum camera pos
		bhs.w	@dontdisplay
		cmpi.w	#$D18,($FFFFF700).w	; minimum left camera pos
		bhs.w	DisplaySprite
@dontdisplay:
		rts
; ===========================================================================

; ---------------------------------------------------------------------------
; Sprite mappings - metal girders in foreground	(SLZ)
; ---------------------------------------------------------------------------
Map_obj5C:
		include	"_maps\obj5C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 1B - water surface (LZ)
; ---------------------------------------------------------------------------

Obj1B:					; XREF: Obj_Index
		jmp	DeleteObject	; we don't need these anymore

		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj1B_Index(pc,d0.w),d1
		jmp	Obj1B_Index(pc,d1.w)
; ===========================================================================
Obj1B_Index:	dc.w Obj1B_Main-Obj1B_Index
		dc.w Obj1B_Action-Obj1B_Index
; ===========================================================================

Obj1B_Main:				; XREF: Obj1B_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj1B,obMap(a0)
		move.w	#$C300,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#$80,obActWid(a0)
		move.w	obX(a0),$30(a0)

Obj1B_Action:				; XREF: Obj1B_Index
		move.w	($FFFFF700).w,d1
		andi.w	#$FFE0,d1
		add.w	$30(a0),d1
		btst	#0,($FFFFFE05).w
		beq.s	loc_11114
		addi.w	#$20,d1

loc_11114:
		move.w	d1,obX(a0)	; match	obj x-position to screen position
		move.w	($FFFFF646).w,d1
		move.w	d1,obY(a0)	; match	obj y-position to water	height
		tst.b	$32(a0)
		bne.s	Obj1B_Animate
		btst	#7,($FFFFF605).w ; is Start button pressed?
		beq.s	loc_1114A	; if not, branch
		addq.b	#3,obFrame(a0)	; use different	frames
		move.b	#1,$32(a0)	; stop animation
		bra.s	Obj1B_Display
; ===========================================================================

Obj1B_Animate:				; XREF: loc_11114
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.s	Obj1B_Display	; if yes, branch
		move.b	#0,$32(a0)	; resume animation
		subq.b	#3,obFrame(a0)	; use normal frames

loc_1114A:				; XREF: loc_11114
		subq.b	#1,obTimeFrame(a0)
		bpl.s	Obj1B_Display
		move.b	#7,obTimeFrame(a0)
		addq.b	#1,obFrame(a0)
		cmpi.b	#3,obFrame(a0)
		bcs.s	Obj1B_Display
		move.b	#0,obFrame(a0)

Obj1B_Display:
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - water surface (LZ)
; ---------------------------------------------------------------------------
Map_obj1B:
		include	"_maps\obj1B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0B - pole that	breaks (LZ)
; ---------------------------------------------------------------------------

Obj0B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj0B_Index(pc,d0.w),d1
		jmp	Obj0B_Index(pc,d1.w)
; ===========================================================================
Obj0B_Index:	dc.w Obj0B_Main-Obj0B_Index
		dc.w Obj0B_Action-Obj0B_Index
		dc.w Obj0B_Display-Obj0B_Index
; ===========================================================================

Obj0B_Main:				; XREF: Obj0B_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj0B,obMap(a0)
		move.w	#$43DE,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#8,obActWid(a0)
		move.b	#4,obPriority(a0)
		move.b	#$E1,obColType(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get object type
		mulu.w	#60,d0		; multiply by 60 (1 second)
		move.w	d0,$30(a0)	; set breakage time

Obj0B_Action:				; XREF: Obj0B_Index
		move.b	#4,obRoutine(a0)	; set to display routine to make it...
		bra.w	Obj0B_Display		; ...purely decorational

		tst.b	$32(a0)
		beq.s	Obj0B_Grab
		tst.w	$30(a0)
		beq.s	Obj0B_MoveUp
		subq.w	#1,$30(a0)
		bne.s	Obj0B_MoveUp
		move.b	#1,obFrame(a0)	; break	the pole
		bra.s	Obj0B_Release
; ===========================================================================

Obj0B_MoveUp:				; XREF: Obj0B_Action
		lea	($FFFFD000).w,a1
		move.w	obY(a0),d0
		subi.w	#$18,d0
		btst	#0,($FFFFF604).w ; check if "up" is pressed
		beq.s	Obj0B_MoveDown
		subq.w	#1,obY(a1)	; move Sonic up
		cmp.w	obY(a1),d0
		bcs.s	Obj0B_MoveDown
		move.w	d0,obY(a1)

Obj0B_MoveDown:
		addi.w	#$24,d0
		btst	#1,($FFFFF604).w ; check if "down" is pressed
		beq.s	Obj0B_LetGo
		addq.w	#1,obY(a1)	; move Sonic down
		cmp.w	obY(a1),d0
		bcc.s	Obj0B_LetGo
		move.w	d0,obY(a1)

Obj0B_LetGo:
		move.b	($FFFFF603).w,d0
		andi.w	#$70,d0
		beq.s	Obj0B_Display

Obj0B_Release:				; XREF: Obj0B_Action
		clr.b	obColType(a0)
		addq.b	#2,obRoutine(a0)
		clr.b	($FFFFF7C8).w
		clr.b	($FFFFF7C9).w
		clr.b	$32(a0)
		bra.s	Obj0B_Display
; ===========================================================================

Obj0B_Grab:				; XREF: Obj0B_Action
		tst.b	obColProp(a0)		; has Sonic touched the	pole?
		beq.s	Obj0B_Display	; if not, branch
		lea	($FFFFD000).w,a1
		move.w	obX(a0),d0
		addi.w	#$14,d0
		cmp.w	obX(a1),d0
		bcc.s	Obj0B_Display
		clr.b	obColProp(a0)
		cmpi.b	#4,obRoutine(a1)
		bcc.s	Obj0B_Display
		clr.w	obVelX(a1)		; stop Sonic moving
		clr.w	obVelY(a1)		; stop Sonic moving
		move.w	obX(a0),d0
		addi.w	#$14,d0
		move.w	d0,obX(a1)
		bclr	#0,obStatus(a1)
		move.b	#$11,obAnim(a1)	; set Sonic's animation to "hanging" ($11)
		move.b	#1,($FFFFF7C8).w ; lock	controls
		move.b	#1,($FFFFF7C9).w ; disable wind	tunnel
		move.b	#1,$32(a0)	; begin	countdown to breakage

Obj0B_Display:				; XREF: Obj0B_Index
		bra.w	MarkObjGone
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - pole that breaks (LZ)
; ---------------------------------------------------------------------------
Map_obj0B:
		include	"_maps\obj0B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0C - flapping door (LZ)
; ---------------------------------------------------------------------------

Obj0C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj0C_Index(pc,d0.w),d1
		jmp	Obj0C_Index(pc,d1.w)
; ===========================================================================
Obj0C_Index:	dc.w Obj0C_Main-Obj0C_Index
		dc.w Obj0C_OpenClose-Obj0C_Index
; ===========================================================================

Obj0C_Main:				; XREF: Obj0C_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj0C,obMap(a0)
		move.w	#$4328,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$28,obActWid(a0)
		moveq	#0,d0
		bset	#0,obAnim(a0)	; close door

Obj0C_OpenClose:			; XREF: Obj0C_Index
		cmpi.b	#3,($FFFFFF97).w	; was third lamppost passed?
		blt.w	Obj0C_Solid		; if not, branch
		bclr	#0,obAnim(a0)		; open door

Obj0C_Solid:
		lea	(Ani_obj0C).l,a1
		bsr	AnimateSprite
		tst.b	obFrame(a0)	; is the door open?
		bne.s	Obj0C_Display	; if yes, branch
		move.w	($FFFFD008).w,d0
		move.w	#$13,d1
		move.w	#$20,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		bsr	SolidObject	; make the door	solid

Obj0C_Display:
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj0C:
		include	"_anim\obj0C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - flapping door (LZ)
; ---------------------------------------------------------------------------
Map_obj0C:
		include	"_maps\obj0C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 71 - invisible	solid blocks
; ---------------------------------------------------------------------------

Obj71:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj71_Index(pc,d0.w),d1
		jmp	Obj71_Index(pc,d1.w)
; ===========================================================================
Obj71_Index:	dc.w Obj71_Main-Obj71_Index
		dc.w Obj71_Solid-Obj71_Index
; ===========================================================================

Obj71_Main:				; XREF: Obj71_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj71,obMap(a0)
		move.w	#$8680,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	obSubtype(a0),d0	; get object type
		move.b	d0,d1
		andi.w	#$F0,d0		; read only the	1st byte
		addi.w	#$10,d0
		lsr.w	#1,d0
		move.b	d0,obActWid(a0)	; set object width
		andi.w	#$F,d1		; read only the	2nd byte
		addq.w	#1,d1
		lsl.w	#3,d1
		move.b	d1,obHeight(a0)	; set object height

Obj71_Solid:				; XREF: Obj71_Index
		cmpi.w	#$302,($FFFFFE10).w	; are we in SAP?
		bne.s	@notsap			; if not, branch
		tst.b	($FFFFFFE1).w		; has P monitor been destroyed?
		beq.s	@notsap			; if not, branch
		cmpi.b	#$72,obSubtype(a0)	; is this the one for the door?
		beq.s	Obj71_ChkDel		; if yes, disable it

@notsap:
		bsr	ChkObjOnScreen
		bne.s	Obj71_ChkDel
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	obHeight(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		bsr	SolidObject71

Obj71_ChkDel:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj71_Delete
		tst.w	($FFFFFE08).w	; are you using	debug mode?
		beq.s	Obj71_NoDisplay	; if not, branch
		jmp	DisplaySprite	; if yes, display the object
; ===========================================================================

Obj71_NoDisplay:
		rts	
; ===========================================================================

Obj71_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - invisible solid blocks
; ---------------------------------------------------------------------------
Map_obj71:
		include	"_maps\obj71.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5D - fans (SLZ)
; ---------------------------------------------------------------------------

Obj5D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj5D_Index(pc,d0.w),d1
		jmp	Obj5D_Index(pc,d1.w)
; ===========================================================================
Obj5D_Index:	dc.w Obj5D_Main-Obj5D_Index
		dc.w Obj5D_Action-Obj5D_Index
; ===========================================================================

Obj5D_Main:				; XREF: Obj5D_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj5D,obMap(a0)
		ori.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#4,obPriority(a0)
		move.w	#$4000|($7400/$20),obGfx(a0)
		cmpi.b	#$18,($FFFFF600).w		; is screen mode ending sequence?
		bne.s	Obj5D_Action			; if not, branch
		move.w	#$0000|($7400/$20),obGfx(a0)	; alternate palette line
; ---------------------------------------------------------------------------

Obj5D_Action:				; XREF: Obj5D_Index
		cmpi.w	#$301,($FFFFFE10).w	; are we in SNP?
		beq.s	@snp			; if yes, branch
		cmpi.b	#$18,($FFFFF600).w	; is screen mode ending sequence?
		bne.w	Obj5D_ChkDel		; if not, branch
		move.b	#1,$30(a0)		; fast animation
		tst.b	($FFFFFF78).w		; pit flag set?
		bne.w	Obj5D_Animate		; if yes, spinni :)
		bra.w	Obj5D_ChkDel		; if not, no spinni :(

@snp:
		tst.b	($FFFFFFA9).w
		beq.s	@early
		cmpi.b	#2,($FFFFFFA9).w	; is Sonic fighting against the walking bomb?
		beq.s	@fanison		; if yes, force fan on
		bra.w	Obj5D_ChkDel
@early:
		tst.b	($FFFFFFE1).w		; has P monitor been destroyed?
		bne.w	Obj5D_ChkDel		; if yes, disable fan
		
@fanison:
		move.b	#0,$30(a0)		; slow animation
		
		move.w	($FFFFD00C).w,d0
		move.w	obY(a0),d1
		subi.w	#$100,d1		; maximum distance above fan
		cmp.w	d0,d1
		bhi.w	Obj5D_Animate

		move.w	($FFFFD008).w,d0	; get Sonic's X pos
		move.w	obX(a0),d1		; get fan's X pos

		btst	#0,obStatus(a0)		; is fan flipped?
		bne.s	@rightfacing		; if yes, branch

		subi.w	#$40,d1			; adjust position
		cmp.w	d1,d0			; is Sonic near the fan?
		bls.w	Obj5D_Animate		; if not, branch
		move.w	d1,d2			; target Sonic X pos
		addi.w	#$100,d1		; check behind the fan
		cmp.w	d1,d0			; is Sonic behind the fan?
		bhi.w	Obj5D_Animate		; if yes, branch
		bra.s	@forcesonicinplace

@rightfacing:
		addi.w	#$40,d1			; adjust position
		cmp.w	d1,d0			; is Sonic near the fan?
		bhi.s	Obj5D_Animate		; if not, branch
		move.w	d1,d2			; target Sonic X pos
		subi.w	#$100,d1		; check behind the fan
		cmp.w	d1,d0			; is Sonic behind the fan?
		blo.s	Obj5D_Animate		; if yes, branch

@forcesonicinplace:
		tst.b	($FFFFF7CC).w		; are controls already locked?
		bne.w	Obj5D_Animate		; if yes, branch
		move.b	#1,$30(a0)		; fast animation
		btst	#1,obStatus(a0)		; is fan vertically flipped?
		bne.w	Obj5D_Animate		; if yes, make it cosmetic only
		move.w	d2,($FFFFD008).w	; force Sonic in place before the fan
@vertical:
		btst	#0,obStatus(a0)		; is fan horizontally flipped?
		bne.s	@rightfacing2		; if yes, branch
		btst	#3,($FFFFF602).w	; right still pressed?
		bne.s	Obj5D_Animate		; if yes, branch
		move.w	#-$800,d0
		move.w	d0,($FFFFD010).w
		move.w	d0,($FFFFD014).w
		bra.s	@fansound

@rightfacing2:
		btst	#2,($FFFFF602).w	; left still pressed?
		bne.s	Obj5D_Animate
		move.w	#$800,d0
		move.w	d0,($FFFFD010).w
		move.w	d0,($FFFFD014).w

@fansound:
		move.b	($FFFFFE05).w,d0	; play fan sound every couple frames
		andi.b	#%11,d0
		bne.s	Obj5D_Animate
		btst	#0,($FFFFFE0F).w
		bne.s	Obj5D_Animate
		move.w	#$B8,d0
		jsr	PlaySound_Special

Obj5D_Animate:				; XREF: Obj5D_ChkSonic
		tst.b	$30(a0)
		bne.s	@fast
		move.w	($FFFFFE04).w,d0
		andi.w	#3,d0
		bne.s	Obj5D_ChkDel
@fast:
		subq.b	#1,obTimeFrame(a0)
		bpl.s	Obj5D_ChkDel
		move.b	#0,obTimeFrame(a0)
		addq.b	#1,obAniFrame(a0)
		cmpi.b	#3,obAniFrame(a0)
		bcs.s	loc_115D8
		move.b	#0,obAniFrame(a0)

loc_115D8:
		moveq	#0,d0
		add.b	obAniFrame(a0),d0
		move.b	d0,obFrame(a0)

Obj5D_ChkDel:				; XREF: Obj5D_Animate
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - fans (SLZ)
; ---------------------------------------------------------------------------
Map_obj5D:
		include	"_maps\obj5D.asm"

; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5E - stationary shotgunner bomb enemy (SLZ)
; ---------------------------------------------------------------------------
BombFuseTime = 100
BombFuseVelocity = $34
BombShotgunSpeed = $400
BombDistance = $A0
BombPellets = 3
; ---------------------------------------------------------------------------
; ===========================================================================

Obj5E:					; XREF: Obj_Index
		frantic
		bne.s	@frantic
		jmp	DeleteObject

@frantic:
		bsr.w	Obj5E_FaceSonic

		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj5E_Index(pc,d0.w),d1
		jmp	Obj5E_Index(pc,d1.w)
; ===========================================================================
Obj5E_Index:	dc.w Obj5E_Main-Obj5E_Index		; [$0]
		dc.w Obj5E_ChkDistance-Obj5E_Index	; [$2]
		dc.w Obj5E_CreateFuse-Obj5E_Index	; [$4]
		dc.w Obj5E_WaitForExplosion-Obj5E_Index	; [$6]
		dc.w Obj5E_Explode-Obj5E_Index		; [$8]
		
		dc.w Obj5E_Fuse-Obj5E_Index		; [$A]
		dc.w Obj5E_Spark-Obj5E_Index		; [$C]
		
		dc.w Obj5E_Shrapnel-Obj5E_Index		; [$E]
; ===========================================================================

Obj5E_Main:				; XREF: Obj5E_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_Obj5F_Giant,obMap(a0)
		move.w	#$42C,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$C,obActWid(a0)
		move.b	#$9A,obColType(a0)	; make bomb hurtable
		move.w	obY(a0),$34(a0)
		
; ---------------------------------------------------------------------------

Obj5E_ChkDistance:				; XREF: Obj5E_Index
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	@xpos
		neg.w	d0
@xpos:		move.w	#BombDistance,d1
		cmp.w	d1,d0
		bcc.w	@outofrange

		move.w	($FFFFD00C).w,d0
		sub.w	obY(a0),d0
		bcc.s	@ypos
		neg.w	d0
@ypos:		move.w	#$90,d1
		cmp.w	d1,d0
		bcc.w	@outofrange
		
		addq.b	#2,obRoutine(a0)	; set to Obj5E_CreateFuse

@outofrange:
		bra.w	Obj5E_DisplayBomb
; ===========================================================================

Obj5E_CreateFuse:			; XREF: Obj5E_Index
		addq.b	#2,obRoutine(a0)	; set to Obj5E_WaitForExplosion
		move.b	#BombFuseTime,$30(a0)	; set fuse time
		move.b	#2,obAnim(a0)

		; create fuse object
		bsr.w	SingleObjLoad
		bne.w	Obj5E_DisplayBomb
		move.b	#$5E,0(a1)	; load fuse object
		move.b	#$A,obRoutine(a1)		; set new object to Obj5E_Fuse
		move.w	obX(a0),obX(a1)
		move.w	$34(a0),obY(a1)
		move.w	$34(a0),$34(a1)
		move.w	obStatus(a0),obStatus(a1)
		bset	#7,obRender(a1)
		move.b	#3,obAnim(a1)
		move.b	#1,obPriority(a1)
		move.b	#BombFuseTime,$30(a1)	; set fuse time

		bra.w	Obj5E_DisplayBomb
; ===========================================================================

Obj5E_WaitForExplosion:			; XREF: Obj5E_Index
		subq.b	#1,$30(a0)		; sub 1 from fuse time
		bpl.s	@timeremaining		; if time remains, branch
		addq.b	#2,obRoutine(a0)	; set to Obj5E_Explode

@timeremaining:
		bra.w	Obj5E_DisplayBomb
; ===========================================================================

Obj5E_Explode:				; XREF: Obj5E_Index
		move.b	#2,obRoutine(a0)	; return to Obj5E_ChkDistance
		
		jsr	SingleObjLoad2
		bne.w	@noobjectleft
		move.b	#$3F,(a1)		; load singular explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)
		move.b	#2,obRoutine(a1)
		
		; load shotgun shrapnels
		moveq	#BombPellets-1,d6

		move.w	#BombShotgunSpeed,d4	; load default speed
		tst.b	obSubtype(a0)		; is this the last bomb?
		beq.s	@shrapnelloop		; if not, branch
		move.w	#BombShotgunSpeed-$100,d4 ; use slower speed
@shrapnelloop:
		jsr	SingleObjLoad2
		bne.w	@noobjectleft
		move.b	#$5E,0(a1)		; load shrapnel	object
		move.b	#$E,obRoutine(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#4,obAnim(a1)
		move.b	#$98,obColType(a1)
		bset	#7,obRender(a1)
		move.b	#20,$30(a1)		; give some deletion immunity
						
		move.w	($FFFFD008).w,d1	; load Sonic's X-pos into d1
		sub.w	obX(a0),d1		; sub bomb's X-pos from it
		move.w	($FFFFD00C).w,d2	; load Sonic's Y-pos into d2
		sub.w	obY(a0),d2		; sub bomb's Y-pos from it
		jsr	CalcAngle		; calculate the angle
		jsr	CalcSine		; calculate the sine
		muls.w	d4,d0			; multiply result 1 shotgun speed
		muls.w	d4,d1			; multiply result 2 by shotgun speed
		asr.l	#8,d0			; align the results to the correct position in the bitfield ...
		asr.l	#8,d1			; ... (e.g. 00000000xxxxxxxxxxxxxxxx00000000 to 0000000000000000xxxxxxxxxxxxxxxx)
		
		move.l	($FFFFF636).w,d3	; get last random number
		ror.l	#1,d3			; rotate to next
		move.l	d3,($FFFFF636).w	; save new value (without rerunning RNG algorithm)

		andi.l	#$01FF01FF,d3		; mask by variance
		subi.w	#$100,d3		; center variance for X
		add.w	d3,d1			; add variance to X
		swap	d3			; get other result
		subi.w	#$100,d3		; center variance for Y
		add.w	d3,d0			; add variance to Y
		move.w	d1,obVelX(a1)		; set final result to Sonic's X-speed
		move.w	d0,obVelY(a1)		; set final result to Sonic's Y-speed

		dbf	d6,@shrapnelloop	; repeat

@noobjectleft:
		bra.w	Obj5E_DisplayBomb

; ===========================================================================
; ===========================================================================

Obj5E_Fuse:				; XREF: Obj5E_Index
		bsr.w	Obj5E_BonusSetup

		subq.b	#1,$30(a0)
		bmi.w	Obj5E_Delete

		move.w	($FFFFFE04).w,d0
		andi.w	#7,d0
		bne.s	@nofusemove
		moveq	#1,d0
		btst	#1,obStatus(a0)
		beq.s	@adjust
		moveq	#-1,d0
@adjust:	add.w	d0,$34(a0)
@nofusemove:

		moveq	#0,d0
		move.w	($FFFFFE04).w,d0
		andi.w	#$F,d0
		bne.s	@nobonussparkles

		jsr	SingleObjLoad
		bne.s	@nobonussparkles
		move.b	#$5E,0(a1)	; load fuse object (bonus sparkles)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#$C,obRoutine(a1)	; set to routine $C
		bset	#7,obRender(a1)
		move.b	#3,obAnim(a1)
		move.b	#2,obPriority(a1)
		btst	#1,obStatus(a0)
		beq.s	@0
		addi.w	#$60,obY(a1)
@0:
		jsr	RandomNumber
		andi.l	#$01FF01FF,d0
		subi.w	#$FF,d0
		asl.w	#1,d0
		move.w	d0,obVelX(a1)
		swap	d0
		subi.w	#$FF,d0
		move.w	d0,obVelY(a1)
		move.b	#15,$30(a1)	; set lifetime for sparkle

@nobonussparkles:
		lea	(Ani_obj5E).l,a1
		jsr	AnimateSprite
		bra.w	Obj5E_DisplayBomb
; ===========================================================================

Obj5E_Spark:				; XREF: Obj5E_Index
		bsr.w	Obj5E_BonusSetup
		subq.b	#1,$30(a0)
		bmi.s	@timesup
		subi.w	#1,obVelY(a0)
		jsr	SpeedToPos
		lea	(Ani_obj5E).l,a1
		jsr	AnimateSprite
		bra.w	Obj5E_Display

@timesup:
		bra.w	Obj5E_Delete

; ===========================================================================
; ===========================================================================

Obj5E_Shrapnel:				; XREF: Obj5E_Index
		bsr.w	Obj5E_BonusSetup

		cmpi.w	#$302,($FFFFFE10).w	; are we in SAP?
		bne.s	@updateshrap		; if not, branch

		; cut off lifetime support for the shrapnel in the zigzag section
		cmpi.w	#$500,obY(a0)
		blo.s	@chkp
		move.b	#0,$30(a0)

@chkp:
		cmpi.w	#$1400,obX(a0)
		blo.s	@updateshrap
		cmpi.w	#$1500,obX(a0)
		bhs.s	@updateshrap
		clr.w	obVelX(a0)		; stop shrapnel in the P monitor section
		addi.w	#$38,obVelY(a0)

@updateshrap:
		bsr.w	SpeedToPos
		lea	(Ani_obj5E).l,a1
		jsr	AnimateSprite

		tst.b	$30(a0)			; is lifetime extension still on?
		bmi.s	@chkrender		; if not, branch
		subq.b	#1,$30(a0)		; sub 1 from lifetime extension

@chkrender:
		tst.b	obRender(a0)		; is shrapnel still on screen?
		bmi.w	Obj5E_Display		; if yes, render
		tst.b	$30(a0)			; is lifetime extension still on?
		bpl.w	Obj5E_Render		; if yes, render anyway
		bra.w	Obj5E_Delete		; otherwise, delete old offscreen shrapnel

; ===========================================================================
; ===========================================================================

Obj5E_DisplayBomb:
		; sway
		move.w	($FFFFFE0E).w,d0
		add.w	obX(a0),d0
		add.w	d0,d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$34(a0),d0
		move.w	d0,obY(a0)

Obj5E_Display:
		bsr.w	MarkObjGone
		tst.b	obRender(a0)		; is object on screen?
		bmi.w	Obj5E_Render		; if yes, render
		rts

Obj5E_Render:
		jmp	DisplaySprite
; ---------------------------------------------------------------------------
Obj5E_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj5E_BonusSetup:
		tst.b	$32(a0)
		bne.s	@setupdone
		move.b	#1,$32(a0)
		move.l	#Map_Obj5F_Giant,obMap(a0)
		move.w	#$42C,obGfx(a0)
		ori.b	#4,obRender(a0)

@setupdone:
		rts
; ---------------------------------------------------------------------------

Obj5E_FaceSonic:
		moveq	#0,d0
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bpl.s	Obj5E_FC2
		bclr	#0,obStatus(a0)
		bclr	#0,obRender(a0)
		rts

Obj5E_FC2:
		bset	#0,obStatus(a0)
		bset	#0,obRender(a0)
		rts
; ===========================================================================

Ani_obj5E:
	include "_anim\obj5E.asm"

; ===========================================================================
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 5F - walking bomb boss (SLZ)
; ---------------------------------------------------------------------------
 
;│WARNING!!!
;│This code is very delicate.
;│Edit responsibly. Or not.
;└─ｖ─────────────────────────
;　∧,,∧
; （＾o＾）
;.（　　）

; ===========================================================================
; ---------------------------------------------------------------------------
BombWalkSpeed_Boss = $140
BombFuseTime_Boss = 41
BombDistance_Boss = $50
BombPellets_Boss = 13
; ---------------------------------------------------------------------------
; ===========================================================================

Obj5F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj5F_Index(pc,d0.w),d1
		jmp	Obj5F_Index(pc,d1.w)
; ===========================================================================
Obj5F_Index:	dc.w Obj5F_Main-Obj5F_Index		; [$0]
		dc.w Obj5F_Action-Obj5F_Index		; [$2]
		dc.w Obj5F_Display-Obj5F_Index		; [$4]
		dc.w Obj5F_End-Obj5F_Index		; [$6]
		dc.w Obj5F_BombMachine-Obj5F_Index	; [$8]
		dc.w Obj5F_BossDefeated-Obj5F_Index	; [$A]
		dc.w Obj5F_Display_Spark-Obj5F_Index	; [$C]
		dc.w Obj5F_Transition-Obj5F_Index	; [$E]
; ===========================================================================

Obj5F_Main:				; XREF: Obj5F_Index
		cmpi.w	#$301,($FFFFFE10).w
		beq.s	@bomballowed
		cmpi.w	#$500,($FFFFFE10).w
		beq.s	@bomballowed
		move.b	#$3F,(a0)
		move.b	#0,obRoutine(a0)
		move.b	#0,$31(a0)
		rts
@bomballowed:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj5F,obMap(a0)
	;	move.l	#Map_obj5F_Giant,obMap(a0)
		move.w	#$400,obGfx(a0)
	;	move.w	#$42C,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$C,obActWid(a0)

		cmpi.w	#$301,($FFFFFE10).w
		bne.s	@conty
		tst.b	($FFFFFFA9).w
		beq.s	@conty
		tst.b	(BossHealth).w
		bne.s	@conty
		move.b	#$A,obRoutine(a0)
		bra.w	Obj5F_BossDefeated 

@conty:
		
		cmpi.w	#$500,($FFFFFE10).w
		bne.s	@cont
		move.b	#8,obRoutine(a0)
		move.w	#$533,obGfx(a0)
		move.l	#Map_obj5F_Cutscene,obMap(a0)
		move.b	#$CD,d0
		jsr	PlaySound_Special
		bra.w	Obj5F_BombMachine

@cont:
		move.b	obSubtype(a0),d0
		beq.s	loc_11A3C
		move.b	d0,obRoutine(a0)
		rts	
; ===========================================================================

loc_11A3C:
		move.b	#$9A,obColType(a0)
		bchg	#0,obStatus(a0)
; ---------------------------------------------------------------------------

Obj5F_Action:				; XREF: Obj5F_Index
		jsr	ObjHitFloor		; check bomb distance to floor
		subi.w	#15,d1			; adjust by 15 pixels
		bgt.s	@fall			; if bomb is above the floor, make it fall
		add.w	d1,obY(a0)		; otherwise, keep it glued to the ground

		tst.w	($FFFFD030).w		; does Sonic have invincibility frames left?
		beq.s	@doaction		; if not, branch
		tst.w	($FFFFFE08).w		; is debug mode	on?
		bne.s	@doaction		; if yes, ignore invicibility frames
		cmpi.b	#20,(BossHealth).w	; is boss still at full health?
		bhs.s	@doaction		; if yes, branch
		
		move.b	#0,ob2ndRout(a0)	; reset to walking state
		move.b	#$A9,d0			; play blip sound
		jsr	PlaySound_Special
		move.w	#-$300,obVelY(a0)	; bounce up
		clr.w 	obVelX(a0)		; reverse direction
		move.b	#2,obAnim(a0)		; reset animation
@fall:
		bsr.w	ObjectFall
@updatepos:
		jsr	SpeedToPos
		bra.s	@animate
; ---------------------------------------------------------------------------

@doaction:
		clr.w	obVelY(a0)
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj5F_Index2(pc,d0.w),d1
		jsr	Obj5F_Index2(pc,d1.w)

@animate:
		lea	(Ani_obj5F).l,a1
		jsr	AnimateSprite
		bra.w	DisplaySprite
; ===========================================================================
Obj5F_Index2:	dc.w Obj5F_Walk-Obj5F_Index2
		dc.w Obj5F_Wait-Obj5F_Index2
		dc.w Obj5F_Explode-Obj5F_Index2
; ===========================================================================

Obj5F_Walk:				; XREF: Obj5F_Index2
		bsr.w	Obj5F_FaceSonic

		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_11ADE
		neg.w	d0
loc_11ADE:	move.w	#BombDistance_Boss,d1
		cmp.w	d1,d0
		bcc.w	Obj5F_DoWalk
		
		cmpi.b	#$1A,($FFFFD000+obAnim)	; is animation $1A (hurting)?
		beq.w	Obj5F_DoWalk
	
Obj5F_MakeFuse:
		addq.b	#2,ob2ndRout(a0)	; set to wait
		move.w	#BombFuseTime_Boss,$30(a0)	; set fuse time

		move.b	#0,obAnim(a0)	; stop animation
		clr.w	obVelX(a0)
		move.b	#2,obAnim(a0)
		bsr.w	SingleObjLoad2
		bne.w	locret_11B5E
		move.b	#$5F,0(a1)	; load fuse object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),d0
	;	addi.w	#$10,d0
		move.w	d0,obY(a1)
		move.w	d0,$34(a1)
		move.w	obStatus(a0),obStatus(a1)
		move.b	#4,obSubtype(a1)		; set new object to routine 4
		move.b	#3,obAnim(a1)
		move.b	#0,obPriority(a1)
		move.w	#0,obVelY(a1)	; no speed
		move.w	#BombFuseTime_Boss,$30(a1)	; set fuse time
		move.l	a0,$3C(a1)
		rts

Obj5F_DoWalk:
		move.b	#1,obAnim(a0)

		moveq	#0,d0
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bpl.s	Obj5F_Walk2
		bclr	#0,obStatus(a0)
		bra.s	Obj5F_Return
Obj5F_Walk2:	bset	#0,obStatus(a0)

Obj5F_Return:		
		move.w	#BombWalkSpeed_Boss,d0
		moveq	#22,d1
		sub.b	(BossHealth).w,d1
		lsl.w	#5,d1
		add.w	d1,d0

		btst	#0,obStatus(a0)
		bne.s	@0
		neg.w	d0
@0:		move.w	d0,obVelX(a0)	; move bomb horizontally
		bra.w	SpeedToPos
; ===========================================================================

Obj5F_Wait:
		subq.w	#1,$30(a0)
		bne.w	locret_11B5E
		addq.b	#2,ob2ndRout(a0)	; set to explode
		rts
; ===========================================================================

Obj5F_FaceSonic:
		moveq	#0,d0
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bpl.s	Obj5F_FC2
		bclr	#0,obStatus(a0)		
		rts

Obj5F_FC2:
		bset	#0,obStatus(a0)
		rts
; ===========================================================================

Obj5F_Explode:				; XREF: Obj5F_Index2
		cmpi.b	#1,(BossHealth).w		; remove one life
		bhi.s	@doend
		tst.b	obRender(a0)			; is bomb on screen?
		bpl.s	@waitforsonic			; if not, branch
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bpl.s	@pos
		neg.w	d0
@pos:		
		cmpi.w	#BombDistance_Boss,d0
		bls.w	@bombvisible	
@waitforsonic:
		rts

@bombvisible:
		tst.b	($FFFFF7CC).w			; are controls already locked?
		bne.s	@doend				; if yes, branch
		move.b	#1,($FFFFF7CC).w		; lock controls
		move.b	#1,($FFFFFE2D).w		; make Sonic invincible
		clr.w	($FFFFD010).w			; clear Sonic's X speed
		clr.w	($FFFFD014).w			; clear Sonic's intertia
		clr.l	($FFFFF602).w			; clear any remaining button presses
; ---------------------------------------------------------------------------

@doend:
		subq.b	#1,(BossHealth).w		; remove one life
		move.b	(BossHealth).w,(HUD_BossHealth).w ; update boss health in HUD
		move.b	#1,($FFFFFE1C).w		; update lives

		tst.b	(BossHealth).w			; has bomb boss been defeated?
		bhi.s	@notdefeated			; if not, branch
		move.b	#$A,obRoutine(a0)		; set routine to transition sequence
		clr.w	obVelX(a0)			; clear bomb's X-speed
		move.b	#0,obAnim(a0)			; set to standing animation
		rts

@notdefeated:
		moveq	#10,d0		; add 100 ...
		jsr	AddPoints	; ... points

		jsr	SingleObjLoad
		bne.s	@reset
		move.b	#$3F,0(a1)			; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

@reset:
		move.b	#0,ob2ndRout(a0)		; reset to walking state

		cmpi.b	#1,($FFFFFFA9).w	; is boss intro cutscene still in progress?
		bne.s	locret_11B5E		; if not, branch
		
		; stuff that gets run when the bomb boss starts for real
		move.b	#2,($FFFFFFA9).w
		move.b	#4,($FFFFD024).w
		move.b	#$1A,($FFFFD01C).w
		bset	#1,($FFFFD022).w
		move.w	#-$200,($FFFFD010).w
	;	subq.w	#1,($FFFFD008).w
		move.w	#-$400,($FFFFD012).w
		move.b	#$9B,d0				; set boss music
		jsr	PlaySound			; play it
		ori.b	#10,(CameraShake).w		; camera shaking
		clr.b	($FFFFF7CC).w			; unlock controls 1

locret_11B5E:
		rts	
; ===========================================================================

Obj5F_Transition:
		move.b	($FFFFFF76).w, d0
		move.w	@JumpTable(pc, d0.w), d0
		jmp		@JumpTable(pc, d0.w)

; ===========================================================================
@JumpTable:
		dc.w 	@StartSequence-@JumpTable
		dc.w 	@CheckAirborne-@JumpTable
		dc.w 	@Explode-@JumpTable
		dc.w 	@CheckExplosions-@JumpTable
		dc.w	@ContinueBoss-@JumpTable
; ===========================================================================

@StartSequence:
		addq.b	#2, $FFFFFF76
		
		; fade out music
		move.b	#$E0, d0
		jsr		PlaySound_Special

		; clear shit
		bset	#0, $FFFFD022
		clr.w	$FFFFFF8C
		clr.w	$FFFFFF8E
		clr.b	$FFFFFFEB
		rts

@CheckAirborne:
		btst	#1, $FFFFD022		; test airborne bit
		bne.s	@NotAirborne		; if 0, branch
		rts

@NotAirborne:
		addq.b	#2, $FFFFFF76		; continue with sequence

@Explode:
		addq.b	#2, $FFFFFF76

		; not my code, blame selbi
		bsr	SingleObjLoad
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		jsr	(RandomNumber).l

		; move.w	d0,d1
		; moveq	#0,d1
		; move.b	d0,d1
		; lsr.b	#2,d1
		; subi.w	#$20,d1
		; add.w	d1,obX(a1)
		; lsr.w	#8,d0
		; lsr.b	#3,d0
		; add.w	d0,obY(a1)
		; subq.w	#8,obY(a1)
		ori.b	#10,(CameraShake).w
		bra.w 	@Return

@CheckExplosions:
		cmpi.w	#10,($FFFFFF7A).w
		ble.w	@ContinueBoss

		move.w	($FFFFFF7A).w,($FFFFFF78).w
		subq.b	#4,($FFFFFF76).w
		subi.w	#10,($FFFFFF7A).w
		move.w	#20,($FFFFFF7C).w
		bra.w	@Return

@ContinueBoss:
		move.b	#21,(BossHealth).w	; set lives
		move.b	#$2, obRoutine(a0)
		move.b	#0, $FFFFFF76
		rts

@Return:
		rts

; ===========================================================================

Obj5F_BossDefeated:
		moveq	#0,d0
		move.b	($FFFFFF76).w,d0
		move.w	off_7118x(pc,d0.w),d0
		jmp	off_7118x(pc,d0.w)
; ===========================================================================
off_7118x:	dc.w Obj5F_BossDefeatedmain-off_7118x
		dc.w Obj5F_BossDefeatedboss1-off_7118x
		dc.w Obj5F_BossDefeatedboss2-off_7118x
		dc.w Obj5F_BossDefeatedend-off_7118x
		dc.w Obj5F_BossDefeatedBlip-off_7118x
; ===========================================================================

Obj5F_BossDefeatedmain:
		addq.b	#2,($FFFFFF76).w
		move.b	#$E0,d0
		jsr	PlaySound_Special
		move.w	#180,($FFFFFF78).w
		move.w	#80,($FFFFFF7A).w

		clr.w	($FFFFFF8C).w
		clr.w	($FFFFFF8E).w
		clr.b	($FFFFFFEB).w

		bset	#0,($FFFFD022).w
		move.w	($FFFFD008).w,d0
		cmp.w	obX(a0),d0
		bcc.s	@cont
		bclr	#0,($FFFFD022).w

@cont:
		bra.w	Obj5F_ShowBomb
; ===========================================================================

Obj5F_BossDefeatedboss1:
		btst	#1,($FFFFD022).w
		bne.s	@cont
		move.b	#0,($FFFFD01B).w

@cont:
		subq.w	#1,($FFFFFF78).w
		bne.w	Obj5F_ShowBomb
		addq.b	#2,($FFFFFF76).w
		bra.w	Obj5F_ShowBomb
; ===========================================================================

Obj5F_BossDefeatedboss2:
		addq.b	#2,($FFFFFF76).w
		bsr	SingleObjLoad
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)

		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,obY(a1)
		subq.w	#8,obY(a1)
		ori.b	#10,(CameraShake).w
		bra.w	Obj5F_ShowBomb
; ===========================================================================

Obj5F_BossDefeatedend:
		cmpi.w	#10,($FFFFFF7A).w
		ble.s	Obj5F_BossDefeatedend2

		move.w	($FFFFFF7A).w,($FFFFFF78).w
		subq.b	#4,($FFFFFF76).w
		subi.w	#10,($FFFFFF7A).w
		move.w	#20,($FFFFFF7C).w
		bra.w	Obj5F_ShowBomb

Obj5F_BossDefeatedend2:
		subq.w	#1,($FFFFFF7C).w
		beq.s	Obj5F_Blip
		move.w	#7,($FFFFFF78).w
		subq.b	#4,($FFFFFF76).w
		bra.w	Obj5F_ShowBomb
; ===========================================================================

Obj5F_Blip:
		addq.b	#2,($FFFFFF76).w
		move.b	#1,obFrame(a0)
		move.w	#5*60+30,($FFFFFF7C).w

Obj5F_BossDefeatedBlip:
		moveq	#0,d1
		move.w	($FFFFFF7C).w,d1
		subq.w	#1,d1
		bmi.s	Obj5F_BossDelete

		cmpi.w	#1*60+30,d1
		beq.s	@patheticexplosion
		blo.s	@hidebomb

		cmpi.w	#3*60+30,d1
		bne.s	@noblip
		move.b	#0,obFrame(a0)
		move.w	#$A9,d0
		jsr	PlaySound_Special
@noblip:
		move.w	d1,($FFFFFF7C).w
		move.b	#0,($FFFFD000+obAniFrame).w ; reset Sonic waiting animation
		bra.w	DisplaySprite

@patheticexplosion:
		jsr	SingleObjLoad
		bne.s	@hidebomb
		move.b	#$3F,(a1)		; load explosion
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#6,obRoutine(a1)	; set to lame
		bra.s	@noblip			; render one last frame
@hidebomb:
		move.w	d1,($FFFFFF7C).w
		move.b	#0,($FFFFD000+obAniFrame).w ; reset Sonic waiting animation
		rts				; don't render bomb anymore
; ===========================================================================

Obj5F_BossDelete:
		move.l	#10000,d0	; add 100000 ...
		jsr	AddPoints	; ... points

		move.b	#$34,($FFFFD080).w 		; load title card object
		move.b	#35,($FFFFD080+$30).w		; set delay before loading title cards
		move.b	#1,($FFFFD080+$31).w		; set title card patterns load flag
		
		move.w	#$302,($FFFFFE10).w	; change level to SLZ3
		move.w	#$1FBF,($FFFFF72A).w
		move.w	#$620,($FFFFF726).w
		move.w	#-1,($FFFFFF7C).w
		move.b	#0,($FFFFF7CC).w
		move.b	#0,($FFFFFF77).w
		clr.b	($FFFFFE30).w
		clr.b	($FFFFFFA9).w
		clr.b	($FFFFFF76).w
		clr.b	($FFFFF7AA).w
		clr.b	($FFFFFE2D).w			; disable invincibility
		clr.b	($FFFFFE2C).w			; clear shield
		clr.b	($FFFFFFE1).w

		clr.b	(HUD_BossHealth).w			; revert lives counter to normal
		ori.b	#1,($FFFFFE1C).w		; update lives counter (to reset it from the boss)
		clr.l	($FFFFFE22).w			; clear time
		ori.b	#1,($FFFFFE1E).w 		; update time counter

		clr.w	($FFFFFE30).w			; clear any set level checkpoints

		jsr	SAP_ResetChallengeObjects	; set up SAP challenge objects now
		
		move.b	#$84,d0
		jsr	PlaySound

		jmp	DeleteObject			; rip walking bomb
; ===========================================================================

Obj5F_ShowBomb:
		lea	(Ani_obj5F).l,a1
		jsr	AnimateSprite
	;	bsr.w	MarkObjGone
Obj5F_Display_NoAnim:
		bra.w	DisplaySprite

; ===========================================================================

Obj5F_Display:				; XREF: Obj5F_Index
	;	tst.b	($FFFFFFA9).w		; is Sonic fighting against the walking bomb?
	;	beq.w	@conty			; if not, don't generate bonus sparkles
		cmpi.b	#3,obAnim(a0)
		bne.s	@conty
		move.b	($FFFFFE05).w,d0
		andi.b	#$0B,d0
		tst.b	d0
		bne.s	@conty
		jsr	SingleObjLoad
		bne.s	@conty
		move.b	#$5F,0(a1)	; load fuse object (bonus sparkles)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#$C,obSubtype(a1)	; set to routine $C
		move.b	#5,obAnim(a1)
		move.b	#1,obPriority(a1)

		btst	#1,obStatus(a0)
		beq.s	@0
		addi.w	#$60,obY(a1)

@0:		
		jsr	RandomNumber
		andi.l	#$01FF01FF,d0
		subi.w	#$FF,d0
		asl.w	#1,d0
		move.w	d0,obVelX(a1)
		swap	d0
		subi.w	#$FF,d0
		move.w	d0,obVelY(a1)
		move.w	$30(a0),d0
		lsr.w	#1,d0
		move.w	#BombFuseTime_Boss,d1
		sub.w	d0,d1
		move.w	d1,$30(a1)	; set fuse time

@conty:
		cmpi.b	#5,obAnim(a0)
		bne.s	@contx
		subi.w	#10,obVelY(a0)
		tst.b	($FFFFFFA9).w
		beq.s	@contx
		tst.b	(BossHealth).w
		bne.s	@contx
		jmp	DeleteObject

@contx:
	;	cmpi.w	#$301,($FFFFFE10).w
	;	bne.s	@cont
		cmpi.b	#3,obAnim(a0)
		bne.s	@cont
		tst.b	($FFFFFF76).w
		beq.s	@cont
		jmp	DeleteObject
@cont:
		bsr	Obj5F_FaceSonic
		bsr.s	loc_11B70
		lea	(Ani_obj5F).l,a1
		jsr	AnimateSprite
	;	bra.w	MarkObjGone
		bra.w	DisplaySprite
; ===========================================================================

Obj5F_Display_Spark:
		subq.w	#1,$30(a0)
		bmi.s	@deletespark
		subi.w	#10,obVelY(a0)
		jsr	SpeedToPos
		lea	(Ani_obj5F).l,a1
		jsr	AnimateSprite
		bsr.w	MarkObjGone
		bra.w	DisplaySprite

@deletespark:
		jmp	DeleteObject
; ===========================================================================

loc_11B70:
		subq.w	#1,$30(a0)
		bmi.s	loc_11B7C
		bsr.w	SpeedToPos
		rts	
; ===========================================================================

loc_11B7C:
		tst.b	(BossHealth).w
		bne.s	@conty
		rts

@conty:
		clr.w	$30(a0)
		clr.b	obRoutine(a0)
		move.w	$34(a0),obY(a0)
		moveq	#BombPellets,d6			; bomb pellets
		tst.b	($FFFFFFA9).w
		beq.s	@cont
		moveq	#2,d6		; bomb pellets
		moveq	#0,d0
		moveq	#0,d1
		move.b	(BossHealth).w,d0
		move.b	#20,d1
		sub.b	d0,d1
	;	lsl.w	#1,d1
		add.w	d1,d6

@cont
		movea.l	a0,a1
		tst.w	($FFFFD030).w	; does Sonic have invincibility frames left?
		bne.w	DeleteObject	; if yes, branch

		cmpi.b	#5,obAnim(a0)
		beq.s	Obj5F_MakeShrap
		ori.b	#10,(CameraShake).w		; camera shaking
		bra.s	Obj5F_MakeShrap
; ===========================================================================

Obj5F_Loop:
		bsr.w	SingleObjLoad2
		bne.w	loc_11BCE

Obj5F_MakeShrap:			; XREF: loc_11B7C
		move.b	#$5F,0(a1)	; load shrapnel	object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#6,obSubtype(a1)
		move.b	#4,obAnim(a1)
		move.b	#$98,obColType(a1)
		bset	#7,obRender(a1)

		jsr	RandomNumber
		move.l	d1,d4
		move.w	d4,d5
		swap	d4
		andi.w	#$2FF,d4
		btst	#0,d6
		beq.s	@cont
		neg.w	d4
@cont:
		andi.w	#$2FF,d5
		neg.w	d5

		move.w	d4,d2
		move.w	d2,d3
		asr.w	#1,d3
		add.w	d3,d2
		move.w	d2,obVelX(a1)

		move.w	d5,d2
		move.w	d2,d3
		asr.w	#1,d3
		add.w	d3,d2
		move.w	d2,obVelY(a1)
		bmi.s	loc_11BCE
		neg.w	obVelY(a1)

loc_11BCE:
		dbf	d6,Obj5F_Loop	; repeat 3 more	times

Obj5F_End:				; XREF: Obj5F_Index
		addi.w	#$20,obVelY(a0)		; apply gravity to shrapnel

		bsr.w	SpeedToPos

		move.w	obY(a0),d0
		cmpi.w	#$3D0,d0
		bhi.w	DeleteObject

		lea	(Ani_obj5F).l,a1
		jsr	AnimateSprite
		bra.w	DisplaySprite

; ===========================================================================
; Bomb in Bomb Machine Cutscene
; ===========================================================================
Obj5F_BombMachine:
		jsr	ObjectFall
		jsr	SpeedToPos

		tst.b	($FFFFFFC8).w
		beq.s	@contx
		cmpi.w	#$0200,obY(a0)
		blt.s	@cont
		move.w	#$0128,obY(a0)
		bra.s	@contz

@contx:
		cmpi.w	#$0240,obY(a0)
		blt.s	@cont

@conty:
		move.w	#$0150,obY(a0)
@contz:
		clr.w	obVelY(a0)
		move.b	#$CD,d0
		jsr	PlaySound_Special
		movea.l	($FFFFFFC4).w,a1
		move.b	#0,obAniFrame(a1)

@cont:
		tst.w	($FFFFFFC4).w
		beq.s	@cont2
		bra.w	DisplaySprite

@cont2:
		rts
; ===========================================================================

Ani_obj5F:
	include "_anim\obj5F.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - walking bomb enemy (SLZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj5F:
	include "_maps\obj5F.asm"

Map_obj5F_Giant:
	include "_maps\GiantBomb.asm"

Map_obj5F_Cutscene:
	include "_maps\obj5F_cutscene.asm"
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 60 - Orbinaut enemy (LZ, SLZ, SBZ)
; ---------------------------------------------------------------------------

Obj60:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj60_Index(pc,d0.w),d1
		jmp	Obj60_Index(pc,d1.w)
; ===========================================================================
Obj60_Index:	dc.w Obj60_Main-Obj60_Index
		dc.w Obj60_ChkSonic-Obj60_Index
		dc.w Obj60_Display-Obj60_Index
		dc.w Obj60_MoveOrb-Obj60_Index
		dc.w Obj60_ChkDel2-Obj60_Index
		dc.w Obj60_Delete-Obj60_Index
; ===========================================================================

Obj60_Main:				; XREF: Obj60_Index
		move.l	#Map_obj60,obMap(a0)
		move.w	#$429,obGfx(a0)	; SBZ specific code
		cmpi.b	#5,($FFFFFE10).w ; check if level is SBZ
		beq.s	loc_11D02
		move.w	#$2429,obGfx(a0)	; SLZ specific code

loc_11D02:
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ
		bne.s	loc_11D10
		move.w	#$467,obGfx(a0)	; LZ specific code

loc_11D10:
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$B,obColType(a0)
		move.b	#$C,obActWid(a0)
		moveq	#0,d2
		lea	$37(a0),a2
		movea.l	a2,a3
		addq.w	#1,a2
		moveq	#3,d1

Obj60_MakeOrbs:
		tst.b	($FFFFFFB1).w
		bmi.s	Obj60_NotInhumanCrush
		tst.b	obRender(a0)
		bpl.b	Obj60_NotInhumanCrush
		move.b	#$A,obRoutine(a0)		
		bsr	SingleObjLoad
		bne.s	Obj60_NotInhumanCrush
		move.b	#$3F,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj60_NotInhumanCrush:
		bsr	SingleObjLoad2
		bne.s	loc_11D90
		addq.b	#1,(a3)
		move.w	a1,d5
		subi.w	#-$3000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	0(a0),0(a1)	; load spiked orb object
		move.b	#6,obRoutine(a1)
		move.l	obMap(a0),obMap(a1)
		move.w	obGfx(a0),obGfx(a1)
		ori.b	#4,obRender(a1)
		move.b	#4,obPriority(a1)
		move.b	#8,obActWid(a1)
		move.b	#3,obFrame(a1)
		move.b	#$98,obColType(a1)
		move.b	d2,obAngle(a1)
		addi.b	#$40,d2
		move.l	a0,$3C(a1)
		dbf	d1,Obj60_MakeOrbs ; repeat sequence 3 more times

loc_11D90:
		moveq	#1,d0
		btst	#0,obStatus(a0)
		beq.s	Obj60_Move
		neg.w	d0

Obj60_Move:
		move.b	d0,$36(a0)
		move.b	obSubtype(a0),obRoutine(a0)	; if type is 02, skip the firing rountine
		addq.b	#2,obRoutine(a0)
		move.w	#-$40,obVelX(a0)	; move orbinaut	to the left
		btst	#0,obStatus(a0)	; is orbinaut reversed?
		beq.s	locret_11DBC	; if not, branch
		neg.w	obVelX(a0)		; move orbinaut	to the right

locret_11DBC:
		rts	
; ===========================================================================

Obj60_ChkSonic:				; XREF: Obj60_Index
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcc.s	loc_11DCA
		neg.w	d0

loc_11DCA:
		cmpi.w	#$A0,d0		; is Sonic within $A0 pixels of	orbinaut?
		bcc.s	Obj60_Animate	; if not, branch
		move.w	($FFFFD00C).w,d0
		sub.w	obY(a0),d0
		bcc.s	loc_11DDC
		neg.w	d0

loc_11DDC:
		cmpi.w	#$50,d0		; is Sonic within $50 pixels of	orbinaut?
		bcc.s	Obj60_Animate	; if not, branch
		tst.w	($FFFFFE08).w	; is debug mode	on?
		bne.s	Obj60_Animate	; if yes, branch
		move.b	#1,obAnim(a0)	; use "angry" animation

Obj60_Animate:
		lea	(Ani_obj60).l,a1
		jsr	AnimateSprite
		bra.w	Obj60_ChkDel
; ===========================================================================

Obj60_Display:				; XREF: Obj60_Index
		bsr	SpeedToPos

Obj60_ChkDel:				; XREF: Obj60_Animate
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj60_ChkGone
		bra.w	DisplaySprite
; ===========================================================================

Obj60_ChkGone:				; XREF: Obj60_ChkDel
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_11E34
		bclr	#7,obGfx(a2,d0.w)

loc_11E34:
		lea	$37(a0),a2
		moveq	#0,d2
		move.b	(a2)+,d2
		subq.w	#1,d2
		bcs.s	Obj60_Delete

loc_11E40:
		moveq	#0,d0
		move.b	(a2)+,d0
		lsl.w	#6,d0
		addi.l	#$FFD000,d0
		movea.l	d0,a1
		bsr	DeleteObject2
		dbf	d2,loc_11E40

Obj60_Delete:
		bra.w	DeleteObject
; ===========================================================================

Obj60_MoveOrb:				; XREF: Obj60_Index
		movea.l	$3C(a0),a1
		cmpi.b	#$60,0(a1)
		bne.w	DeleteObject
		cmpi.b	#2,obFrame(a1)
		bne.s	Obj60_Circle
		cmpi.b	#$40,obAngle(a0)
		bne.s	Obj60_Circle
		addq.b	#2,obRoutine(a0)
		subq.b	#1,$37(a1)
		bne.s	Obj60_FireOrb
		addq.b	#2,obRoutine(a1)

Obj60_FireOrb:
		move.w	#-$200,obVelX(a0)	; move orb to the left (quickly)
		btst	#0,obStatus(a1)
		beq.s	Obj60_Display2
		neg.w	obVelX(a0)

Obj60_Display2:
		bra.w	DisplaySprite
; ===========================================================================

Obj60_Circle:				; XREF: Obj60_MoveOrb
		move.b	obAngle(a0),d0
		jsr	(CalcSine).l
		asr.w	#4,d1
		add.w	obX(a1),d1
		move.w	d1,obX(a0)
		asr.w	#4,d0
		add.w	obY(a1),d0
		move.w	d0,obY(a0)
		move.b	$36(a1),d0
		add.b	d0,obAngle(a0)
		bra.w	DisplaySprite
; ===========================================================================

Obj60_ChkDel2:				; XREF: Obj60_Index
		bsr	SpeedToPos
		tst.b	obRender(a0)
		bpl.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================	
Ani_obj60:
		include	"_anim\obj60.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Orbinaut enemy (LZ,	SLZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj60:
		include	"_maps\obj60.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 16 - harpoon (LZ)
; ---------------------------------------------------------------------------

Obj16:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj16_Index(pc,d0.w),d1
		jmp	Obj16_Index(pc,d1.w)
; ===========================================================================
Obj16_Index:	dc.w Obj16_Main-Obj16_Index
		dc.w Obj16_Move-Obj16_Index
		dc.w Obj16_Wait-Obj16_Index
; ===========================================================================

Obj16_Main:				; XREF: Obj16_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj16,obMap(a0)
		move.w	#$3CC,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	obSubtype(a0),obAnim(a0)
		move.b	#$14,obActWid(a0)
		move.w	#60,$30(a0)

Obj16_Move:				; XREF: Obj16_Index
		lea	(Ani_obj16).l,a1
		jsr	AnimateSprite
		moveq	#0,d0
		move.b	obFrame(a0),d0	; move frame number to d0
		move.b	Obj16_Data(pc,d0.w),obColType(a0) ; load collision response (based on	d0)
		bra.w	MarkObjGone
; ===========================================================================
Obj16_Data:	dc.b $9B, $9C, $9D, $9E, $9F, $A0
; ===========================================================================

Obj16_Wait:				; XREF: Obj16_Index
		subq.w	#1,$30(a0)
		bpl.s	Obj16_ChkDel
		move.w	#60,$30(a0)
		subq.b	#2,obRoutine(a0)	; run "Obj16_Move" subroutine
		bchg	#0,obAnim(a0)	; reverse animation

Obj16_ChkDel:
		bra.w	MarkObjGone
; ===========================================================================
Ani_obj16:
		include	"_anim\obj16.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - harpoon (LZ)
; ---------------------------------------------------------------------------
Map_obj16:
		include	"_maps\obj16.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 61 - blocks (LZ)
; ---------------------------------------------------------------------------

Obj61:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj61_Index(pc,d0.w),d1
		jmp	Obj61_Index(pc,d1.w)
; ===========================================================================
Obj61_Index:	dc.w Obj61_Main-Obj61_Index
		dc.w Obj61_Action-Obj61_Index

Obj61_Var:	dc.b $10, $10		; width, height
		dc.b $20, $C
		dc.b $10, $10
		dc.b $10, $10
; ===========================================================================

Obj61_Main:				; XREF: Obj61_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj61,obMap(a0)
		
		move.w	#$43E6,obGfx(a0)
		cmpi.b	#$27,obSubtype(a0)
		move.w	#$4000|(($7980-$2340)/$20),obGfx(a0)

@notcork:
		move.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsr.w	#3,d0
		andi.w	#$E,d0
		lea	Obj61_Var(pc,d0.w),a2
		move.b	(a2)+,obActWid(a0)
		move.b	(a2),obHeight(a0)
		lsr.w	#1,d0
		move.b	d0,obFrame(a0)
		move.w	obX(a0),$34(a0)
		move.w	obY(a0),$30(a0)
		move.b	obSubtype(a0),d0
		andi.b	#$F,d0
		beq.s	Obj61_Action
		cmpi.b	#7,d0
		beq.s	Obj61_Action
		move.b	#1,$38(a0)

Obj61_Action:				; XREF: Obj61_Index
		move.w	obX(a0),-(sp)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj61_TypeIndex(pc,d0.w),d1
		jsr	obj61_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	obRender(a0)
		bpl.s	Obj61_ChkDel
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	obHeight(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		bsr	SolidObject
		move.b	d4,$3F(a0)
		bsr	loc_12180

Obj61_ChkDel:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		bra.w	DisplaySprite
; ===========================================================================
Obj61_TypeIndex:dc.w Obj61_Type00-Obj61_TypeIndex, Obj61_Type01-Obj61_TypeIndex
		dc.w Obj61_Type02-Obj61_TypeIndex, Obj61_Type01-Obj61_TypeIndex
		dc.w Obj61_Type04-Obj61_TypeIndex, Obj61_Type05-Obj61_TypeIndex
		dc.w Obj61_Type02-Obj61_TypeIndex, Obj61_Type07-Obj61_TypeIndex
; ===========================================================================

Obj61_Type00:				; XREF: Obj61_TypeIndex
		rts	
; ===========================================================================

Obj61_Type01:				; XREF: Obj61_TypeIndex
		tst.w	$36(a0)		; is Sonic standing on the object?
		bne.s	loc_120D6	; if yes, branch
		btst	#3,obStatus(a0)
		beq.s	locret_120D4
		move.w	#30,$36(a0)	; wait for ? second

locret_120D4:
		rts	
; ===========================================================================

loc_120D6:
		subq.w	#1,$36(a0)	; subtract 1 from waiting time
		bne.s	locret_120D4	; if time remains, branch
		addq.b	#1,obSubtype(a0)	; add 1	to type
		clr.b	$38(a0)
		rts	
; ===========================================================================

Obj61_Type02:				; XREF: Obj61_TypeIndex
		bsr	SpeedToPos
		addq.w	#8,obVelY(a0)	; make object fall
		bsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_12106
		addq.w	#1,d1
		add.w	d1,obY(a0)
		clr.w	obVelY(a0)		; stop when it touches the floor
		clr.b	obSubtype(a0)		; set type to 00 (non-moving type)

locret_12106:
		rts	
; ===========================================================================

Obj61_Type04:				; XREF: Obj61_TypeIndex
		bsr	SpeedToPos
		subq.w	#8,obVelY(a0)	; make object rise
		bsr	ObjHitCeiling
		tst.w	d1
		bpl.w	locret_12126
		sub.w	d1,obY(a0)
		clr.w	obVelY(a0)		; stop when it touches the ceiling
		clr.b	obSubtype(a0)		; set type to 00 (non-moving type)

locret_12126:
		rts	
; ===========================================================================

Obj61_Type05:				; XREF: Obj61_TypeIndex
		cmpi.b	#1,$3F(a0)	; is Sonic touching the	object?
		bne.s	locret_12138	; if not, branch
		addq.b	#1,obSubtype(a0)	; if yes, add 1	to type
		clr.b	$38(a0)

locret_12138:
		rts	
; ===========================================================================

Obj61_Type07:				; XREF: Obj61_TypeIndex
		move.w	($FFFFF646).w,d0
		sub.w	obY(a0),d0
		beq.s	locret_1217E
		bcc.s	loc_12162

		move.b	9(a0),d1
		ror.b	#4,d1
		andi.b	#$0F,d1
		addq.b	#1,d1
		lsr.b	#1,d1
		neg.b	d1
		ext.w	d1
		cmp.w	d1,d0
		bge.s	loc_1214E
		move.w	d1,d0

loc_1214E:
		add.w	d0,obY(a0)	; make the block rise with water level
		bsr	ObjHitCeiling
		tst.w	d1
		bpl.w	locret_12160
		sub.w	d1,obY(a0)

locret_12160:
		rts	
; ===========================================================================

loc_12162:				; XREF: Obj61_Type07
		cmpi.b	#$27,obSubtype(a0)
		beq.s	locret_12160		; make cork blocks never go down
		cmpi.w	#2,d0
		ble.s	loc_1216A
		moveq	#2,d0

loc_1216A:
		add.w	d0,obY(a0)	; make the block sink with water level
		bsr	ObjHitFloor
		tst.w	d1
		bpl.w	locret_1217E
		addq.w	#1,d1
		add.w	d1,obY(a0)

locret_1217E:
		rts	
; ===========================================================================

loc_12180:				; XREF: Obj61_Action
		tst.b	$38(a0)
		beq.s	locret_121C0
		btst	#3,obStatus(a0)
		bne.s	loc_1219A
		tst.b	$3E(a0)
		beq.s	locret_121C0
		subq.b	#4,$3E(a0)
		bra.s	loc_121A6
; ===========================================================================

loc_1219A:
		cmpi.b	#$40,$3E(a0)
		beq.s	locret_121C0
		addq.b	#4,$3E(a0)

loc_121A6:
		move.b	$3E(a0),d0
		jsr	(CalcSine).l
		move.w	#$400,d1
		muls.w	d1,d0
		swap	d0
		add.w	$30(a0),d0
		move.w	d0,obY(a0)

locret_121C0:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - blocks (LZ)
; ---------------------------------------------------------------------------
Map_obj61:
		include	"_maps\obj61.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 62 - gargoyle head (LZ)
; ---------------------------------------------------------------------------

Obj62:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj62_Index(pc,d0.w),d1
		jsr	obj62_Index(pc,d1.w)
		bra.w	MarkObjGone
; ===========================================================================
Obj62_Index:	dc.w Obj62_Main-Obj62_Index
		dc.w Obj62_MakeFire-Obj62_Index
		dc.w Obj62_FireBall-Obj62_Index
		dc.w Obj62_AniFire-Obj62_Index

Obj62_SpitRate:	dc.b	30/4	; sanic speed
		dc.b	60, 90, 120, 150, 180, 210, 240
; ===========================================================================

Obj62_Main:				; XREF: Obj62_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj62,obMap(a0)
		move.w	#$42E9,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$10,obActWid(a0)
		move.b	obSubtype(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		move.b	Obj62_SpitRate(pc,d0.w),obDelayAni(a0)	; set fireball spit rate
		move.b	obDelayAni(a0),obTimeFrame(a0)
		andi.b	#$F,obSubtype(a0)

Obj62_MakeFire:				; XREF: Obj62_Index
		tst.b 	($FFFFFFFE).w		; is the =P monitor enabled?
		bne.s	Obj62_NoFire		; if yes, don't fire

		subq.b	#1,obTimeFrame(a0)
		bne.s	Obj62_NoFire
		move.b	obDelayAni(a0),obTimeFrame(a0)
		bsr	ChkObjOnScreen
		bne.s	Obj62_NoFire
		bsr	SingleObjLoad
		bne.s	Obj62_NoFire
		move.b	#$62,0(a1)	; load fireball	object
		addq.b	#4,obRoutine(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	obRender(a0),obRender(a1)
		move.b	obStatus(a0),obStatus(a1)

Obj62_NoFire:
		rts	
; ===========================================================================

Obj62_FireBall:				; XREF: Obj62_Index
		addq.b	#2,obRoutine(a0)
		move.b	#8,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.l	#Map_obj62,obMap(a0)
		move.w	#$2E9,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$98,obColType(a0)
		move.b	#8,obActWid(a0)
		move.b	#2,obFrame(a0)
		addq.w	#8,obY(a0)
		move.w	#$600,obVelX(a0)	; set X speed
		btst	#0,obStatus(a0)
		bne.s	Obj62_Sound
		neg.w	obVelX(a0)

Obj62_Sound:
		move.w	#$A5,d0
		jsr	(PlaySound_Special).l ;	play lava ball sound

Obj62_AniFire:				; XREF: Obj62_Index
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	Obj62_StopFire
		bchg	#0,obFrame(a0)	; switch between frame 01 and 02

Obj62_StopFire:
		bsr	SpeedToPos
		btst	#0,obStatus(a0)
		bne.s	Obj62_StopFire2
		moveq	#-8,d3
		bsr	ObjHitWallLeft
		tst.w	d1
		bmi.w	DeleteObject	; delete if the	fireball hits a	wall
		rts	
; ===========================================================================

Obj62_StopFire2:
		moveq	#8,d3
		bsr	ObjHitWallRight
		tst.w	d1
		bmi.w	DeleteObject
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - gargoyle head (LZ)
; ---------------------------------------------------------------------------
Map_obj62:
		include	"_maps\obj62.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 63 - platforms	on a conveyor belt (LZ)
; ---------------------------------------------------------------------------

Obj63:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj63_Index(pc,d0.w),d1
		jsr	obj63_Index(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_1236A

Obj63_Display:				; XREF: loc_1236A
		bra.w	DisplaySprite
; ===========================================================================

loc_1236A:				; XREF: Obj63
		cmpi.b	#2,($FFFFFE11).w
		bne.s	loc_12378
		cmpi.w	#-$80,d0
		bcc.s	Obj63_Display

loc_12378:
		move.b	$2F(a0),d0
		bpl.w	DeleteObject
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bclr	#0,(a2,d0.w)
		bra.w	DeleteObject
; ===========================================================================
Obj63_Index:	dc.w Obj63_Main-Obj63_Index
		dc.w loc_124B2-Obj63_Index
		dc.w loc_124C2-Obj63_Index
		dc.w loc_124DE-Obj63_Index
; ===========================================================================

Obj63_Main:				; XREF: Obj63_Index
		move.b	obSubtype(a0),d0
		bmi.w	loc_12460
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj63,obMap(a0)
		move.w	#$43F6,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#4,obPriority(a0)
		cmpi.b	#$7F,obSubtype(a0)
		bne.s	loc_123E2
		addq.b	#4,obRoutine(a0)
		move.w	#$3F6,obGfx(a0)
		move.b	#1,obPriority(a0)
		bra.w	loc_124DE
; ===========================================================================

loc_123E2:
		move.b	#4,obFrame(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	Obj63_Data(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,$38(a0)
		move.w	(a2)+,$30(a0)
		move.l	a2,$3C(a0)
		andi.w	#$F,d1
		lsl.w	#2,d1
		move.b	d1,$38(a0)
		move.b	#4,$3A(a0)
		tst.b	($FFFFF7C0).w
		beq.s	loc_1244C
		move.b	#1,$3B(a0)
		neg.b	$3A(a0)
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_12448
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_12448
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_12448:
		move.b	d1,$38(a0)

loc_1244C:
		move.w	(a2,d1.w),$34(a0)
		move.w	obGfx(a2,d1.w),$36(a0)
		jsr	obj63_ChangeDir
		bra.w	loc_124B2
; ===========================================================================

loc_12460:				; XREF: Obj63_Main
		move.b	d0,$2F(a0)
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bset	#0,(a2,d0.w)
		bne.w	DeleteObject
		add.w	d0,d0
		andi.w	#$1E,d0
		addi.w	#$70,d0
		lea	(ObjPos_Index).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d1
		movea.l	a0,a1
		bra.s	Obj63_MakePtfms
; ===========================================================================

Obj63_Loop:
		bsr	SingleObjLoad
		bne.s	loc_124AA

Obj63_MakePtfms:			; XREF: loc_12460
		move.b	#$63,0(a1)
		move.w	(a2)+,obX(a1)
		move.w	(a2)+,obY(a1)
		move.w	(a2)+,d0
		move.b	d0,obSubtype(a1)

loc_124AA:
		dbf	d1,Obj63_Loop

		addq.l	#4,sp
		rts	
; ===========================================================================

loc_124B2:				; XREF: Obj63_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(PlatformObject).l
		bra.w	sub_12502
; ===========================================================================

loc_124C2:				; XREF: Obj63_Index
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(ExitPlatform).l
		move.w	obX(a0),-(sp)
		bsr	sub_12502
		move.w	(sp)+,d2
		jmp	(MvSonicOnPtfm2).l
; ===========================================================================

loc_124DE:				; XREF: Obj63_Index
		move.w	($FFFFFE04).w,d0
		andi.w	#3,d0
		bne.s	loc_124FC
		moveq	#1,d1
		tst.b	($FFFFF7C0).w
		beq.s	loc_124F2
		neg.b	d1

loc_124F2:
		add.b	d1,obFrame(a0)
		andi.b	#3,obFrame(a0)

loc_124FC:
		addq.l	#4,sp
		bra.w	MarkObjGone

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_12502:				; XREF: loc_124B2; loc_124C2
		tst.b	($FFFFF7EE).w
		beq.s	loc_12520
		tst.b	$3B(a0)
		bne.s	loc_12520
		move.b	#1,$3B(a0)
		move.b	#1,($FFFFF7C0).w
		neg.b	$3A(a0)
		bra.s	loc_12534
; ===========================================================================

loc_12520:
		move.w	obX(a0),d0
		cmp.w	$34(a0),d0
		bne.s	loc_1256A
		move.w	obY(a0),d0
		cmp.w	$36(a0),d0
		bne.s	loc_1256A

loc_12534:
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_12552
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_12552
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_12552:
		move.b	d1,$38(a0)
		movea.l	$3C(a0),a1
		move.w	(a1,d1.w),$34(a0)
		move.w	obGfx(a1,d1.w),$36(a0)
		jsr	obj63_ChangeDir

loc_1256A:
		bsr	SpeedToPos
		rts	
; End of function sub_12502


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj63_ChangeDir:			; XREF: loc_123E2; sub_12502
		moveq	#0,d0
		move.w	#-$100,d2
		move.w	obX(a0),d0
		sub.w	$34(a0),d0
		bcc.s	loc_12584
		neg.w	d0
		neg.w	d2

loc_12584:
		moveq	#0,d1
		move.w	#-$100,d3
		move.w	obY(a0),d1
		sub.w	$36(a0),d1
		bcc.s	loc_12598
		neg.w	d1
		neg.w	d3

loc_12598:
		cmp.w	d0,d1
		bcs.s	loc_125C2
		move.w	obX(a0),d0
		sub.w	$34(a0),d0
		beq.s	loc_125AE
		ext.l	d0
		asl.l	#8,d0
		divs.w	d1,d0
		neg.w	d0

loc_125AE:
		move.w	d0,obVelX(a0)
		move.w	d3,obVelY(a0)
		swap	d0
		move.w	d0,obScreenY(a0)
		clr.w	$E(a0)
		rts	
; ===========================================================================

loc_125C2:				; XREF: Obj63_ChangeDir
		move.w	obY(a0),d1
		sub.w	$36(a0),d1
		beq.s	loc_125D4
		ext.l	d1
		asl.l	#8,d1
		divs.w	d0,d1
		neg.w	d1

loc_125D4:
		move.w	d1,obVelY(a0)
		move.w	d2,obVelX(a0)
		swap	d1
		move.w	d1,$E(a0)
		clr.w	obScreenY(a0)
		rts	
; End of function Obj63_ChangeDir

; ===========================================================================
Obj63_Data:	dc.w word_125F4-Obj63_Data
		dc.w word_12610-Obj63_Data
		dc.w word_12628-Obj63_Data
		dc.w word_1263C-Obj63_Data
		dc.w word_12650-Obj63_Data
		dc.w word_12668-Obj63_Data
word_125F4:	dc.w $18, $1070, $1078,	$21A, $10BE, $260, $10BE, $393
		dc.w $108C, $3C5, $1022, $390, $1022, $244
word_12610:	dc.w $14, $1280, $127E,	$280, $12CE, $2D0, $12CE, $46E
		dc.w $1232, $420, $1232, $2CC
word_12628:	dc.w $10, $D68,	$D22, $482, $D22, $5DE,	$DAE, $5DE, $DAE, $482
word_1263C:	dc.w $10, $DA0,	$D62, $3A2, $DEE, $3A2,	$DEE, $4DE, $D62, $4DE
word_12650:	dc.w $14, $D00,	$CAC, $242, $DDE, $242,	$DDE, $3DE, $C52, $3DE,	$C52, $29C
word_12668:	dc.w $10, $1300, $1252,	$20A, $13DE, $20A, $13DE, $2BE,	$1252, $2BE

; ---------------------------------------------------------------------------
; Sprite mappings - platforms on a conveyor belt (LZ)
; ---------------------------------------------------------------------------
Map_obj63:
		include	"_maps\obj63.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 64 - bubbles (LZ)
; ---------------------------------------------------------------------------

Obj64:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj64_Index(pc,d0.w),d1
		jmp	Obj64_Index(pc,d1.w)
; ===========================================================================
Obj64_Index:	dc.w Obj64_Main-Obj64_Index
		dc.w Obj64_Animate-Obj64_Index
		dc.w Obj64_ChkWater-Obj64_Index
		dc.w Obj64_Display2-Obj64_Index
		dc.w Obj64_Delete3-Obj64_Index
		dc.w Obj64_BblMaker-Obj64_Index
; ===========================================================================

Obj64_Main:				; XREF: Obj64_Index
		frantic			; are we in frantic mode?
		bne.w	DeleteObject	; if yes, no bubbles for you

		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj64,obMap(a0)
		move.w	#$8348,obGfx(a0)
		move.b	#$84,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#1,obPriority(a0)
		move.b	obSubtype(a0),d0	; get object type
		bpl.s	Obj64_Bubble	; if type is $0-$7F, branch
		addq.b	#8,obRoutine(a0)
		andi.w	#$7F,d0		; read only last 7 bits	(deduct	$80)
		move.b	d0,$32(a0)
		move.b	d0,$33(a0)
		move.b	#6,obAnim(a0)
		bra.w	Obj64_BblMaker
; ===========================================================================

Obj64_Bubble:				; XREF: Obj64_Main
		move.b	d0,obAnim(a0)
		move.w	obX(a0),$30(a0)
		move.w	#-$88,obVelY(a0)	; float	bubble upwards
		jsr	(RandomNumber).l
		move.b	d0,obAngle(a0)

Obj64_Animate:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		cmpi.b	#6,obFrame(a0)
		bne.s	Obj64_ChkWater
		move.b	#1,$2E(a0)

Obj64_ChkWater:				; XREF: Obj64_Index
		move.w	($FFFFF646).w,d0
		cmp.w	obY(a0),d0	; is bubble underwater?
		bcs.s	Obj64_Wobble	; if yes, branch

Obj64_Burst:				; XREF: Obj64_Wobble
		move.b	#6,obRoutine(a0)
		addq.b	#3,obAnim(a0)	; run "bursting" animation
		bra.w	Obj64_Display2
; ===========================================================================

Obj64_Wobble:				; XREF: Obj64_ChkWater
		move.b	obAngle(a0),d0
		addq.b	#1,obAngle(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,obX(a0)	; change bubble's horizontal position
		tst.b	$2E(a0)
		beq.s	Obj64_Display
		jsr	obj64_ChkSonic	; has Sonic touched the	bubble?
		beq.s	Obj64_Display	; if not, branch

		bsr	ResumeMusic	; cancel countdown music
		move.w	#$AD,d0
		jsr	(PlaySound_Special).l ;	play collecting	bubble sound
		lea	($FFFFD000).w,a1
		clr.w	obVelX(a1)
		clr.w	obVelY(a1)
		clr.w	obInertia(a1)
		move.b	#$15,obAnim(a1)
		move.w	#$23,$3E(a1)
		move.b	#0,$3C(a1)
		bclr	#5,obStatus(a1)
		bclr	#4,obStatus(a1)
		btst	#2,obStatus(a1)
		beq.w	Obj64_Burst
		bclr	#2,obStatus(a1)
		move.b	#$13,obHeight(a1)
		move.b	#9,obWidth(a1)
		subq.w	#5,obY(a1)
		bra.w	Obj64_Burst
; ===========================================================================

Obj64_Display:				; XREF: Obj64_Wobble
		bsr	SpeedToPos
		tst.b	obRender(a0)
		bpl.s	Obj64_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj64_Display2:				; XREF: Obj64_Index
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite
		tst.b	obRender(a0)
		bpl.s	Obj64_Delete2
		jmp	DisplaySprite
; ===========================================================================

Obj64_Delete2:
		jmp	DeleteObject
; ===========================================================================

Obj64_Delete3:				; XREF: Obj64_Index
		bra.w	DeleteObject
; ===========================================================================

Obj64_BblMaker:				; XREF: Obj64_Index
		tst.w	$36(a0)
		bne.s	loc_12874
		move.w	($FFFFF646).w,d0
		cmp.w	obY(a0),d0	; is bubble maker underwater?
		bcc.w	Obj64_ChkDel	; if not, branch
		tst.b	obRender(a0)
		bpl.w	Obj64_ChkDel
		cmpi.w	#$0098,($FFFFFE04).w        ; has the level timer reached a reasonable point?
		blo.w	loc_12914            ; if not, ignore loading bubbles
		subq.w	#1,$38(a0)
		bpl.w	loc_12914
		move.w	#1,$36(a0)

loc_1283A:
		jsr	(RandomNumber).l
		move.w	d0,d1
		andi.w	#7,d0
		cmpi.w	#6,d0
		bcc.s	loc_1283A

		move.b	d0,$34(a0)
		andi.w	#$C,d1
		lea	(Obj64_BblTypes).l,a1
		adda.w	d1,a1
		move.l	a1,$3C(a0)
		subq.b	#1,$32(a0)
		bpl.s	loc_12872
		move.b	$33(a0),$32(a0)
		bset	#7,$36(a0)

loc_12872:
		bra.s	loc_1287C
; ===========================================================================

loc_12874:				; XREF: Obj64_BblMaker
		subq.w	#1,$38(a0)
		bpl.w	loc_12914

loc_1287C:
		jsr	(RandomNumber).l
		andi.w	#$1F,d0
		move.w	d0,$38(a0)
		bsr	SingleObjLoad
		bne.s	loc_128F8
		move.b	#$64,0(a1)	; load bubble object
		move.w	obX(a0),obX(a1)
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		subq.w	#8,d0
		add.w	d0,obX(a1)
		move.w	obY(a0),obY(a1)
		moveq	#0,d0
		move.b	$34(a0),d0
		movea.l	$3C(a0),a2
		move.b	(a2,d0.w),obSubtype(a1)
		btst	#7,$36(a0)
		beq.s	loc_128F8
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_128E4
		bset	#6,$36(a0)
		bne.s	loc_128F8
		move.b	#2,obSubtype(a1)

loc_128E4:
		tst.b	$34(a0)
		bne.s	loc_128F8
		bset	#6,$36(a0)
		bne.s	loc_128F8
		move.b	#2,obSubtype(a1)

loc_128F8:
		subq.b	#1,$34(a0)
		bpl.s	loc_12914
		jsr	(RandomNumber).l
		andi.w	#$7F,d0
		addi.w	#$80,d0
		add.w	d0,$38(a0)
		clr.w	$36(a0)

loc_12914:
		lea	(Ani_obj64).l,a1
		jsr	AnimateSprite

Obj64_ChkDel:				; XREF: Obj64_BblMaker
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject
		move.w	($FFFFF646).w,d0
		cmp.w	obY(a0),d0
		bcs.w	DisplaySprite
		rts	
; ===========================================================================
; bubble production sequence

; 0 = small bubble, 1 =	large bubble

Obj64_BblTypes:	dc.b 0,	1, 0, 0, 0, 0, 1, 0, 0,	0, 0, 1, 0, 1, 0, 0, 1,	0

; ===========================================================================

Obj64_ChkSonic:				; XREF: Obj64_Wobble
		tst.b	($FFFFF7C8).w
		bmi.s	loc_12998
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		move.w	obX(a0),d1
		subi.w	#$10,d1
		cmp.w	d0,d1
		bcc.s	loc_12998
		addi.w	#$20,d1
		cmp.w	d0,d1
		bcs.s	loc_12998
		move.w	obY(a1),d0
		move.w	obY(a0),d1
		cmp.w	d0,d1
		bcc.s	loc_12998
		addi.w	#$10,d1
		cmp.w	d0,d1
		bcs.s	loc_12998
		moveq	#1,d0
		rts	
; ===========================================================================

loc_12998:
		moveq	#0,d0
		rts	
; ===========================================================================
Ani_obj64:
		include	"_anim\obj64.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - bubbles (LZ)
; ---------------------------------------------------------------------------
Map_obj64:
		include	"_maps\obj64.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 65 - waterfalls (LZ)
; ---------------------------------------------------------------------------

Obj65:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj65_Index(pc,d0.w),d1
		jmp	Obj65_Index(pc,d1.w)
; ===========================================================================
Obj65_Index:	dc.w Obj65_Main-Obj65_Index
		dc.w Obj65_Animate-Obj65_Index
		dc.w Obj65_ChkDel-Obj65_Index
		dc.w Obj65_FixHeight-Obj65_Index
		dc.w loc_12B36-Obj65_Index
; ===========================================================================

Obj65_Main:				; XREF: Obj65_Index
		addq.b	#4,obRoutine(a0)
		move.l	#Map_obj65,obMap(a0)
		move.w	#$4259,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$18,obActWid(a0)
		move.b	#1,obPriority(a0)
		move.b	obSubtype(a0),d0	; get object type
		bpl.s	loc_12AE6
		bset	#7,obGfx(a0)

loc_12AE6:
		andi.b	#$F,d0		; read only the	2nd byte
		move.b	d0,obFrame(a0)	; set frame number
		cmpi.b	#9,d0		; is object type $x9 ?
		bne.s	Obj65_ChkDel	; if not, branch
		clr.b	obPriority(a0)
		subq.b	#2,obRoutine(a0)
		btst	#6,obSubtype(a0)	; is object type $4x ?
		beq.s	loc_12B0A	; if not, branch
		move.b	#6,obRoutine(a0)

loc_12B0A:
		btst	#5,obSubtype(a0)	; is object type $Ax ?
		beq.s	Obj65_Animate	; if not, branch
		move.b	#8,obRoutine(a0)

Obj65_Animate:				; XREF: Obj65_Index
		lea	(Ani_obj65).l,a1
		jsr	AnimateSprite

Obj65_ChkDel:				; XREF: Obj65_Index
		bra.w	MarkObjGone
; ===========================================================================

Obj65_FixHeight:			; XREF: Obj65_Index
		clr.b	obPriority(a0)
		move.w	($FFFFF646).w,d0
		subi.w	#12,d0
		move.w	d0,obY(a0)	; match	object position	to water height
		bra.s	Obj65_Animate
; ===========================================================================

loc_12B36:				; XREF: Obj65_Index
		bclr	#7,obGfx(a0)
		cmpi.b	#7, LevelLayout_FG+$40*2+6
		bne.s	Obj65_Animate2
		bset	#7,obGfx(a0)

Obj65_Animate2:
		bra.s	Obj65_Animate
; ===========================================================================
Ani_obj65:
		include	"_anim\obj65.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - waterfalls (LZ)
; ---------------------------------------------------------------------------
Map_obj65:
		include	"_maps\obj65.asm"

; ---------------------------------------------------------------------------
; Object 05 - Spindash Dust
; ---------------------------------------------------------------------------

Obj05:
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move	off_1DD2E(pc,d0.w),d1
		jmp	off_1DD2E(pc,d1.w)
; ===========================================================================
off_1DD2E:	dc.w loc_1DD36-off_1DD2E
		dc.w loc_1DD90-off_1DD2E
		dc.w loc_1DE46-off_1DD2E; 2
		dc.w loc_1DE4A-off_1DD2E; 3
; ===========================================================================

loc_1DD36:				; DATA XREF: h+6DBAo
		addq.b	#2,obRoutine(a0)
		move.l	#MapUnc_1DF5E,obMap(a0)
		ori.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#$10,obActWid(a0)
		move	#$7A0,obGfx(a0)
		move	#-$3000,$3E(a0)
		move	#$F400,$3C(a0)
		cmp	#-$2E40,a0
		beq.s	loc_1DD90
		move.b	#1,$34(a0)

loc_1DD90:				; DATA XREF: h+6DBAo
		movea.w	$3E(a0),a2
		moveq	#0,d0
		move.b	obAnim(a0),d0
		add	d0,d0
		move	off_1DDA4(pc,d0.w),d1
		jmp	off_1DDA4(pc,d1.w)
; ===========================================================================
off_1DDA4:	dc loc_1DE28-off_1DDA4; 0 ; DATA XREF: h+6E30o h+6E32o ...
		dc loc_1DDAC-off_1DDA4; 1
		dc loc_1DDCC-off_1DDA4; 2
		dc loc_1DE28-off_1DDA4; 3
; ===========================================================================

loc_1DDAC:				; DATA XREF: h+6E30o
		move	($FFFFF646).w,obY(a0)
		tst.b	obNextAni(a0)
		bne.s	loc_1DE28
		move	obX(a2),obX(a0)
		move.b	#0,obStatus(a0)
		and	#$7FFF,obGfx(a0)
		bra.s	loc_1DE28
; ===========================================================================

loc_1DDCC:				; DATA XREF: h+6E30o
		cmp.b	#4,obRoutine(a2)
		bcc.s	loc_1DE3E
		
		tst.b	($FFFFFEBC).w	; is peelout flag set?
		bne.s	Obj05_PO	; if yes, branch
		tst.b	$39(a2)		; is spindash flag set?
		beq.s	loc_1DE3E	; if not, branch
		bra.s	Obj05_SPDSH	; skip Obj05_PO

Obj05_PO:
		cmpi.b	#$27,obAnim(a2)	; is SPO anim #3 being showed (fast one)?
		beq.s	Obj05_SPDSH	; if yes, do dust
		rts			; if not, don't do dust

Obj05_SPDSH:
		move	obX(a2),obX(a0)
		move	obY(a2),obY(a0)
		move.b	obStatus(a2),obStatus(a0)
		and.b	#1,obStatus(a0)
		tst.b	$34(a0)
		beq.s	loc_1DE06
		sub	#4,obY(a0)

loc_1DE06:				; CODE XREF: h+6E8Aj
		tst.b	obNextAni(a0)
		bne.s	loc_1DE28
		and	#$7FFF,obGfx(a0)
		tst	obGfx(a2)
		bpl.s	loc_1DE28
		or	#-$8000,obGfx(a0)

; ===========================================================================

loc_1DE28:				; CODE XREF: h+6E42j h+6E56j ...
		lea	(off_1DF38).l,a1
		jsr	AnimateSprite
		jsr	loc_1DEE4
		jmp	DisplaySprite
; ===========================================================================

loc_1DE3E:				; CODE XREF: h+6E5Ej h+6E66j ...
		move.b	#0,obAnim(a0)
		rts	
; ===========================================================================

loc_1DE46:				; DATA XREF: h+6DBAo
		bra.w	DeleteObject
; ===========================================================================



loc_1DE4A:
		movea.w	$3E(a0),a2
		moveq	#$10,d1
		cmp.b	#$D,obAnim(a2)
		beq.s	loc_1DE64
		moveq	#$6,d1
		cmp.b	#$3,obColProp(a2)
		beq.s	loc_1DE64
		move.b	#2,obRoutine(a0)
		move.b	#0,$32(a0)
		rts
; ===========================================================================

loc_1DE64:				; CODE XREF: h+6EE0j
		subq.b	#1,$32(a0)
		bpl.s	loc_1DEE0
		move.b	#3,$32(a0)
		bsr	SingleObjLoad
		bne.s	loc_1DEE0
		move.b	0(a0),0(a1)
		move	obX(a2),obX(a1)
		move	obY(a2),obY(a1)
		tst.b	$34(a0)
		beq.s	loc_1DE9A
		sub	#4,d1

loc_1DE9A:				; CODE XREF: h+6F1Ej
		add	d1,obY(a1)
		move.b	#0,obStatus(a1)
		move.b	#3,obAnim(a1)
		addq.b	#2,obRoutine(a1)
		move.l	obMap(a0),obMap(a1)
		move.b	obRender(a0),obRender(a1)
		move.b	#1,obPriority(a1)
		move.b	#4,obActWid(a1)
		move	obGfx(a0),obGfx(a1)
		move	$3E(a0),$3E(a1)
		and	#$7FFF,obGfx(a1)
		tst	obGfx(a2)
		bpl.s	loc_1DEE0
		or	#-$8000,obGfx(a1)

loc_1DEE0:				; CODE XREF: h+6EF4j h+6F00j ...
		bsr.s	loc_1DEE4
		rts	
; ===========================================================================

loc_1DEE4:				; CODE XREF: h+6EC0p h+6F6Cp
		moveq	#0,d0
		move.b	obFrame(a0),d0
		cmp.b	$30(a0),d0
		beq.w	locret_1DF36
		move.b	d0,$30(a0)
		lea	(off_1E074).l,a2
		add	d0,d0
		add	(a2,d0.w),a2
		move	(a2)+,d5
		subq	#1,d5
		bmi.w	locret_1DF36
		move 	$3C(a0),d4

loc_1DF0A:				; CODE XREF: h+6FBEj
		moveq	#0,d1
		move	(a2)+,d1
		move	d1,d3
		lsr.w	#8,d3
		and	#$F0,d3	; '?'
		add	#$10,d3
		and	#$FFF,d1
		lsl.l	#5,d1
		add.l	#Art_Dust,d1
		move	d4,d2
		add	d3,d4
		add	d3,d4
		jsr	(QueueDMATransfer).l
		dbf	d5,loc_1DF0A

locret_1DF36:				; CODE XREF: h+6F7Aj h+6F90j
		rts	
; ===========================================================================
off_1DF38:	dc byte_1DF40-off_1DF38; 0 ; DATA XREF: h+6EB4o h+6FC4o ...
		dc byte_1DF43-off_1DF38; 1
		dc byte_1DF4F-off_1DF38; 2
		dc byte_1DF58-off_1DF38; 3
byte_1DF40:	dc.b $1F,  0,$FF	; 0 ; DATA XREF: h+6FC4o
byte_1DF43:	dc.b   3,  1,  2,  3,  4,  5,  6,  7,  8,  9,$FD,  0; 0	; DATA XREF: h+6FC4o
byte_1DF4F:	dc.b   1, $A, $B, $C, $D, $E, $F,$10,$FF; 0 ; DATA XREF: h+6FC4o
byte_1DF58:	dc.b   3,$11,$12,$13,$14,$FC; 0	; DATA XREF: h+6FC4o

; -------------------------------------------------------------------------------
; Unknown Sprite Mappings
; -------------------------------------------------------------------------------
MapUnc_1DF5E:
	dc word_1DF8A-MapUnc_1DF5E; 0
	dc word_1DF8C-MapUnc_1DF5E; 1
	dc word_1DF96-MapUnc_1DF5E; 2
	dc word_1DFA0-MapUnc_1DF5E; 3
	dc word_1DFAA-MapUnc_1DF5E; 4
	dc word_1DFB4-MapUnc_1DF5E; 5
	dc word_1DFBE-MapUnc_1DF5E; 6
	dc word_1DFC8-MapUnc_1DF5E; 7
	dc word_1DFD2-MapUnc_1DF5E; 8
	dc word_1DFDC-MapUnc_1DF5E; 9
	dc word_1DFE6-MapUnc_1DF5E; 10
	dc word_1DFF0-MapUnc_1DF5E; 11
	dc word_1DFFA-MapUnc_1DF5E; 12
	dc word_1E004-MapUnc_1DF5E; 13
	dc word_1E016-MapUnc_1DF5E; 14
	dc word_1E028-MapUnc_1DF5E; 15
	dc word_1E03A-MapUnc_1DF5E; 16
	dc word_1E04C-MapUnc_1DF5E; 17
	dc word_1E056-MapUnc_1DF5E; 18
	dc word_1E060-MapUnc_1DF5E; 19
	dc word_1E06A-MapUnc_1DF5E; 20
	dc word_1DF8A-MapUnc_1DF5E; 21
word_1DF8A:	dc.b 0
word_1DF8C:	dc.b 1
	dc.b $F2, $0D, $0, 0,$F0; 0
word_1DF96:	dc.b 1
	dc.b $E2, $0F, $0, 0,$F0; 0
word_1DFA0:	dc.b 1
	dc.b $E2, $0F, $0, 0,$F0; 0
word_1DFAA:	dc.b 1
	dc.b $E2, $0F, $0, 0,$F0; 0
word_1DFB4:	dc.b 1
	dc.b $E2, $0F, $0, 0,$F0; 0
word_1DFBE:	dc.b 1
	dc.b $E2, $0F, $0, 0,$F0; 0
word_1DFC8:	dc.b 1
	dc.b $F2, $0D, $0, 0,$F0; 0
word_1DFD2:	dc.b 1
	dc.b $F2, $0D, $0, 0,$F0; 0
word_1DFDC:	dc.b 1
	dc.b $F2, $0D, $0, 0,$F0; 0
word_1DFE6:	dc.b 1
	dc.b $4, $0D, $0, 0,$E0; 0
word_1DFF0:	dc.b 1
	dc.b $4, $0D, $0, 0,$E0; 0
word_1DFFA:	dc.b 1
	dc.b $4, $0D, $0, 0,$E0; 0
word_1E004:	dc.b 2
	dc.b $F4, $01, $0, 0,$E8; 0
	dc.b $4, $0D, $0, 2,$E0; 4
word_1E016:	dc.b 2
	dc.b $F4, $05, $0, 0,$E8; 0
	dc.b $4, $0D, $0, 4,$E0; 4
word_1E028:	dc.b 2
	dc.b $F4, $09, $0, 0,$E0; 0
	dc.b $4, $0D, $0, 6,$E0; 4
word_1E03A:	dc.b 2
	dc.b $F4, $09, $0, 0,$E0; 0
	dc.b $4, $0D, $0, 6,$E0; 4
word_1E04C:	dc.b 1
	dc.b $F8, $05, $0, 0,$F8; 0
word_1E056:	dc.b 1
	dc.b $F8, $05, $0, 4,$F8; 0
word_1E060:	dc.b 1
	dc.b $F8, $05, $0, 8,$F8; 0
word_1E06A:	dc.b 1
	dc.b $F8, $05, $0, $C,$F8; 0
	dc.b 0
off_1E074:	dc word_1E0A0-off_1E074; 0
	dc word_1E0A2-off_1E074; 1
	dc word_1E0A6-off_1E074; 2
	dc word_1E0AA-off_1E074; 3
	dc word_1E0AE-off_1E074; 4
	dc word_1E0B2-off_1E074; 5
	dc word_1E0B6-off_1E074; 6
	dc word_1E0BA-off_1E074; 7
	dc word_1E0BE-off_1E074; 8
	dc word_1E0C2-off_1E074; 9
	dc word_1E0C6-off_1E074; 10
	dc word_1E0CA-off_1E074; 11
	dc word_1E0CE-off_1E074; 12
	dc word_1E0D2-off_1E074; 13
	dc word_1E0D8-off_1E074; 14
	dc word_1E0DE-off_1E074; 15
	dc word_1E0E4-off_1E074; 16
	dc word_1E0EA-off_1E074; 17
	dc word_1E0EA-off_1E074; 18
	dc word_1E0EA-off_1E074; 19
	dc word_1E0EA-off_1E074; 20
	dc word_1E0EC-off_1E074; 21
word_1E0A0:	dc 0
word_1E0A2:	dc 1
	dc $7000
word_1E0A6:	dc 1
	dc $F008
word_1E0AA:	dc 1
	dc $F018
word_1E0AE:	dc 1
	dc $F028
word_1E0B2:	dc 1
	dc $F038
word_1E0B6:	dc 1
	dc $F048
word_1E0BA:	dc 1
	dc $7058
word_1E0BE:	dc 1
	dc $7060
word_1E0C2:	dc 1
	dc $7068
word_1E0C6:	dc 1
	dc $7070
word_1E0CA:	dc 1
	dc $7078
word_1E0CE:	dc 1
	dc $7080
word_1E0D2:	dc 2
	dc $1088
	dc $708A
word_1E0D8:	dc 2
	dc $3092
	dc $7096
word_1E0DE:	dc 2
	dc $509E
	dc $70A4
word_1E0E4:	dc 2
	dc $50AC
	dc $70B2
word_1E0EA:	dc 0
word_1E0EC:	dc 1
	dc $F0BA
	even

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 02 - ERaZor Banner / U Mad Bro? Sign
; --------------------------------------------------------------------------
UMadBro_X 	= $EB
UMadBro_YStart	= $20A
UMadBro_YEnd	= $158
; --------------------------------------------------------------------------

Obj02:
		moveq	#0,d0			; clear d0
		move.b	obRoutine(a0),d0	; move routine counter to d0
		move.w	Obj02_Index(pc,d0.w),d1 ; move the index to d1
		jmp	Obj02_Index(pc,d1.w)	; find out the current position in the index
; ===========================================================================
Obj02_Index:	dc.w Obj02_Setup-Obj02_Index	; Set up the object (art etc.)	[$0]
		dc.w Obj02_Display-Obj02_Index	; Display Sprite		[$2]
		dc.w Obj02_DisplayE-Obj02_Index	; Display End Sprite		[$4]
; ===========================================================================

Obj02_Setup:
		addq.b	#2,obRoutine(a0)		; set to "Obj02_Display"
		move.l	#Map_Obj02,obMap(a0)		; load mappings
		move.b	#0,obPriority(a0)		; set priority
		move.b	#0,obRender(a0)			; set render flag
		move.w	#$6520,obGfx(a0)		; set art, use fourth palette line
		
		cmpi.b	#$18,($FFFFF600).w		; is screen mode ending sequence?
		bne.s	Obj02_NotEnding			; if not, branch
		move.w	#$0524,obGfx(a0)		; set art, use first palette line
		move.l	#Map_Obj02_End,obMap(a0)	; load mappings
		move.w	#UMadBro_X,obX(a0)		; set X-position
		move.w	#UMadBro_YStart,obScreenY(a0)	; set Y-position
		addq.b	#2,obRoutine(a0)		; set to "Obj02_Display"
		bra.s	Obj02_FinishSetup

Obj02_NotEnding:
		cmpi.b	#$20,($FFFFF600).w		; is screen mode story screen?
		beq.s	@nobgmaps			; if yes, branch
		cmpi.b	#$24,($FFFFF600).w		; is screen mode options menu?
		bne.s	Obj02_NotOptions		; if not, branch
@nobgmaps:
		move.w	#$2520,obGfx(a0)		; set art, use second palette line
		bra.s	Obj02_FinishSetup		; use XY positions set while loading object

Obj02_NotOptions:
		move.w	#$11F,obX(a0)			; set X-position
		move.w	#$113,obScreenY(a0)		; set Y-position

Obj02_FinishSetup:
		move.w	obScreenY(a0),$32(a0)

Obj02_Display:
		; sway
		move.w	($FFFFFE0E).w,d0
		add.w	d0,d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$32(a0),d0
	;	move.w	d0,obScreenY(a0)

		bset	#7,obGfx(a0)			; make object high priority
		jmp	DisplaySprite			; jump to DisplaySprite
; ===========================================================================

Obj02_DisplayE:
		cmpi.b	#6,($FFFFD024).w		; is Sonic dying?
		blt.s	Obj02_DE_No			; if not, branch
		cmpi.w	#UMadBro_YEnd,obScreenY(a0)	; has target location been reached?
		bmi.s	Obj02_DE_No			; if yes, branch
		subq.w	#1,obScreenY(a0)		; move up

Obj02_DE_No:		
		jmp	DisplaySprite			; jump to DisplaySprite
; ===========================================================================

; ---------------------------------------------------------------------------
; Sprite mappings - ERaZor Banner
; ---------------------------------------------------------------------------
Map_Obj02:
		include	"_maps\ERaZor.asm"
Map_Obj02_End:
		include	"_maps\UMadBro.asm"
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 03 - Level Signs in Uberhub Place (SYZ1)
; ---------------------------------------------------------------------------

Obj03:
		moveq	#0,d0			; clear d0
		move.b	obRoutine(a0),d0	; move routine counter to d0
		move.w	Obj03_Index(pc,d0.w),d1 ; move the index to d1
		jmp	Obj03_Index(pc,d1.w)	; find out the current position in the index
; ===========================================================================
Obj03_Index:	dc.w Obj03_Setup-Obj03_Index	; Set up the object (art etc.)	[$0]
		dc.w Obj03_Display-Obj03_Index	; Display Sprite (Sign)		[$2]
; ===========================================================================

Obj03_Setup:
		addq.b	#2,obRoutine(a0)	; set to "Obj03_Display"
		move.l	#Map_Obj03,obMap(a0)	; load mappings
		move.b	#4,obPriority(a0)	; set priority
		move.b	#4,obRender(a0)		; set render flag
		move.b	#$56,obActWid(a0)	; set display width
		move.b	obSubtype(a0),obFrame(a0) ; set frame to subtype ID
		subi.w	#$C,obY(a0)		; adjust Y pos
		move.w	#($6200/$20),obGfx(a0)	; set art, use first palette line
		cmpi.w	#$501,($FFFFFE10).w	; is this the tutorial?
		bne.s	@cont			; if not, branch
		move.w	#($7300/$20),obGfx(a0)	; use alternate mappings
		bset	#7,obGfx(a0)		; make it high plane
	
@cont:		
		; "PLACE" text on level signs
		cmpi.b	#7,obSubtype(a0)	; is this a regular level sign? (for an act)
		bge.s	Obj03_Display		; if not, branch
		bsr	SingleObjLoad		; load an object
		bne.s	Obj03_Display		; skip on fail
		move.b	#$03,0(a1)		; load another level sign object
		move.w	obX(a0),obX(a1)		; copy X pos
		move.w	obY(a0),d0		; get Y pos
		addi.w	#$18,d0			; move it $18 pixels lower
		move.w	d0,obY(a1)		; set Y pos
		move.b	#2,obRoutine(a1)	; set to "Obj03_Display"
		move.l	#Map_Obj03,obMap(a1)	; load mappings
		move.b	#4,obPriority(a1)	; set priority
		move.b	#4,obRender(a1)		; set render flag
		move.b	#86,obActWid(a1)	; set display width
		move.w	#($6200/$20),obGfx(a1)	; set art, use first palette line
		move.b	#9,obFrame(a1)		; set to "PLACE" frame
		move.w	obY(a1),$38(a1)		; remember base Y pos
		
Obj03_Display:
		bclr	#5,obGfx(a0)		; use first palette row
		btst	#0,($FFFFFE05).w	; is this an odd frame?
		beq.s	@notodd			; if not, branch
		bset	#5,obGfx(a0)		; use second palette row (gives a slight flicker effect)
@notodd:
		bsr.s	Obj03_BackgroundColor

		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject		; if object is not on screen, delete it
		bsr	DisplaySprite		; display sprite
		rts				; return
; ===========================================================================

Obj03_BackgroundColor:
		moveq	#$000,d1		; set default BG color to black
	
		moveq	#0,d0			; clear d0
		move.b	($FFFFF700).w,d0	; get upper X camera position (1 unit = $100 pixels)
		subi.b	#2,d0
		bpl.s	@chktutsign
		move.w	#$444,d1		; set color for options sign
		bra.s	@applybgcolor
	
	@chktutsign:
		subi.b	#3,d0
		bmi.s	@applybgcolor
		cmpi.b	#$13-5,d0
		bhs.s	@applybgcolor
		andi.b	#$0E,d0
		move.w	Obj03_BG(pc,d0.w),d1
		andi.w	#$0EEE,d1
@applybgcolor:
		move.w	d1,d0		; base color

		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		bne.s	@doflash		; if yes, branch
		move.w	#$888,d1		; mask
		bsr.w	Pal_LimitColor
		bra.s	@apply

@doflash:
		moveq	#0,d1
		move.w	($FFFFFE0E).w,d2
		btst	#5,d2
		beq.s	@getmask
		lsr.w	#1,d2
		andi.w	#$1E,d2
		move.w	d2,d1
@getmask:
		move.w	Obj03_BGMask(pc,d1.w),d1	; mask
		bsr.w	Pal_LimitColor

@apply:
		move.w	d3,($FFFFFB5E).w	; apply color (color 16 of palette row 3)
		rts
; ---------------------------------------------------------------------------
Obj03_BG:
		dc.w	$2E4	; GHP
		dc.w	$E2E	; SP
		dc.w	$02E	; RP
		dc.w	$EA2	; LP
		dc.w	$E2A	; UP
		dc.w	$E24	; SAP
		dc.w	$000	; FP
		dc.w	$0E4	; options menu
		even
; ---------------------------------------------------------------------------
Obj03_BGMask:
		dc.w	$A88
		dc.w	$866
		dc.w	$A88
		dc.w	$866
		dc.w	$A88
		dc.w	$866
		
		dc.w	$A88
		dc.w	$866
		dc.w	$A88
		dc.w	$866
		dc.w	$A88
		dc.w	$866
		dc.w	$A88
		dc.w	$866

		dc.w	$644
		dc.w	$866
		
		dc.w	  -1
		even
; ===========================================================================

; Take a color and apply a limit to each individual channel.
; d0 = base color
; d1 = mask color
; out: d3
Pal_LimitColor:
		moveq	#0,d3		; limited color
		
		move.w	d1,d4		; copy mask color
		andi.w	#$00E,d4	; limit mask color
		move.w	d0,d5		; copy theme color
		andi.w	#$00E,d5
		cmp.w	d5,d4
		bls.s	@0
		move.w	d5,d4
@0		or.w	d4,d3

		move.w	d1,d4		; copy mask color
		andi.w	#$0E0,d4	; limit mask color
		move.w	d0,d5		; copy theme color
		andi.w	#$0E0,d5
		cmp.w	d5,d4
		bls.s	@1
		move.w	d5,d4
@1		or.w	d4,d3

		move.w	d1,d4		; copy mask color
		andi.w	#$E00,d4	; limit mask color
		move.w	d0,d5		; copy theme color
		andi.w	#$E00,d5
		cmp.w	d5,d4
		bls.s	@2
		move.w	d5,d4
@2		or.w	d4,d3
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - Level Signs
; ---------------------------------------------------------------------------
Map_Obj03:
		include	"_maps\LevelSigns.asm"

; ---------------------------------------------------------------------------
; ===========================================================================


; For Obj04 see Screens\ChapterScreens\ChapterScreen.asm

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 06 - Hard Part Skippers / Info Boxes in the Tutorial Level
; ---------------------------------------------------------------------------

Obj06:
		moveq	#0,d0			; clear d0
		move.b	obRoutine(a0),d0	; move routine counter to d0
		move.w	Obj06_Index(pc,d0.w),d1 ; move the index to d1
		jmp	Obj06_Index(pc,d1.w)	; find out the current position in the index
; ===========================================================================
Obj06_Index:	dc.w Obj06_Setup-Obj06_Index	; Set up the object (art etc.)	[$0]
		dc.w Obj06_ChkDist-Obj06_Index	; Check distance		[$2]
		dc.w Obj06_InfoBox-Obj06_Index	; Info Boxes for Tutorial Level	[$4]
; ===========================================================================

Obj06_Setup:
		addq.b	#2,obRoutine(a0)		; set to "Obj06_Display"
		move.l	#Map_Obj06,obMap(a0)		; load mappings
		move.b	#4,obPriority(a0)		; set priority
		move.b	#4,obRender(a0)			; set render flag
		move.b	#$56,obActWid(a0)		; set display width

		move.w	#$049B,obGfx(a0)		; set art pointer, use palette line 1
		cmpi.w	#$000,($FFFFFE10).w		; is level Night Hill Place?
		beq.s	Obj06_ArtLocFound		; if yes, branch

		move.w	#$04FF,obGfx(a0)		; set art pointer, use palette line 1
		cmpi.w	#$200,($FFFFFE10).w		; is level Ruined Place?
		beq.s	Obj06_ArtLocFound		; if yes, branch

		move.w	#$04A6,obGfx(a0)		; set art pointer, use palette line 1
		cmpi.w	#$101,($FFFFFE10).w		; is level Labyrinthy Place?
		beq.s	Obj06_ArtLocFound

		move.w	#$0490,obGfx(a0)		; set art pointer, use palette line 1
		cmpi.w	#$302,($FFFFFE10).w		; is level Star Agony Place?
		beq.s	Obj06_ArtLocFound		; if yes, branch

		move.w	#$0360,obGfx(a0)		; set art pointer, use palette line 1
		cmpi.b	#5,($FFFFFE10).w		; is this the tutorial or FP?
		beq.s	Obj06_ArtLocFound		; if yes, branch

		move.w	#$0372,obGfx(a0)		; fallback pointer

Obj06_ArtLocFound:
		move.b	#0,$30(a0)
		tst.b	obSubtype(a0)			; is the subtype 0?
		beq.s	Obj06_ChkDist			; if yes, that means it's a regular hard part skipper, so branch
		move.b	#4,obRoutine(a0)		; otherwise it's a tutorial box
		move.b	#1,obFrame(a0)
		bra.w	Obj06_InfoBox

Obj06_ChkDist:
		clr.b	($FFFFFF74).w		; clear spindash block flag
		move.w	($FFFFD008).w,d0	; get Sonic's X-pos
		sub.w	obX(a0),d0		; substract the X-pos from the current object from it
		addi.w	#$10,d0			; add $10 to it
		cmpi.w	#$20,d0			; is Sonic within $10 pixels of that object?
		bhi.w	Obj06_Display		; if not, branch
		move.w	($FFFFD00C).w,d0	; get Sonic's X-pos
		sub.w	obY(a0),d0		; substract the X-pos from the current object from it
		addi.w	#$10,d0			; add $10 to it
		cmpi.w	#$20,d0			; is Sonic within $10 pixels of that object?
		bhi.w	Obj06_Display		; if not, branch
		move.b	#1,($FFFFFF74).w	; set spindash block flag

		tst.b	($FFFFFFB1).w		; is white flash counter empty?
		bpl.w	Obj06_Display		; if not, branch (to prevent the white getting stuck)

		moveq	#0,d0
		move.b	($FFFFF602).w,d0	; get held button presses
		eori.b	#$42,d0			; sort out anything but Down and A
		bne.w	Obj06_Display		; all buttons pressed? if not, branch
		
Obj06_DoHardPartSkip:
		frantic				; are we in Frantic mode?
		beq.s	@notfrantic		; if not, branch
		jsr	SingleObjLoad2
		bne.w	@noobjectleft
		move.b	#$3F,(a1)		; load singular explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#0,$31(a1)
		ori.b	#10,(CameraShake).w
@noobjectleft:	jsr	DeleteObject		; delete Hard Part Skipper
		move.w	#$8F,d0			; play game over jingle
		jsr	PlaySound
		jmp	KillSonic_Inhuman	; get trolled

@notfrantic:
		jsr	FakeLevelID		; get level ID
		lsl.w	#2,d5			; multiply it by 4
		lea	(Obj06_Locations).l,a1	; get location
		adda.w	d5,a1			; add result to it
		move.w	0(a1),($FFFFD008).w	; move X-pos to Sonic's one
		move.w	obGfx(a1),($FFFFD00C).w	; move Y-pos to Sonic's one
		clr.w	($FFFFD010).w		; clear Sonic's X-speed
		clr.w	($FFFFD012).w		; clear Sonic's Y-speed
		clr.w	($FFFFD014).w		; clear Sonic's interia
		clr.l	($FFFFF602).w		; clear inputs

		cmpi.w	#$101,($FFFFFE10).w	; are we in LP?
		bne.s	@notlp			; if not, branch
		move.b	#1,($FFFFFFFE).w	; make sure =P monitor is enabled
		move.b	#3,($FFFFFF97).w	; set to final checkpoint

@notlp:
		cmpi.w	#$302,($FFFFFE10).w	; are we in Star Agony Place?
		bne.w	@notsap			; if not, branch		
		move.b	#1,($FFFFFF77).w	; enable antigrav
		move.b	#$96,d0			; play music
		jsr	PlaySound
		jsr	SAP_LoadSonicPal	; load Sonic's antigrav palette

@notsap:
		clr.w	($FFFFFE20).w		; delete all your rings you cheating bastard
		ori.b	#1,($FFFFFE1D).w	; update ring counter
		move.w	#$C3,d0			; set giant ring sound
		jsr	PlaySound_Special	; play it
		tst.b	($FFFFFFE7).w		; is Sonic in Inhuman Mode?
		beq.s	@notinhuman		; if not, branch
		cmpi.w	#$502,($FFFFFE10).w	; is this FP?
		beq.s	@notinhuman		; if yes, you get to keep your toy
		clr.b	($FFFFFFE7).w		; disable Inhuman Mode
		move.w	d7,-(sp)		; back up d7
		moveq	#3,d0			; load Sonic's palette
		jsr	PalLoad2		; restore sonic's palette
		move.w	(sp)+,d7		; restore d7

@notinhuman:
		jsr	WhiteFlash2		; make a white flash
		move.b	#1,(RedrawEverything).w	; redraw screen after teleportation

Obj06_Display:
		jmp	MarkObjGone

; ---------------------------------------------------------------------------

Obj06_Locations:	;XXXX   YYYY
		dc.w	$18EA, $036C	; Night Hill Place
		dc.w	$FFFF, $FFFF	; Green Hill Place	(Unused)
		dc.w	$FFFF, $FFFF	; Special Place		(Unused)
		dc.w	$1E10, $02B0	; Ruined Place
		dc.w	$0D2F, $05A7	; Labyrinthy Place
		dc.w	$FFFF, $FFFF	; Unreal Place		(Unused)
		dc.w	$FFFF, $FFFF	; Scar Night Place 	(Unused)
		dc.w	$101E, $036C	; Finalor Place
		dc.w	$FFFF, $FFFF	; Uberhub Place		(Unused)
		dc.w	$101E, $036C	; Tutorial Place
		dc.w	$1F00, $06E0	; Star Agony Place
; ===========================================================================
; ---------------------------------------------------------------------------
; Tutorial boxes
; ---------------------------------------------------------------------------

Obj06_InfoBox:
		tst.b	($FFFFFF77).w		; is antigrav enabled?
		bne.s	@allowairborne		; if yes, branch
		btst	#1,($FFFFD022).w	; is Sonic airborne?
		bne.w	Obj06_NoA		; if yes, disallow interaction
@allowairborne:
		move.b	#2,obFrame(a0)		; show A button
		move.w	($FFFFD008).w,d0	; get Sonic's X-pos
		sub.w	obX(a0),d0		; substract the X-pos from the current object from it
		addi.w	#$20,d0			; add $10 to it
		cmpi.w	#$40,d0			; is Sonic within $40 pixels of that object?
		bhi.w	Obj06_NoA		; if not, branch
		move.w	($FFFFD00C).w,d0	; get Sonic's X-pos
		sub.w	obY(a0),d0		; substract the X-pos from the current object from it
		addi.w	#$20,d0			; add $10 to it
		cmpi.w	#$40,d0			; is Sonic within $40 pixels of that object?
		bhi.w	Obj06_NoA		; if not, branch

Obj06_ChkA:
		move.b	($FFFFF603).w,d0	; is A pressed? (part 1)
		andi.b	#$40,d0			; is A pressed? (part 2)
		beq.s	Obj06_Display		; if not, branch
		
		clr.b	($FFFFF603).w		; clear controller 1 bitfield (to prevent rare softlocks)
		move.b	#1,obFrame(a0)		; don't show A button while tutorial box is visible

		moveq	#$FFFFFFD9,d0		; VLADIK => Optimized (couldn't resist =D)
		jsr	PlaySound		; play up/down sound
		
		cmpi.w	#$400,($FFFFFE10).w	; is level Uberhub?
		bne.s	@notuberhubeasteregg	; if not, branch
		bsr	UberhubEasteregg	; ruin everything

@notuberhubeasteregg:
		jsr	DisplaySprite		; VLADIK => Make sure sprite is displayed
		move.b	obSubtype(a0),d0	; VLADIK => Load hint number based on subtype

		tst.b	(FZEscape).w		; are we in the FZ escape sequence?
		beq.s	@displayhint		; if not, branch
		cmpi.b	#1,d0			; is this the first text box?
		beq.s	@first			; if yes, branch
		cmpi.b	#$B,d0			; is this the last text box?
		beq.s	@lasteaster		; if yes, branch
		move.b	#$3F,(a0)		; blow up the tutorial box
		move.b	#0,$31(a0)
		clr.b	obRoutine(a0)		; make sure it's set to the init routine
		rts				; don't do anything else here
	@first:
		move.b	#5,d0			; show alternate text for first monitor
		bra.s	@displayhint		; display hint
	@lasteaster:
		move.b	#$E,d0			; show alternate text for last monitor
		
@displayhint:
		jmp	Tutorial_DisplayHint	; VLADIK => Display hint

Obj06_NoA:
		move.b	#1,obFrame(a0)		; don't show A button
		bra.w	Obj06_Display
; ===========================================================================

Map_Obj06:
		include	"_maps\HardPartSkipper.asm"

; ---------------------------------------------------------------------------
; ===========================================================================

UberhubEasteregg:
		lea	($FFFFFB00).w,a1
		moveq	#(64/2)-1,d2
@loopdestroypalette:
		jsr	RandomNumber
		move.l	#$E0,d3
		tst.l	d0
		bmi.s	@0
		lsl.l	#4,d3
@0:		and.w	d3,d0
		move.w	d0,(a1)+
		and.w	d3,d1
		move.w	d1,(a1)+
		dbf	d2,@loopdestroypalette
		
		move.w	#$000,($FFFFFB24).w
		move.w	#$020,($FFFFFB26).w
		move.w	#$040,($FFFFFB28).w
		move.w	#$060,($FFFFFB2A).w
		move.w	#$080,($FFFFFB2C).w
		move.w	#$0A0,($FFFFFB2E).w
		move.w	#$0C0,($FFFFFB30).w
		move.w	#$0E0,($FFFFFB32).w
		move.w	#$0E0,($FFFFFB34).w
		
		clr.w	($FFFFFB36).w
		move.w	#$0EEE,($FFFFFB38).w
		move.w	#$0CCC,($FFFFFB3A).w
		move.w	#$0AAA,($FFFFFB3C).w
		
		lea	($FFFFFB40).w,a1
		jsr	SineWavePalette
		moveq	#$FFFFFF88,d0		; play special stage jingle...
		jmp	PlaySound		; ...specifically because it tends to ruin the music following it lol

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 07 - ok cool. (used to be the old cropped screen sprites)
; ---------------------------------------------------------------------------

Obj07:
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj07_Index(pc,d0.w),d1
		jmp	Obj07_Index(pc,d1.w)
; ===========================================================================
Obj07_Index:	dc.w Obj07_Init-Obj07_Index
		dc.w Obj07_Animate-Obj07_Index
; ===========================================================================

Obj07_Init:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_Obj07,obMap(a0)
		move.b	#$94,obRender(a0)
		move.b	#$20,obActWid(a0)
		move.b	#0,obPriority(a0)
		move.b	#$40,obHeight(a0)
		move.b	#$60,obWidth(a0)

		; used for the sway
		move.w	obY(a0),$32(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsl.w	#4,d0
		move.w	d0,$34(a0)

		; gfx setup (wildly different per level)
		move.w	($FFFFFE10).w,d0
		move.w	#$9600/$20,obGfx(a0)
		cmpi.w	#$200,d0
		bne.s	@notrp
		move.w	#$6A00/$20,obGfx(a0)
@notrp:		cmpi.w	#$101,d0
		bne.s	@notlp
		move.w	#$9800/$20,obGfx(a0)
@notlp:		cmpi.w	#$302,d0
		bne.s	@notsap
		move.w	#$6600/$20,obGfx(a0)
@notsap:	cmpi.w	#$601,d0
		bne.s	@notend
		move.w	#$BA00/$20,obGfx(a0)
@notend:	cmpi.w	#$400,d0
		bne.s	Obj07_Animate
		move.w	#$8800/$20,obGfx(a0)
; ---------------------------------------------------------------------------

Obj07_Animate:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	DeleteObject

		bsr	Obj07_CheckVisible
		bne.s	@dodisplay
		rts

@dodisplay:
		move.w	($FFFFFE04).w,d0
		add.w	d0,d0
		add.w	$34(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$32(a0),d0
		move.w	d0,obY(a0)

		jmp	DisplaySprite
; ===========================================================================

Obj07_CheckVisible:
		move.w	($FFFFFE10).w,d0	; get level ID
		beq.s	@yes			; are we in NHP? if yes, always display
		cmpi.w	#$400,d0		; are we in Uberhub?
		beq.s	@yes			; if yes, branch
		cmpi.w	#$601,d0		; are we in the ending sequence?
		beq.s	@yes			; if yes, branch
		cmpi.w	#$002,d0		; are we in GHP?
		bne.s	@notghp			; if not, branch
		cmpi.b	#4,($FFFFFE30).w	; did we hit the fourth checkpoint yet?
		beq.s	@yes			; if yes, swag
		bra.s	@no			; not swag
@notghp:
		cmpi.w	#$200,d0		; are we in RP?
		bne.s	@notrp			; if not, branch
		tst.b	($FFFFFF73).w		; P monitor broken?
		bne.s	@yes			; if yes, swag
		bra.s	@no			; not swag
@notrp:
		cmpi.w	#$101,d0		; are we in LP?
		bne.s	@notlp			; if not, branch
		tst.b	($FFFFFF73).w		; eggman monitor broken?
		bne.s	@yes			; lol
		bra.s	@no			; not swag
@notlp:
		cmpi.w	#$302,d0		; are we in SAP?
		bne.s	@notsap			; if not, branch
		tst.b	($FFFFFFE1).w		; P monitor broken?
		bne.s	@yes			; swag
		bra.s	@no			; not swag
@notsap:
		bra.s	@no			; fallback
		
; ---------------------------------------------------------------------------
@yes:		moveq	#-1,d0
		rts
@no:		moveq	#0,d0
		rts
; ---------------------------------------------------------------------------
; ===========================================================================

Map_Obj07:
		include	"_maps\okcool.asm"


; ===========================================================================
; ---------------------------------------------------------------------------
; Afterimage creating routine
; ---------------------------------------------------------------------------

AfterImage:
		tst.b	($FFFFFFAC).w		; is Sonic dying?
		bne.w	After_Return		; if yes, branch
		cmpi.b	#$18,($FFFFF600).w	; is this the ending sequence?
		beq.s	After_DoAfter		; if yes, branch
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		bne.w	After_DoAfter		; if yes, branch
		tst.b	($FFFFFFAD).w		; is Sonic performing a jumpdash or is on a spring?
		bne.w	After_DoAfter		; if yes, branch
		tst.b	($FFFFFF77).w
		beq.s	@cont
		btst	#1,obStatus(a0)
		bne.s	After_DoAfter

@cont:
		moveq	#0,d0			; clear d0
		move.w	obVelX(a0),d0		; move X-speed to d0
		bpl.s	After_X_Positive	; if speed is positive, branch
		neg.w	d0			; otherwise, negate it

After_X_Positive:
		cmpi.w	#$600,d0		; is X-speed at least $600?
		bge.s	After_DoAfter		; if yes, branch
		
		move.w	obVelY(a0),d0		; move Y-speed to d0
		bpl.s	After_Y_Positive	; if speed is positive, branch
		neg.w	d0			; otherwise, negate it

After_Y_Positive:
		cmpi.w	#$600,d0		; is Y-speed at least $600?
		bge.s	After_DoAfter		; if yes, branch
		bra.s	After_Return		; if the X and Y are too little, don't do afterimage
		nop				; in case you are enabling it constantly, we need this
; ===========================================================================

After_DoAfter:
		bsr	SingleObjLoad		; load from SingleObjLoad
		bne.s	After_Return		; if SingleObjLoad is already in use, don't do afterimage
		move.b	#$19,0(a1)		; load Afterimage object
		move.w	obX(a0),obX(a1)		; set X-position to Sonic's
		move.w	obY(a0),obY(a1)		; set Y-position to Sonic's
		move.b	#1,$30(a1)		; make the fading out "better"
		move.b	#3,obPriority(a1)		; set sprite priority to low plane

After_Return:
		rts				; return

; End of function Afterimage
; ===========================================================================

; ---------------------------------------------------------------------------
; Object 01 - Sonic
; ---------------------------------------------------------------------------

Obj01:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj01_Normal	; if not, branch
		jmp	DebugMode
; ===========================================================================

Obj01_Normal:
		tst.w	($FFFFFFFA).w	; is debug cheat enabled?
		beq.s	Obj01_NoDebug	; if not, branch
		btst	#4,($FFFFF605).w ; is button B pressed?
		beq.s	Obj01_NoDebug	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Sonic	into a ring/item
		clr.b	($FFFFF7CC).w
		cmpi.b	#6,obRoutine(a0)
		bne.s	Obj01_RoutineNotDeath
		movem.l	d3-a1,-(sp)
		lea	($FFFFFB20).w,a0	; get palette
		lea	($FFFFC910+$80).w,a1 	; get backup up palette
		move.w	#$002F,d3		; set d3 to $3F (+1 for the first run)

Pal_RTN_LoopXXX:
		move.w	(a1)+,(a0)+		; set new palette
		dbf	d3,Pal_RTN_LoopXXX	; loop for each colour
		movem.l	(sp)+,d3-a1
		clr.b	($FFFFFFAC).w
		move.w	#$0090,($FFFFD048).w
		move.w	#$0108,($FFFFD04A).w
		move.w	#$0108,($FFFFD04C).w

Obj01_RoutineNotDeath:
		move.b	#2,obRoutine(a0)
		clr.w	obVelY(a0)
		rts	

Obj01_NoDebug:
		bsr	AfterImage
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj01_Index(pc,d0.w),d1
		jmp	Obj01_Index(pc,d1.w)
; ===========================================================================
Obj01_Index:	dc.w Obj01_Main-Obj01_Index
		dc.w Obj01_Control-Obj01_Index
		dc.w Obj01_Hurt-Obj01_Index
		dc.w Obj01_Death-Obj01_Index
		dc.w Obj01_ResetLevelX-Obj01_Index
		dc.w Sonic_Drowned-Obj01_Index
; ===========================================================================

Obj01_Main:				; XREF: Obj01_Index
		addq.b	#2,obRoutine(a0)
		move.b	#$13,obHeight(a0)
		move.b	#9,obWidth(a0)
		move.l	#Map_Sonic,obMap(a0)
		move.w	#$780,obGfx(a0)
		move.b	#2,obPriority(a0)
		move.b	#$18,obActWid(a0)
		move.b	#4,obRender(a0)

		cmpi.b	#$0,($FFFFFE10).w
		bne.s	Obj01_M_NotGHZ2
		cmpi.w	#$002,($FFFFFE10).w
		beq.s	Obj01_M_NotGHZ2
		bset	#2,obStatus(a0)
		move.b	#2,obAnim(a0)

Obj01_M_NotGHZ2:
		cmpi.w	#$601,($FFFFFE10).w	; is this the ending sequence?
		beq.s	Obj01_EndingSpeed	; if yes, use different speed
		cmpi.w	#$001,($FFFFFE10).w	; is this the intro sequence?
		beq.s	SetIntroSpeeds		; if yes, use different speeds
		
		; default speeds
		move.w	#Sonic_TopSpeed,($FFFFF760).w 	; Sonic's top speed
		move.w	#Sonic_Acceleration,($FFFFF762).w	; Sonic's acceleration
		move.w	#Sonic_Deceleration,($FFFFF764).w	; Sonic's deceleration
		bra.s	Obj01_Speedcont		; skip
; ===========================================================================

SetIntroSpeeds:
		move.w	#$800,($FFFFF760).w 	; Sonic's top speed
		move.w	#$D,($FFFFF762).w	; Sonic's acceleration
		move.w	#$80,($FFFFF764).w	; Sonic's deceleration
		bra.s	Obj01_Speedcont

SetEndingSpeeds:
		; custom speed values to get the timing on the cliff gag right
		move.w	#$600,($FFFFF760).w	; Sonic's top speed (ending sequence)
		move.w	#$C,($FFFFF762).w	; Sonic's acceleration (ending sequence)
		move.w	#$30,($FFFFF764).w	; Sonic's deceleration (ending sequence)
		rts

Obj01_EndingSpeed:
		bsr.s	SetEndingSpeeds

Obj01_Speedcont:
		move.b	#5,($FFFFD1C0).w	; set up spindash object
		bra.s	Obj01_Control

; ===========================================================================
Obj01_Modes:	dc.w Obj01_MdNormal-Obj01_Modes	; neither jumping, rolling, or airborne
		dc.w Obj01_MdJump-Obj01_Modes	; airborne but not by a manual jump
		dc.w Obj01_MdRoll-Obj01_Modes	; rolling on the ground
		dc.w Obj01_MdJump2-Obj01_Modes	; airborne as a result of a manual jump
; ===========================================================================

Obj01_Control:
		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.s	loc_12C64	; if yes, branch
		move.w	($FFFFF604).w,($FFFFF602).w ; enable joypad control

loc_12C64:
		btst	#0,($FFFFF7C8).w ; are controls	locked?
		bne.s	loc_12C7E	; if yes, branch
		moveq	#0,d0
		move.b	obStatus(a0),d0
		andi.w	#%0110,d0			; only look at bit 1 (airborne flag) and 2 (jumping/rolling flag)
		move.w	Obj01_Modes(pc,d0.w),d1
		jsr	obj01_Modes(pc,d1.w)

loc_12C7E:
		bsr.w	Sonic_Display
		bsr	Sonic_RecordPos
		bsr	Sonic_Water
		move.b	($FFFFF768).w,$36(a0)
		move.b	($FFFFF76A).w,$37(a0)
		tst.b	($FFFFF7C7).w
		beq.s	Obj01_Cutscenes
		tst.b	obAnim(a0)
		bne.s	Obj01_Cutscenes
		move.b	obNextAni(a0),obAnim(a0)

; =========== The big routine of Cutscenes =============
Obj01_Cutscenes:				; Intro of GHZ1
		cmpi.w	#$000,($FFFFFE10).w		; is level GHZ1?
		bne.s	Obj01_NotGHZ1_Main		; if not, branch
		tst.b	($FFFFFFBB).w			; has flag "camera reached $0B00" been set?
		bne.s	Obj01_Not0B00			; if yes, branch
		bclr	#0,obStatus(a0)
		move.b	#1,($FFFFF7CC).w		; lock controls
		bset	#1,($FFFFF602).w		; force down press
		cmpi.w	#$0B00,($FFFFF700).w		; has the camera reached $0B00 on x-axis?
		bcs.s	Obj01_Not0B00			; if not, branch
		move.b	#1,($FFFFFFBB).w		; set this flag
		move.b	#0,($FFFFF7CC).w		; unlock controls
		bclr	#1,($FFFFF602).w		; cancel down press

Obj01_Not0B00:
		tst.b	($FFFFFFA9).w			; has crabmeat boss flag 1 been set?
		beq.s	Obj01_NotGHZ1_Main		; if not, branch
		tst.b	($FFFFFFAA).w			; has crabmeat boss flag 2 been set?
		bne.s	Obj01_NotGHZ1_Main		; if yes, branch
	;	cmpi.w	#$2180,($FFFFF700).w		; has the camera reached $2180 on x-axis?
		cmpi.w	#$2224,($FFFFD008).w		; has Sonic reached position $2224 on x-axis?
		bcs.s	Obj01_NotGHZ1_Main		; if not, branch
	;	move.w	#$2185,($FFFFF728).w
		clr.l	($FFFFF602).w			; cancel any presses
		clr.w	obVelX(a0)				; clear X-speed
		clr.w	obInertia(a0)				; clear interia
		move.b	#1,($FFFFFFAB).w		; set crabmeat boss flag 3
; ===========================================================================
; ===========================================================================

Obj01_NotGHZ1_Main:				; Intro Cutscene of GHZ2
		cmpi.w	#$001,($FFFFFE10).w		; is this GHZ2 (intro level)?
		bne.w	Obj01_Control_Cont 		; if not, branch
		bclr	#0,obStatus(a0)			; make Sonic facing right
		cmpi.w	#$1BB7,obX(a0)			; has Sonic passed point $1BB7?
		blt.s	Obj01_Not1BB7 			; if not, branch
		tst.b	($FFFFFFB7).w			; was flag 1 set? 
		bne.s	Obj01_Not1BB7			; if yes, branch
		move.b	#1,($FFFFFFB7).w		; set flag one (unused, this is a placeholder)
		
Obj01_Not1BB7:
		cmpi.w	#$1770,obX(a0)			; has Sonic passed point $1770?
		blt.s	Obj01_Not1770			; if not, branch
		tst.b	($FFFFFFB6).w			; was flag 2 set?
		bne.s	Obj01_Not1770			; if yes, branch
		move.b	#$40,($FFFFF603).w		; force A press

Obj01_Not1770:
		cmpi.w	#$0EAF,obX(a0)			; has Sonic passed point $0EAF?
		bge.s	Obj01_DoRightPress 		; if yes, branch (press right again)
		cmpi.w	#$0C4D,obX(a0)			; has Sonic passed point $0C4D?
		bge.s	Obj01_CancelRight		; if yes, branch (stop pressing right)

Obj01_DoRightPress:
		move.w	#$900,obVelX(a0)			; set Sonic's speed
		move.b	#1,($FFFFF7CC).w		; lock controls
		bset	#3,($FFFFF602).w		; force right press
		bra.s	Obj01_Control_Cont		; skip
; ===========================================================================

Obj01_CancelRight:
		bclr	#3,($FFFFF602).w		; clear right press
; ===========================================================================
; ===========================================================================

Obj01_Control_Cont:				; Simulated Peelout
		tst.b	($FFFFFF98).w			; is the simulated peelout cancel flag set?
		bne.s	Obj01_PeeloutCancel		; if yes, branch
		tst.b	($FFFFF602).w			; is anything pressed during the charging?
		beq.s	Obj01_PeeloutCancel		; if not, branch
		move.b	#2,($FFFFFF98).w		; if yes, set flag to 2
		clr.b	($FFFFFFAF).w			; clear automatic extended camera flag
		tst.b	($FFFFF603).w			; check controller again
		beq.s	Obj01_PeeloutCancel		; if nothing is pressed, branch
		bsr	Sonic_Jump			; perform a jump

Obj01_PeeloutCancel:
		tst.b	($FFFFFE30).w			; are we restarting from a checkpoint?
		bne.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$601,($FFFFFE10).w		; is this the ending sequence?
		beq.w	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$000,($FFFFFE10).w		; is level GHZ1?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$001,($FFFFFE10).w		; is level GHZ2?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$400,($FFFFFE10).w		; is level SYZ1?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$200,($FFFFFE10).w		; is level MZ1?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$101,($FFFFFE10).w		; is level LZ2?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$302,($FFFFFE10).w		; is level SLZ3?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.w	#$501,($FFFFFE10).w		; is level SBZ2?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.b	#2,($FFFFFFD3).w		; was flag in "Obj01_CancelIntroPO" set?
		beq.s	Obj01_EndOfCutscenesX		; if yes, branch
		cmpi.b	#1,($FFFFFFD3).w		; is title card off-screen?
		beq.s	Obj01_CancelIntroPO		; if yes, branch
		tst.b	($FFFFFF98).w
		bne.s	Obj01_EndOfCutscenesX

Obj01_SimulatedPeelout:					; simulate peelout if all the stuff above got passed
		bclr	#0,obStatus(a0)			; make sonic facing right
		move.b	#1,($FFFFFF99).w
	;	bset	#0,($FFFFF602).w		; force up press
	;	bclr	#1,($FFFFF602).w		; cancel any down presses
	;	bclr	#2,($FFFFF602).w		; cancel any left presses
	;	bclr	#3,($FFFFF602).w		; cancel any right presses
	;	move.b	#1,($FFFFF7CC).w		; lock controls
	;	move.b	#$40,($FFFFF603).w		; force A press
		bra.s	Obj01_EndOfCutscenes		; skip
; ===========================================================================

Obj01_CancelIntroPO:
		move.b	#2,($FFFFFFD3).w		; set title card off-screen flag to 2
		move.b	#1,($FFFFFF98).w
		move.b	#0,($FFFFF7CC).w		; unlock controls
	;	move.b	#$00,($FFFFF603).w		; cancel A press
	;	bclr	#0,($FFFFF602).w		; cancel up press
; ===================== Ends here ======================

Obj01_EndOfCutscenesX:
		move.b	#1,($FFFFFF98).w
		move.b	#1,($FFFFFF99).w

Obj01_EndOfCutscenes:
		bsr	Sonic_Animate
		tst.b	($FFFFF7C8).w
		bmi.s	loc_12CB6
		jsr	TouchResponse

loc_12CB6:
		bsr	Sonic_Loops
		bsr	LoadSonicDynPLC
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to display Sonic and do a shitload of functions
; ---------------------------------------------------------------------------

Sonic_Display:				; XREF: loc_12C7E
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.w	S_D_NoTeleport		; if not, branch

		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		bne.w	S_D_NoTeleport		; if yes, branch

		cmpi.w	#$1BB0,obX(a0)		; is Sonic past the X-location $1BB0?
		bpl.w	S_D_NoTeleport		; if yes, branch
		cmpi.w	#$1340,obX(a0)		; is Sonic before the X-location $1340?
		bmi.w	S_D_NoTeleport		; if yes, branch

		cmpi.w	#$4E0,obY(a0)		; is Sonic above the Y-location $3E0?
		bmi.s	S_D_NoTeleport		; if yes, branch

		clr.b	($FFFFFE2C).w		; remove any shields

		frantic				; is frantic mode enabled?
		beq.s	@notfrantic		; if not, don't do ring penalties
		cmpi.w	#10,($FFFFFE20).w	; do you have at least 10 rings?
		bhs.s	@enough			; if yes, branch
		move.b	#1,($FFFFFF95).w	; make Sonic die
		move.w	($FFFFFE20).w,(FranticDrain).w ; drain whatever rings remain
		bra.s	S_D_NoTeleport		; skip

@enough:
		move.w	#$12A0,obX(a0)		; set new location for Sonic's X-pos
		move.w	#$21A,obY(a0)		; set new location for Sonic's Y-pos
		addi.w	#10,(FranticDrain).w	; add 10 rings to be drained
		bra.s	@teleportend		; skip

@notfrantic:
		move.w	#$12A0,obX(a0)		; set new location for Sonic's X-pos
		move.w	#$21A,obY(a0)		; set new location for Sonic's Y-pos
@teleportend:
		move.w	#$C3,d0			; set giant ring sound
		jsr	PlaySound_Special	; set giant ring sound
		bsr	WhiteFlash2		; make a white flash
		move.b	#1,(RedrawEverything).w	; redraw screen after teleportation
; ===========================================================================

S_D_NoTeleport:
		tst.b	($FFFFFFAE).w		; is WF2 flag set?
		bne.s	S_D_WF2			; if yes, branch
		tst.b	($FFFFFFB2).w		; is jumpdash flag 2 set?
		beq.s	S_D_NoInhumanCrush	; if not, branch

S_D_WF2:
		tst.b	($FFFFFFB1).w		; is white flash counter empty?
		beq.s	S_D_NoInhumanCrush	; if yes, branch
		subq.b	#1,($FFFFFFB1).w	; sub 1 from counter
		bpl.s	S_D_NoInhumanCrush	; is counter now empty? if not, branch
		cmpi.w	#$001,($FFFFFE10).w	; is level GHZ2?
		bne.s	S_D_NotGHZ2_PalX	; if not, branch
		lea	(Pal_GHZ).l,a3		; load GHZ1 palette to a3
		lea	($FFFFFB20).w,a4	; move palette row 3 to a4
		moveq	#0,d5			; make sure d1 is empty
		move.w	#$18,d5			; set loop time ($18 colours)

S_D_GHZ2PalChg_Loop:
		move.l	(a3)+,(a4)+		; set new colour
		dbf	d5,S_D_GHZ2PalChg_Loop	; repeat process for number in d1
		move.w	#$0000,($FFFFFB02).w
		bra.s	S_D_NoInhumanCrush	; skip

S_D_NotGHZ2_PalX:
		jsr	WhiteFlash_Restore
		clr.b	($FFFFFFAE).w		; clear WF2 flag

S_D_NoInhumanCrush:
		cmpi.b	#$10,obAnim(a0)		; is spring animation being showed?
		bne.s	S_D_NoSpring		; if not, branch
		tst.w	obVelY(a0)		; is Y-speed negative (is sonic moving upwards)?
		bmi.s	S_D_NoSpring		; if yes, branch
		move.b	#2,obAnim(a0)		; otherwise change to rolling animation at the apex of the bounce

S_D_NoSpring:
		cmpi.w	#$502,($FFFFFE10).w	; is level FZ?
		bne.s	S_D_NotFZ		; if not, branch
		tst.b	($FFFFFFDB).w		; is max limit empty?
		bmi.s	S_D_TimerEmpty		; if yes, branch
		subq.b	#1,($FFFFFFDB).w	; sub 1 from counter
		bra.s	S_D_NotFZ		; skip

S_D_TimerEmpty:
		move.w	#Sonic_TopSpeed,($FFFFF760).w	; restore Sonic's speed
		move.w	#Sonic_Acceleration,($FFFFF762).w	; restore Sonic's acceleration

S_D_NotFZ:
		cmpi.b	#$0,($FFFFFE10).w	; is zone GHZ?
		bne.s	S_D_NotGHZ2		; if not, branch
		cmpi.w	#$002,($FFFFFE10).w	; is level GHZ3?
		beq.s	S_D_NotGHZ2		; if yes, branch
		
S_D_BA_NotEmpty:
		tst.b	($FFFFFFB8).w		; was flag already set?
		bne.s	S_D_NotGHZ2		; if yes, branch
		btst	#1,obStatus(a0)		; is Sonic on the ground?
		beq.s	S_D_NotGHZ2		; if yes, branch
		move.b	#2,obAnim(a0)		; change Sonic's anim to rolling
		bset	#0,obStatus(a0)		; make sonic facing right

S_D_NotGHZ2:
		; frantic ring drain system
		frantic				; are we in frantic mode?
		beq.s	S_D_AfterImage	 	; if not, branch
		tst.w	(FranticDrain).w	; are any rings left to be drained?
		bls.s	S_D_AfterImage		; if not, branch		
		tst.b	($FFFFD400+$3A).w	; is intro animation for rings HUD finished?
		beq.s	S_D_AfterImage		; if not, branch
		move.w	($FFFFFE04).w,d0	; get level timer
		andi.w	#3,d0			; drain every 4 frames
		bne.s	S_D_AfterImage		; if not on allowed frame, branch

		move.w	(FranticDrain).w,d0	; get currently remaining drain limit
		lsr.w	#3,d0			; divide by 16
		bne.s	@notzero		; if not zero, branch (which means we still have at least 16 rings)
		moveq	#1,d0			; set slowest speed while under 16 rings
@notzero:	sub.w	d0,(FranticDrain).w	; subtract from drain limit
		sub.w	d0,($FFFFFE20).w	; subtract from rings
		bpl.s	@positive		; if still positive, branch
		clr.w	(FranticDrain).w	; skip remaining ring drain, player probably got hurt before it finished
		clr.w	($FFFFFE20).w		; set rings to 0
@positive:
		ori.b	#1,($FFFFFE1D).w	; update rings counter
		move.w	#$A9,d0			; play blip ring sound...
		jsr	(PlaySound_Special).l	; ...to indicate the draining

S_D_AfterImage:	
		move.w	$30(a0),d0
		beq.s	Obj01_Display
		subq.w	#1,$30(a0)
		lsr.w	#3,d0
		bcc.s	Obj01_AfterImage

Obj01_Display:
		bsr	DisplaySprite

; Start of Afterimage setup code
Obj01_AfterImage:
		tst.b	($FFFFFFB1).w
		bmi.s	Obj01_JD_Minus
		subq.b	#1,($FFFFFFB1).w
		
Obj01_JD_Minus:
	;	bsr	AfterImage

; Start of S monitor code
Obj01_ChkS:
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	Obj01_Inhuman		; if not, branch
		move.b	#1,($FFFFFFE7).w 	; enable inhuman mode automatically. have fun, nerd

Obj01_Inhuman:
		tst.b	($FFFFFFE7).w		; is inhuman mode enabled?
		beq.s	Obj01_ChkInvin		; if not, branch	
		move.b	#0,($FFFFFE2C).w	; make sure sonic has no shield
		add.w	#$0100,($FFFFFB04)	; increase Sonic's palette (color 3)
		add.w	#$0100,($FFFFFB06)	; increase Sonic's palette (color 4)
		add.w	#$0100,($FFFFFB08)	; increase Sonic's palette (color 5)
		
		; frantic mode ring drain in RP
		frantic				; are we in frantic?
		beq.s	Obj01_ChkInvin		; if not, branch
		cmpi.w	#$200,($FFFFFE10).w	; are we in RP?
		bne.s	Obj01_ChkInvin		; if not, branch
		btst	#1,($FFFFD022).w	; is sonic airborne?
		bne.s	Obj01_ChkInvin		; if yes, branch
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		bne.s	Obj01_ChkInvin		; if yes, branch

		move.w	($FFFFFE04).w,d0	; get level timer
		andi.w	#3,d0			; subtract a ring every 4 frames
		bne.s	Obj01_ChkInvin		; if not on allowed frame, branch
		ori.b	#1,($FFFFFE1D).w	; update rings counter
		subq.w	#1,($FFFFFE20).w	; subtract 1 ring
		bhi.s	@notdead		; if rings remain, branch
		jmp	KillSonic_Inhuman	; you ran out of rings, hecking die noob
@notdead:
		move.w	#$A9,d0			; play blip ring sound...
		jsr	(PlaySound_Special).l	; ...to indicate the draining
; End of S monitor code

Obj01_ChkInvin:
		tst.b	($FFFFFE2D).w	; does Sonic have invincibility?
		beq.w	Obj01_ChkShoes	; if not, branch	; change to beq.w
		tst.w	$32(a0)		; check	time remaining for invinciblity
		beq.w	Obj01_ChkShoes	; if no	time remains, branch	; change to beq.w
		subq.w	#1,$32(a0)	; subtract 1 from time
		bne.w	Obj01_ChkShoes	; change to bne.w
		tst.b	($FFFFF7AA).w
		bne.w	Obj01_RmvInvin	; change to bne.w
		cmpi.w	#$C,($FFFFFE14).w
		bcs.w	Obj01_RmvInvin	; change to bcs.w
		jsr	PlayLevelMusic	; restart level music

Obj01_RmvInvin:
		move.b	#0,($FFFFFE2D).w ; cancel invincibility
		
Obj01_ChkGoggles:
		tst.b	($FFFFFFE1).w	; has sonic destroyed a goggle monitor?
		beq.w	Obj01_ChkShoes	; if not, branch
		bset	#7,obGfx(a0)	; make sonic being on the foreground
		
Obj01_ChkShoes:
		tst.b	($FFFFFE2E).w	; does Sonic have speed	shoes?
		beq.s	Obj01_ExitChk	; if not, branch
		move.w	#Sonic_TopSpeed_Shoes,($FFFFF760).w ; change Sonic's top speed
		move.w	#Sonic_Acceleration_Shoes,($FFFFF762).w
		move.w	#Sonic_Deceleration_Shoes,($FFFFF764).w
		subq.w	#1,$34(a0)	; subtract 1 from time
		bpl.s	Obj01_ExitChk
		move.w	#0,$34(a0)
		move.w	#Sonic_TopSpeed,($FFFFF760).w		; restore Sonic's speed
		move.w	#Sonic_Acceleration,($FFFFF762).w	; restore Sonic's acceleration
		move.w	#Sonic_Deceleration,($FFFFF764).w	; restore Sonic's deceleration
		clr.b	($FFFFFE2E).w

Obj01_ExitChk:
		rts
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	record Sonic's previous positions for invincibility stars
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RecordPos:			; XREF: loc_12C7E; Obj01_Hurt; Obj01_Death
		move.w	($FFFFF7A8).w,d0
		lea	($FFFFCB00).w,a1
		lea	(a1,d0.w),a1
		move.w	obX(a0),(a1)+
		move.w	obY(a0),(a1)+
		addq.b	#4,($FFFFF7A9).w
		rts	
; End of function Sonic_RecordPos

; ---------------------------------------------------------------------------
; Subroutine for Sonic when he's underwater
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Water:				; XREF: loc_12C7E
		cmpi.b	#1,($FFFFFE10).w ; is level LZ?
		beq.s	Obj01_InWater	; if yes, branch

locret_12D80:
		rts	
; ===========================================================================

Obj01_InWater:
		move.w	($FFFFF646).w,d0
		cmp.w	obY(a0),d0	; is Sonic above the water?
		bge.s	Obj01_OutWater	; if yes, branch
		bset	#6,obStatus(a0)
		bne.s	locret_12D80
	;	bsr	ResumeMusic
		move.b	#$A,($FFFFD340).w ; load bubbles object	from Sonic's mouth
		move.b	#$81,($FFFFD368).w

		tst.b 	($FFFFFFF9).w		; is flooding section happening?
		beq.s 	@noflood		; if not, branch
		tst.b	($FFFFFFA5).w		; was sign post already touched?
		bne.s	@noflood		; if yes, branch

		move.w	#$D,($FFFFFE14).w	; slightly more lenient time for casual
		frantic				; are we in frantic?
		beq.s	@noflood		; if not, branch
		move.w	#$B,($FFFFFE14).w	; force instant countdown when final thingy
		move.w	#$92,d0
		jsr	(PlaySound).l		; play countdown music immediately
		
@noflood:
		move.w	#Sonic_TopSpeed_Water,($FFFFF760).w	; change Sonic's top speed
		move.w	#Sonic_Acceleration_Water,($FFFFF762).w	; change Sonic's acceleration
		move.w	#Sonic_Deceleration_Water,($FFFFF764).w	; change Sonic's deceleration
		asr	obVelX(a0)
		asr	obVelY(a0)
		asr	obVelY(a0)
		beq.s	locret_12D80

		move.b	#8,($FFFFD300).w ; load	splash object
		move.w	#$AA,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; ===========================================================================

Obj01_OutWater:
		bclr	#6,obStatus(a0)
		beq.w	locret_12D80
		tst.b	($FFFFFFF9).w
		bne.s	@noresumemusic
		bsr	ResumeMusic
@noresumemusic:
		move.w	#Sonic_TopSpeed,($FFFFF760).w		; restore Sonic's speed
		move.w	#Sonic_Acceleration,($FFFFF762).w	; restore Sonic's acceleration
		move.w	#Sonic_Deceleration,($FFFFF764).w	; restore Sonic's deceleration
		asl	obVelY(a0)
		beq.w	locret_12D80
		move.b	#8,($FFFFD300).w ; load	splash object
		cmpi.w	#-$1000,obVelY(a0)
		bgt.s	loc_12E0E
		move.w	#-$1000,obVelY(a0)	; set maximum speed on leaving water

loc_12E0E:
		move.w	#$AA,d0
		jmp	(PlaySound_Special).l ;	play splash sound
; End of function Sonic_Water

; ===========================================================================
; ---------------------------------------------------------------------------
; Modes	for controlling	Sonic
; ---------------------------------------------------------------------------

Obj01_MdNormal:				; XREF: Obj01_Modes
		bsr	Sonic_SuperPeelOut
		bsr	Sonic_Spindash
		bsr	Sonic_Jump
		bsr	Sonic_SlopeResist
		bsr	Sonic_Move
		bsr	Sonic_Roll
		bsr	Sonic_LevelBound
		bsr	SpeedToPos
		bsr	Sonic_AnglePos
		bsr	Sonic_SlopeRepel
		bsr	Sonic_Fire
		rts	
; ===========================================================================

Obj01_MdJump:				; XREF: Obj01_Modes
		clr.b	$39(a0)
		bsr	Sonic_AutomaticRoll	; branch to automatic roll routine
		bsr	Sonic_AirFreeze
		bsr	Sonic_JumpHeight
		bsr	Sonic_ChgJumpDir
		bsr	Sonic_LevelBound
		bsr	ObjectFall_Sonic
		btst	#6,obStatus(a0)	; is Sonic underwater?
		beq.s	loc_12E5C	; if not, branch
		subi.w	#$28,obVelY(a0)	; use reduced gravity

loc_12E5C:
		bsr	Sonic_JumpAngle
		bsr	Sonic_Floor
		bsr	Sonic_Fire
		rts	
; ===========================================================================

Obj01_MdRoll:				; XREF: Obj01_Modes
		bsr	Sonic_Jump
		bsr	Sonic_RollRepel
		bsr	Sonic_RollSpeed
		bsr	Sonic_LevelBound
		bsr	SpeedToPos
		bsr	Sonic_AnglePos
		bsr	Sonic_SlopeRepel
		rts	
; ===========================================================================

Obj01_MdJump2:				; XREF: Obj01_Modes
		; MdJump2 is almost identical to MdJump, but you can jumpdash as well
		bsr	Sonic_Jumpdash
		bra.s	Obj01_MdJump

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic walk/run
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Move:				; XREF: Obj01_MdNormal
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		move.w	($FFFFF764).w,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc_12FEE
		tst.w	$3E(a0)
		bne.w	Obj01_ResetScr
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj01_NotLeft	; if not, branch
		bsr	Sonic_MoveLeft

Obj01_NotLeft:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj01_NotRight	; if not, branch
		bsr	Sonic_MoveRight

Obj01_NotRight:
		move.b	obAngle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0		; is Sonic on a	slope?
		bne.w	Obj01_ResetScr	; if yes, branch
		tst.w	obInertia(a0)		; is Sonic moving?
		bne.w	Obj01_ResetScr	; if yes, branch
		bclr	#5,obStatus(a0)
		move.b	#5,obAnim(a0)	; use "standing" animation
		btst	#3,obStatus(a0)
		beq.s	Sonic_Balance
		moveq	#0,d0
		move.b	$3D(a0),d0
		lsl.w	#6,d0
		lea	($FFFFD000).w,a1
		lea	(a1,d0.w),a1
		tst.b	obStatus(a1)
		bmi.s	Sonic_LookUp
		moveq	#0,d1
		move.b	obActWid(a1),d1
		move.w	d1,d2
		add.w	d2,d2
		subq.w	#4,d2
		add.w	obX(a0),d1
		sub.w	obX(a1),d1
		cmpi.w	#4,d1
	;	blt.s	loc_12F6A
		cmp.w	d2,d1
		bge.s	loc_12F5A
		bra.s	Sonic_LookUp
; ===========================================================================

Sonic_Balance:
		bsr	ObjHitFloor
		cmpi.w	#$C,d1
		blt.s	Sonic_LookUp
		cmpi.b	#3,$36(a0)
		bne.s	loc_12F62

loc_12F5A:
	;	bclr	#0,obStatus(a0)
		bra.s	loc_12F70
; ===========================================================================

loc_12F62:
		cmpi.b	#3,$37(a0)
		bne.s	Sonic_LookUp

;loc_12F6A:
;		bset	#0,obStatus(a0)

loc_12F70:
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ1?
		beq.s	Sonic_LookUp	; if yes, branch (no balance animation)
		move.b	#6,obAnim(a0)	; use "balancing" animation
	;	bra.s	Obj01_ResetScr
; ===========================================================================

Sonic_LookUp:
		btst	#0,($FFFFF602).w ; is up being pressed?
		beq.s	Sonic_Duck	; if not, branch
		
		move.b	#7,obAnim(a0)	; use "looking up" animation
		cmpi.w	#$101,($FFFFFE10).w	; is level LZ2?
		beq.s	Sonic_Duck		; if yes, disable vertical camera shift
		addq.b	#1,($FFFFC903).w
		cmp.b	#$78,($FFFFC903).w
		bcs.s	Obj01_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#$C8,($FFFFF73E).w
		beq.s	loc_12FC2
		addq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2
; ===========================================================================

Sonic_Duck:
		btst	#1,($FFFFF602).w ; is down being pressed?
		beq.s	Obj01_ResetScr	; if not, branch
		
		move.b	#8,obAnim(a0)	; use "ducking"	animation
		cmpi.w	#$101,($FFFFFE10).w	; is level LZ2?
		beq.s	Obj01_ResetScr		; if yes, disable vertical camera shift
		addq.b	#1,($FFFFC903).w
		cmpi.b	#$78,($FFFFC903).w
		bcs.s	Obj01_ResetScr_Part2
		move.b	#$78,($FFFFC903).w
		cmpi.w	#8,($FFFFF73E).w
		beq.s	loc_12FC2
		subq.w	#2,($FFFFF73E).w
		bra.s	loc_12FC2
; ===========================================================================

Obj01_ResetScr:
		move.b	#0,($FFFFC903).w
		
Obj01_ResetScr_Part2:
		cmpi.w	#$60,($FFFFF73E).w ; is	screen in its default position?
		beq.s	loc_12FC2	; if yes, branch
		bcc.s	loc_12FBE
		addq.w	#4,($FFFFF73E).w ; move	screen back to default

loc_12FBE:
		subq.w	#2,($FFFFF73E).w ; move	screen back to default

loc_12FC2:
		move.b	($FFFFF602).w,d0
		andi.b	#$C,d0		; is left/right	pressed?
		bne.s	loc_12FEE	; if yes, branch
		move.w	obInertia(a0),d0
		beq.s	loc_12FEE
		bmi.s	loc_12FE2
		sub.w	d5,d0
		bcc.s	loc_12FDC
		move.w	#0,d0

loc_12FDC:
		move.w	d0,obInertia(a0)
		bra.s	loc_12FEE
; ===========================================================================

loc_12FE2:
		add.w	d5,d0
		bcc.s	loc_12FEA
		move.w	#0,d0

loc_12FEA:
		move.w	d0,obInertia(a0)

loc_12FEE:
		move.b	obAngle(a0),d0
		jsr	(CalcSine).l
		muls.w	obInertia(a0),d1
		asr.l	#8,d1
		move.w	d1,obVelX(a0)
		muls.w	obInertia(a0),d0
		asr.l	#8,d0
		move.w	d0,obVelY(a0)

loc_1300C:
		move.b	obAngle(a0),d0
		addi.b	#$40,d0
		bmi.s	locret_1307C
		move.b	#$40,d1
		tst.w	obInertia(a0)
		beq.s	locret_1307C
		bmi.s	loc_13024
		neg.w	d1

loc_13024:
		move.b	obAngle(a0),d0
		add.b	d1,d0
		move.w	d0,-(sp)
		bsr	Sonic_WalkSpeed
		move.w	(sp)+,d0
		tst.w	d1
		bpl.s	locret_1307C
		asl.w	#8,d1
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	loc_13078
		cmpi.b	#$40,d0
		beq.s	loc_13066
		cmpi.b	#$80,d0
		beq.s	loc_13060
		add.w	d1,obVelX(a0)
		bset	#5,obStatus(a0)
		move.w	#0,obInertia(a0)
		rts	
; ===========================================================================

loc_13060:
		sub.w	d1,obVelY(a0)
		rts	
; ===========================================================================

loc_13066:
		sub.w	d1,obVelX(a0)
		bset	#5,obStatus(a0)
		move.w	#0,obInertia(a0)
		rts	
; ===========================================================================

loc_13078:
		add.w	d1,obVelY(a0)

locret_1307C:
		rts	
; End of function Sonic_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


; d6 = ($FFFFF760).w Sonic's top speed
; d5 = ($FFFFF762).w Sonic's acceleration
; d4 = ($FFFFF764).w Sonic's deceleration
	
Sonic_MoveLeft:		   ; XREF: Sonic_Move
		move.w	obInertia(a0),d0
		beq.s	loc_13086
		bpl.s	loc_130B2
 
loc_13086:
		bset	#0,obStatus(a0)
		bne.s	loc_1309A
		bclr	#5,obStatus(a0)
		move.b	#1,obNextAni(a0)
 
loc_1309A:
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_130A6
		add.w	d5,d0
		cmp.w	d1,d0
		ble.s	loc_130A6
		move.w	d1,d0
 
loc_130A6:
		move.w	d0,obInertia(a0)
		move.b	#0,obAnim(a0); use walking animation
		rts
; ===========================================================================

loc_130B2:				; XREF: Sonic_MoveLeft
		sub.w	d4,d0
		bcc.s	loc_130BA
		move.w	#-$80,d0

loc_130BA:
		move.w	d0,obInertia(a0)
		move.b	obAngle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_130E8
		cmpi.w	#$400,d0
		blt.s	locret_130E8
		move.b	#$D,obAnim(a0)	; use "stopping" animation
		bclr	#0,obStatus(a0)
		move.w	#$A4,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret_130E8:
		rts	
; End of function Sonic_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Sonic_MoveRight:	   ; XREF: Sonic_Move
		move.w	obInertia(a0),d0
		bmi.s	loc_13118
		bclr	#0,obStatus(a0)
		beq.s	loc_13104
		bclr	#5,obStatus(a0)
		move.b	#1,obNextAni(a0)
 
loc_13104:
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	loc_1310C
		sub.w	d5,d0
		cmp.w	d6,d0
		bge.s	loc_1310C
		move.w	d6,d0
 
loc_1310C:
		move.w	d0,obInertia(a0)
		move.b	#0,obAnim(a0); use walking animation
		rts	
; ===========================================================================

loc_13118:				; XREF: Sonic_MoveRight
		add.w	d4,d0
		bcc.s	loc_13120
		move.w	#$80,d0

loc_13120:
		move.w	d0,obInertia(a0)
		move.b	obAngle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_1314E
		cmpi.w	#-$400,d0
		bgt.s	locret_1314E
		move.b	#$D,obAnim(a0)	; use "stopping" animation
		bset	#0,obStatus(a0)
		move.w	#$A4,d0
		jsr	(PlaySound_Special).l ;	play stopping sound

locret_1314E:
		rts	
; End of function Sonic_MoveRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's speed as he rolls
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollSpeed:			; XREF: Obj01_MdRoll
		btst	#2,obStatus(a0)	; is Sonic already rolling?
		beq.s	S_R_NoRoll	; if not, branch
		btst	#0,($FFFFF602)	; is up being pressed?
		beq.s	S_R_NoRoll	; if not, branch
		bclr	#2,obStatus(a0)	; clear rolling flag
		move.b	#$13,obHeight(a0)	; restore Y-hitbox-radius
		move.b	#9,obWidth(a0)	; restore X-hitbox-radius
		move.b	#0,obAnim(a0)	; use running anim
		subq.w	#5,obY(a0)	; sub 5 from Sonic's Y-position
		rts			; return
; ===========================================================================

S_R_NoRoll:
		move.w	($FFFFF760).w,d6
		asl.w	#1,d6
		move.w	($FFFFF762).w,d5
		asr.w	#1,d5
		move.w	($FFFFF764).w,d4
		asr.w	#2,d4
		tst.b	($FFFFF7CA).w
		bne.w	loc_131CC
		tst.w	$3E(a0)
		bne.s	loc_13188
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc_1317C	; if not, branch
		bsr	Sonic_RollLeft

loc_1317C:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc_13188	; if not, branch
		bsr	Sonic_RollRight

loc_13188:
		move.w	obInertia(a0),d0
		beq.s	loc_131AA
		bmi.s	loc_1319E
		sub.w	d5,d0
		bcc.s	loc_13198
		move.w	#0,d0

loc_13198:
		move.w	d0,obInertia(a0)
		bra.s	loc_131AA
; ===========================================================================

loc_1319E:				; XREF: Sonic_RollSpeed
		add.w	d5,d0
		bcc.s	loc_131A6
		move.w	#0,d0

loc_131A6:
		move.w	d0,obInertia(a0)

loc_131AA:
		tst.w	obInertia(a0)		; is Sonic moving?
		bne.s	loc_131CC	; if yes, branch
		bclr	#2,obStatus(a0)
		move.b	#$13,obHeight(a0)
		move.b	#9,obWidth(a0)
		move.b	#5,obAnim(a0)	; use "standing" animation
		subq.w	#5,obY(a0)

loc_131CC:
		cmp.w	#$60,($FFFFF73E).w
		beq.s	@cont2
		bcc.s	@cont1
		addq.w	#4,($FFFFF73E).w
		
@cont1:
		subq.w	#2,($FFFFF73E).w
		
@cont2:
		move.b	obAngle(a0),d0
		jsr	(CalcSine).l
		muls.w	obInertia(a0),d0
		asr.l	#8,d0
		move.w	d0,obVelY(a0)
		muls.w	obInertia(a0),d1
		asr.l	#8,d1
		cmpi.w	#$1000,d1
		ble.s	loc_131F0
		move.w	#$1000,d1

loc_131F0:
		cmpi.w	#-$1000,d1
		bge.s	loc_131FA
		move.w	#-$1000,d1

loc_131FA:
		move.w	d1,obVelX(a0)
		bra.w	loc_1300C
; End of function Sonic_RollSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollLeft:				; XREF: Sonic_RollSpeed
		move.w	obInertia(a0),d0
		beq.s	loc_1320A
		bpl.s	loc_13218

loc_1320A:
		bset	#0,obStatus(a0)
		move.b	#2,obAnim(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc_13218:
		sub.w	d4,d0
		bcc.s	loc_13220
		move.w	#-$80,d0

loc_13220:
		move.w	d0,obInertia(a0)
		rts	
; End of function Sonic_RollLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollRight:			; XREF: Sonic_RollSpeed
		move.w	obInertia(a0),d0
		bmi.s	loc_1323A
		bclr	#0,obStatus(a0)
		move.b	#2,obAnim(a0)	; use "rolling"	animation
		rts	
; ===========================================================================

loc_1323A:
		add.w	d4,d0
		bcc.s	loc_13242
		move.w	#$80,d0

loc_13242:
		move.w	d0,obInertia(a0)
		rts	
; End of function Sonic_RollRight

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's direction while jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_ChgJumpDir:			; XREF: Obj01_MdJump; Obj01_MdJump2
		btst	#1,($FFFFFFE5).w	; is air freeze active?
		bne.w	locret_132D2		; if yes, don't mess with speeds
		
		move.w	($FFFFF760).w,d6
		move.w	($FFFFF762).w,d5
		asl.w	#1,d5
		btst	#4,obStatus(a0)
		bne.s	Obj01_ResetScr2
		move.w	obVelX(a0),d0
		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	loc_13278	; if not, branch
		bset	#0,obStatus(a0)
		sub.w	d5,d0
		move.w	d6,d1
		neg.w	d1
		cmp.w	d1,d0
		bgt.s	loc_13278
                add.w d5,d0
	        cmp.w d1,d0
	        ble.s loc_13278
		move.w	d1,d0

loc_13278:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	Obj01_JumpMove	; if not, branch
		bclr	#0,obStatus(a0)
		add.w	d5,d0
		cmp.w	d6,d0
		blt.s	Obj01_JumpMove
                sub.w d5,d0
	        cmp.w d6,d0
	        bge.s Obj01_JumpMove
		move.w	d6,d0

Obj01_JumpMove:
		move.w	d0,obVelX(a0)	; change Sonic's horizontal speed

Obj01_ResetScr2:
		cmpi.w	#$60,($FFFFF73E).w ; is	the screen in its default position?
		beq.s	loc_132A4	; if yes, branch
		bcc.s	loc_132A0
		addq.w	#4,($FFFFF73E).w

loc_132A0:
		subq.w	#2,($FFFFF73E).w

loc_132A4:
		cmpi.w	#-$400,obVelY(a0)	; is Sonic moving faster than -$400 upwards?
		bcs.s	locret_132D2	; if yes, branch
		move.w	obVelX(a0),d0
		move.w	d0,d1
		asr.w	#5,d1
		beq.s	locret_132D2
		bmi.s	loc_132C6
		sub.w	d1,d0
		bcc.s	loc_132C0
		move.w	#0,d0

loc_132C0:
		move.w	d0,obVelX(a0)
		rts	
; ===========================================================================

loc_132C6:
		sub.w	d1,d0
		bcs.s	loc_132CE
		move.w	#0,d0

loc_132CE:
		move.w	d0,obVelX(a0)

locret_132D2:
		rts	
; End of function Sonic_ChgJumpDir

; ===========================================================================
; ---------------------------------------------------------------------------
; Unused subroutine to squash Sonic
; ---------------------------------------------------------------------------
		move.b	obAngle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		bne.s	locret_13302
		bsr	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	locret_13302
		move.w	#0,obInertia(a0)	; stop Sonic moving
		move.w	#0,obVelX(a0)
		move.w	#0,obVelY(a0)
		move.b	#$B,obAnim(a0)	; use "warping"	animation

locret_13302:
		rts	
; ---------------------------------------------------------------------------
; Subroutine to	prevent	Sonic leaving the boundaries of	a level
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_LevelBound:			; XREF: Obj01_MdNormal; et al
		move.l	obX(a0),d1
		move.w	obVelX(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d1
		swap	d1

		move.w	($FFFFF728).w,d0
		addi.w	#$10,d0
		cmp.w	d1,d0		; has Sonic touched the	left side boundary?
		bhi.w	Boundary_Sides	; if yes, branch

		move.w	($FFFFF72A).w,d0
		addi.w	#$128,d0
		tst.b	($FFFFF7AA).w	; is boss mode on?
		bne.s	@notboss	; if yes, branch
		addi.w	#$40,d0
@notboss:	cmp.w	d1,d0		; has Sonic touched the	right side boundary?
		blo.w	Boundary_Sides	; if yes, branch

loc_13336:
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0		; add tolerance of one screen
		cmp.w	obY(a0),d0	; has Sonic touched the	bottom boundary?
		bls.s	Boundary_Bottom	; if yes, branch

		cmpi.b	#0,($FFFFFE10).w ; is zone GHZ?
		beq.s	BT_TopBoundary	; if yes, branch
		cmpi.b	#4,($FFFFFE10).w ; is zone SYZ?
		beq.s	BT_TopBoundary	; if yes, branch
		cmpi.b	#$3,($FFFFFE10).w ; is zone SLZ?
		beq.s	BT_TopBoundary ; if yes, branch
		cmpi.w	#$501,($FFFFFE10).w
		beq.s	BT_TopBoundary
		cmpi.b	#1,($FFFFFE10).w ; is zone LZ?
		bne.s	BT_Return	; if not, branch

BT_TopBoundary:
		move.w	($FFFFF72C).w,d0
		addi.w	#$10,d0
		cmp.w	obY(a0),d0	; has Sonic touched the	upper boundary?
		bgt.w	Boundary_Top	; if yes, branch

BT_Return:
		rts	
; ===========================================================================

Boundary_Bottom:
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ1?
		beq.w	Boundary_Bottom_locret	; if yes, branch

		move.w	($FFFFF726).w,d0
		move.w	($FFFFF72E).w,d1
		cmp.w	d0,d1
		blt.s	Boundary_Bottom_locret	
		cmpi.w	#$001,($FFFFFE10).w ; is level GHZ2 ?
		bne.s	BB_NotGHZ2

Boundary_Bottom_locret:
		rts
; ===========================================================================

BB_NotGHZ2:
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	KillSonic_JMP		; if not, branch
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		beq.s	BB_DoTele		; if not, branch
		bra.s	KillSonic_JMP		; otherwise skip this to allow bouncing

BB_DoTele:
		tst.b	($FFFFFF95).w		; was forced-kill flag set?
		bne.s	KillSonic_JMP		; if yes, branch
		cmpi.w	#$18B0,($FFFFD008).w	; is Sonic past the X-location $18B0?
		bpl.s	KillSonic_JMP		; if yes, branch
		cmpi.w	#$1320,($FFFFD008).w	; is Sonic before the X-location $1320?
		bmi.s	KillSonic_JMP		; if yes, branch
		rts				; otherwise we're in the waterfall section, don't kill here
; ===========================================================================

KillSonic_JMP:
	;	cmpi.w	#$601,($FFFFFE10).w	; is this the ending sequence?
	;	bne.s	NOSBBDead		; if not, branch
	;	move.b	#1,($FFFFFFA1).w	; make sure Sonic dies from boundary bottom, even during inhuman mode
;NOSBBDead:
		jmp	KillSonic		; friggin die noob
; ===========================================================================

Boundary_Sides:
		move.w	d0,obX(a0)
		move.w	#0,obScreenY(a0)
		move.w	#0,obVelX(a0)	; stop Sonic moving
		move.w	#0,obInertia(a0)
		bra.w	loc_13336
; ===========================================================================

Boundary_Top:
		move.w	d0,obY(a0)
		move.w	#0,obVelY(a0)	; stop Sonic moving
		rts
; End of function Sonic_LevelBound

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to roll when he's moving
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Roll:				; XREF: Obj01_MdNormal
		tst.b	($FFFFF7CA).w
		bne.s	Obj01_NoRoll
		move.w	obInertia(a0),d0
		bpl.s	loc_13392
		neg.w	d0

loc_13392:
		cmpi.w	#$80,d0		; is Sonic moving at $80 speed or faster?
		bcs.s	Obj01_NoRoll	; if not, branch
		move.b	($FFFFF602).w,d0
		andi.b	#$C,d0		; is left/right	being pressed?
		bne.s	Obj01_NoRoll	; if yes, branch
		btst	#1,($FFFFF602).w ; is down being pressed?
		bne.s	Obj01_ChkRoll	; if yes, branch

Obj01_NoRoll:
		rts	
; ===========================================================================

Obj01_ChkRoll:
		btst	#2,obStatus(a0)	; is Sonic already rolling?
		beq.s	Obj01_DoRoll	; if not, branch
		rts	
; ===========================================================================

Obj01_DoRoll:
		bset	#2,obStatus(a0)
		move.b	#$E,obHeight(a0)
		move.b	#7,obWidth(a0)
		move.b	#2,obAnim(a0)	; use "rolling"	animation
		addq.w	#5,obY(a0)
		move.w	#$BE,d0
		jsr	(PlaySound_Special).l ;	play rolling sound
		tst.w	obInertia(a0)
		bne.s	locret_133E8
		move.w	#$200,obInertia(a0)

locret_133E8:
		rts	
; End of function Sonic_Roll

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to fix the level after a teleport
; ---------------------------------------------------------------------------

FixLevel:
		bsr	FixCamera
		VBlank_SetMusicOnly
		movem.l	d0-a6,-(sp)		; backup all data and address registers
		jsr	DeformBgLayer		; fix the background position
		jsr 	LevelRenderer_DrawLayout_FG
		jsr 	LevelRenderer_DrawLayout_BG
		movem.l	(sp)+,d0-a6		; restore them
		VBlank_UnsetMusicOnly
		rts
; ---------------------------------------------------------------------------

FixCamera:
		moveq	#0,d0
		move.w	($FFFFD008).w,d0	; load Sonic's X-location into d0
		subi.w	#320/2,d0		; substract 160 pixels from it (half of 320, horizontal screen size)
		bpl.s	@fixx
		moveq	#0,d0
@fixx:		swap	d0
		move.l	d0,($FFFFF700).w	; put result into X-camera location

		moveq	#0,d0
		move.w	($FFFFD00C).w,d0	; load Sonic's Y-location into d0
		subi.w	#224/2,d0		; substract 112 pixels from it (half of 224, vertical screen size)
		bpl.s	@fixy
		moveq	#0,d0
@fixy:		swap	d0
		move.l	d0,($FFFFF704).w	; put result into Y-camera location

		clr.l	($FFFFF73A).w		; clear camera shifts
		clr.b	(CameraShake).w		; clear camera shaking
		rts

; ---------------------------------------------------------------------------
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to make the palette white (and restoring it in Sonic_Display)
; ---------------------------------------------------------------------------

WhiteFlash3:
		move.b	#6,($FFFFFFB1).w	; set inhuman crush flag
		bra.s	WF_DoWhiteFlash		; no inhuman/invin mode required
; ===========================================================================
	
WhiteFlash2:
		move.b	#1,($FFFFFFAE).w	; set WF2 flag
		move.b	#6,($FFFFFFB1).w	; set inhuman crush flag
		bra.s	WF_DoWhiteFlash		; no inhuman/invin mode required
; ===========================================================================

WhiteFlash:
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		bne.s	WF_DoWhiteFlashx	; if yes, branch
		tst.b	($FFFFFE2D).w		; is invincibility mode on?
		beq.w	WF_Return		; if not, branch

WF_DoWhiteFlashx:
		move.b	#6,($FFFFFFB1).w	; set inhuman crush flag

WF_DoWhiteFlash:
		tst.b	($FFFFFFB9).w		; is a white flash currently in progres?
		bne.w	WF_Return		; if yes, skip this one
		move.b	#1,($FFFFFFB9).w	; set white flash flag

		btst	#7,(OptionsBits).w	; are flashy lights even enabled?
		beq.w	WF_SetCameraLag		; if not, well, don't do them

		lea	($FFFFFA80).w,a3	; load palette location to a3
		lea	($FFFFCA00).w,a4	; load backup location to a4
		move.w	#$003F,d3		; set d3 to $7F (+1 for the first run)
WF_BackupPal_Loop:
		move.l	(a3)+,(a4)+		; backup palette
		dbf	d3,WF_BackupPal_Loop	; loop

		lea	($FFFFFA80).w,a1	; load palette location to a3
		move.w	#$007F,d3		; set d3 to $7F (+1 for the first run)
WF_MakeWhite_Loop:
		move.w	(a1),d1			; get current color in palette
	
		cmpi.b	#1,($FFFFFFD6).w	; is a W-block being touched in the special stage?
		beq.s	@boost			; if yes, boost
			
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		beq.s	@wfnotcinematic		; if not, branch

@boost:
		moveq	#7,d4			; bit boost (<-- just a bit, sure :V)
		bra.w	@wfintensity		; branch

@wfnotcinematic:
		; intensity control
		moveq	#2,d4			; intensity boost (for any normal stage)
		
		cmpi.w	#$302,($FFFFFE10).w	; is level Star Agony Place?
		beq.s	@wfintensitynoboost	; if yes, branch
		cmpi.b	#$10,($FFFFF600).w	; are we in a special stage?
		bne.s	@wfintensity		; if not, branch
		tst.b	($FFFFFFBF).w		; Unreal Place floating challenge enabled?
		bne.s	@wfintensitynoboost	; if yes, branch
		tst.b	($FFFFFF5F).w		; blackout challenge?
	;	beq.s	@wfintensity		; if not, branch
	;	frantic				; are we in Frantic mode?
		bne.s	@wfintensity		; if yes, branch
@wfintensitynoboost:
		moveq	#0,d4			; no intensity boost (used for all stages with black backgrounds)

@wfintensity:
		move.w	d1,d2			; copy color
		andi.w	#$00E,d2		; filter for red
		cmpi.w	#$00E,d2		; are we at max?
		beq.s	@maxred			; if yes, branch
		addi.w	#$002,d1		; otherwise, boost color
@maxred:
		tst.b	($FFFFFF5F).w		; blackout challenge?
		bne.s	@maxblue		; if yes, only affect red channel

		move.w	d1,d2			; copy color
		andi.w	#$0E0,d2		; filter for green
		cmpi.w	#$0E0,d2		; are we at max?
		beq.s	@maxgreen		; if yes, branch
		addi.w	#$020,d1		; otherwise, boost color
@maxgreen:
		move.w	d1,d2			; copy color
		andi.w	#$E00,d2		; filter for blue
		cmpi.w	#$E00,d2		; are we at max?
		beq.s	@maxblue		; if yes, branch
		addi.w	#$200,d1		; otherwise, boost color
@maxblue:
		dbf	d4,@wfintensity		; repeat for increased intensity

@intensityend:
		move.w	d1,(a1)+		; set new color
		dbf	d3,WF_MakeWhite_Loop	; loop

WF_SetCameraLag:
		move.b	#12,($FFFFFFB2).w	; set ScrollHoriz delay and jumpdash flag 2
WF_Return:
		rts
; ---------------------------------------------------------------------------

WhiteFlash_Restore:
		tst.b	($FFFFFFB9).w		; is white flash flag set?
		beq.s	WF_Restore_End		; if not, branch
		tst.b	($FFFFFFB1).w
		bpl.s	WF_Restore_End
		clr.b	($FFFFFFB9).w		; clear white flash flag
		
		btst	#7,(OptionsBits).w	; are flashy lights even enabled?
		beq.s	WF_Restore_End		; if not, branch

		lea	($FFFFFA80).w,a4	; load palette location to a4
		lea	($FFFFCA00).w,a3	; load backed up palette to a3
		move.w	#$007F,d5		; set d3 to $7F (+1 for the first run)
WF_Restore_Loop:
		move.w	(a3)+,(a4)+		; set new palette palette
		dbf	d5,WF_Restore_Loop	; loop

WF_Restore_End:
		rts
		
; ---------------------------------------------------------------------------
; Subroutine to perform a JumpDash / Homing Attack
; ---------------------------------------------------------------------------

Sonic_JumpDash:
		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		bne.s	JD_NotMZ		; if not, branch
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		bne.s	JD_NotMZ
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		bne.w	JD_End			; if yes, branch

JD_NotMZ:
		tst.b	($FFFFFFE5).w		; was AirFreeze flag set?
		bne.w	JD_End			; if yes, branch
		move.b	($FFFFF603).w,d0	; is B or C pressed? (part 1)
		andi.w	#$30,d0			; is B C pressed? (part 2)
		beq.w	JD_End			; if not, branch

		tst.b	($FFFFFFEB).w		; was jumpdash flag set?
		bne.w	JD_End			; if yes, branch
		move.b	#1,($FFFFFFEB).w	; if not, set jumpdash flag
		tst.b	($FFFFF7AA).w		; is boss mode on?
		bne.s	JD_NoWhiteFlash		; if yes, branch
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		bne.s	@contx
		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		beq.s	JD_NoWhiteFlash		; if yes, branch

@contx:
		bsr	WhiteFlash		; make white flash

JD_NoWhiteFlash:
		move.b	#1,($FFFFFFAD).w	; enable after image
		move.b	#2,obAnim(a0)		; set rolling animation
		
		btst	#0,($FFFFF602).w	; is up pressed?
		bne.w	Sonic_DoubleJump	; if yes, branch to double jump code
		btst	#1,($FFFFF602).w	; is down pressed?
		bne.w	Sonic_DownDash		; if yes, branch to down dash code		
		move.b	($FFFFF603).w,d0	; is B pressed? (part 1)
		andi.w	#$10,d0			; is B pressed? (part 2)
		bne.w	Sonic_DoubleJump	; if yes, branch to double jump code

JD_NotInhuman:
		move.w	#$BC,d0			; set jumpdash sound
		jsr	(PlaySound).l		; play jumpdash sound

JD_SetSpeed1:
		move.w	#$A00,d0		; set normal jumpdash speed
		tst.b	($FFFFFE2E).w		; do you have speed shoes?
		beq.s	JD_SetSpeed2		; if not, branch
		move.w	#Sonic_TopSpeed+$600,d0	; set speed shoes jumpdash speed

JD_SetSpeed2:
		btst	#6,obStatus(a0)		; is Sonic underwater?
		beq.s	JD_ChkDirection		; if not, branch
		move.w	#$600,d0		; set underwater jumpdash speed

JD_ChkDirection:
		btst	#0,obStatus(a0)		; is sonic facing left?
		beq.s	JD_Move			; if yes, branch
		neg.w	d0			; if not, negate d0 (for jumping to the right)
JD_Move:
		move.w	d0,obVelX(a0)		; move sonic forward (X-velocity)
		clr.w	obVelY(a0)		; clear Y-velocity to move sonic directly down

		bsr.s	Sonic_HomingAttack	; check if homing attack is possible

JD_End:
		rts				; return or cancel jumpdash
		
; ===========================================================================


; ===============================================================================
; -------------------------------------------------------------------------------
; Sonic Homing Attack ~by Selbi
;
; Please note that this code only triggers the homing itself. There are a couple
; of other things spread around the disassembly, stopping and moving Sonic
; upwards after hitting something and making monitors destroyable from any angle.
; -------------------------------------------------------------------------------

Sonic_HomingAttack:
		clr.w	($FFFFFF8C).w		; clear X-distance storer
		clr.w	($FFFFFF8E).w		; clear Y-distance storer

		movem.l	d0-a3,-(sp)		; backup d0 to a3
		lea	($FFFFD800).w,a1	; set a1 to level object RAM
		moveq	#$5F,d2			; set d2 to $5F ($D800 to $F000 = $60 objects)

; -------------------------------------------------------------------------------
SH_ObjectLoop:
		lea	(SH_Objects).l,a2	; (re)set a2 to objects to be checked

SH_EnemyLoop:
		tst.b	(a2)			; is current entry $FF (end of array)?
		bmi.w	SH_NoEnemy		; if yes, branch
		move.b	(a1),d0			; move current object ID to d0
		beq.w	SH_NoEnemy		; if it's not a set object, loop
		cmp.b	(a2)+,d0		; is current object a valid object?
		bne.s	SH_EnemyLoop		; if not, loop

		cmpi.b	#$22,(a1)		; was selected object a buzz bomber
		bne.s	SH_NoBuzz		; if not, branch
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	SH_NoBuzz		; if not, branch
		cmpi.w	#$1900,obX(a0)		; is Sonic past the X-location $1900?
		bpl.s	SH_NoBuzz		; if yes, branch
		cmpi.w	#$1300,obX(a0)		; is Sonic before the X-location $1300?
		bmi.s	SH_NoBuzz		; if yes, branch
		bra.s	SH_NoEnemy		; otherwise, skip object

SH_NoBuzz:
		cmpi.b	#$26,(a1)		; was selected object a monitor?
		bne.s	SH_NoMonitor		; if not, branch
		cmpi.b	#$1,($FFFFFE10).w	; is level LZ?
		beq.w	SH_NoEnemy		; if yes, branch
		cmpi.b	#4,obRoutine(a1)	; is monitor being broken or already broken?
		blt.s	SH_NoMonitor		; if not, branch
		bra.s	SH_NoEnemy		; otherwise, skip object

SH_NoMonitor:
		cmpi.b	#$1F,(a1)		; was selected object a crabmeat?
		bne.s	SH_NoCrabMeat		; if not, branch
		cmpi.b	#6,obRoutine(a1)		; is object an exploding ball?
		blt.s	SH_NoCrabMeat		; if not, brank
		bra.s	SH_NoEnemy		; otherwise, skip object

SH_NoCrabMeat:
		move.w	obX(a1),d3		; load current X-pos into d3
		sub.w	obX(a0),d3		; substract Sonic's X-pos from it
		bpl.s	SH_XPositive		; if result it positive, branch
		btst	#0,obStatus(a0)		; is Sonic looking at the target?
		beq.s	SH_NoEnemy		; if not, branch
		neg.w	d3			; otherwise, negate it
		bra.s	SH_DirectionOK		; skip

SH_XPositive:
		btst	#0,obStatus(a0)		; is Sonic looking at the target?
		bne.s	SH_NoEnemy		; if not, branch

SH_DirectionOK:
		cmpi.w	#$90,d3			; is Sonic within $90 pixels of that object?
		bgt.s	SH_NoEnemy		; if not, branch

		move.w	obY(a1),d4		; load current Y-pos into d3
		sub.w	obY(a0),d4		; substract Sonic's Y-pos from it
		bpl.s	SH_YPositive		; if result it positive, branch
		neg.w	d4			; negate it

SH_YPositive:
		cmpi.w	#$90,d4			; is Sonic within $90 pixels of that object?
		bgt.s	SH_NoEnemy		; if not, branch

		cmp.w	($FFFFFF8C).w,d3	; is stored X-distance smaller than distance of current enemy?
		blt.s	SH_NoEnemy		; if yes, branch
		cmp.w	($FFFFFF8E).w,d4	; is stored Y-distance smaller than distance of current enemy?
		blt.s	SH_NoEnemy		; if yes, branch
		move.w	d3,($FFFFFF8C).w	; store X-pos
		move.w	d4,($FFFFFF8E).w	; store Y-pos
		movea.l	a1,a3			; save RAM position of current enemy

SH_NoEnemy:
		adda.l	#$40,a1			; increase pointer by $40 (next object)
		dbf	d2,SH_ObjectLoop	; loop
; -------------------------------------------------------------------------------

		tst.w	($FFFFFF8C).w		; was any enemy found?
		beq.s	SH_Return		; if not, use normal jumpdash
		suba.l	#$40,a1			; decrease pointer by $40, because it got increased one more time before leaving the loop
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	SH_NotGHZ1		; if not, branch
		cmpi.b	#$1F,(a1)		; is found object a crabmeat?
		beq.s	SH_Return		; if yes, don't allow homing

SH_NotGHZ1:
		move.w	obX(a3),d1		; load X-pos of nearest enemy into d1
		sub.w	obX(a0),d1		; sub Sonic's X-pos from it
		move.w	obY(a3),d2		; load Y-pos of nearest enemy into d1
		sub.w	obY(a0),d2		; sub Sonic's Y-pos from it
		jsr	CalcAngle		; calculate the angle
		jsr	CalcSine		; calculate the sine
		muls.w	#$A00,d0		; multiply result 1 by $900 (this line is for the Y-speed)
		muls.w	#$A00,d1		; multiply result 2 by $900 (this line is for the X-speed)
		asr.l	#8,d0			; align the results to the correct position in the bitfield ...
		asr.l	#8,d1			; ... (e.g. 00000000xxxxxxxxxxxxxxxx00000000 to 0000000000000000xxxxxxxxxxxxxxxx)
		move.w	d1,obVelX(a0)		; set final result to Sonic's X-speed
		move.w	d0,obVelY(a0)		; set final result to Sonic's Y-speed

SH_Return:
		movem.l	(sp)+,d0-a3		; restore d0 to a3

SH_Return2:
		rts				; return
; -------------------------------------------------------------------------------
; ===============================================================================

; ===============================================================================
; -------------------------------------------------------------------------------
; Homing Attack - Objects to be checked
; -------------------------------------------------------------------------------

SH_Objects:
	dc.b	$1F, $22, $26, $2B, $2C, $40, $50, $55
	dc.b	$FF	; this $FF is the end of list
	even
; -------------------------------------------------------------------------------
; ===============================================================================

; ---------------------------------------------------------------------------
; Subroutine to perform a Double Jump
; ---------------------------------------------------------------------------

Sonic_DoubleJump:
		move.w	#$A0,d0			; set jumping sound		
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		beq.s	DJ_PlaySound		; if not, branch
		move.w	#$BC,d0			; set dash sound instead

DJ_PlaySound:
		jsr	(PlaySound).l		; play jumping sound
		move.w	#-$700,obVelY(a0)	; set normal double jump speed
		btst	#3,($FFFFF602).w
		beq.s	DJ_NoRight
		add.w	#$150,obVelX(a0)

DJ_NoRight:
		btst	#2,($FFFFF602).w
		beq.s	DJ_NoLeft
		sub.w	#$150,obVelX(a0)

DJ_NoLeft:
		btst	#6,obStatus(a0)		; is Sonic underwater?
		beq.s	DJ_End			; if not, branch
		move.w	#-$300,obVelY(a0)	; set underwater double jump speed

DJ_End:
		rts				; return or cancel double jump

; ---------------------------------------------------------------------------
; Subroutine to dash Sonic down
; ---------------------------------------------------------------------------

Sonic_DownDash:
		move.w	#$BC,d0			; set jumpdash sound
		jsr	(PlaySound).l		; play jumpadsh sound
		move.w	#$A00,obVelY(a0)	; set normal down dash speed
		btst	#6,obStatus(a0)		; is Sonic underwater?
		beq.s	DD_End			; if not, branch
		move.w	#$600,obVelY(a0)	; set underwater down dash speed

DD_End:
		rts				; return or cancel down dash
		
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to perform a Super Peelout
; ---------------------------------------------------------------------------

Sonic_SuperPeelOut:
		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		bne.s	SPO_NotMZ		; if not, branch
	;	btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
	;	bne.s	SPO_NotMZ
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		bne.w	SPO_End			; if yes, disallow

SPO_NotMZ:
		tst.b	($FFFFFF99).w
		beq.w	SPO_End
		tst.b	($FFFFFEBC).w		; already peelouting?
		bne.s	SPO_CheckDelay		; if set, branch
		tst.b	($FFFFFF98).w		; is intro peelout being performed?
		beq.s	SPO_Simulated		; if yes, branch
		cmpi.b	#7,obAnim(a0)		; is anim looking up?
		bne.w	SPO_End			; if not, return
		move.b	($FFFFF603).w,d0	; read controller
		andi.b	#$40,d0			; pressing A?
		beq.w	SPO_End			; if not, return

SPO_Simulated:
		move.b	#$20,obAnim(a0)		; set Peelout anim
		move.w	#$D2,d0			; set peelout sound
		jsr	(PlaySound_Special).l	; play peelout sound
		addq.l	#4,sp			; increment stack ptr
		move.b	#1,($FFFFFEBC).w	; set peelout flag
		clr.b	($FFFFFECA).w		; clear peelout delay flag
		move.w	#0,$3C(a0)		; set charge count 1 to 0
		move.w	#0,$3A(a0)		; set charge count 2 to 0
		cmpi.b	#$C,obSubtype(a0)		; ??? oxygen remaining?
		move.b	#5,($FFFFD1C0).w	; set up spindash object
		move.b	#2,($FFFFD1DC).w	; Set the spindash dust animation to $2
		jmp	Sonic_AnglePos		; jump to Sonic_AnglePos
; ===========================================================================

SPO_CheckDelay:
		tst.b	($FFFFFF98).w		; is intro peelout being performed?
		beq.w	SPO_PreEnd1		; if yes, branch
		btst	#0,($FFFFF602).w	; is up button still pressed?
		bne.w	SPO_PreEnd1		; if yes, continue charging until Up is released
		cmpi.b	#$26,obAnim(a0)		; is SPO anim #2 being showed?
		beq.w	SPO_SlowPeelout		; if yes, do slow Peelout
		cmpi.b	#$27,obAnim(a0)		; is SPO anim #3 being showed?
		beq.w	SPO_FastPeelout		; if yes, do fast Peelout
		move.w	#$D6,d0			; stop the SPO charge sound
		jsr	(PlaySound_Special).w	; play it
		clr.w	$3C(a0)			; set charge count 1 to 0
		clr.w	$3A(a0)			; set charge count 2 to 0
		move.w	#$60,($FFFFF73E).w	; reset looking up/down
		move.b	#0,obAnim(a0)		; change anim to standing
		clr.b	($FFFFFEBC).w		; clear SPO flag
		bra.w	SPO_End

SPO_SlowPeelout:
		moveq	#0,d1			; clear d1
		move.w	#$A00,d1		; set slowpeelout speed
		bra.s	SPO_ChkUW		; skip SPO_FastPeelout

SPO_FastPeelout:
		moveq	#0,d1			; clear d1
		move.w	#$F00,d1		; set fast peelout speed

SPO_ChkUW:
		btst	#6,obStatus(a0)		; is sonic underwater?
		beq.s	SPO_NotUnderwater	; if not, branch
		sub.w	#$300,d1		; substract $300 from peelout speed, if you are underwater

SPO_NotUnderwater:
		tst.b	($FFFFFFD3).w
		bne.s	SPO_No
		cmpi.b	#2,($FFFFFF98).w	; is intro peelout canceled?
		beq.w	SPO_End			; if yes, branch

SPO_No:
		move.w	d1,obInertia(a0)		; set peelout speed (depening on a half or a full peelout)
		move.b	#0,obAnim(a0)		; set animation to run
		clr.b	($FFFFFEBC).w		; clear peelout flag		
		btst	#0,obStatus(a0)		; is sonic facing right?
		beq.w	SPO_PlaySound		; if not, branch
		neg.w	obInertia(a0)			; negate inertia

SPO_PlaySound:
		clr.b	($FFFFFFAF).w		; clear camera shift flag
		move.b	#0,($FFFFD1DC).w	; clear spindash dust animation
		move.w	#$D3,d0			; peelout release sound
		jsr	(PlaySound_Special).l	; play it!
; ---------------------------------------------------------------------------

SPO_PreEnd1:
		cmpi.b	#$26,obAnim(a0)		; is half peelout anim being showed?
		beq.s	SPO_CameraShift		; if yes, branch
		cmpi.b	#$27,obAnim(a0)		; is half peelout anim being showed?
		bne.s	SPO_PreEnd1_Cont	; if not, branch

SPO_CameraShift:
		move.b	#1,($FFFFFFAF).w	; enable default camera shift

SPO_PreEnd1_Cont:
		move.b	#2,($FFFFD1DC).w	; set dust anim
		tst.b	($FFFFFEBC).w		; is peelout flag still set?
		beq.w	SPO_End			; if not, branch
		addq.l	#4,sp			; increase stack ptr
		cmpi.w	#$60,($FFFFF73E).w	; is camera X-position neutral?
		beq.s	SPO_PreEnd3		; if yes, branch
		bcc.s	SPO_PreEnd2		; if it's below it, branch
		addq.w	#2,($FFFFF73E).w	; add 4 to camera X-position
		bra.s	SPO_PreEnd3		; skip SPO_PreEnd2

SPO_PreEnd2:
		subq.w	#2,($FFFFF73E).w	; substract 2 from camera X-position

SPO_PreEnd3:
		bsr	Sonic_AnglePos		; calc Angle Position

SPO_End:
		rts				; return
; End of function Sonic_SuperPeelOut


; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to perform a Spindash
; ---------------------------------------------------------------------------

Sonic_Spindash:
		tst.b	($FFFFFF74).w		; currently standing in front of a hard part skipper?
		bne.w	locret2_1AC8C		; if yes, prevent spindashing

		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		bne.s	Spdsh_NotMZ		; if not, branch
	;	btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
	;	bne.s	Spdsh_NotMZ		; if yes, branch
		tst.b	($FFFFFF73).w		; P monitor broken?
		bne.s	Spdsh_NotMZ		; if yes, branch
		tst.b	($FFFFFFE7).w		; is inhuman mode on?
		bne.w	locret2_1AC8C		; if yes, branch

Spdsh_NotMZ:

		tst.b	$39(a0)			; already spindashing?
		bne.s	loc2_1AC8E		; if set, branch
		cmpi.b	#8,obAnim(a0)		; is anim duck
		bne.s	locret2_1AC8C		; if not, return
		move.b	($FFFFF603).w,d0	; read controller
		andi.w	#$70,d0			; pressing A/B/C ?
		beq.w	locret2_1AC8C		; if not, return
		move.b	#$1F,obAnim(a0)		; set spindash anim (9 in s2)
		move.w	#$D1,d0			; spin sound ($E0 in s2)
		jsr	(PlaySound_Special).l	; play spin sound
		addq.l	#4,sp			; increment stack ptr
		move.b	#1,$39(a0)		; set spindash flag
		move.w	#0,$3A(a0)		; set charge count to 0
		cmpi.b	#$C,obSubtype(a0)		; ??? oxygen remaining?
		move.b	#5,($FFFFD1C0).w	; set up spindash object
		move.b	#2,($FFFFD1DC).w	; Set the spindash dust animation to $2

loc2_1AC84:
		bsr	Sonic_LevelBound
		bsr	Sonic_AnglePos

locret2_1AC8C:
		rts	
; ---------------------------------------------------------------------------

loc2_1AC8E:
		move.b	#$1F,obAnim(a0)
		move.b	($FFFFF602).w,d0	; read controller
		btst	#1,d0			; check down button
		bne.w	loc2_1AD30		; if set, branch
		move.b	#$E,obHeight(a0)		; obHeight(a0) is height/2
		move.b	#7,obWidth(a0)		; obWidth(a0) is width/2
		move.b	#2,obAnim(a0)		; set animation to roll
		addq.w	#5,obY(a0)		; obY(a0) is Y coordinate
		move.b	#0,$39(a0)		; clear spindash flag
		moveq	#0,d0
		move.b	$3A(a0),d0		; copy charge count
		add.w	d0,d0			; double it
		move.w	spdsh_norm(pc,d0.w),obInertia(a0) ; get normal speed
		tst.b	($FFFFFE19).w		; is sonic super?
		beq.s	loc2_1ACD0		; if no, branch
		move.w	spdsh_super(pc,d0.w),obInertia(a0) ; get super speed

loc2_1ACD0:
		move.w	obInertia(a0),d0		; get inertia
		subi.w	#$800,d0		; subtract $800
		add.w	d0,d0			; double it
		andi.w	#$1F00,d0		; mask it against $1F00
		neg.w	d0			; negate it
		addi.w	#$2000,d0		; add $2000
		move.w	d0,($FFFFEED0).w	; camera delay flag ($C904=On; $EEDo=Off)
		btst	#0,obStatus(a0)		; is sonic facing right?
		beq.s	loc2_1ACF4		; if not, branch
		neg.w	obInertia(a0)			; negate inertia

loc2_1ACF4:
		bset	#2,obStatus(a0)		; set unused (in s1) flag
		clr.b	($FFFFFFAF).w		; clear camera shift flag
		move.b	#0,($FFFFD1DC).w	; clear spindash dust animation
		move.w	#$BC,d0			; spin release sound
		jsr	(PlaySound_Special).l	; play it!
		bra.s	loc2_1AD78
; ===========================================================================
spdsh_norm:
		dc.w  $800		; 0
		dc.w  $880		; 1
		dc.w  $900		; 2
		dc.w  $980		; 3
		dc.w  $A00		; 4
		dc.w  $A80		; 5
		dc.w  $B00		; 6
		dc.w  $B80		; 7
		dc.w  $C00		; 8

spdsh_super:
		dc.w  $B00		; 0
		dc.w  $B80		; 1
		dc.w  $C00		; 2
		dc.w  $C80		; 3
		dc.w  $D00		; 4
		dc.w  $D80		; 5
		dc.w  $E00		; 6
		dc.w  $E80		; 7
		dc.w  $F00		; 8
; ===========================================================================

loc2_1AD30:				; If still charging the dash...
		tst.w	$3A(a0)		; check charge count
		beq.s	loc2_1AD48	; if zero, branch
		move.w	$3A(a0),d0	; otherwise put it in d0
		lsr.w	#5,d0		; shift right 5 (divide it by 32)
		sub.w	d0,$3A(a0)	; subtract from charge count
		bcc.s	loc2_1AD48	; ??? branch if carry clear
		move.w	#0,$3A(a0)	; set charge count to 0

loc2_1AD48:
		move.b	($FFFFF603).w,d0	; read controller
		andi.w	#$70,d0			; pressing A/B/C?
		beq.w	loc2_1AD78		; if not, branch
		move.b	#$1F,obAnim(a0)		; reset spdsh animation
		move.w	#$D1,d0			; was $E0 in sonic 2
		move.b	#2,($FFFFD1DC).w	; Set the spindash dust animation to $2.
		jsr	(PlaySound_Special).l	; play charge sound
		addi.w	#$200,$3A(a0)		; increase charge count
		cmpi.w	#$800,$3A(a0)		; check if it's maxed
		bcs.s	loc2_1AD78		; if not, then branch
		move.w	#$800,$3A(a0)		; reset it to max

loc2_1AD78:
		cmpi.b	#$1F,obAnim(a0)		; is spindash flag being showed?
		bne.s	Spd_NoCamShift		; if not, branch
		move.b	#1,($FFFFFFAF).w	; enable default camera shift

Spd_NoCamShift:
		addq.l	#4,sp			; increase stack ptr
		cmpi.w	#$60,($FFFFF73E).w
		beq.s	loc2_1AD8C
		bcc.s	loc2_1AD88
		addq.w	#4,($FFFFF73E).w

loc2_1AD88:
		subq.w	#2,($FFFFF73E).w

loc2_1AD8C:
		bsr	Sonic_LevelBound
		bsr	Sonic_AnglePos
		;move.w	#$60,($FFFFF73E).w	; reset looking up/down
		rts
; End of function Sonic_Spindash

; ---------------------------------------------------------------------------
; Subroutine to move Sonic in air while holding C (Star Agony Place)
; ---------------------------------------------------------------------------
Last_Direction = $FFFFF670
C_HoldTimer = $FFFFF672
AF_Speed =  $500
AF_Hold_Speed =  $250
AF_UpBoost = $180

Sonic_AirFreeze:
		tst.b	($FFFFFF77).w		; is antigrav enabled?
		beq.w	AM_End			; if not, branch
		tst.b	($FFFFFFE7).w		; is inhuman mode enabled?
		bne.w	AM_End			; if yes, disallow air freeze

		move.b	($FFFFF602).w,d1	; get button pressed
		btst	#5,d1			; is C pressed?
		bne.s	AM_APressed		; if yes, branch
		btst	#1,($FFFFFFE5).w	; was air freeze already active?
		beq.w	AM_End			; if not, branch
		bclr	#1,($FFFFFFE5).w	; clear flag
		bra.w	AM_LetGo		; move Sonic

AM_APressed:
		cmpi.w 	#AF_Hold_Speed, (C_HoldTimer)
		bge.s 	@DontAddToTimer

		add.w 	#3, (C_HoldTimer)
		bra.s 	@DirectionCheck

@DontAddToTimer:
		move.w 	#AF_Hold_Speed, (C_HoldTimer)

@DirectionCheck:
		and.b	#%00001111, d1 	; only use direction nybble
		tst.b 	d1
		beq.w 	@EndInput
		
		move.b 	d1,(Last_Direction) ; store direction
		
		move.w	#-AF_Hold_Speed, d2 ; left + up
		add.w 	(C_HoldTimer), d2

		move.w	#AF_Hold_Speed, d3 ; right + down
		sub.w 	(C_HoldTimer), d3

		btst	#2,(Last_Direction).w	; is left pressed?
		beq.s	@ChkRight		; if not, check if down is pressed
		bset	#0,obStatus(a0)		; make Sonic fake the left
		move.w	d2,obVelX(a0)	; move sonic left
		moveq	#1,d0			; set to something was pressed
		bra.s	@ChkDown		; we don't need ot check right

@ChkRight:
		btst	#3,(Last_Direction).w	; is right pressed?
		beq.s	@ChkDown		; if not, branch
		bclr	#0,obStatus(a0)		; make Sonic fake the right
		move.w	d3,obVelX(a0)	; move sonic right
		moveq	#1,d0			; set to something was pressed

@ChkDown:
		btst	#1,d1			; is down pressed?
		beq.s	@ChkUp		; if not, branch
		move.w	d3,obVelY(a0)	; move sonic down
		moveq	#1,d0			; set to something was pressed
		bra.s	@EndInput		; we don't need to check down

@ChkUp:
		btst	#0,d1			; is up pressed?
		beq.s	@EndInput		; if not, check if down is pressed
		move.w	d2,obVelY(a0)	; move sonic up
		moveq	#1,d0			; set to something was pressed

@EndInput:
		move.b	($FFFFFE05).w,d0
		andi.b	#%111,d0
		bne.s	@0

		cmpi.w 	#$F0, d3
		bge.s	@NormalSound
		
		move.w	#$C7,d0			; continously...
		jsr	(PlaySound_Special).l	; ... play sound while holding A (empty)
		bra.s 	@NothingPressedSet

@NormalSound:
		move.w	#$B8,d0			; continously...
		jsr	(PlaySound_Special).l	; ... play sound while holding A (still got juice)

@NothingPressedSet:
		moveq	#0,d0			; set to nothing was pressed

@0:
		cmpi.w	#$302,($FFFFFE10).w	; is level SLZ3?
		bne.s	AM_SetFlags		; if not, branch
		cmpi.w	#$1F00,($FFFFD008).w	; is Sonic at the end of the stage?
		bcc.w	AM_DontForceRoll	; if not, branch

AM_SetFlags:
		move.b	#2,obAnim(a0)		; use rolling animation
AM_DontForceRoll:
		move.b	#%11,($FFFFFFE5).w	; set flag


AF_Decel = $C0



AM_Decelerate_X:
		tst.w	obVelX(a0)			; test X speed
		beq.s	AM_Decelerate_Y		; is it already zero? skip
		bpl.s	@decelxfromright	; is it positive? branch
		addi.w	#AF_Decel,obVelX(a0)	; decelerate while moving left
		bcc.s	AM_Decelerate_Y		; did the sign change? if not, branch
		clr.w	obVelX(a0)			; if it did, set speed to 0
		bra.s	AM_Decelerate_Y
	@decelxfromright:
		subi.w	#AF_Decel,obVelX(a0)	; decelerate while moving right
		bcc.s	AM_Decelerate_Y		; did the sign change? if not, branch
		clr.w	obVelX(a0)			; if it did, set speed to 0
		
AM_Decelerate_Y:
		tst.w	obVelY(a0)			; test Y speed
		beq.s	AM_EndDecel		; is it already zero? skip
		bpl.s	@decelyfromdown		; is it positive? branch
		addi.w	#AF_Decel,obVelY(a0)	; decelerate while moving up
		bcc.s	AM_EndDecel		; did the sign change? if not, branch
		clr.w	obVelY(a0)			; if it did, set speed to 0
		bra.s	AM_EndDecel
	@decelyfromdown:
		subi.w	#AF_Decel,obVelY(a0)	; decelerate while moving down
		bcc.s	AM_EndDecel		; did the sign change? if not, branch
		clr.w	obVelY(a0)			; if it did, set speed to 0

AM_EndDecel:




	;	clr.w	obVelX(a0)		; clear X-velocity
	;	clr.w	obVelY(a0)		; clear Y-velocity
		clr.w	obInertia(a0)		; clear interia
		bra.w	AM_End
; ---------------------------------------------------------------------------

AM_LetGo:
		moveq	#0,d0			; set to nothing was pressed
		move.b 	#0, (Last_Direction) ; ^ ditto
		move.w 	#0, (C_HoldTimer)

		btst	#2,($FFFFF602).w	; is left pressed?
		beq.s	AM_ChkRight		; if not, check if down is pressed
		bset	#0,obStatus(a0)		; make Sonic fake the left
		move.w	#-AF_Speed,obVelX(a0)	; move sonic left
		move.w	#-AF_UpBoost,obVelY(a0)	; move sonic up a lil
		addq.b	#1,d0			; set to something was pressed
	;	bra.s	AM_ChkDown		; we don't need ot check right

AM_ChkRight:
		btst	#3,($FFFFF602).w	; is right pressed?
		beq.s	AM_ChkDown		; if not, branch
		bclr	#0,obStatus(a0)		; make Sonic fake the right
		move.w	#AF_Speed,obVelX(a0)	; move sonic right
		move.w	#-AF_UpBoost,obVelY(a0)	; move sonic up a lil
		addq.b	#1,d0			; set to something was pressed

AM_ChkDown:
		btst	#1,d1			; is down pressed?
		beq.s	AM_ChkUp		; if not, branch
		move.w	#AF_Speed,obVelY(a0)	; move sonic down
		addq.b	#1,d0			; set to something was pressed
	;	bra.s	AM_MoveEnd		; we don't need to check down

AM_ChkUp:
		btst	#0,d1			; is up pressed?
		beq.s	AM_MoveEnd		; if not, check if down is pressed
		move.w	#-AF_Speed,obVelY(a0)	; move sonic up
	;	tst.b	d0
	;	bne.s	@0
		subi.w	#AF_UpBoost,obVelY(a0)
@0:
		addq.b	#1,d0			; set to something was pressed

AM_MoveEnd:
		tst.b	d0			; was any action made?
		beq.s	AM_End			; if not, branch

		cmpi.b	#2,d0			; were both directions affected?
		blo.s	@notboth		; if not, branch
		move.w	obVelX(a0),d0
		asr.w	#1,d0
	;	move.w	d0,d1
	;	asr.w	#1,d1
	;	add.w	d1,d0
		move.w	d0,obVelX(a0)

		move.w	obVelY(a0),d0
		asr.w	#1,d0
	;	move.w	d0,d1
	;	asr.w	#1,d1
	;	add.w	d1,d0
		move.w	d0,obVelY(a0)

@notboth:
		move.b 	#0, (Last_Direction) ; clear last direction
		move.w	#$A9,d0			; play sound...
		jsr	(PlaySound_Special).l	; ...when letting go

AM_End:
		rts				; return
; End of function Sonic_AirMove

; ---------------------------------------------------------------------------
; Subroutine to	roll Sonic automaticly when he is in the air
; ---------------------------------------------------------------------------

Sonic_AutomaticRoll:
		tst.b	obAnim(a0)		; are we on the walking/running animations?
		beq.s	AR_ChangeAnim		; if yes, force roll
		cmpi.b	#$18,($FFFFF600).w	; are we in the ending sequence?
		beq.s	AR_End			; if yes, don't change animation to not mess up the gag
		cmpi.b	#$D,obAnim(a0)		; are we on the stopping animation (sliding off a platform)?
		bls.s	AR_ChangeAnim		; if yes, force roll
		bra.s	AR_End			; actually you know what fuck you A

AR_ChangeAnim:
		move.b	#2,obAnim(a0)		; change animation to rolling
	
AR_End:
		rts				; return
; End of function Sonic_AutomaticRoll

; ---------------------------------------------------------------------------
; Subroutine to shoot a buzz bomber missile
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Fire:
		tst.b	($FFFFFFE7).w		; is inhuman mode enabled?
		beq.w	S_F_End			; if not, don't do anything
		move.b	($FFFFF603).w,d0	; move button press to d0
		andi.b	#$40,d0			; and it by $40 (A)
		beq.w	S_F_End			; if A is not being pressed, branch
		bsr	SingleObjLoad		; check if SingleObjLoad is already in use
		bne.w	S_F_End			; if it is, don't do anything
		cmpi.w	#$001,($FFFFFE10).w	; is this the intro cutscene?
		bne.s	S_F_NotGHZ2		; if not branch
		tst.b	($FFFFFFB6).w		; has bullet already been fired for cutscene?
		bne.w	S_F_End			; if yes, branch
		move.b	#1,($FFFFFFB6).w	; mark bullet as fired for cutscene
		
S_F_NotGHZ2:
		move.b	#$23,0(a1)		; load missile object
		move.w	obX(a0),obX(a1)		; select sonic's current X-pos as destination point
		move.w	obY(a0),obY(a1)		; do the same with sonic's Y-pos
		

		; if no other D-pad button was held, shoot downwards by default
		move.w	#$200,obVelY(a1)	; move bullet downwards
		move.w	obVelY(a0),d1		; get Sonic's Y-speed
		cmpi.w	#$800,d1		; is Sonic falling faster than $800?
		bmi.s	S_F_WithinTolerance	; if not, branch
		add.w	d1,obVelY(a1)		; if yes, add his speed that to the total Y-speed of the bullet (so we don't outrun the missiles while falling down)
S_F_WithinTolerance:
		move.w	obVelX(a0),d0		; get Sonic's X-speed
		asr.w	#1,d0			; decrease the speed a lot
		move.w	d0,obVelX(a1)		; set that speed
		asr.w	#7,d0
		add.w	d0,obX(a1)		; move the missle a bit in front of Sonic

S_F_PlaySound:
		move.w	#$C4,d0			; set sound $C4
		jsr	(PlaySound_Special).l	; play exploding bomb sound

S_F_End:
		rts				; return
; End of function Sonic_Fire

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to jump
; ---------------------------------------------------------------------------

Sonic_Jump:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		move.b	($FFFFF603).w,d0
		andi.b	#$70,d0		; is A or B or C pressed?
		beq.w	locret_1348E	; if not, branch
		andi.b	#$40,d0		; was specifically A pressed?
		beq.s	@dojump		; if not, branch
		tst.b	($FFFFFF77).w	; is antigrav enabled?
		bne.s	@dojump		; if yes, then and only then, allow jump on A
		rts			; otherwise disallow jump to not interfere with other stuff

@dojump:
		moveq	#0,d0
		move.b	obAngle(a0),d0
		addi.b	#$80,d0
		bsr	sub_14D48
		cmpi.w	#6,d1
		blt.w	locret_1348E
		move.w	#$680,d2
		btst	#6,obStatus(a0)
		beq.s	loc_1341C
		move.w	#$380,d2

loc_1341C:
		moveq	#0,d0
		move.b	obAngle(a0),d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	d2,d1
		asr.l	#8,d1
		add.w	d1,obVelX(a0)	; make Sonic jump
		muls.w	d2,d0
		asr.l	#8,d0
		add.w	d0,obVelY(a0)	; make Sonic jump
		bset	#1,obStatus(a0)
		bclr	#5,obStatus(a0)
		addq.l	#4,sp
		move.b	#1,$3C(a0)
		clr.b	$38(a0)
		move.w	#$A0,d0
		jsr	(PlaySound_Special).l ;	play jumping sound
		move.b	#$13,obHeight(a0)
		move.b	#9,obWidth(a0)
		btst	#2,obStatus(a0)
		bne.s	loc_13490
		move.b	#$E,obHeight(a0)
		move.b	#7,obWidth(a0)
		move.b	#2,obAnim(a0)	; use "jumping"	animation
		bset	#2,obStatus(a0)
		addq.w	#5,obY(a0)

		tst.b	($FFFFFF77).w		; is antigrav enabled?
		beq.s	locret_1348E		; if not, branch
		btst	#6,($FFFFF603).w	; was specifically A pressed to jump?
		beq.s	locret_1348E
		clr.w	obVelY(a0)

locret_1348E:
		rts	
; ===========================================================================

loc_13490:
		bset	#4,obStatus(a0)
		rts	
; End of function Sonic_Jump


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_JumpHeight:			; XREF: Obj01_MdJump; Obj01_MdJump2
		tst.b	($FFFFFFE5).w		; is air freeze active?
		bne.s	locret_134C2		; if yes, don't mess with speeds
		
		tst.b	$3C(a0)
		beq.s	loc_134C4
		move.w	#-$400,d1
		btst	#6,obStatus(a0)
		beq.s	loc_134AE
		move.w	#-$200,d1

loc_134AE:
		cmp.w	obVelY(a0),d1
		ble.s	locret_134C2
		move.b	($FFFFF602).w,d0
		andi.b	#$70,d0		; is A or B or C still held?
		bne.s	locret_134C2	; if yes, branch
		move.w	d1,obVelY(a0)

locret_134C2:
		rts	
; ===========================================================================

loc_134C4:
		cmpi.w	#-$FC0,obVelY(a0)
		bge.s	locret_134D2
		move.w	#-$FC0,obVelY(a0)

locret_134D2:
		rts	
; End of function Sonic_JumpHeight

; ---------------------------------------------------------------------------
; Subroutine to	slow Sonic walking up a	slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_SlopeResist:			; XREF: Obj01_MdNormal
		move.b	obAngle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#$C0,d0
		bcc.s	locret_13508
		move.b	obAngle(a0),d0
		jsr	(CalcSine).l
		muls.w	#$20,d0
		asr.l	#8,d0
		tst.w	obInertia(a0)
		beq.s	locret_13508
		bmi.s	loc_13504
		tst.w	d0
		beq.s	locret_13502
		add.w	d0,obInertia(a0)	; change Sonic's inertia

locret_13502:
		rts	
; ===========================================================================

loc_13504:
		add.w	d0,obInertia(a0)

locret_13508:
		rts	
; End of function Sonic_SlopeResist

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope	while he's rolling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_RollRepel:			; XREF: Obj01_MdRoll
		move.b	obAngle(a0),d0
		addi.b	#$60,d0
		cmpi.b	#-$40,d0
		bcc.s	locret_13544
		move.b	obAngle(a0),d0
		jsr	(CalcSine).l
		muls.w	#$50,d0
		asr.l	#8,d0
		tst.w	obInertia(a0)
		bmi.s	loc_1353A
		tst.w	d0
		bpl.s	loc_13534
		asr.l	#2,d0

loc_13534:
		add.w	d0,obInertia(a0)
		rts	
; ===========================================================================

loc_1353A:
		tst.w	d0
		bmi.s	loc_13540
		asr.l	#2,d0

loc_13540:
		add.w	d0,obInertia(a0)

locret_13544:
		rts	
; End of function Sonic_RollRepel

; ---------------------------------------------------------------------------
; Subroutine to	push Sonic down	a slope
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_SlopeRepel:			; XREF: Obj01_MdNormal; Obj01_MdRoll
		nop	
		tst.b	$38(a0)
		bne.s	locret_13580
		tst.w	$3E(a0)
		bne.s	loc_13582
		move.b	obAngle(a0),d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		beq.s	locret_13580
		move.w	obInertia(a0),d0
		bpl.s	loc_1356A
		neg.w	d0

loc_1356A:
		cmpi.w	#$280,d0
		bcc.s	locret_13580
		clr.w	obInertia(a0)
		bset	#1,obStatus(a0)
		move.w	#$1E,$3E(a0)

locret_13580:
		rts	
; ===========================================================================

loc_13582:
		subq.w	#1,$3E(a0)
		rts	
; End of function Sonic_SlopeRepel

; ---------------------------------------------------------------------------
; Subroutine to	return Sonic's angle to 0 as he jumps
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_JumpAngle:			; XREF: Obj01_MdJump; Obj01_MdJump2
		move.b	obAngle(a0),d0	; get Sonic's angle
		beq.s	locret_135A2	; if already 0,	branch
		bpl.s	loc_13598	; if higher than 0, branch

		addq.b	#2,d0		; increase angle
		bcc.s	loc_13596
		moveq	#0,d0

loc_13596:
		bra.s	loc_1359E
; ===========================================================================

loc_13598:
		subq.b	#2,d0		; decrease angle
		bcc.s	loc_1359E
		moveq	#0,d0

loc_1359E:
		move.b	d0,obAngle(a0)

locret_135A2:
		rts	
; End of function Sonic_JumpAngle

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to control what happens when the player touches the wall
; ---------------------------------------------------------------------------
SAP_FranticRings = 5
; ---------------------------------------------------------------------------

; SLZHitWall:
SAP_HitWall:
		cmpi.w	#$302,($FFFFFE10).w		; are we in SAP?
		bne.w	@end				; if not, branch
		tst.b	($FFFFFF77).w			; is antigrav enabled?
		beq.w	@end				; if not, branch
		tst.b	($FFFFF7CC).w			; are controls locked?
		bne.w	@end				; if yes, branch (this is for the ending sequence)

		frantic					; are we in frantic mode?
		beq.s	@resetstuff			; if not, branch
		ori.b	#1,($FFFFFE1D).w		; update ring counter
		
		cmpi.w	#SAP_FranticRings,($FFFFFE20).w	; do you have enough rings to tank the hit?
		bpl.s	@tankhit			; if yes, branch
		move.w	($FFFFFE20).w,(FranticDrain).w	; drain whatever rings remain
		jmp	KillSonic			; you hecking died noob
@tankhit:
		addq.w	#SAP_FranticRings,(FranticDrain).w	; add ring drain penalty
; ---------------------------------------------------------------------------

@resetstuff:
		move.w	#$0EC0,d0			; set default respawn X position
		move.w	#$0340,d1			; set default respawn Y position
		tst.w	($FFFFFF86).w			; at least one checkpoint touched yet?
		beq.s	@nocheckpoint			; if not, branch
		move.w	($FFFFFF86).w,d0		; restore saved X-position for Sonic
		move.w	($FFFFFF88).w,d1		; restore saved Y-position for Sonic
@nocheckpoint:
		move.w	d0,obX(a0)			; set respawn X position
		move.w	d1,obY(a0)			; set respawn Y position

		move.b	#1,(RedrawEverything).w		; instantly move the camera to where Sonic teleported to

		clr.b	($FFFFFFE5).w			; clear air freeze flags
		clr.w	obVelX(a0)			; clear X speed
		clr.w	obVelY(a0)			; clear Y speed
		clr.w	obInertia(a0)			; clear inertia
		move.b	#2,obAnim(a0)			; use rolling animation
		bset	#1,obStatus(a0)			; set status to be airborne

		move.b	#$C3,d0				; play flash sound
		jsr	PlaySound_Special		; really hope this won't get on your nerves
		jsr	WhiteFlash2			; do a white flash

		tst.b	($FFFFFFE1).w			; has the P monitor been destroyed?
		beq.s	@notp				; if not, branch
		clr.b	($FFFFFFE1).w			; clear P monitor flag
		jsr	SAP_ResetP			; reset P monitor
		move.w	#$1480,d0
		move.w	#$0380,d1
		move.b	#$4F,d2
		move.l	a0,-(sp)
		jsr	Sub_ChangeChunk			; reset blocker chunk
		move.l	(sp)+,a0

@notp:
		cmpi.b	#6,($FFFFFFA0).w		; have all 6 emblems been collected?
		blt.s	@resetloop			; if not, branch
		cmpi.w	#$1EE0,($FFFFFF86).w		; has the final checkpoint been touched?
		bne.s	@resetloop			; if not, branch
		moveq	#2,d0				; keep loop unlocked on the right
		jsr	SAP_SetLoopState		; set loop state
		bra.s	@end				; skip

@resetloop:
		clr.b	($FFFFFFA0).w			; reset emblem counter
		moveq	#0,d0				; reset loop challenge state
		jsr	SAP_SetLoopState		; set loop state
		jsr	SAP_ResetEmblems		; reset the 6th emblem

@end:
		rts
; ===========================================================================

SAP_LoadSonicPal:
		; load antigrav palette for Sonic
		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		beq.s	@nopal			; if not, don't mess with Sonic
		moveq	#$11,d0			; load Sonic's antigrav palette line in palette line 2
		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		beq.s	@loadpal		; if not, branch
		moveq	#$10,d0			; load it into palette line 1 instead
@loadpal:
		movem.l	d7/a1-a3,-(sp)
		jsr	PalLoad2
		movem.l	(sp)+,d7/a1-a3
@nopal:
		rts
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine for Sonic to interact with	the floor after	jumping/falling
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Floor:				; XREF: Obj01_MdJump; Obj01_MdJump2
		move.w	obVelX(a0),d1
		move.w	obVelY(a0),d2
		jsr	(CalcAngle).l
		move.b	d0,($FFFFFFEC).w
		subi.b	#$20,d0
		move.b	d0,($FFFFFFED).w
		andi.b	#$C0,d0
		move.b	d0,($FFFFFFEE).w
		cmpi.b	#$40,d0
		beq.w	loc_13680
		cmpi.b	#$80,d0
		beq.w	loc_136E2
		cmpi.b	#-$40,d0
		beq.w	loc_1373E
		bsr	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_135F0
		sub.w	d1,obX(a0)
		move.w	#0,obVelX(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

loc_135F0:
		bsr	sub_14EB4
		tst.w	d1
		bpl.s	loc_13602
		add.w	d1,obX(a0)
		move.w	#0,obVelX(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

loc_13602:
		bsr	Sonic_HitFloor
		move.b	d1,($FFFFFFEF).w
		tst.w	d1
		bpl.w	locret_1367E
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3
		move.b	obVelY(a0),d2
		addq.b	#8,d2
		neg.b	d2
		cmp.b	d2,d1
		bge.s	loc_1361E
		cmp.b	d2,d0
		blt.s	locret_1367E

loc_1361E:
		add.w	d1,obY(a0)
		move.b	d3,obAngle(a0)
		bsr	Sonic_ResetOnFloor
		move.b	#0,obAnim(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_1365C
		move.b	d3,d0
		addi.b	#$10,d0
		andi.b	#$20,d0
		beq.s	loc_1364E
		asr	obVelY(a0)
		bra.s	loc_13670
; ===========================================================================

loc_1364E:
		move.w	#0,obVelY(a0)
		move.w	obVelX(a0),obInertia(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3
		rts	
; ===========================================================================

loc_1365C:
		move.w	#0,obVelX(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3
		cmpi.w	#$FC0,obVelY(a0)
		ble.s	loc_13670
		move.w	#$FC0,obVelY(a0)

loc_13670:
		move.w	obVelY(a0),obInertia(a0)
		tst.b	d3
		bpl.s	locret_1367E
		neg.w	obInertia(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

locret_1367E:
		rts	
; ===========================================================================

loc_13680:
		bsr	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_1369A
		sub.w	d1,obX(a0)
		move.w	#0,obVelX(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3
		move.w	obVelY(a0),obInertia(a0)
		rts	
; ===========================================================================

loc_1369A:
		bsr	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_136B4
		sub.w	d1,obY(a0)
		tst.w	obVelY(a0)
		bpl.s	locret_136B2
		move.w	#0,obVelY(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

locret_136B2:
		rts	
; ===========================================================================

loc_136B4:
		tst.w	obVelY(a0)
		bmi.s	locret_136E0
		bsr	Sonic_HitFloor
		tst.w	d1
		bpl.s	locret_136E0
		add.w	d1,obY(a0)
		move.b	d3,obAngle(a0)
		bsr	Sonic_ResetOnFloor
		move.b	#0,obAnim(a0)
		move.w	#0,obVelY(a0)
		move.w	obVelX(a0),obInertia(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

locret_136E0:
		rts	
; ===========================================================================

loc_136E2:
		bsr	Sonic_HitWall
		tst.w	d1
		bpl.s	loc_136F4
		sub.w	d1,obX(a0)
		move.w	#0,obVelX(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

loc_136F4:
		bsr	sub_14EB4
		tst.w	d1
		bpl.s	loc_13706
		add.w	d1,obX(a0)
		move.w	#0,obVelX(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

loc_13706:
		bsr	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	locret_1373C
		sub.w	d1,obY(a0)
		move.b	d3,d0
		addi.b	#$20,d0
		andi.b	#$40,d0
		bne.s	loc_13726
		move.w	#0,obVelY(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3
		rts	
; ===========================================================================

loc_13726:
		move.b	d3,obAngle(a0)
		bsr	Sonic_ResetOnFloor
		move.w	obVelY(a0),obInertia(a0)
		tst.b	d3
		bpl.s	locret_1373C
		neg.w	obInertia(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

locret_1373C:
		rts	
; ===========================================================================

loc_1373E:
		bsr	sub_14EB4
		tst.w	d1
		bpl.s	loc_13758
		add.w	d1,obX(a0)
		move.w	#0,obVelX(a0)
		move.w	obVelY(a0),obInertia(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3
		rts	
; ===========================================================================

loc_13758:
		bsr	Sonic_DontRunOnWalls
		tst.w	d1
		bpl.s	loc_13772
		sub.w	d1,obY(a0)
		tst.w	obVelY(a0)
		bpl.s	locret_13770
		move.w	#0,obVelY(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

locret_13770:
		rts	
; ===========================================================================

loc_13772:
		tst.w	obVelY(a0)
		bmi.s	locret_1379E
		bsr	Sonic_HitFloor
		tst.w	d1
		bpl.s	locret_1379E
		add.w	d1,obY(a0)
		move.b	d3,obAngle(a0)
		bsr	Sonic_ResetOnFloor
		move.b	#0,obAnim(a0)
		move.w	#0,obVelY(a0)
		move.w	obVelX(a0),obInertia(a0)
		bsr.w	SAP_HitWall	; teleport Sonic in SLZ3

locret_1379E:
		rts	
; End of function Sonic_Floor

; ---------------------------------------------------------------------------
; Subroutine to	reset Sonic's mode when he lands on the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_ResetOnFloor:			; XREF: PlatformObject; et al
		cmpi.w	#$400,($FFFFFE10).w
		bne.s	@cont
		tst.b	($FFFFFF7F).w
		bne.s	@cont
		move.b	#1,($FFFFFF7F).w
		move.b	#0,($FFFFF7CC).w
@cont:

		bclr	#1,($FFFFFFE5).w	; clear air-freeze flag
		clr.b	($FFFFFFEB).w	; clear jumpdash flag
		clr.b	($FFFFFFAD).w	; clear jumpdash flag for afterimage
		clr.b	($FFFFFF96).w
		move.b	#1,($FFFFFFB8).w
		bclr	#3,obStatus(a0)	; clear "standing on object" flag
		
		cmpi.w	#$601,($FFFFFE10).w	; is this the ending sequence?
		bne.s	@conty			; if not, branch
		jsr	SetEndingSpeeds
		
@conty:
		cmpi.w	#$502,($FFFFFE10).w	; is level FZ?
		bne.s	S_ROF_NotFZ		; if not branch
		move.w	#Sonic_TopSpeed,($FFFFF760).w	; restore Sonic's speed
		move.w	#Sonic_Acceleration,($FFFFF762).w	; restore Sonic's acceleration
S_ROF_NotFZ:
		bclr	#5,obStatus(a0)
		bclr	#1,obStatus(a0)
		bclr	#4,obStatus(a0)
		btst	#2,obStatus(a0)
		beq.s	loc_137E4
		bclr	#2,obStatus(a0)
		move.b	#$13,obHeight(a0)
		move.b	#9,obWidth(a0)
		move.b	#0,obAnim(a0)	; use running/walking animation
		subq.w	#5,obY(a0)

loc_137E4:
		move.b	#0,$3C(a0)
		move.w	#0,($FFFFF7D0).w
		rts	
; End of function Sonic_ResetOnFloor

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	gets hurt
; ---------------------------------------------------------------------------

Obj01_Hurt:				; XREF: Obj01_Index
		clr.b	($FFFFFFAF).w	; clear automatic extended camera flag

		cmpi.b	#$1A,obAnim(a0)	; is animation $1A (hurting)?
		beq.s	Hurt_CorrectAni	; if yes, branch
		move.b	#$1A,obAnim(a0)	; otherwise make sure the correct anim is being used

Hurt_CorrectAni:
		jsr	SpeedToPos
		addi.w	#$30,obVelY(a0)
		btst	#6,obStatus(a0)
		beq.s	loc_1380C
		subi.w	#$20,obVelY(a0)

loc_1380C:
		bsr	Sonic_Display
		bsr	Sonic_HurtStop
		bsr	Sonic_LevelBound
		bsr	Sonic_RecordPos
		bsr	Sonic_Water
		bsr	Sonic_Animate
		bsr	LoadSonicDynPLC
		rts

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic falling after he's been hurt
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HurtStop:				; XREF: Obj01_Hurt
		move.w	($FFFFF72E).w,d0
		addi.w	#$E0,d0
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	S_H_NoTeleport		; if not, branch
		cmpi.w	#$18B0,obX(a0)		; is Sonic past the X-location $18B0?
		bpl.s	S_H_NoTeleport		; if yes, branch
		cmpi.w	#$1340,obX(a0)		; is Sonic before the X-location $1340?
		bmi.s	S_H_NoTeleport		; if yes, branch
		cmpi.w	#$4E0,obY(a0)		; is Sonic above the Y-location $3E0?
		bmi.s	S_H_NoKillCheck		; if yes, branch
		move.b	#2,obRoutine(a0)		; set to normal
		bra.s	S_H_NoKillCheck		; don't check for boundary death
; ===========================================================================

S_H_NoTeleport:	
		cmp.w	obY(a0),d0
		bcs.s	KSJMP2

S_H_NoKillCheck:
		bsr	Sonic_Floor
		btst	#1,obStatus(a0)
		bne.s	locret_13860
		moveq	#0,d0
		move.w	d0,obVelY(a0)
		move.w	d0,obVelX(a0)
		move.w	d0,obInertia(a0)
		move.b	#0,obAnim(a0)
		subq.b	#2,obRoutine(a0)
		move.w	#0,$30(a0)		; set invin time to 0
		tst.b	($FFFFFF72).w
		beq.s	S_H_NoGHZBoss
		clr.b	($FFFFFF72).w
		rts

S_H_NoGHZBoss:
		move.w	#$78,$30(a0)		; otherwise set invin time to $78

locret_13860:
		rts
; ===========================================================================

KSJMP2:
		jmp	KillSonic
; End of function Sonic_HurtStop

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when he	dies
; ---------------------------------------------------------------------------

Obj01_Death:				; XREF: Obj01_Index
		cmpi.w	#$601,($FFFFFE10).w	; is this the ending sequence?
		bne.s	Obj01_Death_NoMS	; if not, branch
		move.b	#$E4,d0
		jsr	PlaySound_Special ; stop music

Obj01_Death_NoMS:
		cmpi.b	#$17,obAnim(a0)		; is drowing animation being showed?
		bne.s	Obj01_NotDrownAnim	; if not, branch
		bset	#7,obGfx(a0)		; make sonic being on the foreground

Obj01_NotDrownAnim:
		tst.b	obAnim(a0)		; are we for some random reason using the walking animation?
		beq.s	@fixanime		; if yes, branch
		cmpi.b	#2,obAnim(a0)		; are we in the rolling animation?
		bne.s	@noanimfix		; if not, branch
@fixanime:
		move.b	#$25,obAnim(a0)		; force death animation

@noanimfix:
		clr.b	(HUD_BossHealth).w
		addq.b	#1,($FFFFFE1C).w ; update lives	counter
		bsr	GameOver
		
		bra.s	Obj01_NoOF	; disabled the "laying face-first on floor for a bit" effect from death cause nobody was getting it
		
		cmpi.w	#$302,($FFFFFE10).w
		beq.s	Obj01_NoOF
		tst.w	obVelY(a0)		; is Sonic moving upwards?
		bmi.s	Obj01_NoOF	; if yes, branch
		cmpi.w	#$101,($FFFFFE10).w	; is level LZ2?
		beq.s	Obj01_NoOF	; if yes, branch (too many walls to make the effect not suck)
		cmpi.w	#$002,($FFFFFE10).w	; is level GHP?
		beq.s	Obj01_NoOF	; if yes, branch
		bsr	ObjHitFloor	; load from ObjHitFloor
		add.w	#10,d1		; sub 10 from it
		tst.w	d1		; did Sonic reached that position?
		bpl.s	Obj01_NoOF	; if not, branch
		move.w	#0,obVelX(a0)	; clear X-speed
		subq.b	#1,($FFFFFFDD).w ; sub one from timer
		bmi.s	Obj01_NoOFX	; is it over? if yes, branch
		move.w	#0,obVelY(a0)	; clear Y-speed
		move.b	#$2B,obAnim(a0)	; set anim to laying death on ground
		bra.s	Obj01_NoOF

Obj01_NoOFX:
		move.b	#$2C,obAnim(a0)	; set anim to drowning 2

Obj01_NoOF:
		jsr	ObjectFall
		bsr	Sonic_RecordPos
		bsr	Sonic_Animate
		bsr	LoadSonicDynPLC
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


GameOver:				; XREF: Obj01_Death
		move.w	($FFFFF704).w,d0
		addi.w	#$230,d0 		; used to be $100, increased for comedic timing
		cmp.w	obY(a0),d0
		bge.w	locret_13900
		move.b	#$A9,d0			; play blip sound as the death counter goes up
		jsr	PlaySound_Special
		addi.w	#$10,($FFFFD480+obScreenY).w	; bounce death counter
		addq.b	#2,obRoutine(a0)
		cmpi.b	#$18,($FFFFF600).w
		bne.s	@cont
		bra.s	loc_138D4

@cont:
		clr.b	($FFFFFE1E).w		; stop time counter
		ori.b	#1,($FFFFFE1C).w	; update lives counter
		addq.w	#1,($FFFFFE12).w	; add one death
	;	addi.w	#47,($FFFFFE12).w	; add a ton of deaths of testing
		cmpi.w	#999,($FFFFFE12).w	; are we at 999 deaths?
		blo.s	loc_138D4		; if not, branch
		move.w	#999,($FFFFFE12).w	; holy shit you suck at video games. cap the counter

loc_138D4:
		move.w	#60,$3A(a0)	; set time delay to 60 frames
		cmpi.w	#$601,($FFFFFE10).w	; is this the ending sequence?
		bne.s	locret_13900	; if not, branch
		move.w	#240,$3A(a0)	; set time delay to 240 frames instead

locret_13900:
		rts	
; End of function GameOver

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic	when the level is restarted
; ---------------------------------------------------------------------------

Obj01_ResetLevelX:			; XREF: Obj01_Index
		tst.w	$3A(a0)
		beq.s	locret_13914
		subq.w	#1,$3A(a0)	; subtract 1 from time delay
		bne.s	locret_13914
		move.w	#1,($FFFFFE02).w ; restart the level

locret_13914:
		rts
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Sonic when he's drowning
; ---------------------------------------------------------------------------
 
Sonic_Drowned:
		jsr	SpeedToPos	; Make Sonic able to move
		addi.w	#$10,obVelY(a0)	; Apply gravity
		bsr.w	Sonic_RecordPos	; Record position
		jsr	Sonic_Animate	; Animate Sonic
		bsr.w	LoadSonicDynPLC	; Load Sonic's DPLCs
		jsr	DisplaySprite	; And finally, display Sonic
; ===========================================================================

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic run around loops (GHZ/SLZ)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Loops:				; XREF: Obj01_Control
		cmpi.b	#3,CurrentZone	; is level SLZ ?
		beq.s	loc_13926	; if yes, branch
		tst.b	CurrentZone	; is level GHZ ?
		bne.w	locret_139C2	; if not, branch

loc_13926:
		move.w	obY(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C0,d0
		move.b	obX(a0),d1
		andi.w	#$3F,d1
		add.w	d1,d0
		lea	LevelLayout_FG, a1
		move.b	(a1,d0.w),d1	; d1 is	the 256x256 tile Sonic is currently on
		cmp.b	($FFFFF7AE).w,d1
		beq.w	Obj01_ChkRoll
		cmp.b	($FFFFF7AF).w,d1
		beq.w	Obj01_ChkRoll
		cmp.b	($FFFFF7AC).w,d1
		beq.s	loc_13976
		cmp.b	($FFFFF7AD).w,d1
		beq.s	loc_13966
		bclr	#6,obRender(a0)
		rts	
; ===========================================================================

loc_13966:
		btst	#1,obStatus(a0)
		beq.s	loc_13976
		bclr	#6,obRender(a0)	; send Sonic to	high plane
		rts	
; ===========================================================================

loc_13976:
		move.w	obX(a0),d2
		cmpi.b	#$2C,d2
		bcc.s	loc_13988
		bclr	#6,obRender(a0)	; send Sonic to	high plane
		rts	
; ===========================================================================

loc_13988:
		cmpi.b	#-$20,d2
		bcs.s	loc_13996
		bset	#6,obRender(a0)	; send Sonic to	low plane
		rts	
; ===========================================================================

loc_13996:
		btst	#6,obRender(a0)
		bne.s	loc_139B2
		move.b	obAngle(a0),d1
		beq.s	locret_139C2
		cmpi.b	#-$80,d1
		bhi.s	locret_139C2
		bset	#6,obRender(a0)	; send Sonic to	low plane
		rts	
; ===========================================================================

loc_139B2:
		move.b	obAngle(a0),d1
		cmpi.b	#-$80,d1
		bls.s	locret_139C2
		bclr	#6,obRender(a0)	; send Sonic to	high plane

locret_139C2:
		rts	
; End of function Sonic_Loops

; ---------------------------------------------------------------------------
; Subroutine to	animate	Sonic's sprites
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Animate:				; XREF: Obj01_Control; et al
		lea	(SonicAniData).l,a1
		moveq	#0,d0
		move.b	obAnim(a0),d0
		cmp.b	obNextAni(a0),d0	; is animation set to restart?
		beq.s	SAnim_Do	; if not, branch
		move.b	d0,obNextAni(a0)	; set to "no restart"
		move.b	#0,obAniFrame(a0)	; reset	animation
		move.b	#0,obTimeFrame(a0)	; reset	frame duration

SAnim_Do:
		add.w	d0,d0
		adda.w	(a1,d0.w),a1	; jump to appropriate animation	script
		move.b	(a1),d0
		bmi.s	SAnim_WalkRun	; if animation is walk/run/roll/jump, branch
		move.b	obStatus(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,obRender(a0)
		or.b	d1,obRender(a0)
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		move.b	d0,obTimeFrame(a0)	; load frame duration

SAnim_Do2:
		moveq	#0,d1
		move.b	obAniFrame(a0),d1	; load current frame number
		move.b	obRender(a1,d1.w),d0	; read sprite number from script
		bmi.s	SAnim_End_FF	; if animation is complete, branch

SAnim_Next:
		move.b	d0,obFrame(a0)	; load sprite number
		addq.b	#1,obAniFrame(a0)	; next frame number

SAnim_Delay:
		rts	
; ===========================================================================

SAnim_End_FF:
		addq.b	#1,d0		; is the end flag = $FF	?
		bne.s	SAnim_End_FE	; if not, branch
		move.b	#0,obAniFrame(a0)	; restart the animation
		move.b	obRender(a1),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FE:
		addq.b	#1,d0		; is the end flag = $FE	?
		bne.s	SAnim_End_FD	; if not, branch
		move.b	obGfx(a1,d1.w),d0	; read the next	byte in	the script
		sub.b	d0,obAniFrame(a0)	; jump back d0 bytes in	the script
		sub.b	d0,d1
		move.b	obRender(a1,d1.w),d0	; read sprite number
		bra.s	SAnim_Next
; ===========================================================================

SAnim_End_FD:
		addq.b	#1,d0		; is the end flag = $FD	?
		bne.s	SAnim_End	; if not, branch
		move.b	obGfx(a1,d1.w),obAnim(a0) ; read next byte, run that animation

SAnim_End:
		rts	
; ===========================================================================

SAnim_WalkRun:				; XREF: SAnim_Do
		subq.b	#1,obTimeFrame(a0)	; subtract 1 from frame	duration
		bpl.s	SAnim_Delay	; if time remains, branch
		addq.b	#1,d0		; is animation walking/running?
		bne.w	SAnim_RollJump	; if not, branch
		moveq	#0,d1
		move.b	obAngle(a0),d0	; get Sonic's angle
		move.b	obStatus(a0),d2
		andi.b	#1,d2		; is Sonic mirrored horizontally?
		bne.s	loc_13A70	; if yes, branch
		not.b	d0		; reverse angle

loc_13A70:
		addi.b	#$10,d0		; add $10 to angle
		bpl.s	loc_13A78	; if angle is $0-$7F, branch
		moveq	#3,d1

loc_13A78:
		andi.b	#$FC,obRender(a0)
		eor.b	d1,d2
		or.b	d2,obRender(a0)
		btst	#5,obStatus(a0)
		bne.w	SAnim_Push
		lsr.b	#4,d0		; divide angle by $10
		andi.b	#6,d0		; angle	must be	0, 2, 4	or 6
		move.w	obInertia(a0),d2	; get Sonic's speed
		bpl.s	Sonic_TestSpeed
		neg.w	d2
		
;loc_13A9C:
Sonic_TestSpeed:
		lea	(SonAni_FastRunning).l,a1	; use figure-8 sprinting animation
		cmpi.w	#$A00,d2			; is Sonic running faster than $A00 units?
		bhs.s	loc_13AB4			; if yes, branch
		cmpi.w	#$001,($FFFFFE10).w		; is this the intro sequence?
		beq.s	loc_13AB4			; if yes, force figure-8 animation (for the swag)

		lea	(SonAni_Run).l,a1		; use regular running animation
		cmpi.w	#$600,d2			; is Sonic at running speed?
		bhs.s	loc_13AB4			; if yes, branch

		lea	(SonAni_Walk).l,a1		; use walking animation
		move.b	d0,d1
		lsr.b	#1,d1
		add.b	d1,d0

loc_13AB4:
		add.b	d0,d0
		move.b	d0,d3
		neg.w	d2
		addi.w	#$800,d2
		bpl.s	loc_13AC2
		moveq	#0,d2

loc_13AC2:
		lsr.w	#8,d2
		move.b	d2,obTimeFrame(a0)	; modify frame duration
		bsr	SAnim_Do2
		add.b	d3,obFrame(a0)	; modify frame number
		rts	
; ===========================================================================

SAnim_RollJump:				; XREF: SAnim_WalkRun
		addq.b	#1,d0		; is animation rolling/jumping?
		bne.s	SAnim_Push	; if not, branch
		move.w	obInertia(a0),d2	; get Sonic's speed
		bpl.s	loc_13ADE
		neg.w	d2

loc_13ADE:
		lea	(SonAni_Roll2).l,a1 ; use fast animation
		cmpi.w	#$600,d2	; is Sonic moving fast?
		bcc.s	loc_13AF0	; if yes, branch
		btst	#1,($FFFFFFE5).w ; air freeze active?
		beq.s	@cont		; if not, branch
		move.w	#$700,d2	; always use fast rolling animation while air freezing
		bra.s	loc_13AF0
	@cont:
		lea	(SonAni_Roll).l,a1 ; use slower	animation

loc_13AF0:
		neg.w	d2
		addi.w	#$400,d2
		bpl.s	loc_13AFA
		moveq	#0,d2

loc_13AFA:
		lsr.w	#8,d2
		move.b	d2,obTimeFrame(a0)	; modify frame duration
		move.b	obStatus(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,obRender(a0)
		or.b	d1,obRender(a0)
		bra.w	SAnim_Do2
; ===========================================================================

SAnim_Push:				; XREF: SAnim_RollJump
		cmpi.w	#$302,($FFFFFE10).w
		bne.s	@cont
		tst.b	($FFFFFF77).w
		beq.s	@cont
		jsr	SAP_HitWall

@cont:
		move.w	obInertia(a0),d2	; get Sonic's speed
		bmi.s	loc_13B1E
		neg.w	d2

loc_13B1E:
		addi.w	#$800,d2
		bpl.s	loc_13B26
		moveq	#0,d2

loc_13B26:
		lsr.w	#6,d2
		move.b	d2,obTimeFrame(a0)	; modify frame duration
		lea	(SonAni_Push).l,a1
		move.b	obStatus(a0),d1
		andi.b	#1,d1
		andi.b	#$FC,obRender(a0)
		or.b	d1,obRender(a0)
		bra.w	SAnim_Do2
; End of function Sonic_Animate

; ===========================================================================
SonicAniData:
		include	"_anim\Sonic.asm"
		
; ---------------------------------------------------------------------------
; Sonic	pattern	loading	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadSonicDynPLC:			; XREF: Obj01_Control; et al
		moveq	#0,d0
		move.b	obFrame(a0),d0	; load frame number
		cmp.b	($FFFFF766).w,d0
		beq.s	locret_13C96
		move.b	d0,($FFFFF766).w
		lea	(SonicDynPLC).l,a2
		add.w	d0,d0
		adda.w	(a2,d0.w),a2
		moveq	#0,d5
		move.b	(a2)+,d5
		subq.w	#1,d5
		bmi.s	locret_13C96
		move.w	#$F000,d4
		move.l	#Art_Sonic,d6

SPLC_ReadEntry:
		moveq	#0,d1
		move.b	(a2)+,d1
		lsl.w	#8,d1
		move.b	(a2)+,d1
		move.w	d1,d3
		lsr.w	#8,d3
		andi.w	#$F0,d3
		addi.w	#$10,d3
		andi.w	#$FFF,d1
		lsl.l	#5,d1
		add.l	d6,d1
		move.w	d4,d2
		add.w	d3,d4
		add.w	d3,d4
		jsr	(QueueDMATransfer).l
		dbf	d5,SPLC_ReadEntry	; repeat for number of entries

locret_13C96:
		rts	
; End of function LoadSonicDynPLC

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 0A - drowning countdown numbers and small bubbles (LZ)
; ---------------------------------------------------------------------------

Obj0A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj0A_Index(pc,d0.w),d1
		jmp	Obj0A_Index(pc,d1.w)
; ===========================================================================
Obj0A_Index:	dc.w Obj0A_Main-Obj0A_Index, Obj0A_Animate-Obj0A_Index
		dc.w Obj0A_ChkWater-Obj0A_Index, Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index,	Obj0A_Countdown-Obj0A_Index
		dc.w Obj0A_AirLeft-Obj0A_Index,	Obj0A_Display-Obj0A_Index
		dc.w Obj0A_Delete2-Obj0A_Index
; ===========================================================================

Obj0A_Main:				; XREF: Obj0A_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj64,obMap(a0)
		move.w	#$8348,obGfx(a0)
		move.b	#$84,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#1,obPriority(a0)
		move.b	obSubtype(a0),d0
		bpl.s	loc_13D00
		addq.b	#8,obRoutine(a0)
		move.l	#Map_obj0A,obMap(a0)
		move.w	#$440,obGfx(a0)
		andi.w	#$7F,d0
		move.b	d0,$33(a0)
		bra.w	Obj0A_Countdown
; ===========================================================================

loc_13D00:
		move.b	d0,obAnim(a0)
		move.w	obX(a0),$30(a0)
		move.w	#-$88,obVelY(a0)

Obj0A_Animate:				; XREF: Obj0A_Index
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite

Obj0A_ChkWater:				; XREF: Obj0A_Index
		move.w	($FFFFF646).w,d0
		cmp.w	obY(a0),d0	; has bubble reached the water surface?
		bcs.s	Obj0A_Wobble	; if not, branch
		move.b	#6,obRoutine(a0)
		addq.b	#7,obAnim(a0)
		cmpi.b	#$D,obAnim(a0)
		beq.s	Obj0A_Display
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Wobble:
		tst.b	($FFFFF7C7).w
		beq.s	loc_13D44
		addq.w	#4,$30(a0)

loc_13D44:
		move.b	obAngle(a0),d0
		addq.b	#1,obAngle(a0)
		andi.w	#$7F,d0
		lea	(Obj0A_WobbleData).l,a1
		move.b	(a1,d0.w),d0
		ext.w	d0
		add.w	$30(a0),d0
		move.w	d0,obX(a0)
		bsr.s	Obj0A_ShowNumber
		jsr	SpeedToPos
		tst.b	obRender(a0)
		bpl.s	Obj0A_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj0A_Display:				; XREF: Obj0A_Index
		bsr.s	Obj0A_ShowNumber
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete2:				; XREF: Obj0A_Index
		jmp	DeleteObject
; ===========================================================================

Obj0A_AirLeft:				; XREF: Obj0A_Index
		cmpi.w	#$C,($FFFFFE14).w ; check air remaining
		bhi.s	Obj0A_Delete3	; if higher than $C, branch
		subq.w	#1,$38(a0)
		bne.s	Obj0A_Display2
		move.b	#$E,obRoutine(a0)
		addq.b	#7,obAnim(a0)
		bra.s	Obj0A_Display
; ===========================================================================

Obj0A_Display2:
		lea	(Ani_obj0A).l,a1
		jsr	AnimateSprite
		tst.b	obRender(a0)
		bpl.s	Obj0A_Delete3
		jmp	DisplaySprite
; ===========================================================================

Obj0A_Delete3:
		jmp	DeleteObject
; ===========================================================================

Obj0A_ShowNumber:			; XREF: Obj0A_Wobble; Obj0A_Display
		tst.w	$38(a0)
		beq.s	locret_13E1A
		subq.w	#1,$38(a0)
		bne.s	locret_13E1A
		cmpi.b	#7,obAnim(a0)
		bcc.s	locret_13E1A
		move.w	#$F,$38(a0)
		clr.w	obVelY(a0)
		move.b	#$80,obRender(a0)
		move.w	obX(a0),d0
		sub.w	($FFFFF700).w,d0
		addi.w	#$80,d0
		move.w	d0,obX(a0)
		move.w	obY(a0),d0
		sub.w	($FFFFF704).w,d0
		addi.w	#$80,d0
		move.w	d0,obScreenY(a0)
		move.b	#$C,obRoutine(a0)

locret_13E1A:
		rts	
; ===========================================================================
Obj0A_WobbleData:
                dc.b 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2
		dc.b 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
		dc.b 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2
		dc.b 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
		dc.b 0, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -3
		dc.b -3, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1
		dc.b 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2
		dc.b 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
		dc.b 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2
		dc.b 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
		dc.b 0, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -3
		dc.b -3, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1

		dc.b 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2
		dc.b 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
		dc.b 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2
		dc.b 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
		dc.b 0, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -3
		dc.b -3, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1
		dc.b 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2
		dc.b 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
		dc.b 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 2
		dc.b 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0
		dc.b 0, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -3, -3, -3, -3, -3
		dc.b -3, -3, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4
		dc.b -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -4, -3
		dc.b -3, -3, -3, -3, -3, -3, -2, -2, -2, -2, -2, -1, -1, -1, -1, -1
; ===========================================================================

Obj0A_Countdown:			; XREF: Obj0A_Index
		tst.w	$2C(a0)
		bne.w	loc_13F86
		cmpi.b	#6,($FFFFD024).w
		bcc.w	locret_1408C
		btst	#6,($FFFFD022).w
		beq.w	locret_1408C

		tst.b 	($FFFFFFFE).w		; is the =P monitor enabled?
		beq.w	locret_1408C		; if not, disable drowning
		
	;	tst.b	($FFFFFFE7).w		; is Sonic inhuman?
	;	bne.w	locret_1408C		; if yes, disable drowning

		subq.w	#1,$38(a0)
		bpl.w	loc_13FAC
		move.w	#59,$38(a0)
		move.w	#1,$36(a0)
		jsr	(RandomNumber).l
		andi.w	#1,d0
		move.b	d0,$34(a0)
		
	;	tst.b 	($FFFFFFFE).w		; is the =P monitor enabled?
	;	bne.w	Obj0A_ReduceAir		; if yes, disable countdown and drown normally

		move.w	($FFFFFE14).w,d0 ; check air remaining
		cmpi.w	#$19,d0
		beq.s	Obj0A_WarnSound	; play sound if	air is $19
		cmpi.w	#$14,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$F,d0
		beq.s	Obj0A_WarnSound
		cmpi.w	#$C,d0
		bhi.s	Obj0A_ReduceAir	; if air is above $C, branch
		bne.s	loc_13F02
		move.w	#$92,d0
		jsr	(PlaySound).l	; play countdown music $92 (speed up music $E2)

loc_13F02:
		subq.b	#1,$32(a0)
		bpl.s	Obj0A_ReduceAir
		move.b	$33(a0),$32(a0)
		bset	#7,$36(a0)
		bra.s	Obj0A_ReduceAir
; ===========================================================================

Obj0A_WarnSound:			; XREF: Obj0A_Countdown
		move.w	#$C2,d0
		jsr	(PlaySound_Special).l ;	play "ding-ding" warning sound

Obj0A_ReduceAir:
		subq.w	#1,($FFFFFE14).w ; subtract 1 from air remaining
		bcc.w	Obj0A_GoMakeItem ; if air is above 0, branch

Obj0A_Drowned:
		bsr	ResumeMusic
		move.b	#$81,($FFFFF7C8).w ; lock controls
		move.w	#$B2,d0
		jsr	(PlaySound_Special).l ;	play drowning sound

		move.b	#$A,$34(a0)
		move.w	#1,$36(a0)
		move.w	#$78,$2C(a0)
		move.l	a0,-(sp)
		lea	($FFFFD000).w,a0
		bsr	Kill_DoKill
	;	move.b	#$0,($FFFFFFFE).w ; reset =P flag
		move.b	#$17,obAnim(a0)	; use Sonic's drowning animation
		bset	#1,obStatus(a0)
		bset	#7,obGfx(a0)
		move.w	#0,obVelY(a0)
		move.w	#0,obVelX(a0)
		move.w	#0,obInertia(a0)
		move.b	#$A,obRoutine(a0)		; Force the character to drown
		move.b	#1,($FFFFF744).w
		move.b	#0,($FFFFFE1E).w	; Stop the timer immediately
		movea.l	(sp)+,a0
		rts	
; ===========================================================================

loc_13F86:
		subq.w	#1,$2C(a0)
		bne.s	loc_13FAC	; Make it jump straight to this location
		move.b	#6,($FFFFD000+$24).w
		rts
; ===========================================================================

Obj0A_GoMakeItem:			; XREF: Obj0A_ReduceAir
	;	tst.b 	($FFFFFFFE).w
	;	bne.w	@Return			; hax
	;	bra.s	Obj0A_MakeItem

@Return:
		rts
; ===========================================================================

loc_13FAC:
		tst.w	$36(a0)
		beq.w	locret_1408C
		subq.w	#1,$3A(a0)
		bpl.w	locret_1408C

Obj0A_MakeItem:
		jsr	(RandomNumber).l
		andi.w	#$F,d0
		move.w	d0,$3A(a0)
		jsr	SingleObjLoad
		bne.w	locret_1408C
		move.b	#$A,0(a1)	; load object
		move.w	($FFFFD008).w,obX(a1) ; match X position to Sonic
		moveq	#6,d0
		btst	#0,($FFFFD022).w
		beq.s	loc_13FF2
		neg.w	d0
		move.b	#$40,obAngle(a1)

loc_13FF2:
		add.w	d0,obX(a1)
		move.w	($FFFFD00C).w,obY(a1)
		move.b	#6,obSubtype(a1)
		tst.w	$2C(a0)
		beq.w	loc_1403E
		andi.w	#7,$3A(a0)
		addi.w	#0,$3A(a0)
		move.w	($FFFFD00C).w,d0
		subi.w	#$C,d0
		move.w	d0,obY(a1)
		jsr	(RandomNumber).l
		move.b	d0,obAngle(a1)
		move.w	($FFFFFE04).w,d0
		andi.b	#3,d0
		bne.s	loc_14082
		move.b	#$E,obSubtype(a1)
		bra.s	loc_14082
; ===========================================================================

loc_1403E:
		btst	#7,$36(a0)
		beq.s	loc_14082
		move.w	($FFFFFE14).w,d2
		lsr.w	#1,d2
		jsr	(RandomNumber).l
		andi.w	#3,d0
		bne.s	loc_1406A
		bset	#6,$36(a0)
		bne.s	loc_14082
		move.b	d2,obSubtype(a1)
		move.w	#$1C,$38(a1)

loc_1406A:
		tst.b	$34(a0)
		bne.s	loc_14082
		bset	#6,$36(a0)
		bne.s	loc_14082
		move.b	d2,obSubtype(a1)
		move.w	#$1C,$38(a1)

loc_14082:
		subq.b	#1,$34(a0)
		bpl.s	locret_1408C
		clr.w	$36(a0)

locret_1408C:
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	play music for LZ/SBZ3 after a countdown
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ResumeMusic:				; XREF: Obj64_Wobble; Sonic_Water; Obj0A_ReduceAir
		jsr	PlayLevelMusic

loc_140AC:
		move.w	#$1E,($FFFFFE14).w
		clr.b	($FFFFD372).w
		rts	
; End of function ResumeMusic

; ===========================================================================
Ani_obj0A:
		include	"_anim\obj0A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - drowning countdown numbers (LZ)
; ---------------------------------------------------------------------------
Map_obj0A:
		include	"_maps\obj0A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 38 - shield and invincibility stars
; ---------------------------------------------------------------------------

Obj38:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj38_Index(pc,d0.w),d1
		jmp	Obj38_Index(pc,d1.w)
; ===========================================================================
Obj38_Index:	dc.w Obj38_Main-Obj38_Index
		dc.w Obj38_Shield-Obj38_Index
		dc.w Obj38_Stars-Obj38_Index
; ===========================================================================

Obj38_Main:				; XREF: Obj38_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj38,obMap(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#$10,obActWid(a0)
		tst.b	obAnim(a0)		; is object a shield?
		bne.s	Obj38_DoStars	; if not, branch
		move.w	#$541,obGfx(a0)	; shield specific code
		rts	
; ===========================================================================

Obj38_DoStars:
		addq.b	#2,obRoutine(a0)	; stars	specific code
		move.w	#$55C,obGfx(a0)
		rts	
; ===========================================================================

Obj38_Shield:				; XREF: Obj38_Index
		tst.b	($FFFFFFE7).w	; is inhuman mode enabled?
		bne.s	Obj38_RmvShield	; if yes, branch
		tst.b	($FFFFFE2D).w	; does Sonic have invincibility?
		bne.s	Obj38_RmvShield	; if yes, branch
		tst.b	($FFFFFE2C).w	; does Sonic have shield?
		beq.s	Obj38_Delete	; if not, branch
		move.w	($FFFFD008).w,obX(a0)
		move.w	($FFFFD00C).w,obY(a0)
		move.b	($FFFFD022).w,obStatus(a0)
		lea	(Ani_obj38).l,a1
		jsr	AnimateSprite
Obj38_DisplaySprite:
		jmp	DisplaySprite
; ===========================================================================

Obj38_RmvShield:
		rts	
; ===========================================================================

Obj38_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj38_Stars:				; XREF: Obj38_Index
		tst.b	($FFFFFFE7).w	; is inhuman mode enabled?
		beq.s	@cont		; if not, branch
		cmpi.w	#$200,($FFFFFE10).w	; is level MZ1?
		bne.s	@cont			; if yes, branch
		btst	#1,($FFFFFF6C).w	; has switch 2 been pressed?
		bne.s	Obj38_IfYes
		rts

@cont:
		tst.b	($FFFFFE2D).w	; does Sonic have invincibility?
		beq.s	Obj38_Delete2	; if not, branch

Obj38_IfYes:
		tst.w	($FFFFD000).w
		beq.s	Obj38_Delete
		move.w	($FFFFF7A8).w,d0
		move.b	obAnim(a0),d1
		subq.b	#1,d1
		bra.s	Obj38_StarTrail
; ===========================================================================
		lsl.b	#4,d1
		addq.b	#4,d1
		sub.b	d1,d0
		move.b	$30(a0),d1
		sub.b	d1,d0
		addq.b	#4,d1
		andi.b	#$F,d1
		move.b	d1,$30(a0)
		bra.s	Obj38_StarTrail2a
; ===========================================================================

Obj38_StarTrail:			; XREF: Obj38_Stars
		lsl.b	#3,d1
		move.b	d1,d2
		add.b	d1,d1
		add.b	d2,d1
		addq.b	#4,d1
		sub.b	d1,d0
		move.b	$30(a0),d1
		sub.b	d1,d0
		addq.b	#4,d1
		cmpi.b	#$18,d1
		bcs.s	Obj38_StarTrail2
		moveq	#0,d1

Obj38_StarTrail2:
		move.b	d1,$30(a0)

Obj38_StarTrail2a:
		lea	($FFFFCB00).w,a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,obX(a0)
		move.w	(a1)+,obY(a0)
		move.b	($FFFFD022).w,obStatus(a0)
		lea	(Ani_obj38).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj38_Delete2:				; XREF: Obj38_Stars
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4A - special stage entry from beta
; ---------------------------------------------------------------------------

Obj4A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj4A_Index(pc,d0.w),d1
		jmp	Obj4A_Index(pc,d1.w)
; ===========================================================================
Obj4A_Index:	dc.w Obj4A_Main-Obj4A_Index
		dc.w Obj4A_RmvSonic-Obj4A_Index
		dc.w Obj4A_LoadSonic-Obj4A_Index
; ===========================================================================

Obj4A_Main:				; XREF: Obj4A_Index
		tst.l	PLC_Pointer	; are pattern load cues	empty?
		beq.s	Obj4A_Main2	; if yes, branch
		rts	
; ===========================================================================

Obj4A_Main2:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj4A,obMap(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#$38,obActWid(a0)
		move.w	#$541,obGfx(a0)
		move.w	#120,$30(a0)	; set time for Sonic's disappearance to 2 seconds

Obj4A_RmvSonic:				; XREF: Obj4A_Index
		move.w	($FFFFD008).w,obX(a0)
		move.w	($FFFFD00C).w,obY(a0)
		move.b	($FFFFD022).w,obStatus(a0)
		lea	(Ani_obj4A).l,a1
		jsr	AnimateSprite
		cmpi.b	#2,obFrame(a0)
		bne.s	Obj4A_Display
		tst.b	($FFFFD000).w
		beq.s	Obj4A_Display
		move.b	#0,($FFFFD000).w ; remove Sonic
		move.w	#$A8,d0
		jsr	(PlaySound_Special).l ;	play Special Stage "GOAL" sound

Obj4A_Display:
		jmp	DisplaySprite
; ===========================================================================

Obj4A_LoadSonic:			; XREF: Obj4A_Index
		subq.w	#1,$30(a0)	; subtract 1 from time
		bne.s	Obj4A_Wait	; if time remains, branch
		move.b	#1,($FFFFD000).w ; load	Sonic object
		jmp	DeleteObject
; ===========================================================================

Obj4A_Wait:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 08 - water splash (LZ)
; ---------------------------------------------------------------------------

Obj08:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj08_Index(pc,d0.w),d1
		jmp	Obj08_Index(pc,d1.w)
; ===========================================================================
Obj08_Index:	dc.w Obj08_Main-Obj08_Index
		dc.w Obj08_Display-Obj08_Index
		dc.w Obj08_Delete-Obj08_Index
; ===========================================================================

Obj08_Main:				; XREF: Obj08_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj08,obMap(a0)
		ori.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#$10,obActWid(a0)
		move.w	#$4259,obGfx(a0)
		move.w	($FFFFD008).w,obX(a0) ; copy x-position from Sonic

Obj08_Display:				; XREF: Obj08_Index
		move.w	($FFFFF646).w,obY(a0) ; copy y-position from water height
		lea	(Ani_obj08).l,a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj08_Delete:				; XREF: Obj08_Index
		jmp	DeleteObject	; delete when animation	is complete
; ===========================================================================
Ani_obj38:
		include	"_anim\obj38.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - shield and invincibility stars
; ---------------------------------------------------------------------------
Map_obj38:
		include	"_maps\obj38.asm"

Ani_obj4A:
		include	"_anim\obj4A.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage entry	from beta
; ---------------------------------------------------------------------------
Map_obj4A:
		include	"_maps\obj4A.asm"

Ani_obj08:
		include	"_anim\obj08.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - water splash (LZ)
; ---------------------------------------------------------------------------
Map_obj08:
		include	"_maps\obj08.asm"

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle & position as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_AnglePos:				; XREF: Obj01_MdNormal; Obj01_MdRoll
		btst	#3,obStatus(a0)
		beq.s	loc_14602
		moveq	#0,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		rts	
; ===========================================================================

loc_14602:
		moveq	#3,d0
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	obAngle(a0),d0
		addi.b	#$20,d0
		bpl.s	loc_14624
		move.b	obAngle(a0),d0
		bpl.s	loc_1461E
		subq.b	#1,d0

loc_1461E:
		addi.b	#$20,d0
		bra.s	loc_14630
; ===========================================================================

loc_14624:
		move.b	obAngle(a0),d0
		bpl.s	loc_1462C
		addq.b	#1,d0

loc_1462C:
		addi.b	#$1F,d0

loc_14630:
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	Sonic_WalkVertL
		cmpi.b	#$80,d0
		beq.w	Sonic_WalkCeiling
		cmpi.b	#$C0,d0
		beq.w	Sonic_WalkVertR
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr	FindFloor
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr	FindFloor
		move.w	(sp)+,d0
		bsr	Sonic_Angle
		tst.w	d1
		beq.s	locret_146BE
		bpl.s	loc_146C0
		cmpi.w	#-$E,d1
		blt.s	locret_146E6
		add.w	d1,obY(a0)

locret_146BE:
		rts	
; ===========================================================================

loc_146C0:
		cmpi.w	#$E,d1
		bgt.s	loc_146CC

loc_146C6:
		add.w	d1,obY(a0)
		rts	
; ===========================================================================

loc_146CC:
		tst.b	$38(a0)
		bne.s	loc_146C6
		bset	#1,obStatus(a0)
		bclr	#5,obStatus(a0)
		move.b	#1,obNextAni(a0)
		rts	
; ===========================================================================

locret_146E6:
		rts	
; End of function Sonic_AnglePos

; ---------------------------------------------------------------------------
; Subroutine to	change Sonic's angle as he walks along the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_Angle:				; XREF: Sonic_AnglePos; et al
		move.b	($FFFFF76A).w,d2
		cmp.w	d0,d1
		ble.s	loc_1475E
		move.b	($FFFFF768).w,d2
		move.w	d0,d1

loc_1475E:
		btst	#0,d2
		bne.s	loc_1476A
		move.b	d2,obAngle(a0)
		rts	
; ===========================================================================

loc_1476A:
		move.b	obAngle(a0),d2
		addi.b	#$20,d2
		andi.b	#$C0,d2
		move.b	d2,obAngle(a0)
		rts	
; End of function Sonic_Angle

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkVertR:			; XREF: Sonic_AnglePos
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		neg.w	d0
		add.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr	FindWall
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr	FindWall
		move.w	(sp)+,d0
		bsr	Sonic_Angle
		tst.w	d1
		beq.s	locret_147F0
		bpl.s	loc_147F2
		cmpi.w	#-$E,d1
		blt.w	locret_146E6
		add.w	d1,obX(a0)

locret_147F0:
		rts	
; ===========================================================================

loc_147F2:
		cmpi.w	#$E,d1
		bgt.s	loc_147FE

loc_147F8:
		add.w	d1,obX(a0)
		rts	
; ===========================================================================

loc_147FE:
		tst.b	$38(a0)
		bne.s	loc_147F8
		bset	#1,obStatus(a0)
		bclr	#5,obStatus(a0)
		move.b	#1,obNextAni(a0)
		rts	
; End of function Sonic_WalkVertR

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk upside-down
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkCeiling:			; XREF: Sonic_AnglePos
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$1000,d6
		moveq	#$D,d5
		bsr	FindFloor
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$1000,d6
		moveq	#$D,d5
		bsr	FindFloor
		move.w	(sp)+,d0
		bsr	Sonic_Angle
		tst.w	d1
		beq.s	locret_14892
		bpl.s	loc_14894
		cmpi.w	#-$E,d1
		blt.w	locret_146E6
		sub.w	d1,obY(a0)

locret_14892:
		rts	
; ===========================================================================

loc_14894:
		cmpi.w	#$E,d1
		bgt.s	loc_148A0

loc_1489A:
		sub.w	d1,obY(a0)
		rts	
; ===========================================================================

loc_148A0:
		tst.b	$38(a0)
		bne.s	loc_1489A
		bset	#1,obStatus(a0)
		bclr	#5,obStatus(a0)
		move.b	#1,obNextAni(a0)
		rts	
; End of function Sonic_WalkCeiling

; ---------------------------------------------------------------------------
; Subroutine allowing Sonic to walk up a vertical slope/wall to	his left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkVertL:			; XREF: Sonic_AnglePos
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		moveq	#$D,d5
		bsr	FindWall
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		moveq	#$D,d5
		bsr	FindWall
		move.w	(sp)+,d0
		bsr	Sonic_Angle
		tst.w	d1
		beq.s	locret_14934
		bpl.s	loc_14936
		cmpi.w	#-$E,d1
		blt.w	locret_146E6
		sub.w	d1,obX(a0)

locret_14934:
		rts	
; ===========================================================================

loc_14936:
		cmpi.w	#$E,d1
		bgt.s	loc_14942

loc_1493C:
		sub.w	d1,obX(a0)
		rts	
; ===========================================================================

loc_14942:
		tst.b	$38(a0)
		bne.s	loc_1493C
		bset	#1,obStatus(a0)
		bclr	#5,obStatus(a0)
		move.b	#1,obNextAni(a0)
		rts	
; End of function Sonic_WalkVertL

; ---------------------------------------------------------------------------
; Subroutine to	find which tile	the object is standing on
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

; Vladikcomper: Heavily optimized

Floor_ChkTile:				; XREF: FindFloor; et al
		move.w	d2,d0			; d0 = Y-pos (sensor)
		lsr.w	#2,d0			; d0 = Y-pos / 4
		andi.w	#$1C0,d0		; d0 = (Y-pos / $100) * $40
		move.w	d3,d1			; d1 = X-pos (sensor)
		lsr.w	#8,d1			; d1 = X-pos / $100
		andi.w	#$3F,d1			; d1 = (X-pos / $100) & $3F
		add.w	d1, d0			; d0 = in-layout pos

		moveq	#-1,d1
		clr.w	d1
		lea	LevelLayout_FG, a1
		move.b	(a1,d0.w),d1		; d1 = chunk id
		beq.s	@EmptyChunk		; if chunk = $00, branch
		bmi.s	@LoopChunk

@GetChunk:
		; Calculate address within chunk where object stands
		add.w	d1, d1
		move.w	@GetChunkOffset-2(pc,d1.w), d1
		
		move.w	d2,d0
		add.w	d0,d0
		andi.w	#$1E0,d0
		add.w	d0,d1

		move.w	d3,d0
		lsr.w	#3,d0
		andi.w	#$1E,d0
		add.w	d0,d1

		movea.l d1,a1
		rts

@EmptyChunk:
		lea	@NullBlock(pc), a1
		rts

; ===========================================================================

@LoopChunk:
		andi.w	#$7F,d1
		btst	#6,1(a0)		; is object on the low plane?
		beq.s	@GetChunk		; if not, branch
		addq.w	#1,d1			; swap collision layer
		bra.s	@GetChunk

; ===========================================================================
@NullBlock:					; they both start with $0000
@GetChunkOffset:
	disp: = 0
        while disp<$A400
                dc.w    disp
disp = disp + $200
        endw

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindFloor:				; XREF: Sonic_AnglePos; et al
		bsr.w	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$7FF,d0
		beq.s	loc_149DE
		btst	d5,d4
		bne.s	loc_149EC

loc_149DE:
		add.w	a3,d2
		bsr	FindFloor2
		sub.w	a3,d2
		addi.w	#$10,d1
		rts	
; ===========================================================================

loc_149EC:
		movea.l	($FFFFF796).w,a2 ; load	collision index
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_149DE
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d3,d1
		btst	#$B,d4
		beq.s	loc_14A12
		not.w	d1
		neg.b	(a4)

loc_14A12:
		btst	#$C,d4
		beq.s	loc_14A22
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14A22:
		andi.w	#$F,d1
		add.w	d0,d1
		lea	(CollArray1).l,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$C,d4
		beq.s	loc_14A3E
		neg.w	d0

loc_14A3E:
		tst.w	d0
		beq.s	loc_149DE
		bmi.s	loc_14A5A
		cmpi.b	#$10,d0
		beq.s	loc_14A66
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14A5A:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_149DE

loc_14A66:
		sub.w	a3,d2
		bsr	FindFloor2
		add.w	a3,d2
		subi.w	#$10,d1
		rts	
; End of function FindFloor


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindFloor2:				; XREF: FindFloor
		bsr	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$7FF,d0
		beq.s	loc_14A86
		btst	d5,d4
		bne.s	loc_14A94

loc_14A86:
		move.w	#$F,d1
		move.w	d2,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14A94:
		movea.l	($FFFFF796).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_14A86
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d3,d1
		btst	#$B,d4
		beq.s	loc_14ABA
		not.w	d1
		neg.b	(a4)

loc_14ABA:
		btst	#$C,d4
		beq.s	loc_14ACA
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14ACA:
		andi.w	#$F,d1
		add.w	d0,d1
		lea	(CollArray1).l,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$C,d4
		beq.s	loc_14AE6
		neg.w	d0

loc_14AE6:
		tst.w	d0
		beq.s	loc_14A86
		bmi.s	loc_14AFC
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14AFC:
		move.w	d2,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14A86
		not.w	d1
		rts	
; End of function FindFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindWall:				; XREF: Sonic_WalkVertR; et al
		bsr	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$7FF,d0
		beq.s	loc_14B1E
		btst	d5,d4
		bne.s	loc_14B2C

loc_14B1E:
		add.w	a3,d3
		bsr	FindWall2
		sub.w	a3,d3
		addi.w	#$10,d1
		rts	
; ===========================================================================

loc_14B2C:
		movea.l	($FFFFF796).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_14B1E
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d2,d1
		btst	#$C,d4
		beq.s	loc_14B5A
		not.w	d1
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14B5A:
		btst	#$B,d4
		beq.s	loc_14B62
		neg.b	(a4)

loc_14B62:
		andi.w	#$F,d1
		add.w	d0,d1
		lea	(CollArray2).l,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$B,d4
		beq.s	loc_14B7E
		neg.w	d0

loc_14B7E:
		tst.w	d0
		beq.s	loc_14B1E
		bmi.s	loc_14B9A
		cmpi.b	#$10,d0
		beq.s	loc_14BA6
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14B9A:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14B1E

loc_14BA6:
		sub.w	a3,d3
		bsr	FindWall2
		add.w	a3,d3
		subi.w	#$10,d1
		rts	
; End of function FindWall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


FindWall2:				; XREF: FindWall
		bsr	Floor_ChkTile
		move.w	(a1),d0
		move.w	d0,d4
		andi.w	#$7FF,d0
		beq.s	loc_14BC6
		btst	d5,d4
		bne.s	loc_14BD4

loc_14BC6:
		move.w	#$F,d1
		move.w	d3,d0
		andi.w	#$F,d0
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14BD4:
		movea.l	($FFFFF796).w,a2
		move.b	(a2,d0.w),d0
		andi.w	#$FF,d0
		beq.s	loc_14BC6
		lea	(AngleMap).l,a2
		move.b	(a2,d0.w),(a4)
		lsl.w	#4,d0
		move.w	d2,d1
		btst	#$C,d4
		beq.s	loc_14C02
		not.w	d1
		addi.b	#$40,(a4)
		neg.b	(a4)
		subi.b	#$40,(a4)

loc_14C02:
		btst	#$B,d4
		beq.s	loc_14C0A
		neg.b	(a4)

loc_14C0A:
		andi.w	#$F,d1
		add.w	d0,d1
		lea	(CollArray2).l,a2
		move.b	(a2,d1.w),d0
		ext.w	d0
		eor.w	d6,d4
		btst	#$B,d4
		beq.s	loc_14C26
		neg.w	d0

loc_14C26:
		tst.w	d0
		beq.s	loc_14BC6
		bmi.s	loc_14C3C
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		move.w	#$F,d1
		sub.w	d0,d1
		rts	
; ===========================================================================

loc_14C3C:
		move.w	d3,d1
		andi.w	#$F,d1
		add.w	d1,d0
		bpl.w	loc_14BC6
		not.w	d1
		rts	
; End of function FindWall2
; ===========================================================================


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_WalkSpeed:			; XREF: Sonic_Move
		move.l	obX(a0),d3
		move.l	obY(a0),d2
		move.w	obVelX(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d3
		move.w	obVelY(a0),d1
		ext.l	d1
		asl.l	#8,d1
		add.l	d1,d2
		swap	d2
		swap	d3
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		move.b	d0,d1
		addi.b	#$20,d0
		bpl.s	loc_14D1A
		move.b	d1,d0
		bpl.s	loc_14D14
		subq.b	#1,d0

loc_14D14:
		addi.b	#$20,d0
		bra.s	loc_14D24
; ===========================================================================

loc_14D1A:
		move.b	d1,d0
		bpl.s	loc_14D20
		addq.b	#1,d0

loc_14D20:
		addi.b	#$1F,d0

loc_14D24:
		andi.b	#$C0,d0
		beq.w	loc_14DF0
		cmpi.b	#$80,d0
		beq.w	loc_14F7C
		andi.b	#$38,d1
		bne.s	loc_14D3C
		addq.w	#8,d2
		btst	#2,obStatus(a0)    ; Is Sonic rolling?
		beq.s	loc_14D3C          ; If not, branch
		subq.w	#5,d2              ; If so, move push sensor up a bit
        
loc_14D3C:
		cmpi.b	#$40,d0
		beq.w	loc_1504A
		bra.w	loc_14EBC

; End of function Sonic_WalkSpeed


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14D48:				; XREF: Sonic_Jump
		move.b	d0,($FFFFF768).w
		move.b	d0,($FFFFF76A).w
		addi.b	#$20,d0
		andi.b	#$C0,d0
		cmpi.b	#$40,d0
		beq.w	loc_14FD6
		cmpi.b	#$80,d0
		beq.w	Sonic_DontRunOnWalls
		cmpi.b	#$C0,d0
		beq.w	sub_14E50

; End of function sub_14D48

; ---------------------------------------------------------------------------
; Subroutine to	make Sonic land	on the floor after jumping
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HitFloor:				; XREF: Sonic_Floor
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr	FindFloor
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr	FindFloor
		move.w	(sp)+,d0
		move.b	#0,d2

loc_14DD0:
		move.b	($FFFFF76A).w,d3
		cmp.w	d0,d1
		ble.s	loc_14DDE
		move.b	($FFFFF768).w,d3
		exg	d0,d1

loc_14DDE:
		btst	#0,d3
		beq.s	locret_14DE6
		move.b	d2,d3

locret_14DE6:
		rts	

; End of function Sonic_HitFloor

; ===========================================================================
		move.w	obY(a0),d2
		move.w	obX(a0),d3

loc_14DF0:				; XREF: Sonic_WalkSpeed
		addi.w	#$A,d2
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$E,d5
		bsr	FindFloor
		move.b	#0,d2

loc_14E0A:				; XREF: sub_14EB4
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E16
		move.b	d2,d3

locret_14E16:
		rts	

; ---------------------------------------------------------------------------
; Subroutine allowing objects to interact with the floor
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor:
		move.w	obX(a0),d3

; End of function ObjHitFloor


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitFloor2:
		move.w	obY(a0),d2
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$D,d5
		bsr	FindFloor
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14E4E
		move.b	#0,d3

locret_14E4E:
		rts	
; End of function ObjHitFloor2


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14E50:				; XREF: sub_14D48
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$E,d5
		bsr	FindWall
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$E,d5
		bsr	FindWall
		move.w	(sp)+,d0
		move.b	#-$40,d2
		bra.w	loc_14DD0

; End of function sub_14E50


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_14EB4:				; XREF: Sonic_Floor
		move.w	obY(a0),d2
		move.w	obX(a0),d3

loc_14EBC:
		addi.w	#$A,d3
		lea	($FFFFF768).w,a4
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$E,d5
		bsr	FindWall
		move.b	#-$40,d2
		bra.w	loc_14E0A

; End of function sub_14EB4

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its right
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallRight:
		add.w	obX(a0),d3
		move.w	obY(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#$10,a3
		move.w	#0,d6
		moveq	#$E,d5
		bsr	FindWall
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14F06
		move.b	#-$40,d3

locret_14F06:
		rts	

; End of function ObjHitWallRight

; ---------------------------------------------------------------------------
; Subroutine preventing	Sonic from running on walls and	ceilings when he
; touches them
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_DontRunOnWalls:			; XREF: Sonic_Floor; et al
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$1000,d6
		moveq	#$E,d5
		bsr	FindFloor
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		move.b	obWidth(a0),d0
		ext.w	d0
		sub.w	d0,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$1000,d6
		moveq	#$E,d5
		bsr	FindFloor
		move.w	(sp)+,d0
		move.b	#-$80,d2
		bra.w	loc_14DD0
; End of function Sonic_DontRunOnWalls

; ===========================================================================
		move.w	obY(a0),d2
		move.w	obX(a0),d3

loc_14F7C:
		subi.w	#$A,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$1000,d6
		moveq	#$E,d5
		bsr	FindFloor
		move.b	#-$80,d2
		bra.w	loc_14E0A

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitCeiling:
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d2
		eori.w	#$F,d2
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$1000,d6
		moveq	#$E,d5
		bsr	FindFloor
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_14FD4
		move.b	#-$80,d3

locret_14FD4:
		rts	
; End of function ObjHitCeiling

; ===========================================================================

loc_14FD6:				; XREF: sub_14D48
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		sub.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		moveq	#$E,d5
		bsr	FindWall
		move.w	d1,-(sp)
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		moveq	#0,d0
		move.b	obWidth(a0),d0
		ext.w	d0
		add.w	d0,d2
		move.b	obHeight(a0),d0
		ext.w	d0
		sub.w	d0,d3
		eori.w	#$F,d3
		lea	($FFFFF76A).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		moveq	#$E,d5
		bsr	FindWall
		move.w	(sp)+,d0
		move.b	#$40,d2
		bra.w	loc_14DD0

; ---------------------------------------------------------------------------
; Subroutine to	stop Sonic when	he jumps at a wall
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Sonic_HitWall:				; XREF: Sonic_Floor
		move.w	obY(a0),d2
		move.w	obX(a0),d3

loc_1504A:
		subi.w	#$A,d3
		eori.w	#$F,d3
		lea	($FFFFF768).w,a4
		movea.w	#-$10,a3
		move.w	#$800,d6
		moveq	#$E,d5
		bsr	FindWall
		move.b	#$40,d2
		bra.w	loc_14E0A
; End of function Sonic_HitWall

; ---------------------------------------------------------------------------
; Subroutine to	detect when an object hits a wall to its left
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ObjHitWallLeft:
		add.w	obX(a0),d3
		move.w	obY(a0),d2
		lea	($FFFFF768).w,a4
		move.b	#0,(a4)
		movea.w	#-$10,a3
		move.w	#$800,d6
		moveq	#$E,d5
		bsr	FindWall
		move.b	($FFFFF768).w,d3
		btst	#0,d3
		beq.s	locret_15098
		move.b	#$40,d3

locret_15098:
		rts	
; End of function ObjHitWallLeft

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 66 - rotating disc that grabs Sonic (SBZ)
; ---------------------------------------------------------------------------

Obj66:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj66_Index(pc,d0.w),d1
		jmp	Obj66_Index(pc,d1.w)
; ===========================================================================
Obj66_Index:	dc.w Obj66_Main-Obj66_Index
		dc.w Obj66_Action-Obj66_Index
		dc.w Obj66_Display-Obj66_Index
		dc.w Obj66_Release-Obj66_Index
; ===========================================================================

Obj66_Main:				; XREF: Obj66_Index
		addq.b	#2,obRoutine(a0)
		move.w	#1,d1
		movea.l	a0,a1
		bra.s	Obj66_MakeItem
; ===========================================================================

Obj66_Loop:
		jsr	SingleObjLoad
		bne.s	loc_150FE
		move.b	#$66,0(a1)
		addq.b	#4,obRoutine(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#3,obPriority(a1)
		move.b	#$10,obFrame(a1)

Obj66_MakeItem:				; XREF: Obj66_Main
		move.l	#Map_obj66,obMap(a1)
		move.w	#$4348,obGfx(a1)
		ori.b	#4,obRender(a1)
		move.b	#$38,obActWid(a1)

loc_150FE:
		dbf	d1,Obj66_Loop

		move.b	#$30,obActWid(a0)
		move.b	#4,obPriority(a0)
		move.w	#$3C,$30(a0)
		move.b	#1,$34(a0)
		move.b	obSubtype(a0),$38(a0)

Obj66_Action:				; XREF: Obj66_Index
		jsr	obj66_ChkSwitch
		tst.b	obRender(a0)
		bpl.w	Obj66_Display
		move.w	#$30,d1
		move.w	d1,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		jsr	SolidObject
		btst	#5,obStatus(a0)
		beq.w	Obj66_Display
		lea	($FFFFD000).w,a1
		moveq	#$E,d1
		move.w	obX(a1),d0
		cmp.w	obX(a0),d0
		bcs.s	Obj66_GrabSonic
		moveq	#7,d1

Obj66_GrabSonic:
		cmp.b	obFrame(a0),d1
		bne.s	Obj66_Display
		move.b	d1,$32(a0)
		addq.b	#4,obRoutine(a0)
		move.b	#1,($FFFFF7C8).w ; lock	controls
		move.b	#2,obAnim(a1)	; make Sonic use "rolling" animation
		move.w	#$800,obInertia(a1)
		move.w	#0,obVelX(a1)
		move.w	#0,obVelY(a1)
		bclr	#5,obStatus(a0)
		bclr	#5,obStatus(a1)
		bset	#1,obStatus(a1)
		move.w	obX(a1),d2
		move.w	obY(a1),d3
		jsr	obj66_ChgPos
		add.w	d2,obX(a1)
		add.w	d3,obY(a1)
		asr	obX(a1)
		asr	obY(a1)

Obj66_Display:				; XREF: Obj66_Index
		jmp	MarkObjGone
; ===========================================================================

Obj66_Release:				; XREF: Obj66_Index
		move.b	obFrame(a0),d0
		cmpi.b	#4,d0
		beq.s	loc_151C8
		cmpi.b	#7,d0
		bne.s	loc_151F8

loc_151C8:
		cmp.b	$32(a0),d0
		beq.s	loc_151F8
		lea	($FFFFD000).w,a1
		move.w	#0,obVelX(a1)
		move.w	#$800,obVelY(a1)
		cmpi.b	#4,d0
		beq.s	loc_151F0
		move.w	#$800,obVelX(a1)
		move.w	#$800,obVelY(a1)

loc_151F0:
		clr.b	($FFFFF7C8).w	; unlock controls
		subq.b	#4,obRoutine(a0)

loc_151F8:
		bsr.s	Obj66_ChkSwitch
		bsr.s	Obj66_ChgPos
		jmp	MarkObjGone

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj66_ChkSwitch:			; XREF: Obj66_Action
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$38(a0),d0
		btst	#0,(a2,d0.w)	; is switch pressed?
		beq.s	loc_15224	; if not, branch
		tst.b	$36(a0)		; has switch previously	been pressed?
		bne.s	Obj66_Animate	; if yes, branch
		neg.b	$34(a0)
		move.b	#1,$36(a0)	; set to "previously pressed"
		bra.s	Obj66_Animate
; ===========================================================================

loc_15224:
		clr.b	$36(a0)		; set to "not yet pressed"

Obj66_Animate:
		subq.b	#1,obTimeFrame(a0)
		bpl.s	locret_15246
		move.b	#7,obTimeFrame(a0)
		move.b	$34(a0),d1
		move.b	obFrame(a0),d0
		add.b	d1,d0
		andi.b	#$F,d0
		move.b	d0,obFrame(a0)

locret_15246:
		rts	
; End of function Obj66_ChkSwitch


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj66_ChgPos:				; XREF: Obj66_GrabSonic
		lea	($FFFFD000).w,a1
		moveq	#0,d0
		move.b	obFrame(a0),d0
		add.w	d0,d0
		lea	Obj66_PosData(pc,d0.w),a2
		move.b	(a2)+,d0
		ext.w	d0
		add.w	obX(a0),d0
		move.w	d0,obX(a1)
		move.b	(a2)+,d0
		ext.w	d0
		add.w	obY(a0),d0
		move.w	d0,obY(a1)
		rts	
; End of function Obj66_ChgPos

; ===========================================================================
Obj66_PosData:	dc.b  $E0,   0,	$E2,  $E ; disc	x-pos, Sonic x-pos, disc y-pos,	Sonic y-pos
		dc.b  $E8, $18,	$F2, $1E
		dc.b	0, $20,	 $E, $1E
		dc.b  $18, $18,	$1E,  $E
		dc.b  $20,   0,	$1E, $F2
		dc.b  $18, $E8,	 $E, $E2
		dc.b	0, $E0,	$F2, $E2
		dc.b  $E8, $E8,	$E2, $F2
; ---------------------------------------------------------------------------
; Sprite mappings - rotating disc that grabs Sonic (SBZ)
; ---------------------------------------------------------------------------
Map_obj66:
		include	"_maps\obj66.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 67 - Explosion emitter
; ---------------------------------------------------------------------------
Obj67:

; ---------------------------------------------------------------------------
@Timer:		equ $26
; ---------------------------------------------------------------------------

		add.w 	#$1000/3, @Timer(a0)
		bcc.s	@Return

		jsr		SingleObjLoad
		bne.s	@Return

		move.b	#$3F, (a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1, $30(a1)

@Return:
		rts

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - disc that you run around (SBZ)
; (It's just a small blob that moves around in a circle. The disc itself is
; part of the level tiles.)
; ---------------------------------------------------------------------------
Map_obj67:
		include	"_maps\obj67.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 68 - conveyor belts (SBZ)
; ---------------------------------------------------------------------------

Obj68:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj68_Index(pc,d0.w),d1
		jmp	Obj68_Index(pc,d1.w)
; ===========================================================================
Obj68_Index:	dc.w Obj68_Main-Obj68_Index
		dc.w Obj68_Action-Obj68_Index
; ===========================================================================

Obj68_Main:				; XREF: Obj68_Index
		addq.b	#2,obRoutine(a0)
		move.b	#128,$38(a0)	; set width to 128 pixels
		move.b	obSubtype(a0),d1	; get object type
		andi.b	#$F,d1		; read only the	2nd digit
		beq.s	loc_156BA	; if zero, branch
		move.b	#56,$38(a0)	; set width to 56 pixels

loc_156BA:
		move.b	obSubtype(a0),d1	; get object type
		andi.b	#$F0,d1		; read only the	1st digit
		ext.w	d1
		asr.w	#4,d1
		move.w	d1,$36(a0)	; set belt speed

Obj68_Action:				; XREF: Obj68_Index
		bsr.s	Obj68_MoveSonic
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj68_Delete
		rts	
; ===========================================================================

Obj68_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj68_MoveSonic:			; XREF: Obj68_Action
		moveq	#0,d2
		move.b	$38(a0),d2
		move.w	d2,d3
		add.w	d3,d3
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.s	locret_1572E
		move.w	obY(a1),d1
		sub.w	obY(a0),d1
		addi.w	#$30,d1
		cmpi.w	#$30,d1
		bcc.s	locret_1572E
		btst	#1,obStatus(a1)
		bne.s	locret_1572E
		move.w	$36(a0),d0
		add.w	d0,obX(a1)

locret_1572E:
		rts	

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 69 - spinning platforms and trapdoors (SBZ)
; ---------------------------------------------------------------------------

Obj69:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj69_Index(pc,d0.w),d1
		jmp	Obj69_Index(pc,d1.w)
; ===========================================================================
Obj69_Index:	dc.w Obj69_Main-Obj69_Index
		dc.w Obj69_Trapdoor-Obj69_Index
		dc.w Obj69_Spinner-Obj69_Index
; ===========================================================================

Obj69_Main:				; XREF: Obj69_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj69,obMap(a0)
		move.w	#$4492,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$80,obActWid(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		mulu.w	#$3C,d0
		move.w	d0,$32(a0)
		tst.b	obSubtype(a0)
		bpl.s	Obj69_Trapdoor
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj69a,obMap(a0)
		move.w	#$4DF,obGfx(a0)
		move.b	#$10,obActWid(a0)
		move.b	#2,obAnim(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get object type
		move.w	d0,d1
		andi.w	#$F,d0		; read only the	2nd digit
		mulu.w	#6,d0		; multiply by 6
		move.w	d0,$30(a0)	; set time delay
		move.w	d0,$32(a0)
		andi.w	#$70,d1
		addi.w	#$10,d1
		lsl.w	#2,d1
		subq.w	#1,d1
		move.w	d1,$36(a0)
		bra.s	Obj69_Spinner
; ===========================================================================

Obj69_Trapdoor:				; XREF: Obj69_Index
		subq.w	#1,$30(a0)
		bpl.s	Obj69_Animate
		move.w	$32(a0),$30(a0)
		bchg	#0,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj69_Animate
		move.w	#$BB,d0
		jsr	(PlaySound_Special).l ;	play door sound

Obj69_Animate:
		lea	(Ani_obj69).l,a1
		jsr	AnimateSprite
		tst.b	obFrame(a0)		; is frame number 0 displayed?
		bne.s	Obj69_NotSolid	; if not, branch
		move.w	#$4B,d1
		move.w	#$C,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		jsr	SolidObject
		jmp	MarkObjGone
; ===========================================================================

Obj69_NotSolid:
		btst	#3,obStatus(a0)
		beq.s	Obj69_Display
		lea	($FFFFD000).w,a1
		bclr	#3,obStatus(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)

Obj69_Display:
		jmp	MarkObjGone
; ===========================================================================

Obj69_Spinner:				; XREF: Obj69_Index
		move.w	($FFFFFE04).w,d0
		and.w	$36(a0),d0
		bne.s	Obj69_Delay
		move.b	#1,$34(a0)

Obj69_Delay:
		tst.b	$34(a0)
		beq.s	Obj69_Animate2
		subq.w	#1,$30(a0)
		bpl.s	Obj69_Animate2
		move.w	$32(a0),$30(a0)
		clr.b	$34(a0)
		bchg	#0,obAnim(a0)

Obj69_Animate2:
		lea	(Ani_obj69).l,a1
		jsr	AnimateSprite
		tst.b	obFrame(a0)		; check	if frame number	0 is displayed
		bne.s	Obj69_NotSolid2	; if not, branch
		move.w	#$1B,d1
		move.w	#7,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	obX(a0),d4
		jsr	SolidObject
		jmp	MarkObjGone
; ===========================================================================

Obj69_NotSolid2:
		btst	#3,obStatus(a0)
		beq.s	Obj69_Display2
		lea	($FFFFD000).w,a1
		bclr	#3,obStatus(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)

Obj69_Display2:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj69:
		include	"_anim\obj69.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - trapdoor (SBZ)
; ---------------------------------------------------------------------------
Map_obj69:
		include	"_maps\obj69.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - spinning platforms (SBZ)
; ---------------------------------------------------------------------------
Map_obj69a:
		include	"_maps\obj69a.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6A - ground saws and pizza cutters (SBZ)
; ---------------------------------------------------------------------------

Obj6A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj6A_Index(pc,d0.w),d1
		jmp	Obj6A_Index(pc,d1.w)
; ===========================================================================
Obj6A_Index:	dc.w Obj6A_Main-Obj6A_Index
		dc.w Obj6A_Action-Obj6A_Index
		dc.w Obj6A_PostFinalBoss-Obj6A_Index
		dc.w Obj6A_PostFinalBoss2-Obj6A_Index
; ===========================================================================

Obj6A_PostFinalBoss:
		addq.b	#2,obRoutine(a0)
		move.b	#3,(CameraShake_Intensity).w

		jsr	SingleObjLoad
		bne.s	@0
		move.b	#$3F,(a1)
		move.b	#0,obRoutine(a1)
		move.b	#1,$31(a1)
		move.w	#$2588,obX(a1)
		move.w	#$05B0,obY(a1)
@0:
		rts
; ---------------------------------------------------------------------------

Obj6A_PostFinalBoss2:
		move.l	a0,-(sp)
		VBlank_SetMusicOnly
		vram	$7400
		lea	(ArtKospM_FzEggman).l,a0
		jsr	KosPlusMDec_VRAM
		VBlank_UnsetMusicOnly
		move.l	(sp)+,a0

		jmp	DeleteObject
; ===========================================================================

Obj6A_Main:				; XREF: Obj6A_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj6A,obMap(a0)
		move.w	#$4000|($76A0/$20),obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#0,obPriority(a0)
		move.b	#$20,obActWid(a0)
		move.w	obX(a0),$3A(a0)
		move.w	obY(a0),$38(a0)
		cmpi.b	#3,obSubtype(a0)
		bcc.s	Obj6A_Action
		move.b	#$A2,obColType(a0)

		move.b	#0,obFrame(a0)

Obj6A_Action:				; XREF: Obj6A_Index
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#7,d0
		add.w	d0,d0
		move.w	Obj6A_TypeIndex(pc,d0.w),d1
		jsr	obj6A_TypeIndex(pc,d1.w)
		move.w	$3A(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj6A_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj6A_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj6A_TypeIndex:dc.w Obj6A_Type00-Obj6A_TypeIndex, Obj6A_Type01-Obj6A_TypeIndex
		dc.w Obj6A_Type02-Obj6A_TypeIndex, Obj6A_Type03-Obj6A_TypeIndex
		dc.w Obj6A_Type04-Obj6A_TypeIndex
; ===========================================================================

Obj6A_Type00:				; XREF: Obj6A_TypeIndex
		subq.b	#1,obTimeFrame(a0)
		bpl.s	@noframechg
		move.b	#2,obTimeFrame(a0)
		bchg	#0,obFrame(a0)
@noframechg:
		rts	
; ===========================================================================

Obj6A_Type01:				; XREF: Obj6A_TypeIndex
		move.w	#$60,d1
		moveq	#0,d0
		move.b	($FFFFFE6C).w,d0
		btst	#0,obStatus(a0)
		beq.s	Obj6A_Animate01
		neg.w	d0
		add.w	d1,d0

Obj6A_Animate01:
		move.w	$3A(a0),d1
		sub.w	d0,d1
		move.w	d1,obX(a0)	; move saw sideways
		subq.b	#1,obTimeFrame(a0)
		bpl.s	loc_15A46
		move.b	#2,obTimeFrame(a0)	; time between frame changes
		bchg	#0,obFrame(a0)	; change frame

loc_15A46:
		tst.b	obRender(a0)
		bpl.s	locret_15A60
		move.w	($FFFFFE04).w,d0
		andi.w	#$F,d0
		bne.s	locret_15A60
		move.w	#$B0,d0
		jsr	(PlaySound_Special).l ;	play saw sound

locret_15A60:
		rts	
; ===========================================================================

Obj6A_Type02:				; XREF: Obj6A_TypeIndex
		moveq	#0,d0
		move.b	($FFFFFE68).w,d0
		asr.w	#2,d0
		move.w	$38(a0),d1
		sub.w	d0,d1
		move.w	d1,obY(a0)	; move saw vertically

		subq.b	#1,obTimeFrame(a0)
		bpl.s	locret_15AB0
		move.b	#2,obTimeFrame(a0)
		bchg	#0,obFrame(a0)

locret_15AB0:
		rts	
; ===========================================================================

Obj6A_Type03:				; XREF: Obj6A_TypeIndex
		tst.b	$3D(a0)
		bne.s	Obj6A_Animate03
		move.w	($FFFFD008).w,d0
		subi.w	#$C0,d0
		bcs.s	loc_15B02
		sub.w	obX(a0),d0
		bcs.s	loc_15B02
		move.w	($FFFFD00C).w,d0
		subi.w	#$80,d0
		cmp.w	obY(a0),d0
		bcc.s	locret_15B04
		addi.w	#$100,d0
		cmp.w	obY(a0),d0
		bcs.s	locret_15B04
		move.b	#1,$3D(a0)
		move.w	#$600,obVelX(a0)	; move object to the right
		move.b	#$A2,obColType(a0)
		move.b	#2,obFrame(a0)
		move.w	#$B0,d0
		jsr	(PlaySound_Special).l ;	play saw sound

loc_15B02:
		addq.l	#4,sp

locret_15B04:
		rts	
; ===========================================================================

Obj6A_Animate03:			; XREF: ROM:00015AB6j
		jsr	SpeedToPos
		move.w	obX(a0),$3A(a0)
		subq.b	#1,obTimeFrame(a0)
		bpl.s	locret_15B24
		move.b	#2,obTimeFrame(a0)
		bchg	#0,obFrame(a0)

locret_15B24:
		rts	
; ===========================================================================

Obj6A_Type04:				; XREF: Obj6A_TypeIndex
		tst.b	$3D(a0)
		bne.s	Obj6A_Animate04
		move.w	($FFFFD008).w,d0
		addi.w	#$E0,d0
		sub.w	obX(a0),d0
		bcc.s	loc_15B74
		move.w	($FFFFD00C).w,d0
		subi.w	#$80,d0
		cmp.w	obY(a0),d0
		bcc.s	locret_15B76
		addi.w	#$100,d0
		cmp.w	obY(a0),d0
		bcs.s	locret_15B76
		move.b	#1,$3D(a0)
		move.w	#-$600,obVelX(a0)	; move object to the left
		move.b	#$A2,obColType(a0)
		move.b	#2,obFrame(a0)
		move.w	#$B0,d0
		jsr	(PlaySound_Special).l ;	play saw sound

loc_15B74:
		addq.l	#4,sp

locret_15B76:
		rts	
; ===========================================================================

Obj6A_Animate04:
		jsr	SpeedToPos
		move.w	obX(a0),$3A(a0)
		subq.b	#1,obTimeFrame(a0)
		bpl.s	locret_15B96
		move.b	#2,obTimeFrame(a0)
		bchg	#0,obFrame(a0)

locret_15B96:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - ground saws	and pizza cutters (SBZ)
; ---------------------------------------------------------------------------
Map_obj6A:
		include	"_maps\obj6A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6B - stomper (SBZ)
; ---------------------------------------------------------------------------

Obj6B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj6B_Index(pc,d0.w),d1
		jmp	Obj6B_Index(pc,d1.w)
; ===========================================================================
Obj6B_Index:	dc.w Obj6B_Main-Obj6B_Index
		dc.w Obj6B_Action-Obj6B_Index

Obj6B_Var:	dc.b  $40,  $C,	$80,   1 ; width, height, ????,	type number
		dc.b  $1C, $20,	$38,   3
		dc.b  $1C, $20,	$40,   4
		dc.b  $1C, $20,	$60,   4
		dc.b  $80, $40,	  0,   5
; ===========================================================================

Obj6B_Main:				; XREF: Obj6B_Index
		addq.b	#2,obRoutine(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsr.w	#2,d0
		andi.w	#$1C,d0
		lea	Obj6B_Var(pc,d0.w),a3
		move.b	(a3)+,obActWid(a0)
		move.b	(a3)+,obHeight(a0)
		lsr.w	#2,d0
		move.b	d0,obFrame(a0)
		move.l	#Map_obj6B,obMap(a0)
		move.w	#$22C0,obGfx(a0)
		cmpi.b	#1,($FFFFFE10).w ; check if level is LZ/SBZ3
		bne.s	Obj6B_SBZ12	; if not, branch
		bset	#0,($FFFFF7CB).w
		beq.s	Obj6B_SBZ3

Obj6B_ChkGone:				; XREF: Obj6B_SBZ3
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj6B_Delete
		bclr	#7,obGfx(a2,d0.w)

Obj6B_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj6B_SBZ3:				; XREF: Obj6B_Main
		move.w	#$41F0,obGfx(a0)
		cmpi.w	#$A80,obX(a0)
		bne.s	Obj6B_SBZ12
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj6B_SBZ12
		btst	#0,obGfx(a2,d0.w)
		beq.s	Obj6B_SBZ12
		clr.b	($FFFFF7CB).w
		bra.s	Obj6B_ChkGone
; ===========================================================================

Obj6B_SBZ12:				; XREF: Obj6B_Main
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.w	obX(a0),$34(a0)
		move.w	obY(a0),$30(a0)
		moveq	#0,d0
		move.b	(a3)+,d0
		move.w	d0,$3C(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		bpl.s	Obj6B_Action
		andi.b	#$F,d0
		move.b	d0,$3E(a0)
		move.b	(a3),obSubtype(a0)
		cmpi.b	#5,(a3)
		bne.s	Obj6B_ChkGone2
		bset	#4,obRender(a0)

Obj6B_ChkGone2:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj6B_Action
		bclr	#7,obGfx(a2,d0.w)

Obj6B_Action:				; XREF: Obj6B_Index
		move.w	obX(a0),-(sp)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		andi.w	#$F,d0
		add.w	d0,d0
		move.w	Obj6B_TypeIndex(pc,d0.w),d1
		jsr	obj6B_TypeIndex(pc,d1.w)
		move.w	(sp)+,d4
		tst.b	obRender(a0)
		bpl.s	Obj6B_ChkDel
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	obHeight(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsr	SolidObject

Obj6B_ChkDel:
		move.w	$34(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_15D64
		jmp	DisplaySprite
; ===========================================================================

loc_15D64:
		cmpi.b	#1,($FFFFFE10).w
		bne.s	Obj6B_Delete2
		clr.b	($FFFFF7CB).w
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	Obj6B_Delete2
		bclr	#7,obGfx(a2,d0.w)

Obj6B_Delete2:
		jmp	DeleteObject
; ===========================================================================
Obj6B_TypeIndex:dc.w Obj6B_Type00-Obj6B_TypeIndex, Obj6B_Type01-Obj6B_TypeIndex
		dc.w Obj6B_Type02-Obj6B_TypeIndex, Obj6B_Type03-Obj6B_TypeIndex
		dc.w Obj6B_Type04-Obj6B_TypeIndex, Obj6B_Type05-Obj6B_TypeIndex
; ===========================================================================

Obj6B_Type00:				; XREF: Obj6B_TypeIndex
		rts	
; ===========================================================================

Obj6B_Type01:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15DB4
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	loc_15DC2
		move.b	#1,$38(a0)

loc_15DB4:
		move.w	$3C(a0),d0
		cmp.w	$3A(a0),d0
		beq.s	loc_15DE0
		addq.w	#2,$3A(a0)

loc_15DC2:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_15DD4
		neg.w	d0
		addi.w	#$80,d0

loc_15DD4:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,obX(a0)
		rts	
; ===========================================================================

loc_15DE0:
		addq.b	#1,obSubtype(a0)
		move.w	#$B4,$36(a0)
		clr.b	$38(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_15DC2
		bset	#0,obGfx(a2,d0.w)
		bra.s	loc_15DC2
; ===========================================================================

Obj6B_Type02:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15E14
		subq.w	#1,$36(a0)
		bne.s	loc_15E1E
		move.b	#1,$38(a0)

loc_15E14:
		tst.w	$3A(a0)
		beq.s	loc_15E3C
		subq.w	#2,$3A(a0)

loc_15E1E:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_15E30
		neg.w	d0
		addi.w	#$80,d0

loc_15E30:
		move.w	$34(a0),d1
		sub.w	d0,d1
		move.w	d1,obX(a0)
		rts	
; ===========================================================================

loc_15E3C:
		subq.b	#1,obSubtype(a0)
		clr.b	$38(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_15E1E
		bclr	#0,obGfx(a2,d0.w)
		bra.s	loc_15E1E
; ===========================================================================

Obj6B_Type03:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15E7C
		tst.w	$3A(a0)
		beq.s	loc_15E6A
		subq.w	#1,$3A(a0)
		bra.s	loc_15E8E
; ===========================================================================

loc_15E6A:
		subq.w	#1,$36(a0)
		bpl.s	loc_15E8E
		move.w	#$3C,$36(a0)
		move.b	#1,$38(a0)

loc_15E7C:
		addq.w	#8,$3A(a0)
		move.w	$3A(a0),d0
		cmp.w	$3C(a0),d0
		bne.s	loc_15E8E
		clr.b	$38(a0)

loc_15E8E:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_15EA0
		neg.w	d0
		addi.w	#$38,d0

loc_15EA0:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================

Obj6B_Type04:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15ED0
		tst.w	$3A(a0)
		beq.s	loc_15EBE
		subq.w	#8,$3A(a0)
		bra.s	loc_15EF0
; ===========================================================================

loc_15EBE:
		subq.w	#1,$36(a0)
		bpl.s	loc_15EF0
		move.w	#$3C,$36(a0)
		move.b	#1,$38(a0)

loc_15ED0:
		move.w	$3A(a0),d0
		cmp.w	$3C(a0),d0
		beq.s	loc_15EE0
		addq.w	#8,$3A(a0)
		bra.s	loc_15EF0
; ===========================================================================

loc_15EE0:
		subq.w	#1,$36(a0)
		bpl.s	loc_15EF0
		move.w	#$3C,$36(a0)
		clr.b	$38(a0)

loc_15EF0:
		move.w	$3A(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_15F02
		neg.w	d0
		addi.w	#$38,d0

loc_15F02:
		move.w	$30(a0),d1
		add.w	d0,d1
		move.w	d1,obY(a0)
		rts	
; ===========================================================================

Obj6B_Type05:				; XREF: Obj6B_TypeIndex
		tst.b	$38(a0)
		bne.s	loc_15F3E
		lea	($FFFFF7E0).w,a2
		moveq	#0,d0
		move.b	$3E(a0),d0
		btst	#0,(a2,d0.w)
		beq.s	locret_15F5C
		move.b	#1,$38(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_15F3E
		bset	#0,obGfx(a2,d0.w)

loc_15F3E:
		subi.l	#$10000,obX(a0)
		addi.l	#$8000,obY(a0)
		move.w	obX(a0),$34(a0)
		cmpi.w	#$980,obX(a0)
		beq.s	loc_15F5E

locret_15F5C:
		rts	
; ===========================================================================

loc_15F5E:
		clr.b	obSubtype(a0)
		clr.b	$38(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - stomper and	platforms (SBZ)
; ---------------------------------------------------------------------------
Map_obj6B:
		include	"_maps\obj6B.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6C - vanishing	platforms (SBZ)
; ---------------------------------------------------------------------------

Obj6C:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj6C_Index(pc,d0.w),d1
		jmp	Obj6C_Index(pc,d1.w)
; ===========================================================================
Obj6C_Index:	dc.w Obj6C_Main-Obj6C_Index
		dc.w Obj6C_Vanish-Obj6C_Index
		dc.w Obj6C_Vanish-Obj6C_Index
		dc.w loc_16068-Obj6C_Index
; ===========================================================================

Obj6C_Main:				; XREF: Obj6C_Index
		addq.b	#6,obRoutine(a0)
		move.l	#Map_obj6C,obMap(a0)
		move.w	#$44C3,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$10,obActWid(a0)
		move.b	#4,obPriority(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get object type
		andi.w	#$F,d0		; read only the	2nd digit
		addq.w	#1,d0		; add 1
		lsl.w	#7,d0		; multiply by $80
		move.w	d0,d1
		subq.w	#1,d0
		move.w	d0,$30(a0)
		move.w	d0,$32(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; get object type
		andi.w	#$F0,d0		; read only the	1st digit
		addi.w	#$80,d1
		mulu.w	d1,d0
		lsr.l	#8,d0
		move.w	d0,$36(a0)
		subq.w	#1,d1
		move.w	d1,$38(a0)

loc_16068:				; XREF: Obj6C_Index
		move.w	($FFFFFE04).w,d0
		sub.w	$36(a0),d0
		and.w	$38(a0),d0
		bne.s	Obj6C_Animate
		subq.b	#4,obRoutine(a0)
		bra.s	Obj6C_Vanish
; ===========================================================================

Obj6C_Animate:
		lea	(Ani_obj6C).l,a1
		jsr	AnimateSprite
		jmp	MarkObjGone
; ===========================================================================

Obj6C_Vanish:				; XREF: Obj6C_Index
		subq.w	#1,$30(a0)
		bpl.s	loc_160AA
		move.w	#127,$30(a0)
		tst.b	obAnim(a0)
		beq.s	loc_160A4
		move.w	$32(a0),$30(a0)

loc_160A4:
		bchg	#0,obAnim(a0)

loc_160AA:
		lea	(Ani_obj6C).l,a1
		jsr	AnimateSprite
		btst	#1,obFrame(a0)	; has platform vanished?
		bne.s	Obj6C_NotSolid	; if yes, branch
		cmpi.b	#2,obRoutine(a0)
		bne.s	loc_160D6
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(PlatformObject).l
		jmp	MarkObjGone
; ===========================================================================

loc_160D6:
		moveq	#0,d1
		move.b	obActWid(a0),d1
		jsr	(ExitPlatform).l
		move.w	obX(a0),d2
		jsr	(MvSonicOnPtfm2).l
		jmp	MarkObjGone
; ===========================================================================

Obj6C_NotSolid:				; XREF: Obj6C_Vanish
		btst	#3,obStatus(a0)
		beq.s	Obj6C_Display
		lea	($FFFFD000).w,a1
		bclr	#3,obStatus(a1)
		bclr	#3,obStatus(a0)
		move.b	#2,obRoutine(a0)
		clr.b	ob2ndRout(a0)

Obj6C_Display:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj6C:
		include	"_anim\obj6C.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - vanishing platforms	(SBZ)
; ---------------------------------------------------------------------------
Map_obj6C:
		include	"_maps\obj6C.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6E - electrocution orbs (SBZ)
; ---------------------------------------------------------------------------

Obj6E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj6E_Index(pc,d0.w),d1
		jmp	Obj6E_Index(pc,d1.w)
; ===========================================================================
Obj6E_Index:	dc.w Obj6E_Main-Obj6E_Index
		dc.w Obj6E_Shock-Obj6E_Index
; ===========================================================================

Obj6E_Main:				; XREF: Obj6E_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj6E,obMap(a0)
		move.w	#$47E,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#$28,obActWid(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0	; read object type
		lsl.w	#4,d0		; multiply by $10
		subq.w	#1,d0
		move.w	d0,$34(a0)

Obj6E_Shock:				; XREF: Obj6E_Index
		move.w	($FFFFFE04).w,d0
		and.w	$34(a0),d0
		bne.s	Obj6E_Animate
		move.b	#1,obAnim(a0)	; run "shocking" animation
		tst.b	obRender(a0)
		bpl.s	Obj6E_Animate
		move.w	#$B1,d0
		jsr	(PlaySound_Special).l ;	play electricity sound

Obj6E_Animate:
		lea	(Ani_obj6E).l,a1
		jsr	AnimateSprite
		move.b	#0,obColType(a0)
		cmpi.b	#4,obFrame(a0)	; is frame number 4 displayed?
		bne.s	Obj6E_Display	; if not, branch
		move.b	#$A4,obColType(a0)	; if yes, make object hurt Sonic

Obj6E_Display:
		jmp	MarkObjGone
; ===========================================================================
Ani_obj6E:
		include	"_anim\obj6E.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - electrocution orbs (SBZ)
; ---------------------------------------------------------------------------
Map_obj6E:
		include	"_maps\obj6E.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6F - spinning platforms that move around a conveyor belt (SBZ)
; ---------------------------------------------------------------------------

Obj6F:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj6F_Index(pc,d0.w),d1
		jsr	obj6F_Index(pc,d1.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	loc_1629A

Obj6F_Display:
		jmp	DisplaySprite
; ===========================================================================

loc_1629A:
		cmpi.b	#2,($FFFFFE11).w ; check if act	is 3
		bne.s	Obj6F_Act1or2	; if not, branch
		cmpi.w	#-$80,d0
		bcc.s	Obj6F_Display

Obj6F_Act1or2:
		move.b	$2F(a0),d0
		bpl.s	Obj6F_Delete
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bclr	#0,(a2,d0.w)

Obj6F_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj6F_Index:	dc.w Obj6F_Main-Obj6F_Index
		dc.w loc_163D8-Obj6F_Index
; ===========================================================================

Obj6F_Main:				; XREF: Obj6F_Index
		move.b	obSubtype(a0),d0
		bmi.w	loc_16380
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj69a,obMap(a0)
		move.w	#$4DF,obGfx(a0)
		move.b	#$10,obActWid(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		move.w	d0,d1
		lsr.w	#3,d0
		andi.w	#$1E,d0
		lea	off_164A6(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,$38(a0)
		move.w	(a2)+,$30(a0)
		move.l	a2,$3C(a0)
		andi.w	#$F,d1
		lsl.w	#2,d1
		move.b	d1,$38(a0)
		move.b	#4,$3A(a0)
		tst.b	($FFFFF7C0).w
		beq.s	loc_16356
		move.b	#1,$3B(a0)
		neg.b	$3A(a0)
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_16352
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_16352
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_16352:
		move.b	d1,$38(a0)

loc_16356:
		move.w	(a2,d1.w),$34(a0)
		move.w	obGfx(a2,d1.w),$36(a0)
		tst.w	d1
		bne.s	loc_1636C
		move.b	#1,obAnim(a0)

loc_1636C:
		cmpi.w	#8,d1
		bne.s	loc_16378
		move.b	#0,obAnim(a0)

loc_16378:
		jsr	obj63_ChangeDir
		bra.w	loc_163D8
; ===========================================================================

loc_16380:				; XREF: Obj6F_Main
		move.b	d0,$2F(a0)
		andi.w	#$7F,d0
		lea	($FFFFF7C1).w,a2
		bset	#0,(a2,d0.w)
		beq.s	loc_1639A
		jmp	DeleteObject
; ===========================================================================

loc_1639A:
		add.w	d0,d0
		andi.w	#$1E,d0
		addi.w	#$80,d0
		lea	(ObjPos_Index).l,a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,d1
		movea.l	a0,a1
		bra.s	Obj6F_LoadPform
; ===========================================================================

Obj6F_Loop:
		jsr	SingleObjLoad
		bne.s	loc_163D0

Obj6F_LoadPform:			; XREF: loc_1639A
		move.b	#$6F,0(a1)
		move.w	(a2)+,obX(a1)
		move.w	(a2)+,obY(a1)
		move.w	(a2)+,d0
		move.b	d0,obSubtype(a1)

loc_163D0:
		dbf	d1,Obj6F_Loop

		addq.l	#4,sp
		rts	
; ===========================================================================

loc_163D8:				; XREF: Obj6F_Index
		lea	(Ani_obj6F).l,a1
		jsr	AnimateSprite
		tst.b	obFrame(a0)
		bne.s	loc_16404
		move.w	obX(a0),-(sp)
		bsr	loc_16424
		move.w	#$1B,d1
		move.w	#7,d2
		move.w	d2,d3
		addq.w	#1,d3
		move.w	(sp)+,d4
		jmp	SolidObject
; ===========================================================================

loc_16404:
		btst	#3,obStatus(a0)
		beq.s	loc_16420
		lea	($FFFFD000).w,a1
		bclr	#3,obStatus(a1)
		bclr	#3,obStatus(a0)
		clr.b	ob2ndRout(a0)

loc_16420:
		bra.w	*+4

loc_16424:
		move.w	obX(a0),d0
		cmp.w	$34(a0),d0
		bne.s	loc_16484
		move.w	obY(a0),d0
		cmp.w	$36(a0),d0
		bne.s	loc_16484
		moveq	#0,d1
		move.b	$38(a0),d1
		add.b	$3A(a0),d1
		cmp.b	$39(a0),d1
		bcs.s	loc_16456
		move.b	d1,d0
		moveq	#0,d1
		tst.b	d0
		bpl.s	loc_16456
		move.b	$39(a0),d1
		subq.b	#4,d1

loc_16456:
		move.b	d1,$38(a0)
		movea.l	$3C(a0),a1
		move.w	(a1,d1.w),$34(a0)
		move.w	obGfx(a1,d1.w),$36(a0)
		tst.w	d1
		bne.s	loc_16474
		move.b	#1,obAnim(a0)

loc_16474:
		cmpi.w	#8,d1
		bne.s	loc_16480
		move.b	#0,obAnim(a0)

loc_16480:
		jsr	obj63_ChangeDir

loc_16484:
		jmp	SpeedToPos
; ===========================================================================
Ani_obj6F:
		include	"_anim\obj6F.asm"

off_164A6:	dc.w word_164B2-off_164A6, word_164C6-off_164A6, word_164DA-off_164A6
		dc.w word_164EE-off_164A6, word_16502-off_164A6, word_16516-off_164A6
word_164B2:	dc.w $10, $E80,	$E14, $370, $EEF, $302,	$EEF, $340, $E14, $3AE
word_164C6:	dc.w $10, $F80,	$F14, $2E0, $FEF, $272,	$FEF, $2B0, $F14, $31E
word_164DA:	dc.w $10, $1080, $1014,	$270, $10EF, $202, $10EF, $240,	$1014, $2AE
word_164EE:	dc.w $10, $F80,	$F14, $570, $FEF, $502,	$FEF, $540, $F14, $5AE
word_16502:	dc.w $10, $1B80, $1B14,	$670, $1BEF, $602, $1BEF, $640,	$1B14, $6AE
word_16516:	dc.w $10, $1C80, $1C14,	$5E0, $1CEF, $572, $1CEF, $5B0,	$1C14, $61E
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 70 - large girder block (SBZ)
; ---------------------------------------------------------------------------

Obj70:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj70_Index(pc,d0.w),d1
		jmp	Obj70_Index(pc,d1.w)
; ===========================================================================
Obj70_Index:	dc.w Obj70_Main-Obj70_Index
		dc.w Obj70_Action-Obj70_Index
; ===========================================================================

Obj70_Main:				; XREF: Obj70_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj70,obMap(a0)
		move.w	#$42F0,obGfx(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$60,obActWid(a0)
		move.b	#$18,obHeight(a0)
		move.w	obX(a0),$32(a0)
		move.w	obY(a0),$30(a0)
		jsr	obj70_Move2

Obj70_Action:				; XREF: Obj70_Index
		move.w	obX(a0),-(sp)
		tst.w	$3A(a0)
		beq.s	Obj70_Move
		subq.w	#1,$3A(a0)
		bne.s	Obj70_Solid

Obj70_Move:
		jsr	SpeedToPos
		subq.w	#1,$34(a0)	; subtract 1 from movement duration
		bne.s	Obj70_Solid	; if time remains, branch
		jsr	obj70_Move2	; if time is zero, branch

Obj70_Solid:
		move.w	(sp)+,d4
		tst.b	obRender(a0)
		bpl.s	Obj70_ChkDel
		moveq	#0,d1
		move.b	obActWid(a0),d1
		addi.w	#$B,d1
		moveq	#0,d2
		move.b	obHeight(a0),d2
		move.w	d2,d3
		addq.w	#1,d3
		jsr	SolidObject

Obj70_ChkDel:
		move.w	$32(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj70_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj70_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj70_Move2:				; XREF: Obj70_Main
		move.b	$38(a0),d0
		andi.w	#$18,d0
		lea	(Obj70_MoveData).l,a1
		lea	(a1,d0.w),a1
		move.w	(a1)+,obVelX(a0)
		move.w	(a1)+,obVelY(a0)
		move.w	(a1)+,$34(a0)
		addq.b	#8,$38(a0)	; use next movedata set
		move.w	#7,$3A(a0)
		rts	
; ===========================================================================
Obj70_MoveData:	dc.w   $100,	 0,   $60,     0 ; x-speed, y-speed, duration, blank
		dc.w	  0,  $100,   $30,     0
		dc.w  $FF00, $FFC0,   $60,     0
		dc.w	  0, $FF00,   $18,     0
; ---------------------------------------------------------------------------
; Sprite mappings - large girder block (SBZ)
; ---------------------------------------------------------------------------
Map_obj70:
		include	"_maps\obj70.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 72 - teleporter (SBZ)
; ---------------------------------------------------------------------------

Obj72:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj72_Index(pc,d0.w),d1
		jsr	obj72_Index(pc,d1.w)
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj72_Delete
		rts	
; ===========================================================================

Obj72_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj72_Index:	dc.w Obj72_Main-Obj72_Index
		dc.w loc_166C8-Obj72_Index
		dc.w loc_1675E-Obj72_Index
		dc.w loc_16798-Obj72_Index
; ===========================================================================

Obj72_Main:				; XREF: Obj72_Index
		addq.b	#2,obRoutine(a0)
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	Obj72_Data(pc),a2
		adda.w	(a2,d0.w),a2
		move.w	(a2)+,$3A(a0)
		move.l	a2,$3C(a0)
		move.w	(a2)+,$36(a0)
		move.w	(a2)+,$38(a0)

loc_166C8:				; XREF: Obj72_Index
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_166E0
		addi.w	#$F,d0

loc_166E0:
		cmpi.w	#$10,d0
		bcc.s	locret_1675C
		move.w	obY(a1),d1
		sub.w	obY(a0),d1
		addi.w	#$20,d1
		cmpi.w	#$40,d1
		bcc.s	locret_1675C
		tst.b	($FFFFF7C8).w
		bne.s	locret_1675C
		cmpi.b	#7,obSubtype(a0)
		bne.s	loc_1670E
		cmpi.w	#50,($FFFFFE20).w
		bcs.s	locret_1675C

loc_1670E:
		addq.b	#2,obRoutine(a0)
		move.b	#$81,($FFFFF7C8).w ; lock controls
		move.b	#2,obAnim(a1)	; use Sonic's rolling animation
		move.w	#$800,obInertia(a1)
		move.w	#0,obVelX(a1)
		move.w	#0,obVelY(a1)
		bclr	#5,obStatus(a0)
		bclr	#5,obStatus(a1)
		bset	#1,obStatus(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		clr.b	$32(a0)
		move.w	#$BE,d0
		jsr	(PlaySound_Special).l ;	play Sonic rolling sound

locret_1675C:
		rts	
; ===========================================================================

loc_1675E:				; XREF: Obj72_Index
		lea	($FFFFD000).w,a1
		move.b	$32(a0),d0
		addq.b	#2,$32(a0)
		jsr	(CalcSine).l
		asr.w	#5,d0
		move.w	obY(a0),d2
		sub.w	d0,d2
		move.w	d2,obY(a1)
		cmpi.b	#$80,$32(a0)
		bne.s	locret_16796
		bsr	sub_1681C
		addq.b	#2,obRoutine(a0)
		move.w	#$BC,d0
		jsr	(PlaySound_Special).l ;	play teleport sound

locret_16796:
		rts	
; ===========================================================================

loc_16798:				; XREF: Obj72_Index
		addq.l	#4,sp
		lea	($FFFFD000).w,a1
		subq.b	#1,$2E(a0)
		bpl.s	loc_167DA
		move.w	$36(a0),obX(a1)
		move.w	$38(a0),obY(a1)
		moveq	#0,d1
		move.b	$3A(a0),d1
		addq.b	#4,d1
		cmp.b	$3B(a0),d1
		bcs.s	loc_167C2
		moveq	#0,d1
		bra.s	loc_16800
; ===========================================================================

loc_167C2:
		move.b	d1,$3A(a0)
		movea.l	$3C(a0),a2
		move.w	(a2,d1.w),$36(a0)
		move.w	obGfx(a2,d1.w),$38(a0)
		bra.w	sub_1681C
; ===========================================================================

loc_167DA:
		move.l	obX(a1),d2
		move.l	obY(a1),d3
		move.w	obVelX(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	obVelY(a1),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,obX(a1)
		move.l	d3,obY(a1)
		rts	
; ===========================================================================

loc_16800:
		andi.w	#$7FF,obY(a1)
		clr.b	obRoutine(a0)
		clr.b	($FFFFF7C8).w
		move.w	#0,obVelX(a1)
		move.w	#$200,obVelY(a1)
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_1681C:
		moveq	#0,d0
		move.w	#$1000,d2
		move.w	$36(a0),d0
		sub.w	obX(a1),d0
		bge.s	loc_16830
		neg.w	d0
		neg.w	d2

loc_16830:
		moveq	#0,d1
		move.w	#$1000,d3
		move.w	$38(a0),d1
		sub.w	obY(a1),d1
		bge.s	loc_16844
		neg.w	d1
		neg.w	d3

loc_16844:
		cmp.w	d0,d1
		bcs.s	loc_1687A
		moveq	#0,d1
		move.w	$38(a0),d1
		sub.w	obY(a1),d1
		swap	d1
		divs.w	d3,d1
		moveq	#0,d0
		move.w	$36(a0),d0
		sub.w	obX(a1),d0
		beq.s	loc_16866
		swap	d0
		divs.w	d1,d0

loc_16866:
		move.w	d0,obVelX(a1)
		move.w	d3,obVelY(a1)
		tst.w	d1
		bpl.s	loc_16874
		neg.w	d1

loc_16874:
		move.w	d1,$2E(a0)
		rts	
; ===========================================================================

loc_1687A:
		moveq	#0,d0
		move.w	$36(a0),d0
		sub.w	obX(a1),d0
		swap	d0
		divs.w	d2,d0
		moveq	#0,d1
		move.w	$38(a0),d1
		sub.w	obY(a1),d1
		beq.s	loc_16898
		swap	d1
		divs.w	d0,d1

loc_16898:
		move.w	d1,obVelY(a1)
		move.w	d2,obVelX(a1)
		tst.w	d0
		bpl.s	loc_168A6
		neg.w	d0

loc_168A6:
		move.w	d0,$2E(a0)
		rts	
; End of function sub_1681C

; ===========================================================================
Obj72_Data:	dc.w word_168BC-Obj72_Data, word_168C2-Obj72_Data, word_168C8-Obj72_Data
		dc.w word_168E6-Obj72_Data, word_168EC-Obj72_Data, word_1690A-Obj72_Data
		dc.w word_16910-Obj72_Data, word_1692E-Obj72_Data
word_168BC:	dc.w 4,	$794, $98C
word_168C2:	dc.w 4,	$94, $38C
word_168C8:	dc.w $1C, $794,	$2E8
		dc.w $7A4, $2C0, $7D0
		dc.w $2AC, $858, $2AC
		dc.w $884, $298, $894
		dc.w $270, $894, $190
word_168E6:	dc.w 4,	$894, $690
word_168EC:	dc.w $1C, $1194, $470
		dc.w $1184, $498, $1158
		dc.w $4AC, $FD0, $4AC
		dc.w $FA4, $4C0, $F94
		dc.w $4E8, $F94, $590
word_1690A:	dc.w 4,	$1294, $490
word_16910:	dc.w $1C, $1594, $FFE8
		dc.w $1584, $FFC0, $1560
		dc.w $FFAC, $14D0, $FFAC
		dc.w $14A4, $FF98, $1494
		dc.w $FF70, $1494, $FD90
word_1692E:	dc.w 4,	$894, $90
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 78 - Caterkiller enemy	(MZ, SBZ)
; ---------------------------------------------------------------------------

Obj78:					; XREF: Obj_Index
		jmp	DeleteObject
; ---------------------------------------------------------------------------
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj78_Index(pc,d0.w),d1
		jmp	Obj78_Index(pc,d1.w)
; ===========================================================================
Obj78_Index:	dc.w Obj78_Main-Obj78_Index
		dc.w Obj78_Action-Obj78_Index
		dc.w Obj78_BodySeg1-Obj78_Index
		dc.w Obj78_BodySeg2-Obj78_Index
		dc.w Obj78_BodySeg1-Obj78_Index
		dc.w Obj78_Delete-Obj78_Index
		dc.w loc_16CC0-Obj78_Index
; ===========================================================================

locret_16950:
		rts	
; ===========================================================================

Obj78_Main:				; XREF: Obj78_Index
		move.b	#7,obHeight(a0)
		move.b	#8,obWidth(a0)
		jsr	ObjectFall
		jsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_16950
		add.w	d1,obY(a0)
		clr.w	obVelY(a0)
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj78,obMap(a0)
		move.w	#$22B0,obGfx(a0)
		cmpi.b	#5,($FFFFFE10).w ; if level is SBZ, branch
		beq.s	loc_16996
		move.w	#$24FF,obGfx(a0)	; MZ specific code

loc_16996:
		andi.b	#3,obRender(a0)
		ori.b	#4,obRender(a0)
		move.b	obRender(a0),obStatus(a0)
		move.b	#4,obPriority(a0)
		move.b	#8,obActWid(a0)
		move.b	#$B,obColType(a0)
		move.w	obX(a0),d2
		moveq	#$C,d5
		btst	#0,obStatus(a0)
		beq.s	loc_169CA
		neg.w	d5

loc_169CA:
		move.b	#4,d6
		moveq	#0,d3
		moveq	#4,d4
		movea.l	a0,a2
		moveq	#2,d1

Obj78_LoadBody:
		jsr	SingleObjLoad2
		bne.s	Obj78_QuitLoad
		move.b	#$78,0(a1)	; load body segment object
		move.b	d6,obRoutine(a1)
		addq.b	#2,d6
		move.l	obMap(a0),obMap(a1)
		move.w	obGfx(a0),obGfx(a1)
		move.b	#5,obPriority(a1)
		move.b	#8,obActWid(a1)
		move.b	#$CB,obColType(a1)
		add.w	d5,d2
		move.w	d2,obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	obStatus(a0),obStatus(a1)
		move.b	obStatus(a0),obRender(a1)
		move.b	#8,obFrame(a1)
		move.l	a2,$3C(a1)
		move.b	d4,$3C(a1)
		addq.b	#4,d4
		movea.l	a1,a2

Obj78_QuitLoad:
		dbf	d1,Obj78_LoadBody ; repeat sequence 2 more times

		move.b	#7,$2A(a0)
		clr.b	$3C(a0)

Obj78_Action:				; XREF: Obj78_Index
		tst.b	obStatus(a0)
		bmi.w	loc_16C96
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj78_Index2(pc,d0.w),d1
		jsr	obj78_Index2(pc,d1.w)
		move.b	$2B(a0),d1
		bpl.s	Obj78_Display
		lea	(Ani_obj78).l,a1
		move.b	obAngle(a0),d0
		andi.w	#$7F,d0
		addq.b	#4,obAngle(a0)
		move.b	(a1,d0.w),d0
		bpl.s	Obj78_AniHead
		bclr	#7,$2B(a0)
		bra.s	Obj78_Display
; ===========================================================================

Obj78_AniHead:
		andi.b	#$10,d1
		add.b	d1,d0
		move.b	d0,obFrame(a0)

Obj78_Display:
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.w	Obj78_ChkGone
		jmp	DisplaySprite
; ===========================================================================

Obj78_ChkGone:
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		beq.s	loc_16ABC
		bclr	#7,obGfx(a2,d0.w)

loc_16ABC:
		move.b	#$A,obRoutine(a0)	; run "Obj78_Delete" routine
		rts	
; ===========================================================================

Obj78_Delete:				; XREF: Obj78_Index
		jmp	DeleteObject
; ===========================================================================
Obj78_Index2:	dc.w Obj78_Move-Obj78_Index2
		dc.w loc_16B02-Obj78_Index2
; ===========================================================================

Obj78_Move:				; XREF: Obj78_Index2
		subq.b	#1,$2A(a0)
		bmi.s	Obj78_Move2
		rts	
; ===========================================================================

Obj78_Move2:
		addq.b	#2,ob2ndRout(a0)
		move.b	#$10,$2A(a0)
		move.w	#-$C0,obVelX(a0)
		move.w	#$40,obInertia(a0)
		bchg	#4,$2B(a0)
		bne.s	loc_16AFC
		clr.w	obVelX(a0)
		neg.w	obInertia(a0)

loc_16AFC:
		bset	#7,$2B(a0)

loc_16B02:				; XREF: Obj78_Index2
		subq.b	#1,$2A(a0)
		bmi.s	loc_16B5E
		move.l	obX(a0),-(sp)
		move.l	obX(a0),d2
		move.w	obVelX(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_16B1E
		neg.w	d0

loc_16B1E:
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.l	d2,obX(a0)
		bsr	ObjHitFloor
		move.l	(sp)+,d2
		cmpi.w	#-8,d1
		blt.s	loc_16B70
		cmpi.w	#$C,d1
		bge.s	loc_16B70
		add.w	d1,obY(a0)
		swap	d2
		cmp.w	obX(a0),d2
		beq.s	locret_16B5C
		moveq	#0,d0
		move.b	$3C(a0),d0
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		move.b	d1,$2C(a0,d0.w)

locret_16B5C:
		rts	
; ===========================================================================

loc_16B5E:
		subq.b	#2,ob2ndRout(a0)
		move.b	#7,$2A(a0)
		move.w	#0,obVelX(a0)
		rts	
; ===========================================================================

loc_16B70:
		move.l	d2,obX(a0)
		bchg	#0,obStatus(a0)
		move.b	obStatus(a0),obRender(a0)
		moveq	#0,d0
		move.b	$3C(a0),d0
		move.b	#$80,$2C(a0,d0.w)
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		rts	
; ===========================================================================

Obj78_BodySeg2:				; XREF: Obj78_Index
		movea.l	$3C(a0),a1
		move.b	$2B(a1),$2B(a0)
		bpl.s	Obj78_BodySeg1
		lea	(Ani_obj78).l,a1
		move.b	obAngle(a0),d0
		andi.w	#$7F,d0
		addq.b	#4,obAngle(a0)
		tst.b	obMap(a1,d0.w)
		bpl.s	Obj78_AniBody
		addq.b	#4,obAngle(a0)

Obj78_AniBody:
		move.b	(a1,d0.w),d0
		addq.b	#8,d0
		move.b	d0,obFrame(a0)

Obj78_BodySeg1:				; XREF: Obj78_Index
		movea.l	$3C(a0),a1
		tst.b	obStatus(a0)
		bmi.w	loc_16C90
		move.b	$2B(a1),$2B(a0)
		move.b	ob2ndRout(a1),ob2ndRout(a0)
		beq.w	loc_16C64
		move.w	obInertia(a1),obInertia(a0)
		move.w	obVelX(a1),d0
		add.w	obInertia(a1),d0
		move.w	d0,obVelX(a0)
		move.l	obX(a0),d2
		move.l	d2,d3
		move.w	obVelX(a0),d0
		btst	#0,obStatus(a0)
		beq.s	loc_16C0C
		neg.w	d0

loc_16C0C:
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.l	d2,obX(a0)
		swap	d3
		cmp.w	obX(a0),d3
		beq.s	loc_16C64
		moveq	#0,d0
		move.b	$3C(a0),d0
		move.b	$2C(a1,d0.w),d1
		cmpi.b	#-$80,d1
		bne.s	loc_16C50
		swap	d3
		move.l	d3,obX(a0)
		move.b	d1,$2C(a0,d0.w)
		bchg	#0,obStatus(a0)
		move.b	obStatus(a0),obRender(a0)
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		bra.s	loc_16C64
; ===========================================================================

loc_16C50:
		ext.w	d1
		add.w	d1,obY(a0)
		addq.b	#1,$3C(a0)
		andi.b	#$F,$3C(a0)
		move.b	d1,$2C(a0,d0.w)

loc_16C64:
		cmpi.b	#$C,obRoutine(a1)
		beq.s	loc_16C90
		cmpi.b	#$27,0(a1)
		beq.s	loc_16C7C
		cmpi.b	#$A,obRoutine(a1)
		bne.s	loc_16C82

loc_16C7C:
		move.b	#$A,obRoutine(a0)

loc_16C82:
		jmp	DisplaySprite

; ===========================================================================
Obj78_FragSpeed:dc.w $FE00, $FE80, $180, $200
; ===========================================================================

loc_16C90:
		bset	#7,obStatus(a1)

loc_16C96:
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj78_FragSpeed-obGfx(pc,d0.w),d0
		btst	#0,obStatus(a0)
		beq.s	loc_16CAA
		neg.w	d0

loc_16CAA:
		move.w	d0,obVelX(a0)
		move.w	#-$400,obVelY(a0)
		move.b	#$C,obRoutine(a0)
		andi.b	#-8,obFrame(a0)

loc_16CC0:				; XREF: Obj78_Index
		jsr	ObjectFall
		tst.w	obVelY(a0)
		bmi.s	loc_16CE0
		bsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_16CE0
		add.w	d1,obY(a0)
		move.w	#-$400,obVelY(a0)

loc_16CE0:
		tst.b	obRender(a0)
		bpl.w	Obj78_ChkGone
		jmp	DisplaySprite
; ===========================================================================
Ani_obj78:
		include	"_anim\obj78.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Caterkiller	enemy (MZ, SBZ)
; ---------------------------------------------------------------------------
Map_obj78:
		include	"_maps\obj78.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 79 - lamppost
; ---------------------------------------------------------------------------

Obj79:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj79_Index(pc,d0.w),d1
		jsr	obj79_Index(pc,d1.w)
		jmp	MarkObjGone
; ===========================================================================
Obj79_Index:	dc.w Obj79_Main-Obj79_Index
		dc.w Obj79_BlueLamp-Obj79_Index
		dc.w Obj79_AfterHit-Obj79_Index
		dc.w Obj79_Twirl-Obj79_Index
; ===========================================================================

Obj79_Main:				; XREF: Obj79_Index
		frantic			
		beq.s	@notrpfrantic
		cmpi.w	#$200,($FFFFFE10).w
		bne.s	@notrpfrantic
		jmp	DeleteObject

@notrpfrantic:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj79,obMap(a0)
		move.w	#($D800/$20),obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#8,obActWid(a0)
		move.b	#5,obPriority(a0)
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		bclr	#7,obGfx(a2,d0.w)
		btst	#0,obGfx(a2,d0.w)
		bne.s	Obj79_RedLamp
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	obSubtype(a0),d2	; get lamppost number
		andi.b	#$7F,d2
		cmp.b	d2,d1		; is lamppost number higher than the number hit?
		bcs.s	Obj79_BlueLamp	; if yes, branch

Obj79_RedLamp:
		bset	#0,obGfx(a2,d0.w)
		move.b	#4,obRoutine(a0)	; run "Obj79_AfterHit" routine
		move.b	#3,obFrame(a0)	; use red lamppost frame
		rts	
; ===========================================================================

Obj79_BlueLamp:				; XREF: Obj79_Index
	;	tst.w	($FFFFFE08).w	; is debug mode	being used?
	;	bne.w	locret_16F90	; if yes, branch
		tst.b	($FFFFF7C8).w
		bmi.w	locret_16F90
		move.b	($FFFFFE30).w,d1
		andi.b	#$7F,d1
		move.b	obSubtype(a0),d2
		andi.b	#$7F,d2
		cmp.b	d2,d1
		bcs.s	Obj79_HitLamp
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		bset	#0,obGfx(a2,d0.w)
		move.b	#4,obRoutine(a0)
		move.b	#3,obFrame(a0)
		bra.w	locret_16F90
; ===========================================================================

Obj79_HitLamp:
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.w	locret_16F90		; if yes, branch

		; lamppost collision detection
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		addq.w	#8,d0
		cmpi.w	#$10,d0
		bcc.w	locret_16F90

		cmpi.w	#$002,($FFFFFE10).w	; are we in GHP?
		beq.s	@endghpaction		; if yes, end the black bars action stuff

		cmpi.w	#$101,($FFFFFE10).w	; are we in LP?
		bne.w	@regular		; if not, lampposts have no vertical hitbox
		move.w	($FFFFD00C).w,d0
		sub.w	obY(a0),d0
		addi.w	#$40,d0
		cmpi.w	#$68,d0
		bcc.w	locret_16F90
		bra.s	@regular

@endghpaction:
		move.b	#4,($FFFFFE30).w
		move.b	#0, ($FFFFFE2D).w ; remove invincibility

		movem.l	d0-d7/a1-a3,-(sp)
		moveq	#3,d0
		jsr	PalLoad2		; load Sonic palette
		moveq	#$C,d0
		jsr	PalLoad2	; load GHZ palette
		jsr	WhiteFlash2

		move.b	#$94,d0
		jsr	PlaySound
		
		movem.l	(sp)+,d0-d7/a1-a3
		bra.s 	@hitrest
		
@regular:
		move.w	#$A1,d0
		jsr	(PlaySound_Special).l ;	play lamppost sound
		
		cmpi.W	#$101,($FFFFFE10).w	; are we in LZ2?
		bne.s	@hitrest		; if not, branch
		move.b	#1,($FFFFFFFE).w	; make sure =P monitor is enabled (if the player somehow skipped it)
		move.b	obSubtype(a0),d2
		cmp.b	($FFFFFF97).w,d2
		blo.s	@hitrest
		move.b	d2,($FFFFFF97).w	; copy subtype to checkpoint counter

@hitrest:
		move.w	#1000,d0		; add 10000 ...
		jsr	AddPoints	; ... points

		addq.b	#2,obRoutine(a0)
		jsr	SingleObjLoad
		bne.s	loc_16F76
		move.b	#$79,0(a1)	; load twirling	lamp object
		move.b	#6,obRoutine(a1)	; use "Obj79_Twirl" routine
		move.w	obX(a0),$30(a1)
		move.w	obY(a0),$32(a1)
		subi.w	#$18,$32(a1)
		move.l	#Map_obj79,obMap(a1)
		move.w	#($D800/$20),obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#8,obActWid(a1)
		move.b	#4,obPriority(a1)
		move.b	#2,obFrame(a1)
		move.w	#$20,$36(a1)

loc_16F76:
		move.b	#1,obFrame(a0)	; use "post only" frame, with no lamp
		jsr	obj79_StoreInfo
		lea	($FFFFFC00).w,a2
		moveq	#0,d0
		move.b	obRespawnNo(a0),d0
		bset	#0,obGfx(a2,d0.w)

locret_16F90:
		rts	
; ===========================================================================

Obj79_AfterHit:				; XREF: Obj79_Index
		rts	
; ===========================================================================

Obj79_Twirl:				; XREF: Obj79_Index
		subq.w	#1,$36(a0)
		bpl.s	loc_16FA0
		move.b	#4,obRoutine(a0)

loc_16FA0:
		move.b	obAngle(a0),d0
		subi.b	#$10,obAngle(a0)
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$C00,d1
		swap	d1
		add.w	$30(a0),d1
		move.w	d1,obX(a0)
		muls.w	#$C00,d0
		swap	d0
		add.w	$32(a0),d0
		move.w	d0,obY(a0)
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	store information when you hit a lamppost
; ---------------------------------------------------------------------------

Obj79_StoreInfo:			; XREF: Obj79_HitLamp
		move.b	obSubtype(a0),($FFFFFE30).w 		; lamppost number
		move.b	($FFFFFE30).w,($FFFFFE31).w
		move.w	obX(a0),($FFFFFE32).w		; x-position
		move.w	obY(a0),($FFFFFE34).w		; y-position
		move.w	($FFFFFE20).w,($FFFFFE36).w 	; rings
		move.b	($FFFFFE1B).w,($FFFFFE54).w 	; lives
		move.l	($FFFFFE22).w,($FFFFFE38).w 	; time
		move.b	($FFFFF742).w,($FFFFFE3C).w 	; routine counter for dynamic level mod
		move.w	($FFFFF72E).w,($FFFFFE3E).w 	; lower y-boundary of level
		move.w	($FFFFF700).w,($FFFFFE40).w 	; screen x-position
		move.w	($FFFFF704).w,($FFFFFE42).w 	; screen y-position
		move.w	($FFFFF708).w,($FFFFFE44).w 	; bg position
		move.w	($FFFFF70C).w,($FFFFFE46).w 	; bg position
		move.w	($FFFFF710).w,($FFFFFE48).w 	; bg position
		move.w	($FFFFF714).w,($FFFFFE4A).w 	; bg position
		move.w	($FFFFF718).w,($FFFFFE4C).w 	; bg position
		move.w	($FFFFF71C).w,($FFFFFE4E).w 	; bg position
		move.w	($FFFFF648).w,($FFFFFE50).w 	; water height
		move.b	($FFFFF64D).w,($FFFFFE52).w 	; rountine counter for water
		move.b	($FFFFF64E).w,($FFFFFE53).w 	; water direction
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	load stored info when you start	a level	from a lamppost
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj79_LoadInfo:				; XREF: LevelSizeLoad
		move.b	($FFFFFE31).w,($FFFFFE30).w
		move.w	($FFFFFE32).w,($FFFFD008).w
		move.w	($FFFFFE34).w,($FFFFD00C).w
		move.w	($FFFFFE36).w,($FFFFFE20).w
		move.b	($FFFFFE54).w,($FFFFFE1B).w
	;	clr.w	($FFFFFE20).w
		clr.b	($FFFFFE1B).w
		move.l	($FFFFFE38).w,($FFFFFE22).w
		move.b	#59,($FFFFFE25).w
		subq.b	#1,($FFFFFE24).w
		move.b	($FFFFFE3C).w,($FFFFF742).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.w	($FFFFFE3E).w,($FFFFF72E).w
		move.w	($FFFFFE3E).w,($FFFFF726).w
		move.w	($FFFFFE40).w,($FFFFF700).w
		move.w	($FFFFFE42).w,($FFFFF704).w
		move.w	($FFFFFE44).w,($FFFFF708).w
		move.w	($FFFFFE46).w,($FFFFF70C).w
		move.w	($FFFFFE48).w,($FFFFF710).w
		move.w	($FFFFFE4A).w,($FFFFF714).w
		move.w	($FFFFFE4C).w,($FFFFF718).w
		move.w	($FFFFFE4E).w,($FFFFF71C).w
		cmpi.b	#1,($FFFFFE10).w
		bne.s	loc_170E4
		move.w	($FFFFFE50).w,($FFFFF648).w
		move.b	($FFFFFE52).w,($FFFFF64D).w
		move.b	($FFFFFE53).w,($FFFFF64E).w

loc_170E4:
		tst.b	($FFFFFE30).w
		bpl.s	locret_170F6
		move.w	($FFFFFE32).w,d0
		subi.w	#$A0,d0
		move.w	d0,($FFFFF728).w

locret_170F6:
		rts	
; End of function Obj79_LoadInfo

; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - lamppost
; ---------------------------------------------------------------------------

Map_obj79:
		include	"_maps\obj79.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7D - hidden points at the end of a level (emblems)
; ---------------------------------------------------------------------------

Obj7D_LeftRightJump = $170

Obj7D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj7D_Index(pc,d0.w),d1
		jmp	Obj7D_Index(pc,d1.w)
; ===========================================================================
Obj7D_Index:	dc.w Obj7D_Main-Obj7D_Index
		dc.w Obj7D_Emblem-Obj7D_Index
		dc.w Obj7D_SoundStopper-Obj7D_Index
; ===========================================================================

Obj7D_Main:				; XREF: Obj7D_Index
		cmpi.w	#$400,($FFFFFE10).w	; is level SYZ?
		bne.s 	Obj7D_Main_SLZ		; if not, branch
		move.b	#6,obRoutine(a0)	; set to "sound stopper" mode
		bra.w	Obj7D_SoundStopper
		move.b  #6,obAnim(a0)

Obj7D_Main_SLZ:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj7D,obMap(a0)
		move.w	#$84B6,obGfx(a0)
		ori.b	#$84,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#3,obFrame(a0)
		move.b  #6,obAnim(a0)
		move.b	#0,$30(a0)		; set to right
; ---------------------------------------------------------------------------

Obj7D_Emblem:
		cmpi.b	#6,($FFFFFFA0).w	; have all six emblems been collected?
		blo.s	@displayemblem		; if not, branch
		rts				; otherwise, don't render (but don't delete in case the player derps up again)

@displayemblem:
		; check touch
		moveq	#$20,d2
		move.w	d2,d3
		add.w	d3,d3
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.w	Obj7D_NoTouch
		move.w	obY(a1),d1
		sub.w	obY(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bcc.w	Obj7D_NoTouch

		; emblem touched
		addq.b	#1,($FFFFFFA0).w		; increase emblems collected counter
		move.b	($FFFFFFA0).w,obFrame(a0)	; set new frame
		move.w	#$C9,d0			; play bonus sound
		jsr	(PlaySound_Special).l
		moveq	#10,d0			; add 100 points
		jsr	AddPoints

		; jump emblem left and right in the loop
		move.w	#Obj7D_LeftRightJump,d0
		tst.b	$30(a0)
		bne.s	@toggle
		neg.w	d0
@toggle:	eori.b	#1,$30(a0)
		add.w	d0,obX(a0)

		; alter loop when collecting the first and last emblem
		cmpi.b	#1,($FFFFFFA0).w	; is this the first collected emblem?
		bne.s	@checklast		; if not, branch
		moveq	#1,d0			; close loop
		bra.s	@alterloop		; skip
@checklast:
		cmpi.b	#6,($FFFFFFA0).w	; is this the sixth collected emblem?
		blt.s	Obj7D_NoTouch		; if not, branch
		moveq	#2,d0			; open loop on the right
@alterloop:
		bsr	SAP_SetLoopState	; set new loop state
		move.w	#$B7,d0			; play rumbling sound
		jsr	(PlaySound_Special).l

Obj7D_NoTouch:
		jmp	DisplaySprite		; otherwise continue displaying
; ===========================================================================
; ===========================================================================

Obj7D_SoundStopper:
		moveq	#$20,d2
		move.w	d2,d3
		add.w	d3,d3
		lea	($FFFFD000).w,a1
		move.w	obX(a1),d0
		sub.w	obX(a0),d0
		add.w	d2,d0
		cmp.w	d3,d0
		bcc.w	@end
		move.w	obY(a1),d1
		sub.w	obY(a0),d1
		add.w	d2,d1
		cmp.w	d3,d1
		bcc.w	@end

		move.w	#$E0,d0			; set song $E0
		jsr	PlaySound_Special	; fade out music		
		movea.l	$30(a0),a1		; get saved RAM address of the door
		move.b	#1,$30(a1)		; turn the door red
		move.b	#1,($FFFFFFA5).w	; move HUD off screen
		jmp	DeleteObject

@end:
		rts
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - hidden points at the end of	a level
; ---------------------------------------------------------------------------
Map_obj7D:
		include	"_maps\obj7D.asm"
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Star Agony Place challenge object control
; ---------------------------------------------------------------------------
SAP_EmblemLeft = $1C48
SAP_EmblemRight = $1DB8
SAP_EmblemDiff = $170
SAP_EmblemY = $0200
; ---------------------------------------------------------------------------

SAP_SetLoopState:
		move.l	a0,-(sp)		; backup a0

		; update layout to lock you into a loop
		cmpi.b	#1,d0			; set to lock loop?
		bne.s	@checkloopbeaten	; if not, branch
		move.w	#$1B80,d0
		move.w	#$0280,d1
		move.b	#$3B,d2
		jsr	Sub_ChangeChunk
		move.w	#$1C80,d0
		move.w	#$0280,d1
		move.b	#$47,d2
		jsr	Sub_ChangeChunk
		bra.w	@setloopend

@checkloopbeaten:
		; update layout to open up the loop on the right
		cmpi.b	#2,d0			; set to unlock loop on the right?
		bne.s	@resetloop		; if not, branch
		move.w	#$1D80,d0
		move.w	#$0280,d1
		move.b	#$18,d2
		jsr	Sub_ChangeChunk
		move.w	#$1E80,d0
		move.w	#$0280,d1
		move.b	#$21,d2
		jsr	Sub_ChangeChunk
		bra.s	@setloopend

@resetloop:
		; reset layout to its initial state
		move.w	#$1B80,d0
		move.w	#$0280,d1
		move.b	#$50,d2
		jsr	Sub_ChangeChunk
		move.w	#$1C80,d0
		move.w	#$0280,d1
		move.b	#$0D,d2
		jsr	Sub_ChangeChunk
		move.w	#$1D80,d0
		move.w	#$0280,d1
		move.b	#$46,d2
		jsr	Sub_ChangeChunk
		move.w	#$1E80,d0
		move.w	#$0280,d1
		move.b	#$16,d2
		jsr	Sub_ChangeChunk

@setloopend:
		move.l	(sp)+,a0
		rts
; ===========================================================================

; SetupSAPItems:
SAP_ResetChallengeObjects:
		bsr	SAP_ResetEmblems
		bsr	SAP_ResetP
		rts
; ---------------------------------------------------------------------------

SAP_ResetEmblems:
		; place 6th emblem in the looping section
		lea	($FFFFDFC0).w,a1
		move.b	#$7D,(a1)
		move.w	#SAP_EmblemRight,obX(a1)
		move.w	#SAP_EmblemY,obY(a1)
		move.b	#2,obRoutine(a1)
		move.l	#Map_obj7D,obMap(a1)
		move.w	#$84B6,obGfx(a1)
		ori.b	#$84,obRender(a1)
		move.b	#3,obPriority(a1)
		move.b	#0,obFrame(a1)
		move.b	#0,$30(a1)
		rts
; ---------------------------------------------------------------------------

SAP_ResetP:
		; place P monitor required to open a door
		lea	($FFFFDF40).w,a1
		move.b	#$26,(a1)
		move.w	#$17E0,obX(a1)
		move.w	#$03F0,obY(a1)
		move.b	#2,obRoutine(a1)
		move.b	#$E,obHeight(a1)
		move.b	#$E,obWidth(a1)
		move.l	#Map_obj26,obMap(a1)
		move.b	#8,obSubtype(a1)
		move.w	#$680,obGfx(a1)
		move.b	#$84,obRender(a1)
		move.b	#3,obPriority(a1)
		move.b	#$F,obActWid(a1)
		move.b	#$46,obColType(a1)
		move.b	#8,obAnim(a1)
		rts
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 8A - "SONIC TEAM PRESENTS" and	credits
; ---------------------------------------------------------------------------

Obj8A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj8A_Index(pc,d0.w),d1
		jmp	Obj8A_Index(pc,d1.w)
; ===========================================================================
Obj8A_Index:	dc.w Obj8A_Main-Obj8A_Index
		dc.w Obj8A_Display-Obj8A_Index
; ===========================================================================

Obj8A_Main:				; XREF: Obj8A_Index
		addq.b	#2,obRoutine(a0)
		move.w	#$120,obX(a0)
		move.w	#$F0,obScreenY(a0)
		move.l	#Map_obj8A,obMap(a0)
		move.w	#$5A0,obGfx(a0)
		move.w	($FFFFFFF4).w,d0 ; load	credits	index number
		move.b	d0,obFrame(a0)	; display appropriate sprite
		move.b	#0,obRender(a0)
		move.b	#0,obPriority(a0)
		cmpi.b	#4,($FFFFF600).w ; is the scene	number 04 (title screen)?
		bne.s	Obj8A_Display	; if not, branch
		move.w	#$A6,obGfx(a0)
		move.b	#$A,obFrame(a0)	; display "SONIC TEAM PRESENTS"
		tst.b	($FFFFFFE3).w	; is hidden credits cheat on?
		beq.s	Obj8A_Display	; if not, branch
		cmpi.b	#$72,($FFFFF604).w ; is	Start+A+C+Down being pressed?
		bne.s	Obj8A_Display	; if not, branch
		move.w	#$EEE,($FFFFFBC0).w ; 3rd palette, 1st entry = white
		move.w	#$880,($FFFFFBC2).w ; 3rd palette, 2nd entry = cyan
		jmp	DeleteObject
; ===========================================================================

Obj8A_Display:				; XREF: Obj8A_Index
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - "SONIC TEAM	PRESENTS" and credits
; ---------------------------------------------------------------------------
Map_obj8A:
		include	"_maps\obj8A.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3D - Eggman (GHZ)
; ---------------------------------------------------------------------------

Obj3D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj3D_Index(pc,d0.w),d1
		jmp	Obj3D_Index(pc,d1.w)
; ===========================================================================
Obj3D_Index:	dc.w Obj3D_Main-Obj3D_Index
		dc.w Obj3D_ShipMain-Obj3D_Index
		dc.w Obj3D_FaceMain-Obj3D_Index
		dc.w Obj3D_FlameMain-Obj3D_Index

Obj3D_ObjData:	dc.b 2,	0		; routine counter, animation
		dc.b 4,	1
		dc.b 6,	7
; ===========================================================================

Obj3D_Main:				; XREF: Obj3D_Index
		lea	(Obj3D_ObjData).l,a2
		movea.l	a0,a1
		moveq	#2,d1
	;	move.b	#0,($FFFFFE2C).w ; remove shield
		move.b	#0,($FFFFFFD1).w
		bra.s	Obj3D_LoadBoss
; ===========================================================================

Obj3D_Loop:
		jsr	SingleObjLoad2
		bne.s	loc_17772

Obj3D_LoadBoss:				; XREF: Obj3D_Main
		move.b	(a2)+,obRoutine(a1)
		move.b	#$3D,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.l	#Map_Eggman,obMap(a1)
		move.w	#$400,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$20,obActWid(a1)
		move.b	#3,obPriority(a1)
		move.b	(a2)+,obAnim(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj3D_Loop	; repeat sequence 2 more times

loc_17772:
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$38(a0)

	if LowBossHP=1
		move.b	#1,obColProp(a0)		; set number of	hits to	1
	else
		move.b	#20,obColProp(a0)	; set number of	hits to	20
	endif
		move.b	obColProp(a0),(HUD_BossHealth).w

Obj3D_ShipMain:				; XREF: Obj3D_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj3D_ShipIndex(pc,d0.w),d1
		jsr	obj3D_ShipIndex(pc,d1.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		move.b	obStatus(a0),d0
		andi.b	#3,d0
		andi.b	#$FC,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj3D_ShipIndex:dc.w Obj3D_ShipStart-Obj3D_ShipIndex
		dc.w Obj3D_MakeBall-Obj3D_ShipIndex
		dc.w Obj3D_ShipMove-Obj3D_ShipIndex
		dc.w loc_17954-Obj3D_ShipIndex
		dc.w loc_1797A-Obj3D_ShipIndex
		dc.w loc_179AC-Obj3D_ShipIndex
		dc.w loc_179F6-Obj3D_ShipIndex
; ===========================================================================

Obj3D_ShipStart:			; XREF: Obj3D_ShipIndex
		move.b	#1,($FFFFF7CC).w		; lock controls
		clr.l	($FFFFF602).w			; clear any remaining button presses
		move.w	#-$100,obVelY(a0)	; move ship up
		bsr	BossMove
		cmpi.w	#$338,$38(a0)
		bne.s	Obj3D_MainStuff
		move.w	#0,obVelY(a0)	; stop ship
		addq.b	#2,ob2ndRout(a0)	; goto next routine

Obj3D_MainStuff:
		move.b	$3F(a0),d0
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$38(a0),d0
		move.w	d0,obY(a0)
		move.w	$30(a0),obX(a0)
		addq.b	#2,$3F(a0)
		cmpi.b	#8,ob2ndRout(a0)
		bcc.w	locret_1784A
		tst.b	obStatus(a0)
		bmi.w	loc_1784C

		tst.b	($FFFFF7CC).w	; are controls locked?
		bne.w	locret_1784A	; if yes, don't do any of this (boss intro cutscene)

		tst.b	obColType(a0)
		bne.w	locret_1784A
		tst.b	$3E(a0)
		bne.s	Obj3D_ShipFlash
		move.b	#$20,$3E(a0)	; set number of	times for ship to flash
		bsr	BossDamageSound ; play boss damage sound
		moveq	#10,d0		; add 100 ...
		jsr	AddPoints	; ... points
		move.b	obColProp(a0),(HUD_BossHealth).w	; copy lives to HUD boss health counter

		tst.b	($FFFFFFD1).w		; was flag to destroy the platforms already set?
		bne.s	Obj3D_ShipFlash		; if yes, branch
		cmpi.b	#7,obColProp(a0)	; does boss have exactly 7 lives now?
		bne.s	Obj3D_ShipFlash		; if not, branch
		move.b	#1,($FFFFFFD1).w	; set flag now
		lea	($FFFFD800).w,a1
		move.w	#$3F,d0
loopdashit:	cmpi.b	#$18,(a1)		; is current object a platform?
		bne.s	@cont			; if not, branch
		move.b	#$3F,(a1)		; turn into an explosion
		move.b	#0,obRoutine(a1)
		move.b	#0,$31(a1)
@cont:		lea	$40(a1),a1
		dbf	d0,loopdashit

Obj3D_ShipFlash:
		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		beq.s	@noflash		; if not, branch

		lea	($FFFFFB22).w,a1 ; load	2nd palette, 2nd	entry
		moveq	#0,d0		; move 0 (black) to d0
		tst.w	(a1)
		bne.s	@flashloop
		move.w	#$EEE,d0	; move 0EEE (white) to d0
@flashloop:	move.w	d0,(a1)		; load colour stored in	d0

@noflash:
		subq.b	#1,$3E(a0)
		bne.s	locret_1784A
		move.b	#$F,obColType(a0)

locret_1784A:
		rts	
; ===========================================================================

loc_1784C:				; XREF: Obj3D_MainStuff
		move.b	#$E3,d0
		jsr	(PlaySound_Special).l	; slow down music
		move.b	#8,ob2ndRout(a0)
		move.w	#$B3,$3C(a0)
		rts	


; ===========================================================================

Obj3D_MakeBall:				; XREF: Obj3D_ShipIndex
	;	move.w	#-$100,obVelX(a0)
	;	bsr	BossMove
	;	cmpi.w	#$2A00,$30(a0)
	;	bne.s	loc_17916

		move.b	#0,($FFFFF7CC).w		; unlock controls
		
		move.b	#$F,obColType(a0)

		move.w	#0,obVelX(a0)
		move.w	#0,obVelY(a0)
		addq.b	#2,ob2ndRout(a0)

		jsr	SingleObjLoad2
		bne.s	loc_17910
		move.b	#$48,0(a1)	; load swinging	ball object
		move.w	$30(a0),obX(a1)
		move.w	$38(a0),obY(a1)
		move.l	a0,$34(a1)
		move.b	#0,obVelX(a1)

		jsr	SingleObjLoad2
		bne.s	loc_17910
		move.b	#$48,0(a1)	; load swinging	ball object
		move.w	$30(a0),obX(a1)
		move.w	$38(a0),obY(a1)
		move.l	a0,$34(a1)
		move.b	#$40,ob2ndRout(a1)
		move.b	#10,obVelX(a1)

		jsr	SingleObjLoad2
		bne.s	loc_17910
		move.b	#$48,0(a1)	; load swinging	ball object
		move.w	$30(a0),obX(a1)
		move.w	$38(a0),obY(a1)
		move.l	a0,$34(a1)
		move.b	#$80,ob2ndRout(a1)
		move.b	#5,obVelX(a1)

loc_17910:
	;	move.w	#$77,$3C(a0)

loc_17916:
		bra.w	Obj3D_MainStuff

; ===========================================================================

Obj3D_ShipMove:				; XREF: Obj3D_ShipIndex
		cmpi.b	#7,obColProp(a0)
		bgt.s	@cont2
		move.b	#$E2,d0
		jsr	(PlaySound_Special).l	; speed up music
		bra.s	@cont
	
	@cont2:
		subq.w	#1,$3C(a0)
		bpl.s	Obj3D_Reverse

@cont:
		addq.b	#2,ob2ndRout(a0)
		move.w	#$3F,$3C(a0)
		move.w	#$400,obVelX(a0)	; move the ship	fast sideways
		cmpi.w	#$2A00+GHZ3Add,$30(a0)
		bne.s	Obj3D_Reverse
		move.w	#$7F,$3C(a0)
		move.w	#$100,obVelX(a0)	; move the ship	sideways

Obj3D_Reverse:
		btst	#0,obStatus(a0)
		bne.s	loc_17950
		neg.w	obVelX(a0)		; reverse direction of the ship

loc_17950:
		bra.w	Obj3D_MainStuff
; ===========================================================================

loc_17954:				; XREF: Obj3D_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_17960
		bsr	BossMove
		bra.s	loc_17976
; ===========================================================================

loc_17960:
		bchg	#0,obStatus(a0)
		move.w	#$3F,$3C(a0)
		subq.b	#2,ob2ndRout(a0)
		move.w	#0,obVelX(a0)

loc_17976:
		bra.w	Obj3D_MainStuff
; ===========================================================================

loc_1797A:				; XREF: Obj3D_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_17984
		addq.w	#3,obX(a0)	; move eggman to the right
		move.b	#1,($FFFFFE1C).w
		move.b	#0,(HUD_BossHealth).w
		bset	#0,obStatus(a0)
		bra.w	BossDefeated
; ===========================================================================

loc_17984:
		bset	#0,obStatus(a0)
		bclr	#7,obStatus(a0)
		clr.w	obVelX(a0)
		addq.b	#2,ob2ndRout(a0)
		move.w	#-$26,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	locret_179AA
		move.b	#1,($FFFFF7A7).w

locret_179AA:
	if LowBossHP=1
		move.b	#1,($FFFFFE2D).w		; make Sonic invincible
	endif
		move.w	#$94,d0
		jsr	(PlaySound).l	; play GHZ music
		move.w	#$2AC0+GHZ3Add,($FFFFF72A).w
		moveq	#$12,d0
		jsr	LoadPLC2	; load signpost	patterns
		move.b	#1,($FFFFFF91).w
		clr.b	($FFFFF7AA).w
		lea	@Spring(pc), a1	; load spring graphics
		jsr	LoadPLC_Direct
		jmp	DeleteObject

; ===========================================================================
@Spring:
	dc.l	ArtKospM_HSpring
	dc.w	$A460
	dc.w	-1

; ===========================================================================

loc_179AC:				; XREF: Obj3D_ShipIndex
		addq.w	#1,$3C(a0)
		beq.s	loc_179BC
		bpl.s	loc_179C2
		addi.w	#$18,obVelY(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179BC:
		clr.w	obVelY(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179C2:
		cmpi.w	#$30,$3C(a0)
		bcs.s	loc_179DA
		beq.s	loc_179E0
		cmpi.w	#$38,$3C(a0)
		bcs.s	loc_179EE
		addq.b	#2,ob2ndRout(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179DA:
		subq.w	#8,obVelY(a0)
		bra.s	loc_179EE
; ===========================================================================

loc_179E0:
		clr.w	obVelY(a0)
		move.w	#$94,d0
		jsr	(PlaySound).l	; play GHZ music

loc_179EE:
		bsr	BossMove
		bra.w	Obj3D_MainStuff
; ===========================================================================

loc_179F6:				; XREF: Obj3D_ShipIndex
		move.w	#$400,obVelX(a0)
		move.w	#-$40,obVelY(a0)
		cmpi.w	#$2AC0+GHZ3Add,($FFFFF72A).w
		beq.s	loc_17A10
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_17A16
; ===========================================================================

loc_17A10:
		tst.b	obRender(a0)
		bpl.s	Obj3D_ShipDel

loc_17A16:
		bsr	BossMove
		bra.w	Obj3D_MainStuff
; ===========================================================================

Obj3D_ShipDel:
		move.l	#10000,d0	; add 100000 ...
		jsr	AddPoints	; ... points
		jmp	DeleteObject
; ===========================================================================

Obj3D_FaceMain:				; XREF: Obj3D_Index
		moveq	#0,d0
		moveq	#1,d1
		movea.l	$34(a0),a1
		move.b	ob2ndRout(a1),d0
		subq.b	#4,d0
		bne.s	loc_17A3E
		cmpi.w	#$2A00+GHZ3Add,$30(a1)
		bne.s	loc_17A46
		moveq	#4,d1

loc_17A3E:
		subq.b	#6,d0
		bmi.s	loc_17A46
		moveq	#$A,d1
		bra.s	loc_17A5A
; ===========================================================================

loc_17A46:
		tst.b	obColType(a1)
		bne.s	loc_17A50
		tst.b	($FFFFF7CC).w
		beq.s	@cont
		moveq	#4,d1
		bra.s	loc_17A5A

@cont:
		moveq	#5,d1
		bra.s	loc_17A5A
; ===========================================================================

loc_17A50:
		cmpi.b	#4,($FFFFD024).w
		bcs.s	loc_17A5A
		moveq	#4,d1

loc_17A5A:
		move.b	d1,obAnim(a0)
		subq.b	#2,d0
		bne.s	Obj3D_FaceDisp
		move.b	#6,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj3D_FaceDel

Obj3D_FaceDisp:
		tst.b	($FFFFFF91).w
		bne.s	absdjasd
		bra.s	Obj3D_Display
; ===========================================================================

absdjasd:
		rts
; ===========================================================================

Obj3D_FaceDel:
		jmp	DeleteObject
; ===========================================================================

Obj3D_FlameMain:			; XREF: Obj3D_Index
		move.b	#7,obAnim(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$C,ob2ndRout(a1)
		bne.s	loc_17A96
		move.b	#$B,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj3D_FlameDel
		bra.s	Obj3D_FlameDisp
; ===========================================================================

loc_17A96:
		move.w	obVelX(a1),d0
		beq.s	Obj3D_FlameDisp
		move.b	#8,obAnim(a0)

Obj3D_FlameDisp:
		bra.s	Obj3D_Display
; ===========================================================================

Obj3D_FlameDel:
		jmp	DeleteObject
; ===========================================================================

Obj3D_Display:				; XREF: Obj3D_FaceDisp; Obj3D_FlameDisp
		movea.l	$34(a0),a1
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)
		move.b	obStatus(a1),obStatus(a0)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		move.b	obStatus(a0),d0
		andi.b	#3,d0
		andi.b	#$FC,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 48 - ball on a	chain that Eggman swings (GHZ)
; ---------------------------------------------------------------------------

Obj48:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj48_Index(pc,d0.w),d1
		jmp	Obj48_Index(pc,d1.w)
; ===========================================================================
Obj48_Index:	dc.w Obj48_Main-Obj48_Index
		dc.w Obj48_Base-Obj48_Index
		dc.w Obj48_Display2-Obj48_Index
		dc.w Obj48_Chain-Obj48_Index
		dc.w Obj48_ChkVanish-Obj48_Index
		dc.w Obj48_Fall-Obj48_Index
; ===========================================================================

Obj48_Main:				; XREF: Obj48_Index
		frantic				; are we in frantic mode?
		bne.s	Obj48_Main_Frantic	; if yes, spawn all three balls at once like usual
		
		; casual GHP boss ball spawn logic
		tst.b	ob2ndRout(a0)		; is this the first ball?
		beq.s	Obj48_Do		; if yes, spawn it immediately
		
		movea.l	$34(a0),a1		; move root boss object to a1
		cmpi.b	#$40,ob2ndRout(a0)	; is this the second ball?
		bhi.s	@checkthirdball		; if not, branch
		cmpi.b	#17,obColProp(a1)	; damaged Eggman to at least 17 HP?
		bhi.s	@waitball		; if not, branch
@delayballs:
		move.b	ob2ndRout(a0),d0	; get current delay
		cmpi.b	#30,d0			; is it above 30 frames?
		bls.s	@nocap			; if not, branch
		moveq	#30,d0			; cap delay
@nocap:		subq.b	#1,d0			; sub 1 from delay
		bls.s	Obj48_Do		; if delay is over, spawn ball
		move.b	d0,ob2ndRout(a0)	; update delay
		bra.s	@waitball		; wait until delay is over
@checkthirdball:
		cmpi.b	#$80,ob2ndRout(a0)	; is this the third ball?
		bhi.s	@waitball		; if not, branch
		cmpi.b	#13,obColProp(a1)	; damaged Eggman to at least 13 HP?
		bls.s	@delayballs		; if yes, spawn third ball
@waitball:
		rts
; ---------------------------------------------------------------------------

Obj48_Main_Frantic:
		tst.b	ob2ndRout(a0)		; is delay limit remaining?
		beq.s	Obj48_Do		; if not, spawn ball
		subq.b	#1,ob2ndRout(a0)	; decrease limit	
		movea.l	$34(a0),a1		; move root boss object to a1
	if LowBossHP=1
		move.b	#1,obColProp(a1)	; force boss to have full health until all three balls appeared
	else
		move.b	#20,obColProp(a1)	; force boss to have full health until all three balls appeared
	endif
		rts
; ---------------------------------------------------------------------------

Obj48_Do:
		addq.b	#2,obRoutine(a0)
		move.w	#$4080,obAngle(a0)
		move.w	#-$200,$3E(a0) ; -$200
		move.l	#Map_BossItems,obMap(a0)
		move.w	#$46C,obGfx(a0)
		lea	obSubtype(a0),a2
		move.b	#0,(a2)+
		moveq	#5,d1
		movea.l	a0,a1
		bra.s	loc_17B60
; ===========================================================================

Obj48_MakeLinks:
		jsr	SingleObjLoad2
		bne.s	Obj48_MakeBall
	;	move.w	obX(a0),obX(a1)
	;	move.w	obY(a0),obY(a1)
		clr.w	obX(a1)
		clr.w	obVelX(a1)
		move.b	#$48,0(a1)	; load chain link object
		move.b	#6,obRoutine(a1)
		move.l	#Map_obj15,obMap(a1)
		move.w	#$380,obGfx(a1)
		move.b	#1,obFrame(a1)
		addq.b	#1,obSubtype(a0)

loc_17B60:				; XREF: Obj48_Main
		move.w	a1,d5
		subi.w	#$D000,d5
		lsr.w	#6,d5
		andi.w	#$7F,d5
		move.b	d5,(a2)+
		move.b	#4,obRender(a1)
		move.b	#8,obActWid(a1)
		move.b	#6,obPriority(a1)
		move.l	$34(a0),$34(a1)
		move.b	obVelX(a0),obVelX(a1)
		dbf	d1,Obj48_MakeLinks ; repeat sequence 5 more times

Obj48_MakeBall:
		move.b	#8,obRoutine(a1)
		move.l	#Map_obj48,obMap(a1) ; load	different mappings for final link
		move.w	#$3AA,obGfx(a1)	; use different	graphics
		move.b	#1,obFrame(a1)
		move.b	#5,obPriority(a1)
		move.b	#$81,obColType(a1)	; make object hurt Sonic
		move.b	obVelX(a0),$3F(a1)
		rts	
; ===========================================================================

Obj48_PosData:	dc.b 0,	$10, $20, $30, $40, $57	; y-position data for links and	giant ball

; ===========================================================================

Obj48_Base:				; XREF: Obj48_Index
		lea	(Obj48_PosData).l,a3
		lea	obSubtype(a0),a2
		moveq	#0,d6
		move.b	(a2)+,d6

loc_17BC6:
		moveq	#0,d4
		move.b	(a2)+,d4
		lsl.w	#6,d4
		addi.l	#$FFD000,d4
		movea.l	d4,a1
		move.b	(a3)+,d0
		cmp.b	$3C(a1),d0
		beq.s	loc_17BE0
		addq.b	#1,$3C(a1)

loc_17BE0:
		dbf	d6,loc_17BC6

		cmp.b	$3C(a1),d0
		bne.s	loc_17BFA
		movea.l	$34(a0),a1
		cmpi.b	#6,ob2ndRout(a1)
		bne.s	loc_17BFA
		addq.b	#2,obRoutine(a0)

loc_17BFA:
		cmpi.w	#$20,$32(a0)
		beq.s	Obj48_Display
		addq.w	#1,$32(a0)

Obj48_Display:
		bsr	sub_17C2A
		move.b	obAngle(a0),d0
		jsr	(Obj48_Move).l ; jsr	(Obj15_Move2).l
		bra.w	Obj48_DoDisplay
; ===========================================================================

Obj48_Display2:				; XREF: Obj48_Index
		bsr	sub_17C2A
		cmpi.b	#7+1,obColProp(a1) ; +1 for whatever reason
		bpl.s	@cont2
		jsr	(Obj48_Move).l

@cont2
		cmpi.b	#15+1,obColProp(a1) ; +1 for whatever reason
		bpl.s	@cont
		jsr	(Obj48_Move).l

@cont
		jsr	(Obj48_Move).l
		bra.w	Obj48_DoDisplay

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


sub_17C2A:				; XREF: Obj48_Display; Obj48_Display2
		movea.l	$34(a0),a1
		addi.b	#$20,obAniFrame(a0)
		bcc.s	loc_17C3C
		bchg	#0,obFrame(a0)

loc_17C3C:
		move.w	obX(a1),$3A(a0)
		move.w	obY(a1),d0
		add.w	$32(a0),d0
		move.w	d0,$38(a0)
		move.b	obStatus(a1),obStatus(a0)

		move.b	obColProp(a1),d1
		cmp.b	obVelX(a0),d1
		bne.s	locret_17C66

		move.b	#$3F,0(a0)
		move.b	#0,obRoutine(a0)
		move.b	#0,$31(a0)

locret_17C66:
		rts	
; End of function sub_17C2A

; ===========================================================================

Obj48_Chain:				; XREF: Obj48_Index
		movea.l	$34(a0),a1
		move.b	obColProp(a1),d1
		cmp.b	obVelX(a0),d1
		bne.s	Obj48_Display3
		jsr	ObjectFall		; make chain fall
		tst.b	obRender(a0)			; is chain still on screen?
		bmi.s	Obj48_Display3		; if yes, keep displaying
		jmp	DeleteObject		; otherwise delete it

Obj48_Display3:
		jmp	DisplaySprite
; ===========================================================================
		
Obj48_ChkVanish:			; XREF: Obj48_Index
		moveq	#0,d0
		tst.b	obFrame(a0)
		bne.s	Obj48_Vanish
		addq.b	#1,d0

Obj48_Vanish:
		move.b	d0,obFrame(a0)
		movea.l	$34(a0),a1

		move.b	obColProp(a1),d1
		cmp.b	$3F(a0),d1
		bne.s	Obj48_Display4

		bsr	BossDefeated
		move.b	#$A,obRoutine(a0)	; set spiked ball to fall
		
		; prevent detached ball from moving offscreen
		move.w	obX(a0),d0
		cmpi.w	#$5060,d0
		bhi.s	@cont
		move.w	#$5060,obX(a0)
@cont:
		cmpi.w	#$51A0,d0
		blo.s	Obj48_Display4
		move.w	#$51A0,obX(a0)

Obj48_Display4:
		bra.s	Obj48_DoDisplay
; ===========================================================================

Obj48_Fall:
		jsr	ObjHitFloor
		subq.w	#4,d1
		cmp.w	obY(a0),d1
		bcc.s	Obj48_DoDisplay
		clr.w	obVelX(a0)
		jsr	ObjectFall

; ===========================================================================

Obj48_DoDisplay:
		jmp	DisplaySprite
; ===========================================================================

Ani_Eggman:
		include	"_anim\Eggman.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Eggman (boss levels)
; ---------------------------------------------------------------------------
Map_Eggman:
		include	"_maps\Eggman.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - extra boss items (e.g. swinging ball on a chain in GHZ)
; ---------------------------------------------------------------------------
Map_BossItems:
		include	"_maps\Boss items.asm"

; ---------------------------------------------------------------------------
; Defeated boss	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BossDefeated:
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	locret_178A2
		jsr	SingleObjLoad
		bne.s	locret_178A2
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,obY(a1)
	;	clr.b	($FFFFFE1E).w	; stop time counter

locret_178A2:
		rts	
; End of function BossDefeated

; ---------------------------------------------------------------------------
; Subroutine to	play the boss damage sound
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BossDamageSound:
		move.w	#$AC,d0
		jsr	(PlaySound_Special).l ;	play boss damage sound
		rts
; End of function BossDamageSound

; ---------------------------------------------------------------------------
; Subroutine to	move a boss
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


BossMove:
		move.l	$30(a0),d2
		move.l	$38(a0),d3
		move.w	obVelX(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d2
		move.w	obVelY(a0),d0
		ext.l	d0
		asl.l	#8,d0
		add.l	d0,d3
		move.l	d2,$30(a0)
		move.l	d3,$38(a0)
		rts	
; End of function BossMove


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 77 - Eggman (LZ)
; ---------------------------------------------------------------------------

Obj77:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj77_Index(pc,d0.w),d1
		jmp	Obj77_Index(pc,d1.w)
; ===========================================================================
Obj77_Index:	dc.w Obj77_Main-Obj77_Index
		dc.w Obj77_ShipMain-Obj77_Index
		dc.w Obj77_FaceMain-Obj77_Index
		dc.w Obj77_FlameMain-Obj77_Index

Obj77_ObjData:	dc.b 2,	0		; routine number, animation
		dc.b 4,	1
		dc.b 6,	7
; ===========================================================================

Obj77_Main:				; XREF: Obj77_Index
		move.w	#$1E10,obX(a0)
		move.w	#$5C0,obY(a0)
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$38(a0)
		move.b	#$F,obColType(a0)
		move.b	#8,obColProp(a0)	; set number of	hits to	8
		move.b	#4,obPriority(a0)
		lea	Obj77_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#2,d1
		bra.s	Obj77_LoadBoss
; ===========================================================================

Obj77_Loop:
		jsr	SingleObjLoad2
		bne.s	Obj77_ShipMain
		move.b	#$77,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj77_LoadBoss:				; XREF: Obj77_Main
		bclr	#0,obStatus(a0)
		clr.b	ob2ndRout(a1)
		move.b	(a2)+,obRoutine(a1)
		move.b	(a2)+,obAnim(a1)
		move.b	obPriority(a0),obPriority(a1)
		move.l	#Map_Eggman,obMap(a1)
		move.w	#$400,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$20,obActWid(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj77_Loop

Obj77_ShipMain:
		lea	($FFFFD000).w,a1
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj77_ShipIndex(pc,d0.w),d1
		jsr	obj77_ShipIndex(pc,d1.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#$FC,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj77_ShipIndex:dc.w loc_17F1E-Obj77_ShipIndex,	loc_17FA0-Obj77_ShipIndex
		dc.w loc_17FE0-Obj77_ShipIndex,	loc_1801E-Obj77_ShipIndex
		dc.w loc_180BC-Obj77_ShipIndex,	loc_180F6-Obj77_ShipIndex
		dc.w loc_1812A-Obj77_ShipIndex,	loc_18152-Obj77_ShipIndex
; ===========================================================================

loc_17F1E:				; XREF: Obj77_ShipIndex
		move.w	obX(a1),d0
		cmpi.w	#$1DA0,d0
		bcs.s	loc_17F38
		move.w	#-$180,obVelY(a0)
		move.w	#$60,obVelX(a0)
		addq.b	#2,ob2ndRout(a0)

loc_17F38:
		bsr	BossMove
		move.w	$38(a0),obY(a0)
		move.w	$30(a0),obX(a0)

loc_17F48:
		tst.b	$3D(a0)
		bne.s	loc_17F8E
		tst.b	obStatus(a0)
		bmi.s	loc_17F92
		tst.b	obColType(a0)
		bne.s	locret_17F8C
		tst.b	$3E(a0)
		bne.s	loc_17F70
		move.b	#$20,$3E(a0)
		bsr	BossDamageSound

loc_17F70:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_17F7E
		move.w	#$EEE,d0

loc_17F7E:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_17F8C
		move.b	#$F,obColType(a0)

locret_17F8C:
		rts	
; ===========================================================================

loc_17F8E:				; XREF: loc_17F48
		bra.w	BossDefeated
; ===========================================================================

loc_17F92:				; XREF: loc_17F48
		moveq	#100,d0
		bsr	AddPoints
		move.b	#-1,$3D(a0)
		rts	
; ===========================================================================

loc_17FA0:				; XREF: Obj77_ShipIndex
		moveq	#-2,d0
		cmpi.w	#$1E48,$30(a0)
		bcs.s	loc_17FB6
		move.w	#$1E48,$30(a0)
		clr.w	obVelX(a0)
		addq.w	#1,d0

loc_17FB6:
		cmpi.w	#$500,$38(a0)
		bgt.s	loc_17FCA
		move.w	#$500,$38(a0)
		clr.w	obVelY(a0)
		addq.w	#1,d0

loc_17FCA:
		bne.s	loc_17FDC
		move.w	#$140,obVelX(a0)
		move.w	#-$200,obVelY(a0)
		addq.b	#2,ob2ndRout(a0)

loc_17FDC:
		bra.w	loc_17F38
; ===========================================================================

loc_17FE0:				; XREF: Obj77_ShipIndex
		moveq	#-2,d0
		cmpi.w	#$1E70,$30(a0)
		bcs.s	loc_17FF6
		move.w	#$1E70,$30(a0)
		clr.w	obVelX(a0)
		addq.w	#1,d0

loc_17FF6:
		cmpi.w	#$4C0,$38(a0)
		bgt.s	loc_1800A
		move.w	#$4C0,$38(a0)
		clr.w	obVelY(a0)
		addq.w	#1,d0

loc_1800A:
		bne.s	loc_1801A
		move.w	#-$180,obVelY(a0)
		addq.b	#2,ob2ndRout(a0)
		clr.b	$3F(a0)

loc_1801A:
		bra.w	loc_17F38
; ===========================================================================

loc_1801E:				; XREF: Obj77_ShipIndex
		cmpi.w	#$100,$38(a0)
		bgt.s	loc_1804E
		move.w	#$100,$38(a0)
		move.w	#$140,obVelX(a0)
		move.w	#-$80,obVelY(a0)
		tst.b	$3D(a0)
		beq.s	loc_18046
		asl	obVelX(a0)
		asl	obVelY(a0)

loc_18046:
		addq.b	#2,ob2ndRout(a0)
		bra.w	loc_17F38
; ===========================================================================

loc_1804E:
		bset	#0,obStatus(a0)
		addq.b	#2,$3F(a0)
		move.b	$3F(a0),d0
		jsr	(CalcSine).l
		tst.w	d1
		bpl.s	loc_1806C
		bclr	#0,obStatus(a0)

loc_1806C:
		asr.w	#4,d0
		swap	d0
		clr.w	d0
		add.l	$30(a0),d0
		swap	d0
		move.w	d0,obX(a0)
		move.w	obVelY(a0),d0
		move.w	($FFFFD00C).w,d1
		sub.w	obY(a0),d1
		bcs.s	loc_180A2
		subi.w	#$48,d1
		bcs.s	loc_180A2
		asr.w	#1,d0
		subi.w	#$28,d1
		bcs.s	loc_180A2
		asr.w	#1,d0
		subi.w	#$28,d1
		bcs.s	loc_180A2
		moveq	#0,d0

loc_180A2:
		ext.l	d0
		asl.l	#8,d0
		tst.b	$3D(a0)
		beq.s	loc_180AE
		add.l	d0,d0

loc_180AE:
		add.l	d0,$38(a0)
		move.w	$38(a0),obY(a0)
		bra.w	loc_17F48
; ===========================================================================

loc_180BC:				; XREF: Obj77_ShipIndex
		moveq	#-2,d0
		cmpi.w	#$1F4C,$30(a0)
		bcs.s	loc_180D2
		move.w	#$1F4C,$30(a0)
		clr.w	obVelX(a0)
		addq.w	#1,d0

loc_180D2:
		cmpi.w	#$C0,$38(a0)
		bgt.s	loc_180E6
		move.w	#$C0,$38(a0)
		clr.w	obVelY(a0)
		addq.w	#1,d0

loc_180E6:
		bne.s	loc_180F2
		addq.b	#2,ob2ndRout(a0)
		bclr	#0,obStatus(a0)

loc_180F2:
		bra.w	loc_17F38
; ===========================================================================

loc_180F6:				; XREF: Obj77_ShipIndex
		tst.b	$3D(a0)
		bne.s	loc_18112
		cmpi.w	#$1EC8,obX(a1)
		blt.s	loc_18126
		cmpi.w	#$F0,obY(a1)
		bgt.s	loc_18126
		move.b	#$32,$3C(a0)

loc_18112:
		move.w	#$82,d0
		jsr	(PlaySound).l	; play LZ music
		bset	#0,obStatus(a0)
		addq.b	#2,ob2ndRout(a0)

loc_18126:
		bra.w	loc_17F38
; ===========================================================================

loc_1812A:				; XREF: Obj77_ShipIndex
		tst.b	$3D(a0)
		bne.s	loc_18136
		subq.b	#1,$3C(a0)
		bne.s	loc_1814E

loc_18136:
		clr.b	$3C(a0)
		move.w	#$400,obVelX(a0)
		move.w	#-$40,obVelY(a0)
		clr.b	$3D(a0)
		addq.b	#2,ob2ndRout(a0)

loc_1814E:
		bra.w	loc_17F38
; ===========================================================================

loc_18152:				; XREF: Obj77_ShipIndex
		cmpi.w	#$2030,($FFFFF72A).w
		bcc.s	loc_18160
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_18166
; ===========================================================================

loc_18160:
		tst.b	obRender(a0)
		bpl.s	Obj77_ShipDel

loc_18166:
		bra.w	loc_17F38
; ===========================================================================

Obj77_ShipDel:
		jmp	DeleteObject
; ===========================================================================

Obj77_FaceMain:				; XREF: Obj77_Index
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.s	Obj77_FaceDel
		moveq	#0,d0
		move.b	ob2ndRout(a1),d0
		moveq	#1,d1
		tst.b	$3D(a0)
		beq.s	loc_1818C
		moveq	#$A,d1
		bra.s	loc_181A0
; ===========================================================================

loc_1818C:
		tst.b	obColType(a1)
		bne.s	loc_18196
		moveq	#5,d1
		bra.s	loc_181A0
; ===========================================================================

loc_18196:
		cmpi.b	#4,($FFFFD024).w
		bcs.s	loc_181A0
		moveq	#4,d1

loc_181A0:
		move.b	d1,obAnim(a0)
		cmpi.b	#$E,d0
		bne.s	loc_181B6
		move.b	#6,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj77_FaceDel

loc_181B6:
		bra.s	Obj77_Display
; ===========================================================================

Obj77_FaceDel:
		jmp	DeleteObject
; ===========================================================================

Obj77_FlameMain:			; XREF: Obj77_Index
		move.b	#7,obAnim(a0)
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.s	Obj77_FlameDel
		cmpi.b	#$E,ob2ndRout(a1)
		bne.s	loc_181F0
		move.b	#$B,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj77_FlameDel
		bra.s	loc_181F0
; ===========================================================================
		tst.w	obVelX(a1)
		beq.s	loc_181F0
		move.b	#8,obAnim(a0)

loc_181F0:
		bra.s	Obj77_Display
; ===========================================================================

Obj77_FlameDel:				; XREF: Obj77_FlameMain
		jmp	DeleteObject
; ===========================================================================

Obj77_Display:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		movea.l	$34(a0),a1
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)
		move.b	obStatus(a1),obStatus(a0)
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#-4,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 73 - Eggman (MZ)
; ---------------------------------------------------------------------------

Obj73:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj73_Index(pc,d0.w),d1
		jmp	Obj73_Index(pc,d1.w)
; ===========================================================================
Obj73_Index:	dc.w Obj73_Main-Obj73_Index
		dc.w Obj73_ShipMain-Obj73_Index
		dc.w Obj73_FaceMain-Obj73_Index
		dc.w Obj73_FlameMain-Obj73_Index
		dc.w Obj73_TubeMain-Obj73_Index

Obj73_ObjData:	dc.b 2,	0, 4		; routine number, animation, priority
		dc.b 4,	1, 4
		dc.b 6,	7, 4
		dc.b 8,	0, 3
; ===========================================================================

Obj73_Main:				; XREF: Obj73_Index
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$38(a0)
		move.b	#$F,obColType(a0)
		move.b	#8,obColProp(a0)	; set number of	hits to	8
		lea	Obj73_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj73_LoadBoss
; ===========================================================================

Obj73_Loop:
		jsr	SingleObjLoad2
		bne.s	Obj73_ShipMain
		move.b	#$73,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj73_LoadBoss:				; XREF: Obj73_Main
		bclr	#0,obStatus(a0)
		clr.b	ob2ndRout(a1)
		move.b	(a2)+,obRoutine(a1)
		move.b	(a2)+,obAnim(a1)
		move.b	(a2)+,obPriority(a1)
		move.l	#Map_Eggman,obMap(a1)
		move.w	#$400,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$20,obActWid(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj73_Loop	; repeat sequence 3 more times

Obj73_ShipMain:
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj73_ShipIndex(pc,d0.w),d1
		jsr	obj73_ShipIndex(pc,d1.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#$FC,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj73_ShipIndex:dc.w loc_18302-Obj73_ShipIndex
		dc.w loc_183AA-Obj73_ShipIndex
		dc.w loc_184F6-Obj73_ShipIndex
		dc.w loc_1852C-Obj73_ShipIndex
		dc.w loc_18582-Obj73_ShipIndex
; ===========================================================================

loc_18302:				; XREF: Obj73_ShipIndex
		move.b	$3F(a0),d0
		addq.b	#2,$3F(a0)
		jsr	(CalcSine).l
		asr.w	#2,d0
		move.w	d0,obVelY(a0)
		move.w	#-$100,obVelX(a0)
		bsr	BossMove
		cmpi.w	#$1910,$30(a0)
		bne.s	loc_18334
		addq.b	#2,ob2ndRout(a0)
		clr.b	obSubtype(a0)
		clr.l	obVelX(a0)

loc_18334:
		jsr	(RandomNumber).l
		move.b	d0,$34(a0)

loc_1833E:
		move.w	$38(a0),obY(a0)
		move.w	$30(a0),obX(a0)
		cmpi.b	#4,ob2ndRout(a0)
		bcc.s	locret_18390
		tst.b	obStatus(a0)
		bmi.s	loc_18392
		tst.b	obColType(a0)
		bne.s	locret_18390
		tst.b	$3E(a0)
		bne.s	loc_18374
		move.b	#$28,$3E(a0)
		bsr	BossDamageSound

loc_18374:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_18382
		move.w	#$EEE,d0

loc_18382:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_18390
		move.b	#$F,obColType(a0)

locret_18390:
		rts	
; ===========================================================================

loc_18392:				; XREF: loc_1833E
		moveq	#100,d0
		bsr	AddPoints
		move.b	#4,ob2ndRout(a0)
		move.w	#$B4,$3C(a0)
		clr.w	obVelX(a0)
		rts	
; ===========================================================================

loc_183AA:				; XREF: Obj73_ShipIndex
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		move.w	off_183C2(pc,d0.w),d0
		jsr	off_183C2(pc,d0.w)
		andi.b	#6,obSubtype(a0)
		bra.w	loc_1833E
; ===========================================================================
off_183C2:	dc.w loc_183CA-off_183C2
		dc.w Obj73_MakeLava2-off_183C2
		dc.w loc_183CA-off_183C2
		dc.w Obj73_MakeLava2-off_183C2
; ===========================================================================

loc_183CA:				; XREF: off_183C2
		tst.w	obVelX(a0)
		bne.s	loc_183FE
		moveq	#$40,d0
		cmpi.w	#$22C,$38(a0)
		beq.s	loc_183E6
		bcs.s	loc_183DE
		neg.w	d0

loc_183DE:
		move.w	d0,obVelY(a0)
		bra.w	BossMove
; ===========================================================================

loc_183E6:
		move.w	#$200,obVelX(a0)
		move.w	#$100,obVelY(a0)
		btst	#0,obStatus(a0)
		bne.s	loc_183FE
		neg.w	obVelX(a0)

loc_183FE:
		cmpi.b	#$18,$3E(a0)
		bcc.s	Obj73_MakeLava
		bsr	BossMove
		subq.w	#4,obVelY(a0)

Obj73_MakeLava:
		subq.b	#1,$34(a0)
		bcc.s	loc_1845C
		jsr	SingleObjLoad
		bne.s	loc_1844A
		move.b	#$14,0(a1)	; load lava ball object
		move.w	#$2E8,obY(a1)	; set Y	position
		jsr	(RandomNumber).l
		andi.l	#$FFFF,d0
		divu.w	#$50,d0
		swap	d0
		addi.w	#$1878,d0
		move.w	d0,obX(a1)
		lsr.b	#7,d1
		move.w	#$FF,obSubtype(a1)

loc_1844A:
		jsr	(RandomNumber).l
		andi.b	#$1F,d0
		addi.b	#$40,d0
		move.b	d0,$34(a0)

loc_1845C:
		btst	#0,obStatus(a0)
		beq.s	loc_18474
		cmpi.w	#$1910,$30(a0)
		blt.s	locret_1849C
		move.w	#$1910,$30(a0)
		bra.s	loc_18482
; ===========================================================================

loc_18474:
		cmpi.w	#$1830,$30(a0)
		bgt.s	locret_1849C
		move.w	#$1830,$30(a0)

loc_18482:
		clr.w	obVelX(a0)
		move.w	#-$180,obVelY(a0)
		cmpi.w	#$22C,$38(a0)
		bcc.s	loc_18498
		neg.w	obVelY(a0)

loc_18498:
		addq.b	#2,obSubtype(a0)

locret_1849C:
		rts	
; ===========================================================================

Obj73_MakeLava2:			; XREF: off_183C2
		bsr	BossMove
		move.w	$38(a0),d0
		subi.w	#$22C,d0
		bgt.s	locret_184F4
		move.w	#$22C,d0
		tst.w	obVelY(a0)
		beq.s	loc_184EA
		clr.w	obVelY(a0)
		move.w	#$50,$3C(a0)
		bchg	#0,obStatus(a0)
		jsr	SingleObjLoad
		bne.s	loc_184EA
		move.w	$30(a0),obX(a1)
		move.w	$38(a0),obY(a1)
		addi.w	#$18,obY(a1)
		move.b	#$74,(a1)	; load lava ball object
		move.b	#1,obSubtype(a1)

loc_184EA:
		subq.w	#1,$3C(a0)
		bne.s	locret_184F4
		addq.b	#2,obSubtype(a0)

locret_184F4:
		rts	
; ===========================================================================

loc_184F6:				; XREF: Obj73_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_18500
		bra.w	BossDefeated
; ===========================================================================

loc_18500:
		bset	#0,obStatus(a0)
		bclr	#7,obStatus(a0)
		clr.w	obVelX(a0)
		addq.b	#2,ob2ndRout(a0)
		move.w	#-$26,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	locret_1852A
		move.b	#1,($FFFFF7A7).w
		clr.w	obVelY(a0)

locret_1852A:
		rts	
; ===========================================================================

loc_1852C:				; XREF: Obj73_ShipIndex
		addq.w	#1,$3C(a0)
		beq.s	loc_18544
		bpl.s	loc_1854E
		cmpi.w	#$270,$38(a0)
		bcc.s	loc_18544
		addi.w	#$18,obVelY(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_18544:
		clr.w	obVelY(a0)
		clr.w	$3C(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_1854E:
		cmpi.w	#$30,$3C(a0)
		bcs.s	loc_18566
		beq.s	loc_1856C
		cmpi.w	#$38,$3C(a0)
		bcs.s	loc_1857A
		addq.b	#2,ob2ndRout(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_18566:
		subq.w	#8,obVelY(a0)
		bra.s	loc_1857A
; ===========================================================================

loc_1856C:
		clr.w	obVelY(a0)
		move.w	#$83,d0
		jsr	(PlaySound).l	; play MZ music

loc_1857A:
		bsr	BossMove
		bra.w	loc_1833E
; ===========================================================================

loc_18582:				; XREF: Obj73_ShipIndex
		move.w	#$500,obVelX(a0)
		move.w	#-$40,obVelY(a0)
		cmpi.w	#$1960,($FFFFF72A).w
		bcc.s	loc_1859C
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_185A2
; ===========================================================================

loc_1859C:
		tst.b	obRender(a0)
		bpl.s	Obj73_ShipDel

loc_185A2:
		bsr	BossMove
		bra.w	loc_1833E
; ===========================================================================

Obj73_ShipDel:
		jmp	DeleteObject
; ===========================================================================

Obj73_FaceMain:				; XREF: Obj73_Index
		moveq	#0,d0
		moveq	#1,d1
		movea.l	$34(a0),a1
		move.b	ob2ndRout(a1),d0
		subq.w	#2,d0
		bne.s	loc_185D2
		btst	#1,obSubtype(a1)
		beq.s	loc_185DA
		tst.w	obVelY(a1)
		bne.s	loc_185DA
		moveq	#4,d1
		bra.s	loc_185EE
; ===========================================================================

loc_185D2:
		subq.b	#2,d0
		bmi.s	loc_185DA
		moveq	#$A,d1
		bra.s	loc_185EE
; ===========================================================================

loc_185DA:
		tst.b	obColType(a1)
		bne.s	loc_185E4
		moveq	#5,d1
		bra.s	loc_185EE
; ===========================================================================

loc_185E4:
		cmpi.b	#4,($FFFFD024).w
		bcs.s	loc_185EE
		moveq	#4,d1

loc_185EE:
		move.b	d1,obAnim(a0)
		subq.b	#4,d0
		bne.s	loc_18602
		move.b	#6,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj73_FaceDel

loc_18602:
		bra.s	Obj73_Display
; ===========================================================================

Obj73_FaceDel:
		jmp	DeleteObject
; ===========================================================================

Obj73_FlameMain:			; XREF: Obj73_Index
		move.b	#7,obAnim(a0)
		movea.l	$34(a0),a1
		cmpi.b	#8,ob2ndRout(a1)
		blt.s	loc_1862A
		move.b	#$B,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj73_FlameDel
		bra.s	loc_18636
; ===========================================================================

loc_1862A:
		tst.w	obVelX(a1)
		beq.s	loc_18636
		move.b	#8,obAnim(a0)

loc_18636:
		bra.s	Obj73_Display
; ===========================================================================

Obj73_FlameDel:				; XREF: Obj73_FlameMain
		jmp	DeleteObject
; ===========================================================================

Obj73_Display:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite

loc_1864A:
		movea.l	$34(a0),a1
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)
		move.b	obStatus(a1),obStatus(a0)
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#-4,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================

Obj73_TubeMain:				; XREF: Obj73_Index
		movea.l	$34(a0),a1
		cmpi.b	#8,ob2ndRout(a1)
		bne.s	loc_18688
		tst.b	obRender(a0)
		bpl.s	Obj73_TubeDel

loc_18688:
		move.l	#Map_BossItems,obMap(a0)
		move.w	#$246C,obGfx(a0)
		move.b	#4,obFrame(a0)
		bra.s	loc_1864A
; ===========================================================================

Obj73_TubeDel:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 74 - lava that	Eggman drops (MZ)
; ---------------------------------------------------------------------------

Obj74:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj74_Index(pc,d0.w),d0
		jsr	obj74_Index(pc,d0.w)
		jmp	DisplaySprite
; ===========================================================================
Obj74_Index:	dc.w Obj74_Main-Obj74_Index
		dc.w Obj74_Action-Obj74_Index
		dc.w loc_18886-Obj74_Index
		dc.w Obj74_Delete3-Obj74_Index
; ===========================================================================

Obj74_Main:				; XREF: Obj74_Index
		move.b	#8,obHeight(a0)
		move.b	#8,obWidth(a0)
		move.l	#Map_obj14,obMap(a0)
		move.w	#$345,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#5,obPriority(a0)
		move.w	obY(a0),$38(a0)
		move.b	#8,obActWid(a0)
		addq.b	#2,obRoutine(a0)
		tst.b	obSubtype(a0)
		bne.s	loc_1870A
		move.b	#$8B,obColType(a0)
		addq.b	#2,obRoutine(a0)
		bra.w	loc_18886
; ===========================================================================

loc_1870A:
		move.b	#$1E,$29(a0)
		move.w	#$AE,d0
		jsr	(PlaySound_Special).l ;	play lava sound

Obj74_Action:				; XREF: Obj74_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj74_Index2(pc,d0.w),d0
		jsr	obj74_Index2(pc,d0.w)
		jsr	SpeedToPos
		lea	(Ani_obj14).l,a1
		jsr	AnimateSprite
		cmpi.w	#$2E8,obY(a0)
		bhi.s	Obj74_Delete
		rts	
; ===========================================================================

Obj74_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj74_Index2:	dc.w Obj74_Drop-Obj74_Index2
		dc.w Obj74_MakeFlame-Obj74_Index2
		dc.w Obj74_Duplicate-Obj74_Index2
		dc.w Obj74_FallEdge-Obj74_Index2
; ===========================================================================

Obj74_Drop:				; XREF: Obj74_Index2
		bset	#1,obStatus(a0)
		subq.b	#1,$29(a0)
		bpl.s	locret_18780
		move.b	#$8B,obColType(a0)
		clr.b	obSubtype(a0)
		addi.w	#$18,obVelY(a0)
		bclr	#1,obStatus(a0)
		bsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_18780
		addq.b	#2,ob2ndRout(a0)

locret_18780:
		rts	
; ===========================================================================

Obj74_MakeFlame:			; XREF: Obj74_Index2
		subq.w	#2,obY(a0)
		bset	#7,obGfx(a0)
		move.w	#$A0,obVelX(a0)
		clr.w	obVelY(a0)
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$38(a0)
		move.b	#3,$29(a0)
		jsr	SingleObjLoad2
		bne.s	loc_187CA
		lea	(a1),a3
		lea	(a0),a2
		moveq	#3,d0

Obj74_Loop:
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		dbf	d0,Obj74_Loop

		neg.w	obVelX(a1)
		addq.b	#2,ob2ndRout(a1)

loc_187CA:
		addq.b	#2,ob2ndRout(a0)
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj74_Duplicate2:			; XREF: Obj74_Duplicate
		jsr	SingleObjLoad2
		bne.s	locret_187EE
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#$74,(a1)
		move.w	#$67,obSubtype(a1)

locret_187EE:
		rts	
; End of function Obj74_Duplicate2

; ===========================================================================

Obj74_Duplicate:			; XREF: Obj74_Index2
		bsr	ObjHitFloor
		tst.w	d1
		bpl.s	loc_18826
		move.w	obX(a0),d0
		cmpi.w	#$1940,d0
		bgt.s	loc_1882C
		move.w	$30(a0),d1
		cmp.w	d0,d1
		beq.s	loc_1881E
		andi.w	#$10,d0
		andi.w	#$10,d1
		cmp.w	d0,d1
		beq.s	loc_1881E
		bsr.s	Obj74_Duplicate2
		move.w	obX(a0),$32(a0)

loc_1881E:
		move.w	obX(a0),$30(a0)
		rts	
; ===========================================================================

loc_18826:
		addq.b	#2,ob2ndRout(a0)
		rts	
; ===========================================================================

loc_1882C:
		addq.b	#2,obRoutine(a0)
		rts	
; ===========================================================================

Obj74_FallEdge:				; XREF: Obj74_Index2
		bclr	#1,obStatus(a0)
		addi.w	#$24,obVelY(a0)	; make flame fall
		move.w	obX(a0),d0
		sub.w	$32(a0),d0
		bpl.s	loc_1884A
		neg.w	d0

loc_1884A:
		cmpi.w	#$12,d0
		bne.s	loc_18856
		bclr	#7,obGfx(a0)

loc_18856:
		bsr	ObjHitFloor
		tst.w	d1
		bpl.s	locret_1887E
		subq.b	#1,$29(a0)
		beq.s	Obj74_Delete2
		clr.w	obVelY(a0)
		move.w	$32(a0),obX(a0)
		move.w	$38(a0),obY(a0)
		bset	#7,obGfx(a0)
		subq.b	#2,ob2ndRout(a0)

locret_1887E:
		rts	
; ===========================================================================

Obj74_Delete2:
		jmp	DeleteObject
; ===========================================================================

loc_18886:				; XREF: Obj74_Index
		bset	#7,obGfx(a0)
		subq.b	#1,$29(a0)
		bne.s	Obj74_Animate
		move.b	#1,obAnim(a0)
		subq.w	#4,obY(a0)
		clr.b	obColType(a0)

Obj74_Animate:
		lea	(Ani_obj14).l,a1
		jmp	AnimateSprite
; ===========================================================================

Obj74_Delete3:				; XREF: Obj74_Index
		jmp	DeleteObject
; ===========================================================================

Obj7A_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7A - Eggman (SLZ)
; ---------------------------------------------------------------------------

Obj7A:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj7A_Index(pc,d0.w),d1
		jmp	Obj7A_Index(pc,d1.w)
; ===========================================================================
Obj7A_Index:	dc.w Obj7A_Main-Obj7A_Index
		dc.w Obj7A_ShipMain-Obj7A_Index
		dc.w Obj7A_FaceMain-Obj7A_Index
		dc.w Obj7A_FlameMain-Obj7A_Index
		dc.w Obj7A_TubeMain-Obj7A_Index

Obj7A_ObjData:	dc.b 2,	0, 4		; routine number, animation, priority
		dc.b 4,	1, 4
		dc.b 6,	7, 4
		dc.b 8,	0, 3
; ===========================================================================

Obj7A_Main:				; XREF: Obj7A_Index
		move.w	#$2188,obX(a0)
		move.w	#$228,obY(a0)
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$38(a0)
		move.b	#$F,obColType(a0)
		move.b	#8,obColProp(a0)	; set number of	hits to	8
		lea	Obj7A_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj7A_LoadBoss
; ===========================================================================

Obj7A_Loop:
		jsr	SingleObjLoad2
		bne.s	loc_1895C
		move.b	#$7A,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj7A_LoadBoss:				; XREF: Obj7A_Main
		bclr	#0,obStatus(a0)
		clr.b	ob2ndRout(a1)
		move.b	(a2)+,obRoutine(a1)
		move.b	(a2)+,obAnim(a1)
		move.b	(a2)+,obPriority(a1)
		move.l	#Map_Eggman,obMap(a1)
		move.w	#$400,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$20,obActWid(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj7A_Loop	; repeat sequence 3 more times

loc_1895C:
		lea	($FFFFD040).w,a1
		lea	$2A(a0),a2
		moveq	#$5E,d0
		moveq	#$3E,d1

loc_18968:
		cmp.b	(a1),d0
		bne.s	loc_18974
		tst.b	obSubtype(a1)
		beq.s	loc_18974
		move.w	a1,(a2)+

loc_18974:
		adda.w	#$40,a1
		dbf	d1,loc_18968

Obj7A_ShipMain:				; XREF: Obj7A_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj7A_ShipIndex(pc,d0.w),d0
		jsr	obj7A_ShipIndex(pc,d0.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#$FC,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj7A_ShipIndex:dc.w loc_189B8-Obj7A_ShipIndex
		dc.w loc_18A5E-Obj7A_ShipIndex
		dc.w Obj7A_MakeBall-Obj7A_ShipIndex
		dc.w loc_18B48-Obj7A_ShipIndex
		dc.w loc_18B80-Obj7A_ShipIndex
		dc.w loc_18BC6-Obj7A_ShipIndex
; ===========================================================================

loc_189B8:				; XREF: Obj7A_ShipIndex
		move.w	#-$100,obVelX(a0)
		cmpi.w	#$2120,$30(a0)
		bcc.s	loc_189CA
		addq.b	#2,ob2ndRout(a0)

loc_189CA:
		bsr	BossMove
		move.b	$3F(a0),d0
		addq.b	#2,$3F(a0)
		jsr	(CalcSine).l
		asr.w	#6,d0
		add.w	$38(a0),d0
		move.w	d0,obY(a0)
		move.w	$30(a0),obX(a0)
		bra.s	loc_189FE
; ===========================================================================

loc_189EE:
		bsr	BossMove
		move.w	$38(a0),obY(a0)
		move.w	$30(a0),obX(a0)

loc_189FE:
		cmpi.b	#6,ob2ndRout(a0)
		bcc.s	locret_18A44
		tst.b	obStatus(a0)
		bmi.s	loc_18A46
		tst.b	obColType(a0)
		bne.s	locret_18A44
		tst.b	$3E(a0)
		bne.s	loc_18A28
		move.b	#$20,$3E(a0)
		bsr	BossDamageSound

loc_18A28:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_18A36
		move.w	#$EEE,d0

loc_18A36:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_18A44
		move.b	#$F,obColType(a0)

locret_18A44:
		rts	
; ===========================================================================

loc_18A46:
		moveq	#100,d0
		bsr	AddPoints
		move.b	#6,ob2ndRout(a0)
		move.b	#$78,$3C(a0)
		clr.w	obVelX(a0)
		rts	
; ===========================================================================

loc_18A5E:				; XREF: Obj7A_ShipIndex
		move.w	$30(a0),d0
		move.w	#$200,obVelX(a0)
		btst	#0,obStatus(a0)
		bne.s	loc_18A7C
		neg.w	obVelX(a0)
		cmpi.w	#$2008,d0
		bgt.s	loc_18A88
		bra.s	loc_18A82
; ===========================================================================

loc_18A7C:
		cmpi.w	#$2138,d0
		blt.s	loc_18A88

loc_18A82:
		bchg	#0,obStatus(a0)

loc_18A88:
		move.w	obX(a0),d0
		moveq	#-1,d1
		moveq	#2,d2
		lea	$2A(a0),a2
		moveq	#$28,d4
		tst.w	obVelX(a0)
		bpl.s	loc_18A9E
		neg.w	d4

loc_18A9E:
		move.w	(a2)+,d1
		movea.l	d1,a3
		btst	#3,obStatus(a3)
		bne.s	loc_18AB4
		move.w	obX(a3),d3
		add.w	d4,d3
		sub.w	d0,d3
		beq.s	loc_18AC0

loc_18AB4:
		dbf	d2,loc_18A9E

		move.b	d2,obSubtype(a0)
		bra.w	loc_189CA
; ===========================================================================

loc_18AC0:
		move.b	d2,obSubtype(a0)
		addq.b	#2,ob2ndRout(a0)
		move.b	#$28,$3C(a0)
		bra.w	loc_189CA
; ===========================================================================

Obj7A_MakeBall:				; XREF: Obj7A_ShipIndex
		cmpi.b	#$28,$3C(a0)
		bne.s	loc_18B36
		moveq	#-1,d0
		move.b	obSubtype(a0),d0
		ext.w	d0
		bmi.s	loc_18B40
		subq.w	#2,d0
		neg.w	d0
		add.w	d0,d0
		lea	$2A(a0),a1
		move.w	(a1,d0.w),d0
		movea.l	d0,a2
		lea	($FFFFD040).w,a1
		moveq	#$3E,d1

loc_18AFA:
		cmp.l	$3C(a1),d0
		beq.s	loc_18B40
		adda.w	#$40,a1
		dbf	d1,loc_18AFA

		move.l	a0,-(sp)
		lea	(a2),a0
		jsr	SingleObjLoad2
		movea.l	(sp)+,a0
		bne.s	loc_18B40
		move.b	#$7B,(a1)	; load spiked ball object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		addi.w	#$20,obY(a1)
		move.b	obStatus(a2),obStatus(a1)
		move.l	a2,$3C(a1)

loc_18B36:
		subq.b	#1,$3C(a0)
		beq.s	loc_18B40
		bra.w	loc_189FE
; ===========================================================================

loc_18B40:
		subq.b	#2,ob2ndRout(a0)
		bra.w	loc_189CA
; ===========================================================================

loc_18B48:				; XREF: Obj7A_ShipIndex
		subq.b	#1,$3C(a0)
		bmi.s	loc_18B52
		bra.w	BossDefeated
; ===========================================================================

loc_18B52:
		addq.b	#2,ob2ndRout(a0)
		clr.w	obVelY(a0)
		bset	#0,obStatus(a0)
		bclr	#7,obStatus(a0)
		clr.w	obVelX(a0)
		move.b	#-$18,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_18B7C
		move.b	#1,($FFFFF7A7).w

loc_18B7C:
		bra.w	loc_189FE
; ===========================================================================

loc_18B80:				; XREF: Obj7A_ShipIndex
		addq.b	#1,$3C(a0)
		beq.s	loc_18B90
		bpl.s	loc_18B96
		addi.w	#$18,obVelY(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18B90:
		clr.w	obVelY(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18B96:
		cmpi.b	#$20,$3C(a0)
		bcs.s	loc_18BAE
		beq.s	loc_18BB4
		cmpi.b	#$2A,$3C(a0)
		bcs.s	loc_18BC2
		addq.b	#2,ob2ndRout(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18BAE:
		subq.w	#8,obVelY(a0)
		bra.s	loc_18BC2
; ===========================================================================

loc_18BB4:
		clr.w	obVelY(a0)
		move.w	#$84,d0
		jsr	(PlaySound).l	; play SLZ music

loc_18BC2:
		bra.w	loc_189EE
; ===========================================================================

loc_18BC6:				; XREF: Obj7A_ShipIndex
		move.w	#$400,obVelX(a0)
		move.w	#-$40,obVelY(a0)
		cmpi.w	#$2160,($FFFFF72A).w
		bcc.s	loc_18BE0
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_18BE8
; ===========================================================================

loc_18BE0:
		tst.b	obRender(a0)
		bpl.w	Obj7A_Delete

loc_18BE8:
		bsr	BossMove
		bra.w	loc_189CA
; ===========================================================================

Obj7A_FaceMain:				; XREF: Obj7A_Index
		moveq	#0,d0
		moveq	#1,d1
		movea.l	$34(a0),a1
		move.b	ob2ndRout(a1),d0
		cmpi.b	#6,d0
		bmi.s	loc_18C06
		moveq	#$A,d1
		bra.s	loc_18C1A
; ===========================================================================

loc_18C06:
		tst.b	obColType(a1)
		bne.s	loc_18C10
		moveq	#5,d1
		bra.s	loc_18C1A
; ===========================================================================

loc_18C10:
		cmpi.b	#4,($FFFFD024).w
		bcs.s	loc_18C1A
		moveq	#4,d1

loc_18C1A:
		move.b	d1,obAnim(a0)
		cmpi.b	#$A,d0
		bne.s	loc_18C32
		move.b	#6,obAnim(a0)
		tst.b	obRender(a0)
		bpl.w	Obj7A_Delete

loc_18C32:
		bra.s	loc_18C6C
; ===========================================================================

Obj7A_FlameMain:			; XREF: Obj7A_Index
		move.b	#8,obAnim(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$A,ob2ndRout(a1)
		bne.s	loc_18C56
		tst.b	obRender(a0)
		bpl.w	Obj7A_Delete
		move.b	#$B,obAnim(a0)
		bra.s	loc_18C6C
; ===========================================================================

loc_18C56:
		cmpi.b	#8,ob2ndRout(a1)
		bgt.s	loc_18C6C
		cmpi.b	#4,ob2ndRout(a1)
		blt.s	loc_18C6C
		move.b	#7,obAnim(a0)

loc_18C6C:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite

loc_18C78:
		movea.l	$34(a0),a1
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)
		move.b	obStatus(a1),obStatus(a0)
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#-4,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================

Obj7A_TubeMain:				; XREF: Obj7A_Index
		movea.l	$34(a0),a1
		cmpi.b	#$A,ob2ndRout(a1)
		bne.s	loc_18CB8
		tst.b	obRender(a0)
		bpl.w	Obj7A_Delete

loc_18CB8:
		move.l	#Map_BossItems,obMap(a0)
		move.w	#$246C,obGfx(a0)
		move.b	#3,obFrame(a0)
		bra.s	loc_18C78
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 7B - exploding	spikeys	that Eggman drops (SLZ)
; ---------------------------------------------------------------------------

Obj7B:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj7B_Index(pc,d0.w),d0
		jsr	obj7B_Index(pc,d0.w)
		move.w	$30(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		bmi.w	Obj7A_Delete
		cmpi.w	#$280,d0
		bhi.w	Obj7A_Delete
		jmp	DisplaySprite
; ===========================================================================
Obj7B_Index:	dc.w Obj7B_Main-Obj7B_Index
		dc.w Obj7B_Fall-Obj7B_Index
		dc.w loc_18DC6-Obj7B_Index
		dc.w loc_18EAA-Obj7B_Index
		dc.w Obj7B_Explode-Obj7B_Index
		dc.w Obj7B_MoveFrag-Obj7B_Index
; ===========================================================================

Obj7B_Main:				; XREF: Obj7B_Index
		move.l	#Map_obj5Ea,obMap(a0)
		move.w	#$518,obGfx(a0)
		move.b	#1,obFrame(a0)
		ori.b	#4,obRender(a0)
		move.b	#4,obPriority(a0)
		move.b	#$8B,obColType(a0)
		move.b	#$C,obActWid(a0)
		movea.l	$3C(a0),a1
		move.w	obX(a1),$30(a0)
		move.w	obY(a1),$34(a0)
		bset	#0,obStatus(a0)
		move.w	obX(a0),d0
		cmp.w	obX(a1),d0
		bgt.s	loc_18D68
		bclr	#0,obStatus(a0)
		move.b	#2,$3A(a0)

loc_18D68:
		addq.b	#2,obRoutine(a0)

Obj7B_Fall:				; XREF: Obj7B_Index
		jsr	ObjectFall
		movea.l	$3C(a0),a1
		lea	(word_19018).l,a2
		moveq	#0,d0
		move.b	obFrame(a1),d0
		move.w	obX(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_18D8E
		addq.w	#2,d0

loc_18D8E:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		cmp.w	obY(a0),d1
		bgt.s	locret_18DC4
		movea.l	$3C(a0),a1
		moveq	#2,d1
		btst	#0,obStatus(a0)
		beq.s	loc_18DAE
		moveq	#0,d1

loc_18DAE:
		move.w	#$F0,obSubtype(a0)
		move.b	#10,obDelayAni(a0)	; set frame duration to	10 frames
		move.b	obDelayAni(a0),obTimeFrame(a0)
		bra.w	loc_18FA2
; ===========================================================================

locret_18DC4:
		rts	
; ===========================================================================

loc_18DC6:				; XREF: Obj7B_Index
		movea.l	$3C(a0),a1
		moveq	#0,d0
		move.b	$3A(a0),d0
		sub.b	$3A(a1),d0
		beq.s	loc_18E2A
		bcc.s	loc_18DDA
		neg.b	d0

loc_18DDA:
		move.w	#-$818,d1
		move.w	#-$114,d2
		cmpi.b	#1,d0
		beq.s	loc_18E00
		move.w	#-$960,d1
		move.w	#-$F4,d2
		cmpi.w	#$9C0,$38(a1)
		blt.s	loc_18E00
		move.w	#-$A20,d1
		move.w	#-$80,d2

loc_18E00:
		move.w	d1,obVelY(a0)
		move.w	d2,obVelX(a0)
		move.w	obX(a0),d0
		sub.w	$30(a0),d0
		bcc.s	loc_18E16
		neg.w	obVelX(a0)

loc_18E16:
		move.b	#1,obFrame(a0)
		move.w	#$20,obSubtype(a0)
		addq.b	#2,obRoutine(a0)
		bra.w	loc_18EAA
; ===========================================================================

loc_18E2A:				; XREF: loc_18DC6
		lea	(word_19018).l,a2
		moveq	#0,d0
		move.b	obFrame(a1),d0
		move.w	#$28,d2
		move.w	obX(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_18E48
		neg.w	d2
		addq.w	#2,d0

loc_18E48:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		move.w	d1,obY(a0)
		add.w	$30(a0),d2
		move.w	d2,obX(a0)
		clr.w	$E(a0)
		clr.w	obScreenY(a0)
		subq.w	#1,obSubtype(a0)
		bne.s	loc_18E7A
		move.w	#$20,obSubtype(a0)
		move.b	#8,obRoutine(a0)
		rts	
; ===========================================================================

loc_18E7A:
		cmpi.w	#$78,obSubtype(a0)
		bne.s	loc_18E88
		move.b	#5,obDelayAni(a0)

loc_18E88:
		cmpi.w	#$3C,obSubtype(a0)
		bne.s	loc_18E96
		move.b	#2,obDelayAni(a0)

loc_18E96:
		subq.b	#1,obTimeFrame(a0)
		bgt.s	locret_18EA8
		bchg	#0,obFrame(a0)
		move.b	obDelayAni(a0),obTimeFrame(a0)

locret_18EA8:
		rts	
; ===========================================================================

loc_18EAA:				; XREF: Obj7B_Index
		lea	($FFFFD040).w,a1
		moveq	#$7A,d0
		moveq	#$40,d1
		moveq	#$3E,d2

loc_18EB4:
		cmp.b	(a1),d0
		beq.s	loc_18EC0
		adda.w	d1,a1
		dbf	d2,loc_18EB4

		bra.s	loc_18F38
; ===========================================================================

loc_18EC0:
		move.w	obX(a1),d0
		move.w	obY(a1),d1
		move.w	obX(a0),d2
		move.w	obY(a0),d3
		lea	byte_19022(pc),a2
		lea	byte_19026(pc),a3
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d0
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d2
		cmp.w	d0,d2
		bcs.s	loc_18F38
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d0
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d2
		cmp.w	d2,d0
		bcs.s	loc_18F38
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d1
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d3
		cmp.w	d1,d3
		bcs.s	loc_18F38
		move.b	(a2)+,d4
		ext.w	d4
		add.w	d4,d1
		move.b	(a3)+,d4
		ext.w	d4
		add.w	d4,d3
		cmp.w	d3,d1
		bcs.s	loc_18F38
		addq.b	#2,obRoutine(a0)
		clr.w	obSubtype(a0)
		clr.b	obColType(a1)
		subq.b	#1,obColProp(a1)
		bne.s	loc_18F38
		bset	#7,obStatus(a1)
		clr.w	obVelX(a0)
		clr.w	obVelY(a0)

loc_18F38:
		tst.w	obVelY(a0)
		bpl.s	loc_18F5C
		jsr	ObjectFall
		move.w	$34(a0),d0
		subi.w	#$2F,d0
		cmp.w	obY(a0),d0
		bgt.s	loc_18F58
		jsr	ObjectFall

loc_18F58:
		bra.w	loc_18E7A
; ===========================================================================

loc_18F5C:
		jsr	ObjectFall
		movea.l	$3C(a0),a1
		lea	(word_19018).l,a2
		moveq	#0,d0
		move.b	obFrame(a1),d0
		move.w	obX(a0),d1
		sub.w	$30(a0),d1
		bcc.s	loc_18F7E
		addq.w	#2,d0

loc_18F7E:
		add.w	d0,d0
		move.w	$34(a0),d1
		add.w	(a2,d0.w),d1
		cmp.w	obY(a0),d1
		bgt.s	loc_18F58
		movea.l	$3C(a0),a1
		moveq	#2,d1
		tst.w	obVelX(a0)
		bmi.s	loc_18F9C
		moveq	#0,d1

loc_18F9C:
		move.w	#0,obSubtype(a0)

loc_18FA2:
		move.b	d1,$3A(a1)
		move.b	d1,$3A(a0)
		cmp.b	obFrame(a1),d1
		beq.s	loc_19008
		bclr	#3,obStatus(a1)
		beq.s	loc_19008
		clr.b	ob2ndRout(a1)
		move.b	#2,obRoutine(a1)
		lea	($FFFFD000).w,a2
		move.w	obVelY(a0),obVelY(a2)
		neg.w	obVelY(a2)
		cmpi.b	#1,obFrame(a1)
		bne.s	loc_18FDC
		asr	obVelY(a2)

loc_18FDC:
		bset	#1,obStatus(a2)
		bclr	#3,obStatus(a2)
		clr.b	$3C(a2)
		move.l	a0,-(sp)
		lea	(a2),a0
		jsr	obj01_ChkRoll
		movea.l	(sp)+,a0
		move.b	#2,obRoutine(a2)
		move.w	#$CC,d0
		jsr	(PlaySound_Special).l ;	play "spring" sound

loc_19008:
		clr.w	obVelX(a0)
		clr.w	obVelY(a0)
		addq.b	#2,obRoutine(a0)
		bra.w	loc_18E7A
; ===========================================================================
word_19018:	dc.w $FFF8, $FFE4, $FFD1, $FFE4, $FFF8
		even
byte_19022:	dc.b $E8, $30, $E8, $30
		even
byte_19026:	dc.b 8,	$F0, 8,	$F0
		even
; ===========================================================================

Obj7B_Explode:				; XREF: Obj7B_Index
		move.b	#$3F,(a0)
		clr.b	obRoutine(a0)
		move.b	#0,$31(a0)
		cmpi.w	#$20,obSubtype(a0)
		beq.s	Obj7B_MakeFrag
		rts	
; ===========================================================================

Obj7B_MakeFrag:
		move.w	$34(a0),obY(a0)
		moveq	#3,d1
		lea	Obj7B_FragSpeed(pc),a2

Obj7B_Loop:
		jsr	SingleObjLoad
		bne.s	loc_1909A
		move.b	#$7B,(a1)	; load shrapnel	object
		move.b	#$A,obRoutine(a1)
		move.l	#Map_obj7B,obMap(a1)
		move.b	#3,obPriority(a1)
		move.w	#$518,obGfx(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.w	(a2)+,obVelX(a1)
		move.w	(a2)+,obVelY(a1)
		move.b	#$98,obColType(a1)
		ori.b	#4,obRender(a1)
		bset	#7,obRender(a1)
		move.b	#$C,obActWid(a1)

loc_1909A:
		dbf	d1,Obj7B_Loop	; repeat sequence 3 more times

		rts	
; ===========================================================================
Obj7B_FragSpeed:dc.w $FF00, $FCC0	; horizontal, vertical
		dc.w $FF60, $FDC0
		dc.w $100, $FCC0
		dc.w $A0, $FDC0
; ===========================================================================

Obj7B_MoveFrag:				; XREF: Obj7B_Index
		jsr	SpeedToPos
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$34(a0)
		addi.w	#$18,obVelY(a0)
		moveq	#4,d0
		and.w	($FFFFFE0E).w,d0
		lsr.w	#2,d0
		move.b	d0,obFrame(a0)
		tst.b	obRender(a0)
		bpl.w	Obj7A_Delete
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - exploding spikeys that the SLZ boss	drops
; ---------------------------------------------------------------------------
Map_obj7B:
		include	"_maps\obj7B.asm"
; ---------------------------------------------------------------------------
; Sprite mappings - spiked balls on the	seesaws	(SLZ)
; ---------------------------------------------------------------------------
Map_obj5E:
Map_obj5Ea:
		include	"_maps\obj5Eballs.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 75 - Eggman (SYZ)
; ---------------------------------------------------------------------------

Obj75:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj75_Index(pc,d0.w),d1
		jmp	Obj75_Index(pc,d1.w)
; ===========================================================================
Obj75_Index:	dc.w Obj75_Main-Obj75_Index
		dc.w Obj75_ShipMain-Obj75_Index
		dc.w Obj75_FaceMain-Obj75_Index
		dc.w Obj75_FlameMain-Obj75_Index
		dc.w Obj75_SpikeMain-Obj75_Index

Obj75_ObjData:	dc.b 2,	0, 5		; routine number, animation, priority
		dc.b 4,	1, 5
		dc.b 6,	7, 5
		dc.b 8,	0, 5
; ===========================================================================

Obj75_Main:				; XREF: Obj75_Index
		move.w	#$2DB0,obX(a0)
		move.w	#$4DA,obY(a0)
		move.w	obX(a0),$30(a0)
		move.w	obY(a0),$38(a0)
		move.b	#$F,obColType(a0)
		move.b	#8,obColProp(a0)	; set number of	hits to	8
		lea	Obj75_ObjData(pc),a2
		movea.l	a0,a1
		moveq	#3,d1
		bra.s	Obj75_LoadBoss
; ===========================================================================

Obj75_Loop:
		jsr	SingleObjLoad2
		bne.s	Obj75_ShipMain
		move.b	#$75,(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Obj75_LoadBoss:				; XREF: Obj75_Main
		bclr	#0,obStatus(a0)
		clr.b	ob2ndRout(a1)
		move.b	(a2)+,obRoutine(a1)
		move.b	(a2)+,obAnim(a1)
		move.b	(a2)+,obPriority(a1)
		move.l	#Map_Eggman,obMap(a1)
		move.w	#$400,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$20,obActWid(a1)
		move.l	a0,$34(a1)
		dbf	d1,Obj75_Loop	; repeat sequence 3 more times

Obj75_ShipMain:				; XREF: Obj75_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj75_ShipIndex(pc,d0.w),d1
		jsr	obj75_ShipIndex(pc,d1.w)
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#$FC,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================
Obj75_ShipIndex:dc.w loc_191CC-Obj75_ShipIndex,	loc_19270-Obj75_ShipIndex
		dc.w loc_192EC-Obj75_ShipIndex,	loc_19474-Obj75_ShipIndex
		dc.w loc_194AC-Obj75_ShipIndex,	loc_194F2-Obj75_ShipIndex
; ===========================================================================

loc_191CC:				; XREF: Obj75_ShipIndex
		move.w	#-$100,obVelX(a0)
		cmpi.w	#$2D38,$30(a0)
		bcc.s	loc_191DE
		addq.b	#2,ob2ndRout(a0)

loc_191DE:
		move.b	$3F(a0),d0
		addq.b	#2,$3F(a0)
		jsr	(CalcSine).l
		asr.w	#2,d0
		move.w	d0,obVelY(a0)

loc_191F2:
		bsr	BossMove
		move.w	$38(a0),obY(a0)
		move.w	$30(a0),obX(a0)

loc_19202:
		move.w	obX(a0),d0
		subi.w	#$2C00,d0
		lsr.w	#5,d0
		move.b	d0,$34(a0)
		cmpi.b	#6,ob2ndRout(a0)
		bcc.s	locret_19256
		tst.b	obStatus(a0)
		bmi.s	loc_19258
		tst.b	obColType(a0)
		bne.s	locret_19256
		tst.b	$3E(a0)
		bne.s	loc_1923A
		move.b	#$20,$3E(a0)
		bsr	BossDamageSound

loc_1923A:
		lea	($FFFFFB22).w,a1
		moveq	#0,d0
		tst.w	(a1)
		bne.s	loc_19248
		move.w	#$EEE,d0

loc_19248:
		move.w	d0,(a1)
		subq.b	#1,$3E(a0)
		bne.s	locret_19256
		move.b	#$F,obColType(a0)

locret_19256:
		rts	
; ===========================================================================

loc_19258:				; XREF: loc_19202
		moveq	#100,d0
		bsr	AddPoints
		move.b	#6,ob2ndRout(a0)
		move.w	#$B4,$3C(a0)
		clr.w	obVelX(a0)
		rts	
; ===========================================================================

loc_19270:				; XREF: Obj75_ShipIndex
		move.w	$30(a0),d0
		move.w	#$140,obVelX(a0)
		btst	#0,obStatus(a0)
		bne.s	loc_1928E
		neg.w	obVelX(a0)
		cmpi.w	#$2C08,d0
		bgt.s	loc_1929E
		bra.s	loc_19294
; ===========================================================================

loc_1928E:
		cmpi.w	#$2D38,d0
		blt.s	loc_1929E

loc_19294:
		bchg	#0,obStatus(a0)
		clr.b	$3D(a0)

loc_1929E:
		subi.w	#$2C10,d0
		andi.w	#$1F,d0
		subi.w	#$1F,d0
		bpl.s	loc_192AE
		neg.w	d0

loc_192AE:
		subq.w	#1,d0
		bgt.s	loc_192E8
		tst.b	$3D(a0)
		bne.s	loc_192E8
		move.w	($FFFFD008).w,d1
		subi.w	#$2C00,d1
		asr.w	#5,d1
		cmp.b	$34(a0),d1
		bne.s	loc_192E8
		moveq	#0,d0
		move.b	$34(a0),d0
		asl.w	#5,d0
		addi.w	#$2C10,d0
		move.w	d0,$30(a0)
		jsr	obj75_FindBlocks
		addq.b	#2,ob2ndRout(a0)
		clr.w	obSubtype(a0)
		clr.w	obVelX(a0)

loc_192E8:
		bra.w	loc_191DE
; ===========================================================================

loc_192EC:				; XREF: Obj75_ShipIndex
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		move.w	off_192FA(pc,d0.w),d0
		jmp	off_192FA(pc,d0.w)
; ===========================================================================
off_192FA:	dc.w loc_19302-off_192FA
		dc.w loc_19348-off_192FA
		dc.w loc_1938E-off_192FA
		dc.w loc_193D0-off_192FA
; ===========================================================================

loc_19302:				; XREF: off_192FA
		move.w	#$180,obVelY(a0)
		move.w	$38(a0),d0
		cmpi.w	#$556,d0
		bcs.s	loc_19344
		move.w	#$556,$38(a0)
		clr.w	$3C(a0)
		moveq	#-1,d0
		move.w	$36(a0),d0
		beq.s	loc_1933C
		movea.l	d0,a1
		move.b	#-1,$29(a1)
		move.b	#-1,$29(a0)
		move.l	a0,$34(a1)
		move.w	#$32,$3C(a0)

loc_1933C:
		clr.w	obVelY(a0)
		addq.b	#2,obSubtype(a0)

loc_19344:
		bra.w	loc_191F2
; ===========================================================================

loc_19348:				; XREF: off_192FA
		subq.w	#1,$3C(a0)
		bpl.s	loc_19366
		addq.b	#2,obSubtype(a0)
		move.w	#-$800,obVelY(a0)
		tst.w	$36(a0)
		bne.s	loc_19362
		asr	obVelY(a0)

loc_19362:
		moveq	#0,d0
		bra.s	loc_1937C
; ===========================================================================

loc_19366:
		moveq	#0,d0
		cmpi.w	#$1E,$3C(a0)
		bgt.s	loc_1937C
		moveq	#2,d0
		btst	#1,$3D(a0)
		beq.s	loc_1937C
		neg.w	d0

loc_1937C:
		add.w	$38(a0),d0
		move.w	d0,obY(a0)
		move.w	$30(a0),obX(a0)
		bra.w	loc_19202
; ===========================================================================

loc_1938E:				; XREF: off_192FA
		move.w	#$4DA,d0
		tst.w	$36(a0)
		beq.s	loc_1939C
		subi.w	#$18,d0

loc_1939C:
		cmp.w	$38(a0),d0
		blt.s	loc_193BE
		move.w	#8,$3C(a0)
		tst.w	$36(a0)
		beq.s	loc_193B4
		move.w	#$2D,$3C(a0)

loc_193B4:
		addq.b	#2,obSubtype(a0)
		clr.w	obVelY(a0)
		bra.s	loc_193CC
; ===========================================================================

loc_193BE:
		cmpi.w	#-$40,obVelY(a0)
		bge.s	loc_193CC
		addi.w	#$C,obVelY(a0)

loc_193CC:
		bra.w	loc_191F2
; ===========================================================================

loc_193D0:				; XREF: off_192FA
		subq.w	#1,$3C(a0)
		bgt.s	loc_19406
		bmi.s	loc_193EE
		moveq	#-1,d0
		move.w	$36(a0),d0
		beq.s	loc_193E8
		movea.l	d0,a1
		move.b	#$A,$29(a1)

loc_193E8:
		clr.w	$36(a0)
		bra.s	loc_19406
; ===========================================================================

loc_193EE:
		cmpi.w	#-$1E,$3C(a0)
		bne.s	loc_19406
		clr.b	$29(a0)
		subq.b	#2,ob2ndRout(a0)
		move.b	#-1,$3D(a0)
		bra.s	loc_19446
; ===========================================================================

loc_19406:
		moveq	#1,d0
		tst.w	$36(a0)
		beq.s	loc_19410
		moveq	#2,d0

loc_19410:
		cmpi.w	#$4DA,$38(a0)
		beq.s	loc_19424
		blt.s	loc_1941C
		neg.w	d0

loc_1941C:
		tst.w	$36(a0)
		add.w	d0,$38(a0)

loc_19424:
		moveq	#0,d0
		tst.w	$36(a0)
		beq.s	loc_19438
		moveq	#2,d0
		btst	#0,$3D(a0)
		beq.s	loc_19438
		neg.w	d0

loc_19438:
		add.w	$38(a0),d0
		move.w	d0,obY(a0)
		move.w	$30(a0),obX(a0)

loc_19446:
		bra.w	loc_19202

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj75_FindBlocks:			; XREF: loc_192AE
		clr.w	$36(a0)
		lea	($FFFFD040).w,a1
		moveq	#$3E,d0
		moveq	#$76,d1
		move.b	$34(a0),d2

Obj75_FindLoop:
		cmp.b	(a1),d1		; is object a SYZ boss block?
		bne.s	loc_1946A	; if not, branch
		cmp.b	obSubtype(a1),d2
		bne.s	loc_1946A
		move.w	a1,$36(a0)
		bra.s	locret_19472
; ===========================================================================

loc_1946A:
		lea	$40(a1),a1	; next object RAM entry
		dbf	d0,Obj75_FindLoop

locret_19472:
		rts	
; End of function Obj75_FindBlocks

; ===========================================================================

loc_19474:				; XREF: Obj75_ShipIndex
		subq.w	#1,$3C(a0)
		bmi.s	loc_1947E
		bra.w	BossDefeated
; ===========================================================================

loc_1947E:
		addq.b	#2,ob2ndRout(a0)
		clr.w	obVelY(a0)
		bset	#0,obStatus(a0)
		bclr	#7,obStatus(a0)
		clr.w	obVelX(a0)
		move.w	#-1,$3C(a0)
		tst.b	($FFFFF7A7).w
		bne.s	loc_194A8
		move.b	#1,($FFFFF7A7).w

loc_194A8:
		bra.w	loc_19202
; ===========================================================================

loc_194AC:				; XREF: Obj75_ShipIndex
		addq.w	#1,$3C(a0)
		beq.s	loc_194BC
		bpl.s	loc_194C2
		addi.w	#$18,obVelY(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194BC:
		clr.w	obVelY(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194C2:
		cmpi.w	#$20,$3C(a0)
		bcs.s	loc_194DA
		beq.s	loc_194E0
		cmpi.w	#$2A,$3C(a0)
		bcs.s	loc_194EE
		addq.b	#2,ob2ndRout(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194DA:
		subq.w	#8,obVelY(a0)
		bra.s	loc_194EE
; ===========================================================================

loc_194E0:
		clr.w	obVelY(a0)
		move.w	#$85,d0
		jsr	(PlaySound).l	; play SYZ music

loc_194EE:
		bra.w	loc_191F2
; ===========================================================================

loc_194F2:				; XREF: Obj75_ShipIndex
		move.w	#$400,obVelX(a0)
		move.w	#-$40,obVelY(a0)
		cmpi.w	#$2D40,($FFFFF72A).w
		bcc.s	loc_1950C
		addq.w	#2,($FFFFF72A).w
		bra.s	loc_19512
; ===========================================================================

loc_1950C:
		tst.b	obRender(a0)
		bpl.s	Obj75_ShipDelete

loc_19512:
		bsr	BossMove
		bra.w	loc_191DE
; ===========================================================================

Obj75_ShipDelete:
		jmp	DeleteObject
; ===========================================================================

Obj75_FaceMain:				; XREF: Obj75_Index
		moveq	#1,d1
		movea.l	$34(a0),a1
		moveq	#0,d0
		move.b	ob2ndRout(a1),d0
		move.w	off_19546(pc,d0.w),d0
		jsr	off_19546(pc,d0.w)
		move.b	d1,obAnim(a0)
		move.b	(a0),d0
		cmp.b	(a1),d0
		bne.s	Obj75_FaceDelete
		bra.s	loc_195BE
; ===========================================================================

Obj75_FaceDelete:
		jmp	DeleteObject
; ===========================================================================
off_19546:	dc.w loc_19574-off_19546, loc_19574-off_19546
		dc.w loc_1955A-off_19546, loc_19552-off_19546
		dc.w loc_19552-off_19546, loc_19556-off_19546
; ===========================================================================

loc_19552:				; XREF: off_19546
		moveq	#$A,d1
		rts	
; ===========================================================================

loc_19556:				; XREF: off_19546
		moveq	#6,d1
		rts	
; ===========================================================================

loc_1955A:				; XREF: off_19546
		moveq	#0,d0
		move.b	obSubtype(a1),d0
		move.w	off_19568(pc,d0.w),d0
		jmp	off_19568(pc,d0.w)
; ===========================================================================
off_19568:	dc.w loc_19570-off_19568, loc_19572-off_19568
		dc.w loc_19570-off_19568, loc_19570-off_19568
; ===========================================================================

loc_19570:				; XREF: off_19568
		bra.s	loc_19574
; ===========================================================================

loc_19572:				; XREF: off_19568
		moveq	#6,d1

loc_19574:				; XREF: off_19546
		tst.b	obColType(a1)
		bne.s	loc_1957E
		moveq	#5,d1
		rts	
; ===========================================================================

loc_1957E:
		cmpi.b	#4,($FFFFD024).w
		bcs.s	locret_19588
		moveq	#4,d1

locret_19588:
		rts	
; ===========================================================================

Obj75_FlameMain:			; XREF: Obj75_Index
		move.b	#7,obAnim(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$A,ob2ndRout(a1)
		bne.s	loc_195AA
		move.b	#$B,obAnim(a0)
		tst.b	obRender(a0)
		bpl.s	Obj75_FlameDelete
		bra.s	loc_195B6
; ===========================================================================

loc_195AA:
		tst.w	obVelX(a1)
		beq.s	loc_195B6
		move.b	#8,obAnim(a0)

loc_195B6:
		bra.s	loc_195BE
; ===========================================================================

Obj75_FlameDelete:
		jmp	DeleteObject
; ===========================================================================

loc_195BE:
		lea	(Ani_Eggman).l,a1
		jsr	AnimateSprite
		movea.l	$34(a0),a1
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)

loc_195DA:
		move.b	obStatus(a1),obStatus(a0)
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#$FC,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================

Obj75_SpikeMain:			; XREF: Obj75_Index
		move.l	#Map_BossItems,obMap(a0)
		move.w	#$246C,obGfx(a0)
		move.b	#5,obFrame(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$A,ob2ndRout(a1)
		bne.s	loc_1961C
		tst.b	obRender(a0)
		bpl.s	Obj75_SpikeDelete

loc_1961C:
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)
		move.w	$3C(a0),d0
		cmpi.b	#4,ob2ndRout(a1)
		bne.s	loc_19652
		cmpi.b	#6,obSubtype(a1)
		beq.s	loc_1964C
		tst.b	obSubtype(a1)
		bne.s	loc_19658
		cmpi.w	#$94,d0
		bge.s	loc_19658
		addq.w	#7,d0
		bra.s	loc_19658
; ===========================================================================

loc_1964C:
		tst.w	$3C(a1)
		bpl.s	loc_19658

loc_19652:
		tst.w	d0
		ble.s	loc_19658
		subq.w	#5,d0

loc_19658:
		move.w	d0,$3C(a0)
		asr.w	#2,d0
		add.w	d0,obY(a0)
		move.b	#8,obActWid(a0)
		move.b	#$C,obHeight(a0)
		clr.b	obColType(a0)
		movea.l	$34(a0),a1
		tst.b	obColType(a1)
		beq.s	loc_19688
		tst.b	$29(a1)
		bne.s	loc_19688
		move.b	#$84,obColType(a0)

loc_19688:
		bra.w	loc_195DA
; ===========================================================================

Obj75_SpikeDelete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 76 - blocks that Eggman picks up (SYZ)
; ---------------------------------------------------------------------------

Obj76:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj76_Index(pc,d0.w),d1
		jmp	Obj76_Index(pc,d1.w)
; ===========================================================================
Obj76_Index:	dc.w Obj76_Main-Obj76_Index
		dc.w Obj76_Action-Obj76_Index
		dc.w loc_19762-Obj76_Index
; ===========================================================================

Obj76_Main:				; XREF: Obj76_Index
		moveq	#0,d4
		move.w	#$2C10,d5
		moveq	#9,d6
		lea	(a0),a1
		bra.s	Obj76_MakeBlock
; ===========================================================================

Obj76_Loop:
		jsr	SingleObjLoad
		bne.s	Obj76_ExitLoop

Obj76_MakeBlock:			; XREF: Obj76_Main
		move.b	#$76,(a1)
		move.l	#Map_obj76,obMap(a1)
		move.w	#$4000,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$10,obActWid(a1)
		move.b	#$10,obHeight(a1)
		move.b	#3,obPriority(a1)
		move.w	d5,obX(a1)	; set x-position
		move.w	#$582,obY(a1)
		move.w	d4,obSubtype(a1)
		addi.w	#$101,d4
		addi.w	#$20,d5		; add $20 to next x-position
		addq.b	#2,obRoutine(a1)
		dbf	d6,Obj76_Loop	; repeat sequence 9 more times

Obj76_ExitLoop:
		rts	
; ===========================================================================

Obj76_Action:				; XREF: Obj76_Index
		move.b	$29(a0),d0
		cmp.b	obSubtype(a0),d0
		beq.s	Obj76_Solid
		tst.b	d0
		bmi.s	loc_19718

loc_19712:
		jsr	obj76_Break
		bra.s	Obj76_Display
; ===========================================================================

loc_19718:
		movea.l	$34(a0),a1
		tst.b	obColProp(a1)
		beq.s	loc_19712
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)
		addi.w	#$2C,obY(a0)
		cmpa.w	a0,a1
		bcs.s	Obj76_Display
		move.w	obVelY(a1),d0
		ext.l	d0
		asr.l	#8,d0
		add.w	d0,obY(a0)
		bra.s	Obj76_Display
; ===========================================================================

Obj76_Solid:				; XREF: Obj76_Action
		move.w	#$1B,d1
		move.w	#$10,d2
		move.w	#$11,d3
		move.w	obX(a0),d4
		jsr	SolidObject

Obj76_Display:				; XREF: Obj76_Action
		jmp	DisplaySprite
; ===========================================================================

loc_19762:				; XREF: Obj76_Index
		tst.b	obRender(a0)
		bpl.s	Obj76_Delete
		jsr	ObjectFall
		jmp	DisplaySprite
; ===========================================================================

Obj76_Delete:
		jmp	DeleteObject

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj76_Break:				; XREF: Obj76_Action
		lea	Obj76_FragSpeed(pc),a4
		lea	Obj76_FragPos(pc),a5
		moveq	#1,d4
		moveq	#3,d1
		moveq	#$38,d2
		addq.b	#2,obRoutine(a0)
		move.b	#8,obActWid(a0)
		move.b	#8,obHeight(a0)
		lea	(a0),a1
		bra.s	Obj76_MakeFrag
; ===========================================================================

Obj76_LoopFrag:
		jsr	SingleObjLoad2
		bne.s	loc_197D4

Obj76_MakeFrag:
		lea	(a0),a2
		lea	(a1),a3
		moveq	#3,d3

loc_197AA:
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		dbf	d3,loc_197AA

		move.w	(a4)+,obVelX(a1)
		move.w	(a4)+,obVelY(a1)
		move.w	(a5)+,d3
		add.w	d3,obX(a1)
		move.w	(a5)+,d3
		add.w	d3,obY(a1)
		move.b	d4,obFrame(a1)
		addq.w	#1,d4
		dbf	d1,Obj76_LoopFrag ; repeat sequence 3 more times

loc_197D4:
		move.w	#$CB,d0
		jmp	(PlaySound_Special).l ;	play smashing sound
; End of function Obj76_Break

; ===========================================================================
Obj76_FragSpeed:dc.w $FE80, $FE00
		dc.w $180, $FE00
		dc.w $FF00, $FF00
		dc.w $100, $FF00
Obj76_FragPos:	dc.w $FFF8, $FFF8
		dc.w $10, 0
		dc.w 0,	$10
		dc.w $10, $10
; ---------------------------------------------------------------------------
; Sprite mappings - blocks that	Eggman picks up (SYZ)
; ---------------------------------------------------------------------------
Map_obj76:
		include	"_maps\obj76.asm"

; ===========================================================================

loc_1982C:				; XREF: loc_19C62; loc_19C80
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 82 - Eggman in Bomb Machine Cutscene
; ---------------------------------------------------------------------------

Obj82:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj82_Index(pc,d0.w),d1
		jmp	Obj82_Index(pc,d1.w)
; ===========================================================================
Obj82_Index:	dc.w Obj82_Main-Obj82_Index
		dc.w Obj82_Eggman-Obj82_Index
		dc.w Obj82_Switch-Obj82_Index

Obj82_ObjData:	dc.b 2,	0, 3		; routine number, animation, priority
		dc.b 4,	0, 3
; ===========================================================================

Obj82_Main:				; XREF: Obj82_Index
		moveq	#$1E,d0
		jsr	LoadPLC		; load SBZ2 Eggman patterns

		jsr	SingleObjLoad
		move.b	#$3A,(a1)
		move.w	#$01B4,obX(a1)
		move.w	#$0128,obY(a1)
		move.l	a0,$30(a1)

		lea	Obj82_ObjData(pc),a2
		move.w	#$50,obX(a0)
		move.w	#$1A5,obY(a0)
		move.b	#$F,obColType(a0)
		move.b	#$10,obColProp(a0)
		bset	#0,obStatus(a0)
		clr.b	ob2ndRout(a0)
		move.b	(a2)+,obRoutine(a0)
		move.b	(a2)+,obAnim(a0)
		move.b	(a2)+,obPriority(a0)
		move.l	#Map_obj82,obMap(a0)
		move.w	#$400,obGfx(a0)
		move.b	#4,obRender(a0)
		bset	#7,obRender(a0)
		move.b	#$20,obActWid(a0)

		jsr	SingleObjLoad2
		bne.s	Obj82_Eggman
		move.l	a0,$34(a1)
		move.b	#$82,(a1)	; load switch object
		move.w	#$170,obX(a1)
		move.w	#$1BB,obY(a1)
		clr.b	ob2ndRout(a0)
		move.b	(a2)+,obRoutine(a1)
		move.b	(a2)+,obAnim(a1)
		move.b	(a2)+,obPriority(a1)
		move.l	#Map_obj32,obMap(a1)
		move.w	#$4A4,obGfx(a1)
		move.b	#4,obRender(a1)
		bset	#7,obRender(a1)
		move.b	#$10,obActWid(a1)
		move.b	#0,obFrame(a1)

Obj82_Eggman:				; XREF: Obj82_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj82_EggIndex(pc,d0.w),d1
		jsr	obj82_EggIndex(pc,d1.w)
		lea	Ani_obj82(pc),a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================
Obj82_EggIndex:	dc.w Obj82_ChkSonic-Obj82_EggIndex
		dc.w Obj82_PreLeap-Obj82_EggIndex
		dc.w Obj82_Leap-Obj82_EggIndex
		dc.w loc_19934_2-Obj82_EggIndex
; ===========================================================================

Obj82_ChkSonic:				; XREF: Obj82_EggIndex
		move.w	obX(a0),d0

		cmpi.w	#$110,d0
		blt.s	@cont
		move.b	#1,obAnim(a0)	; make eggman laugh

@cont:
		move.w	#$B0,obVelX(a0)
		cmpi.w	#$140,d0
		blt.s	loc_19934
		addq.b	#2,ob2ndRout(a0)
		move.w	#1,$3C(a0)	; set delay to 3 seconds

loc_19934:				; XREF: Obj82_EggIndex
		jmp	SpeedToPos
; ===========================================================================

Obj82_PreLeap:				; XREF: Obj82_EggIndex
		subq.w	#1,$3C(a0)	; subtract 1 from time delay
		bne.s	loc_19954	; if time remains, branch
		addq.b	#2,ob2ndRout(a0)
		move.b	#2,obAnim(a0)
		addq.w	#4,obY(a0)
		move.w	#15,$3C(a0)

loc_19954:
		bra.s	loc_19934
; ===========================================================================

Obj82_Leap:				; XREF: Obj82_EggIndex
		subq.w	#1,$3C(a0)
		bgt.w	loc_199D0
		bne.s	loc_1996A
		move.w	#$FC,obVelX(a0)	; make Eggman leap
		move.w	#-$3C0,obVelY(a0)

loc_1996A:
		cmpi.w	#$170,obX(a0)
		blt.s	loc_19976
		clr.w	obVelX(a0)

loc_19976:
		addi.w	#$24,obVelY(a0)
		tst.w	obVelY(a0)
		bmi.s	Obj82_FindBlocks
		cmpi.w	#$194,obY(a0)
		bcs.s	Obj82_FindBlocks
		move.w	#$5357,obSubtype(a0)
		cmpi.w	#$19A,obY(a0)
		bcs.s	Obj82_FindBlocks
		move.w	#$19A,obY(a0)
		clr.w	obVelY(a0)

Obj82_FindBlocks:
		move.w	obVelX(a0),d0
		or.w	obVelY(a0),d0
		bne.s	loc_199D0
		
		move.b	#1,($FFFFFFC8).w	; set flag that button was pressed

		jsr	SingleObjLoad
		move.b	#$3A,(a1)
		move.b	#$A,obRoutine(a1)
		move.w	#$01B4,obX(a1)
		move.w	#$0128,obY(a1)

		move.l	#Map_BombMachine,obMap(a1)
		move.w	#$22B0,obGfx(a1)
		ori.b	#4,obRender(a1)
		move.b	#1,obPriority(a1)

		move.b	#1,($FFFFD45A).w	; use second frame

		addq.b	#2,ob2ndRout(a0)
		move.b	#1,obAnim(a0)

loc_199D0:
	;	bra.w	loc_19934
; ===========================================================================

loc_19934_2:				; XREF: Obj82_EggIndex
		jmp	SpeedToPos
; ===========================================================================

Obj82_Switch:				; XREF: Obj82_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj82_SwIndex(pc,d0.w),d0
		jmp	Obj82_SwIndex(pc,d0.w)
; ===========================================================================
Obj82_SwIndex:	dc.w loc_199E6-Obj82_SwIndex
		dc.w Obj82_SwDisplay-Obj82_SwIndex
; ===========================================================================

loc_199E6:				; XREF: Obj82_SwIndex
		movea.l	$34(a0),a1
		cmpi.w	#$5357,obSubtype(a1)
		bne.s	Obj82_SwDisplay
		move.b	#1,obFrame(a0)
		addq.b	#2,ob2ndRout(a0)

Obj82_SwDisplay:			; XREF: Obj82_SwIndex
		jmp	DisplaySprite
; ===========================================================================
Ani_obj82:
		include	"_anim\obj82.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - Eggman (SBZ2)
; ---------------------------------------------------------------------------
Map_obj82:
		include	"_maps\obj82.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 83 - blocks that disintegrate Eggman	presses	a switch (SBZ2)
; ---------------------------------------------------------------------------

Obj83:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj83_Index(pc,d0.w),d1
		jmp	Obj83_Index(pc,d1.w)
; ===========================================================================
Obj83_Index:	dc.w Obj83_Main-Obj83_Index
		dc.w Obj83_ChkBreak-Obj83_Index
		dc.w loc_19C36-Obj83_Index
		dc.w loc_19C62-Obj83_Index
		dc.w loc_19C72-Obj83_Index
		dc.w loc_19C80-Obj83_Index
; ===========================================================================

Obj83_Main:				; XREF: Obj83_Index
		move.w	#$2080,obX(a0)
		move.w	#$5D0,obY(a0)
		move.b	#$80,obActWid(a0)
		move.b	#$10,obHeight(a0)
		move.b	#4,obRender(a0)
		bset	#7,obRender(a0)
		moveq	#0,d4
		move.w	#$2010,d5
		moveq	#7,d6
		lea	$30(a0),a2

Obj83_MakeBlock:
		jsr	SingleObjLoad
		bne.s	Obj83_ExitMake
		move.w	a1,(a2)+
		move.b	#$83,(a1)	; load block object
		move.l	#Map_obj83,obMap(a1)
		move.w	#$4518,obGfx(a1)
		move.b	#4,obRender(a1)
		move.b	#$10,obActWid(a1)
		move.b	#$10,obHeight(a1)
		move.b	#3,obPriority(a1)
		move.w	d5,obX(a1)	; set X	position
		move.w	#$5D0,obY(a1)
		addi.w	#$20,d5		; add $20 for next X position
		move.b	#8,obRoutine(a1)
		dbf	d6,Obj83_MakeBlock ; repeat sequence 7 more times

Obj83_ExitMake:
		addq.b	#2,obRoutine(a0)
		rts	
; ===========================================================================

Obj83_ChkBreak:				; XREF: Obj83_Index
		cmpi.w	#$474F,obSubtype(a0)	; is object set	to disintegrate?
		bne.s	Obj83_Solid	; if not, branch
		clr.b	obFrame(a0)
		addq.b	#2,obRoutine(a0)	; next subroutine

Obj83_Solid:
		moveq	#0,d0
		move.b	obFrame(a0),d0
		neg.b	d0
		ext.w	d0
		addq.w	#8,d0
		asl.w	#4,d0
		move.w	#$2100,d4
		sub.w	d0,d4
		move.b	d0,obActWid(a0)
		move.w	d4,obX(a0)
		moveq	#$B,d1
		add.w	d0,d1
		moveq	#$10,d2
		moveq	#$11,d3
		jmp	SolidObject
; ===========================================================================

loc_19C36:				; XREF: Obj83_Index
		subi.b	#$E,obTimeFrame(a0)
		bcc	Obj83_Solid2
		moveq	#-1,d0
		move.b	obFrame(a0),d0
		ext.w	d0
		add.w	d0,d0
		move.w	$30(a0,d0.w),d0
		movea.l	d0,a1
		move.w	#$474F,obSubtype(a1)
		addq.b	#1,obFrame(a0)
		cmpi.b	#8,obFrame(a0)
		beq.s	loc_19C62

Obj83_Solid2:
		bra.s	Obj83_Solid
; ===========================================================================

loc_19C62:				; XREF: Obj83_Index
		bclr	#3,obStatus(a0)
		bclr	#3,($FFFFD022).w
		bra.w	loc_1982C
; ===========================================================================

loc_19C72:				; XREF: Obj83_Index
		cmpi.w	#$474F,obSubtype(a0)	; is object set	to disintegrate?
		beq.s	Obj83_Break	; if yes, branch
		jmp	DisplaySprite
; ===========================================================================

loc_19C80:				; XREF: Obj83_Index
		tst.b	obRender(a0)
		bpl.w	loc_1982C
		jsr	ObjectFall
		jmp	DisplaySprite
; ===========================================================================

Obj83_Break:				; XREF: loc_19C72
		lea	Obj83_FragSpeed(pc),a4
		lea	Obj83_FragPos(pc),a5
		moveq	#1,d4
		moveq	#3,d1
		moveq	#$38,d2
		addq.b	#2,obRoutine(a0)
		move.b	#8,obActWid(a0)
		move.b	#8,obHeight(a0)
		lea	(a0),a1
		bra.s	Obj83_MakeFrag
; ===========================================================================

Obj83_LoopFrag:
		jsr	SingleObjLoad2
		bne.s	Obj83_BreakSnd

Obj83_MakeFrag:				; XREF: Obj83_Break
		lea	(a0),a2
		lea	(a1),a3
		moveq	#3,d3

loc_19CC4:
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		move.l	(a2)+,(a3)+
		dbf	d3,loc_19CC4

		move.w	(a4)+,obVelY(a1)
		move.w	(a5)+,d3
		add.w	d3,obX(a1)
		move.w	(a5)+,d3
		add.w	d3,obY(a1)
		move.b	d4,obFrame(a1)
		addq.w	#1,d4
		dbf	d1,Obj83_LoopFrag ; repeat sequence 3 more times

Obj83_BreakSnd:
		move.w	#$CB,d0
		jsr	(PlaySound_Special).l ;	play smashing sound
		jmp	DisplaySprite
; ===========================================================================
Obj83_FragSpeed:dc.w $80, 0
		dc.w $120, $C0
Obj83_FragPos:	dc.w $FFF8, $FFF8
		dc.w $10, 0
		dc.w 0,	$10
		dc.w $10, $10
; ---------------------------------------------------------------------------
; Sprite mappings - blocks that	disintegrate when Eggman presses a switch
; ---------------------------------------------------------------------------
Map_obj83:
		include	"_maps\obj83.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 85 - Eggman (FZ)
; ---------------------------------------------------------------------------

Obj85_Delete:
		jmp	DeleteObject
; ===========================================================================

Obj85:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj85_Index(pc,d0.w),d0
		jmp	Obj85_Index(pc,d0.w)
; ===========================================================================
Obj85_Index:	dc.w Obj85_Main-Obj85_Index
		dc.w Obj85_Eggman-Obj85_Index
		dc.w loc_1A38E-Obj85_Index
		dc.w loc_1A346-Obj85_Index
		dc.w loc_1A2C6-Obj85_Index
		dc.w loc_1A3AC-Obj85_Index
		dc.w loc_1A264-Obj85_Index

Obj85_ObjData:	dc.w $100, $100, $470	; X pos, Y pos,	VRAM setting
		dc.l Map_obj82		; mappings pointer
		dc.w $25B0, $5A0, $300
		dc.l Map_obj84
		dc.w $26E0, $596, $3A0
		dc.l Map_FZBoss
		dc.w $26E0, $596, $470
		dc.l Map_obj82
		dc.w $26E0, $596, $400
		dc.l Map_Eggman
		dc.w $26E0, $596, $400
		dc.l Map_Eggman

Obj85_ObjData2:	dc.b 2,	0, 4, $20, $19	; routine num, animation, sprite priority, width, height
		dc.b 4,	0, 1, $12, 8
		dc.b 6,	0, 3, 0, 0
		dc.b 8,	0, 3, 0, 0
		dc.b $A, 0, 3, $20, $20
		dc.b $C, 0, 3, 0, 0
; ===========================================================================

Obj85_Main:				; XREF: Obj85_Index
		move.b	#3,(CameraShake_Intensity).w	; start the boss with reduced camera shake intensity

		lea	Obj85_ObjData(pc),a2
		lea	Obj85_ObjData2(pc),a3
		movea.l	a0,a1
		moveq	#5,d1
		bra.s	Obj85_LoadBoss
; ===========================================================================

Obj85_Loop:
		jsr	SingleObjLoad2
		bne.s	loc_19E20

Obj85_LoadBoss:				; XREF: Obj85_Main
		move.b	#$85,(a1)
		move.w	(a2)+,obX(a1)
		move.w	(a2)+,obY(a1)
		move.w	(a2)+,obGfx(a1)
		move.l	(a2)+,obMap(a1)
		move.b	(a3)+,obRoutine(a1)
		move.b	(a3)+,obAnim(a1)
		move.b	(a3)+,obPriority(a1)
		move.b	(a3)+,obWidth(a1)
		move.b	(a3)+,obHeight(a1)
		move.b	#4,obRender(a1)
		bset	#7,obRender(a0)
		move.l	a0,$34(a1)
		dbf	d1,Obj85_Loop

loc_19E20:
		move.w	#$E0,d0			; set song $E0
		jsr	PlaySound_Special	; fade out music

		lea	$36(a0),a2
		jsr	SingleObjLoad
		bne.s	loc_19E5A
		move.b	#$86,(a1)	; load energy ball object
		move.w	a1,(a2)
		move.l	a0,$34(a1)
		lea	$38(a0),a2
		moveq	#0,d2
		moveq	#3,d1

loc_19E3E:
		jsr	SingleObjLoad2
		bne.s	loc_19E5A
		move.w	a1,(a2)+
		move.b	#$84,(a1)	; load crushing	cylinder object
		move.l	a0,$34(a1)
		move.b	d2,obSubtype(a1)
		addq.w	#2,d2
		dbf	d1,loc_19E3E

loc_19E5A:
		move.w	#0,$34(a0)
	if LowBossHP=1
		move.b	#0,obColProp(a0)	; set number of	hits to	1
	else
		move.b	#30,obColProp(a0)	; set number of	hits to	30
	endif
		move.b	obColProp(a0),(HUD_BossHealth).w
		move.w	#-1,$30(a0)

Obj85_Eggman:				; XREF: Obj85_Index
		moveq	#0,d0
		move.b	$34(a0),d0
		move.w	off_19E80(pc,d0.w),d0
		jsr	off_19E80(pc,d0.w)
		jmp	DisplaySprite
; ===========================================================================
off_19E80:	dc.w loc_19E90-off_19E80, loc_19EA8-off_19E80
		dc.w loc_19FE6-off_19E80, loc_1A02A-off_19E80
		dc.w loc_1A074-off_19E80, loc_1A112-off_19E80
		dc.w loc_1A192-off_19E80, loc_1A1D4-off_19E80
; ===========================================================================

loc_19E90:				; XREF: off_19E80
		tst.l	PLC_Pointer
		bne.s	loc_19EA2
		cmpi.w	#$2450,($FFFFF700).w
		bcs.s	loc_19EA2
		addq.b	#2,$34(a0)
		move.w	#$9E,d0		; set song $9E
		jsr	PlaySound	; play FZ boss music

loc_19EA2:
		addq.l	#1,(CurrentRandomNumber).w
		rts	
; ===========================================================================

loc_19EA8:				; XREF: off_19E80
		tst.w	$30(a0)
		bpl.s	loc_19F10
		clr.w	$30(a0)
		jsr	(RandomNumber).l
		andi.w	#$14,d0		; changed from $C
		move.w	d0,d1
		addq.w	#2,d1
		tst.l	d0		; adds small chance for Robotnik's position in the pillars to swap
		bpl.s	loc_19EC6
		exg	d1,d0

loc_19EC6:
		lea	Obj85_PillarPossibilties_Casusal(pc),a1
		frantic
		beq.s	@0
		lea	Obj85_PillarPossibilties_Frantic(pc),a1
@0:		move.w	(a1,d0.w),d0	; the pillar Robotnik will be in
		move.w	(a1,d1.w),d1	; the other (empty) pillar
		move.w	d0,$30(a0)
		moveq	#-1,d2
		move.w	$38(a0,d0.w),d2
		movea.l	d2,a1
		move.b	#-1,$29(a1)
		move.w	#-1,$30(a1)
		move.w	$38(a0,d1.w),d2
		movea.l	d2,a1
		move.b	#1,$29(a1)
		move.w	#0,$30(a1)
		move.w	#1,$32(a0)
		clr.b	$35(a0)
		move.w	#$B7,d0
		jsr	(PlaySound_Special).l ;	play rumbling sound

		ori.b	#$FF,(CameraShake).w	; INFINITE CAMERA SHAKE HOORAY

loc_19F10:
		tst.w	$32(a0)
		bmi.w	loc_19FA6
		bclr	#0,obStatus(a0)
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcs.s	loc_19F2E
		bset	#0,obStatus(a0)

loc_19F2E:
		move.w	#$2B,d1
		move.w	#$14,d2
		move.w	#$14,d3
		move.w	obX(a0),d4
		jsr	SolidObject
		tst.w	d4
		bgt.s	loc_19F50

loc_19F48:
		tst.b	$35(a0)
		bne.w	loc_19F88
		bra.w	loc_19F96
; ===========================================================================

loc_19F50:
		addq.w	#7,(CurrentRandomNumber).w
		cmpi.b	#2,($FFFFD01C).w	; is Sonic rolling?
		bne.s	loc_19F48		; if not, branch
		move.w	#$300,d0		; bounce velocity for Sonic after hitting the capsule
		btst	#0,obStatus(a0)		; is Sonic to the left of the pillar?
		bne.s	loc_19F6A		; if not, branch
		neg.w	d0			; negate bounce direction 
loc_19F6A:	move.w	d0,($FFFFD010).w	; set bounce

		tst.b	$35(a0)			; is eggman currently invulnerable from a previous hit?
		bne.w	loc_19F88		; if yes, branch
		subq.b	#1,obColProp(a0)	; sub 1 health
		bpl.s	@0			; if it's positive, branch
		move.b	#0,obColProp(a0)	; make sure we don't underflow
@0:

		move.b	obColProp(a0),(HUD_BossHealth).w
		bsr	BossDamageSound
		moveq	#10,d0		; add 100 ...
		jsr	AddPoints	; ... points

		cmpi.b	#10,obColProp(a0)	; does eggman have exactly 10 lives now?
		bne.s	@nobosspinch		; if not, branch
		move.w	#$E2,d0
		jsr	(PlaySound_Special).l	; speed up music
		move.b	#7,(CameraShake_Intensity).w	; ramp up camera shake intensity during pinch mode
@nobosspinch:

		tst.b	obColProp(a0)	; does eggman lost all his lives?
		beq.s	Eggman_0lives	; if yes, branch
		move.b	#5,$35(a0)	; short flashing (5) - original: $65
		btst	#1,($FFFFD022).w ; is sonic on the ground?
		beq.s	loc_19F88	; if yes, branch
		move.b	#5,($FFFFFFDB).w ; set max limit
		move.w	#$1200,($FFFFF760).w ; double Sonic's speed
		move.w	#$CC,($FFFFF762).w ; dramatically increase Sonic's acceleration
		bra.s	loc_19F88	; branch the next label
		
Eggman_0lives:
		move.l	#10000,d0	; add 100000 ...
		jsr	AddPoints	; ... points
		move.b	#0,(HUD_BossHealth).w
		move.b	#1,($FFFFFE1C).w
		move.b	#$FF,$35(a0)	; long flashing, because you may not hit eggman again
	;	move.w	#$8D,d0
	;	bsr	PlaySound	; play normal fz music

loc_19F88:
		subq.b	#1,$35(a0)
		beq.s	loc_19F96
		move.b	#3,obAnim(a0)
		bra.s	loc_19F9C
; ===========================================================================

loc_19F96:
		move.b	#1,obAnim(a0)

loc_19F9C:
		lea	Ani_obj82(pc),a1
		jmp	AnimateSprite
; ===========================================================================

loc_19FA6:
		tst.b	obColProp(a0)
		beq.s	loc_19FBC
		addq.b	#2,$34(a0)
		move.w	#-1,$30(a0)
		clr.w	$32(a0)
		rts	
; ===========================================================================

loc_19FBC:
		move.b	#6,$34(a0)
		move.w	#$25C0,obX(a0)
		move.w	#$53C,obY(a0)
		move.b	#$14,obHeight(a0)
		rts	
; ===========================================================================
; possible pillar selections
; 2-based, two words each
; in order from left to right: 4, 0, 6, 2
pillar1 = 4
pillar2 = 0
pillar3 = 6
pillar4 = 2

;word_19FD6:	dc.w pillar2, pillar4
;		dc.w pillar4, pillar1
;		dc.w pillar1, pillar3
;		dc.w pillar3, pillar2

; word_19FD6:
Obj85_PillarPossibilties_Casusal:
		dc.w pillar2, pillar4
		dc.w pillar4, pillar2
		dc.w pillar4, pillar1
		dc.w pillar1, pillar3
		dc.w pillar3, pillar1
		dc.w pillar3, pillar2

Obj85_PillarPossibilties_Frantic:
		dc.w pillar1, pillar2	; 00
		dc.w pillar1, pillar3	; 04
		dc.w pillar1, pillar4	; 08
		dc.w pillar2, pillar3	; 0C
		dc.w pillar2, pillar4	; 10
		dc.w pillar3, pillar4	; 14

; ===========================================================================

loc_19FE6:				; XREF: off_19E80
		moveq	#-1,d0
		move.w	$36(a0),d0
		movea.l	d0,a1
		tst.w	$30(a0)
		bpl.s	loc_1A000
		clr.w	$30(a0)
		move.b	#-1,$29(a1)
		bsr.s	loc_1A020

loc_1A000:
		moveq	#$F,d0
		and.w	($FFFFFE0E).w,d0
		bne.s	loc_1A00A
		bsr.s	loc_1A020

loc_1A00A:
		tst.w	$32(a0)
		beq.s	locret_1A01E
		subq.b	#2,$34(a0)
		move.w	#-1,$30(a0)
		clr.w	$32(a0)

locret_1A01E:
		rts	
; ===========================================================================

loc_1A020:
		move.w	#$B1,d0
		jmp	(PlaySound_Special).l ;	play electricity sound
; ===========================================================================

loc_1A02A:				; XREF: off_19E80
		move.b	#$30,obWidth(a0)
		bset	#0,obStatus(a0)
		jsr	SpeedToPos
		move.b	#6,obFrame(a0)
		addi.w	#$10,obVelY(a0)
		cmpi.w	#$5AC,obY(a0)
		bcs.s	loc_1A070
		move.w	#$5AC,obY(a0)
		addq.b	#2,$34(a0)
		move.b	#$20,obWidth(a0)
		move.w	#$100,obVelX(a0)
		move.w	#-$100,obVelY(a0)
		addq.b	#2,($FFFFF742).w

loc_1A070:
		bra.w	loc_1A166
; ===========================================================================

loc_1A074:				; XREF: off_19E80
		bset	#0,obStatus(a0)
		move.b	#4,obAnim(a0)
		jsr	SpeedToPos
		addi.w	#$10,obVelY(a0)
		cmpi.w	#$5A3,obY(a0)
		bcs.s	loc_1A09A
		move.w	#-$40,obVelY(a0)

loc_1A09A:
		move.w	#$400,obVelX(a0)
		move.w	obX(a0),d0
		sub.w	($FFFFD008).w,d0
		bpl.s	loc_1A0B4
		move.w	#$500,obVelX(a0)
		bra.w	loc_1A0F2
; ===========================================================================

loc_1A0B4:
		subi.w	#$70,d0
		bcs.s	loc_1A0F2
		subi.w	#$100,obVelX(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$100,obVelX(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$80,obVelX(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$80,obVelX(a0)
		subq.w	#8,d0
		bcs.s	loc_1A0F2
		subi.w	#$80,obVelX(a0)
		subi.w	#$38,d0
		bcs.s	loc_1A0F2
		clr.w	obVelX(a0)

loc_1A0F2:
		cmpi.w	#$26A0,obX(a0)
		bcs.s	loc_1A110
		move.w	#$26A0,obX(a0)
		move.w	#$240,obVelX(a0)
		move.w	#-$4C0,obVelY(a0)
		addq.b	#2,$34(a0)

loc_1A110:
		bra.s	loc_1A15C
; ===========================================================================

loc_1A112:				; XREF: off_19E80
		jsr	SpeedToPos
		cmpi.w	#$26E0,obX(a0)
		bcs.s	loc_1A124
		clr.w	obVelX(a0)

loc_1A124:
		addi.w	#$34,obVelY(a0)
		tst.w	obVelY(a0)
		bmi.s	loc_1A142
		cmpi.w	#$592,obY(a0)
		bcs.s	loc_1A142
		move.w	#$592,obY(a0)
		clr.w	obVelY(a0)

loc_1A142:
		move.w	obVelX(a0),d0
		or.w	obVelY(a0),d0
		bne.s	loc_1A15C
		addq.b	#2,$34(a0)
		move.w	#-$180,obVelY(a0)
		move.b	#1,obColProp(a0)

loc_1A15C:
		lea	Ani_obj82(pc),a1
		jsr	AnimateSprite

loc_1A166:
	;	cmpi.w	#$2700,($FFFFF72A).w
	;	bge.s	loc_1A172
		move.w	#$2860,($FFFFF72A).w	; set right boundary after defeating the FZ boss

loc_1A172:
		cmpi.b	#$C,$34(a0)
		bge.s	locret_1A190
		move.w	#$1B,d1
		move.w	#$70,d2
		move.w	#$71,d3
		move.w	obX(a0),d4
		jmp	SolidObject
; ===========================================================================

locret_1A190:
		rts	
; ===========================================================================

loc_1A192:				; XREF: off_19E80
		move.l	#Map_Eggman,obMap(a0)
		move.w	#$400,obGfx(a0)
		move.b	#0,obAnim(a0)
		bset	#0,obStatus(a0)
		jsr	SpeedToPos
		cmpi.w	#$544,obY(a0)
		bcc.s	loc_1A1D0
		move.w	#$200,obVelX(a0)
		move.w	#-$18,obVelY(a0)
		move.b	#$F,obColType(a0)
		addq.b	#2,$34(a0)

loc_1A1D0:
		bra.w	loc_1A15C
; ===========================================================================

loc_1A1D4:				; XREF: off_19E80
		bset	#0,obStatus(a0)
		jsr	SpeedToPos
		tst.w	$30(a0)
		bne.s	loc_1A1FC
		tst.b	obColType(a0)
		bne.s	loc_1A216
		move.w	#$1E,$30(a0)
		bsr	BossDamageSound

loc_1A1FC:
		subq.w	#1,$30(a0)
		bne.s	loc_1A216
		tst.b	obStatus(a0)
		bpl.s	loc_1A210
		move.w	#$60,obVelY(a0)
		bra.s	loc_1A216
; ===========================================================================

loc_1A210:
		move.b	#$F,obColType(a0)

loc_1A216:
		; cutscene after hitting eggman one last time
		cmpi.w	#$27B0,($FFFFD008).w
		blt.s	loc_1A23A
		move.w	#$180,obVelX(a0)

		move.b	#1,($FFFFF7CC).w	; lock controls
		move.w	#0,($FFFFF602).w	; clear inputs
		clr.w	($FFFFD014).w		; clear inertia
		bclr	#5,($FFFFD022).w
		
		move.w	($FFFFD00C).w,d0
		cmp.w	obY(a0),d0
		blo.s	loc_1A248
		move.w	#$100,($FFFFF602).w

loc_1A23A:
		cmpi.w	#$27E0,($FFFFD008).w
		blt.s	loc_1A248
		move.w	#$27E0,($FFFFD008).w

loc_1A248:
		cmpi.w	#$2900,obX(a0)
		bcs.w	loc_1A15C

		tst.b	obRender(a0)		; has Eggman object been deleted after the crash cutscene?
		bmi.w	loc_1A15C		; if not, branch
		move.b	#0,($FFFFD000+obAniFrame).w ; reset Sonic waiting animation
		move.b	#1,(FZEscape).w		; set final sequence flag
		move.b	#0,($FFFFF7CC).w	; unlock controls
		move.w	#$E0,d0
		jsr	PlaySound		; fade out music
		bra.w	Obj85_Delete
; ===========================================================================

loc_1A264:				; XREF: Obj85_Index
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.w	Obj85_Delete
		move.b	#7,obAnim(a0)
		cmpi.b	#$C,$34(a1)
		bge.s	loc_1A280
		bra.s	loc_1A2A6
; ===========================================================================

loc_1A280:
		tst.w	obVelX(a1)
		beq.s	loc_1A28C
		move.b	#$B,obAnim(a0)

loc_1A28C:
		lea	Ani_Eggman(pc),a1
		jsr	AnimateSprite

loc_1A296:
		movea.l	$34(a0),a1
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)

loc_1A2A6:
		movea.l	$34(a0),a1
		move.b	obStatus(a1),obStatus(a0)
		moveq	#3,d0
		and.b	obStatus(a0),d0
		andi.b	#-4,obRender(a0)
		or.b	d0,obRender(a0)
		jmp	DisplaySprite
; ===========================================================================

loc_1A2C6:				; XREF: Obj85_Index
		movea.l	$34(a0),a1
		move.b	(a1),d0
		cmp.b	(a0),d0
		bne.w	Obj85_Delete
		cmpi.l	#Map_Eggman,obMap(a1)
		beq.s	loc_1A2E4
		move.b	#$A,obFrame(a0)
		bra.s	loc_1A2A6
; ===========================================================================

loc_1A2E4:
		cmpi.w 	#$27A0, obX(a0)
		blt.s	@NoFall

		cmpi.w 	#$0600, obY(a0)
		bge.s	@Crash

		jsr	ObjectFall
		subi.w 	#$35, obVelY(a0)
		jsr	SpeedToPos

		; move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		bra.s 	@NoFall

@Crash:
		move.b 	#$B9,d0
		jsr	PlaySound_Special

		jsr	WhiteFlash2
		jsr	DeleteObject

@NoFall:
		move.b	#1,obAnim(a0)
		tst.b	obColProp(a1)
		ble.s	loc_1A312
		move.b	#6,obAnim(a0)
		move.l	#Map_Eggman,obMap(a0)
		move.w	#$400,obGfx(a0)
		lea	Ani_Eggman(pc),a1
		jsr	AnimateSprite
		bra.w	loc_1A296
; ===========================================================================

loc_1A312:
	;	tst.b	obRender(a0)
	;	bpl.w	Obj85_Delete
		bsr	BossDefeated
		ori.b	#10,(CameraShake).w		; camera shaking
		move.b	#2,obPriority(a0)
		move.b	#0,obAnim(a0)
		move.l	#Map_Eggman2,obMap(a0)
		move.w	#$3A0,obGfx(a0)
		lea	Ani_obj85(pc),a1
		jsr	AnimateSprite
		bra.w	loc_1A296
; ===========================================================================

loc_1A346:				; XREF: Obj85_Index
		bset	#0,obStatus(a0)
		movea.l	$34(a0),a1
		cmpi.l	#Map_Eggman,obMap(a1)
		beq.s	loc_1A35E
		bra.w	loc_1A2A6
; ===========================================================================

loc_1A35E:
		move.w	obX(a1),obX(a0)
		move.w	obY(a1),obY(a0)
		tst.b	obTimeFrame(a0)
		bne.s	loc_1A376
		move.b	#$14,obTimeFrame(a0)

loc_1A376:
		subq.b	#1,obTimeFrame(a0)
		bgt.s	loc_1A38A
		addq.b	#1,obFrame(a0)
		cmpi.b	#2,obFrame(a0)
		bgt.w	Obj85_Delete

loc_1A38A:
		bra.w	loc_1A296
; ===========================================================================

loc_1A38E:				; XREF: Obj85_Index
		move.b	#$B,obFrame(a0)
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bcs.s	loc_1A3A6
		tst.b	obRender(a0)
		bpl.w	Obj85_Delete

loc_1A3A6:
		jmp	DisplaySprite
; ===========================================================================

loc_1A3AC:				; XREF: Obj85_Index
		move.b	#0,obFrame(a0)
		bset	#0,obStatus(a0)
		movea.l	$34(a0),a1
		cmpi.b	#$C,$34(a1)
		bne.s	loc_1A3D0
		cmpi.l	#Map_Eggman,obMap(a1)
		beq.w	Obj85_Delete

loc_1A3D0:
		bra.w	loc_1A2A6
; ===========================================================================
Ani_obj85:
		include	"_anim\obj85.asm"

Map_Eggman2:
		include	"_maps\Eggman2.asm"

Map_FZBoss:
		include	"_maps\FZ boss.asm"

; ===========================================================================

Obj84_Delete:
		jmp	DeleteObject
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 84 - cylinder Eggman	hides in (FZ)
; ---------------------------------------------------------------------------

Obj84:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj84_Index(pc,d0.w),d0
		jmp	Obj84_Index(pc,d0.w)
; ===========================================================================
Obj84_Index:	dc.w Obj84_Main-Obj84_Index
		dc.w loc_1A4CE-Obj84_Index
		dc.w loc_1A57E-Obj84_Index

Obj84_PosData:	dc.w $24D0, $620
		dc.w $2550, $620
		dc.w $2490, $4C0
		dc.w $2510, $4C0
; ===========================================================================

Obj84_Main:				; XREF: Obj84_Index
		lea	Obj84_PosData(pc),a1
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		add.w	d0,d0
		adda.w	d0,a1
		move.b	#4,obRender(a0)
		bset	#7,obRender(a0)
		bset	#4,obRender(a0)
		move.w	#$300,obGfx(a0)
		move.l	#Map_obj84,obMap(a0)
		move.w	(a1)+,obX(a0)
		move.w	(a1),obY(a0)
		move.w	(a1)+,$38(a0)
		move.b	#$20,obHeight(a0)
		move.b	#$60,obWidth(a0)
		move.b	#$20,obActWid(a0)
		move.b	#$60,obHeight(a0)
		move.b	#1,obPriority(a0)
		addq.b	#2,obRoutine(a0)

loc_1A4CE:				; XREF: Obj84_Index
		cmpi.b	#2,obSubtype(a0)
		ble.s	loc_1A4DC
		bset	#1,obRender(a0)

loc_1A4DC:
		clr.l	$3C(a0)
		tst.b	$29(a0)
		beq.s	loc_1A4EA
		addq.b	#2,obRoutine(a0)

loc_1A4EA:
		move.l	$3C(a0),d0
		move.l	$38(a0),d1
		add.l	d0,d1
		swap	d1
		move.w	d1,obY(a0)
		cmpi.b	#4,obRoutine(a0)
		bne.s	loc_1A524
		tst.w	$30(a0)
		bpl.s	loc_1A524
		moveq	#-$A,d0
		cmpi.b	#2,obSubtype(a0)
		ble.s	loc_1A514
		moveq	#$E,d0

loc_1A514:
		add.w	d0,d1
		movea.l	$34(a0),a1
		move.w	d1,obY(a1)
		move.w	obX(a0),obX(a1)

loc_1A524:
		move.w	#$2B,d1
		move.w	#$60,d2
		move.w	#$61,d3
		move.w	obX(a0),d4
		jsr	SolidObject
		moveq	#0,d0
		move.w	$3C(a0),d1
		bpl.s	loc_1A550
		neg.w	d1
		subq.w	#8,d1
		bcs.s	loc_1A55C
		addq.b	#1,d0
		asr.w	#4,d1
		add.w	d1,d0
		bra.s	loc_1A55C
; ===========================================================================

loc_1A550:
		subi.w	#$27,d1
		bcs.s	loc_1A55C
		addq.b	#1,d0
		asr.w	#4,d1
		add.w	d1,d0

loc_1A55C:
		move.b	d0,obFrame(a0)
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bmi.s	loc_1A578
		subi.w	#$140,d0
		bmi.s	loc_1A578
		tst.b	obRender(a0)
		bpl.w	Obj84_Delete

loc_1A578:
		jmp	DisplaySprite
; ===========================================================================

loc_1A57E:				; XREF: Obj84_Index
		cmpi.b	#10,(HUD_BossHealth).w
		bgt.s	@cont
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		move.w	off2_1A590(pc,d0.w),d0
		jsr	off2_1A590(pc,d0.w)
		bra.w	loc_1A4EA

@cont:
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		move.w	off_1A590(pc,d0.w),d0
		jsr	off_1A590(pc,d0.w)
		bra.w	loc_1A4EA
; ===========================================================================
off_1A590:	dc.w loc_1A598-off_1A590
		dc.w loc_1A598-off_1A590
		dc.w loc_1A604-off_1A590
		dc.w loc_1A604-off_1A590

off2_1A590:	dc.w loc2_1A598-off2_1A590
		dc.w loc2_1A598-off2_1A590
		dc.w loc2_1A604-off2_1A590
		dc.w loc2_1A604-off2_1A590
; ===========================================================================

loc_1A598:				; XREF: off_1A590
		tst.b	$29(a0)
		bne.s	loc_1A5D4
		movea.l	$34(a0),a1
		tst.b	obColProp(a1)
		bne.s	loc_1A5B4
		bsr	BossDefeated
		subi.l	#$10000,$3C(a0)

loc_1A5B4:
		addi.l	#$20000,$3C(a0)
		bcc.s	locret_1A602
		clr.l	$3C(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)
		clr.w	$30(a1)
		subq.b	#2,obRoutine(a0)
		rts	
; ===========================================================================

loc_1A5D4:
		cmpi.w	#-$10,$3C(a0)
		bge.s	loc_1A5E4
		subi.l	#$28000,$3C(a0)

loc_1A5E4:
		subi.l	#$8000,$3C(a0)
		cmpi.w	#-$A0,$3C(a0)
		bgt.s	locret_1A602
		clr.w	$3E(a0)
		move.w	#-$A0,$3C(a0)
		clr.b	$29(a0)

locret_1A602:
		rts	
; ===========================================================================

loc_1A604:				; XREF: off_1A590
		bset	#1,obRender(a0)
		tst.b	$29(a0)
		bne.s	loc_1A646
		movea.l	$34(a0),a1
		tst.b	obColProp(a1)
		bne.s	loc_1A626
		bsr	BossDefeated
		addi.l	#$10000,$3C(a0)

loc_1A626:
		subi.l	#$20000,$3C(a0)
		bcc.s	locret_1A674
		clr.l	$3C(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)
		clr.w	$30(a1)
		subq.b	#2,obRoutine(a0)
		rts	
; ===========================================================================

loc_1A646:
		cmpi.w	#$10,$3C(a0)
		blt.s	loc_1A656
		addi.l	#$28000,$3C(a0)

loc_1A656:
		addi.l	#$8000,$3C(a0)
		cmpi.w	#$A0,$3C(a0)
		blt.s	locret_1A674
		clr.w	$3E(a0)
		move.w	#$A0,$3C(a0)
		clr.b	$29(a0)

locret_1A674:
		rts	
; ===========================================================================
; ===========================================================================
; ===========================================================================
FZpinch = $8000

loc2_1A598:				; XREF: off_1A590
		tst.b	$29(a0)
		bne.s	loc2_1A5D4
		movea.l	$34(a0),a1
		tst.b	obColProp(a1)
		bne.s	loc2_1A5B4
		bsr	BossDefeated
		subi.l	#$10000+FZpinch,$3C(a0)

loc2_1A5B4:
		addi.l	#$20000+FZpinch,$3C(a0)
		bcc.s	locret2_1A602
		clr.l	$3C(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)
		clr.w	$30(a1)
		subq.b	#2,obRoutine(a0)
		rts	
; ===========================================================================

loc2_1A5D4:
		cmpi.w	#-$10,$3C(a0)
		bge.s	loc2_1A5E4
		subi.l	#$28000+FZpinch,$3C(a0)

loc2_1A5E4:
		subi.l	#$8000+FZpinch,$3C(a0)
		cmpi.w	#-$A0,$3C(a0)
		bgt.s	locret2_1A602
		clr.w	$3E(a0)
		move.w	#-$A0,$3C(a0)
		clr.b	$29(a0)

locret2_1A602:
		rts	
; ===========================================================================
BossDefeatedX:
		move.b	($FFFFFE05).w,d0
		andi.b	#7,d0
		bne.s	xlocret_178A2x
		jsr	SingleObjLoad
		bne.s	xlocret_178A2x
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		move.b	#2,obRoutine(a1)
		jsr	(RandomNumber).l
		move.w	d0,d1
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,obY(a1)

xlocret_178A2x:
		rts

loc2_1A604:				; XREF: off_1A590
		bset	#1,obRender(a0)
		tst.b	$29(a0)
		bne.s	loc2_1A646
		movea.l	$34(a0),a1
		tst.b	obColProp(a1)
		bne.s	loc2_1A626
		bsr	BossDefeatedX
		addi.l	#$10000+FZpinch,$3C(a0)

loc2_1A626:
		subi.l	#$20000+FZpinch,$3C(a0)
		bcc.s	locret2_1A674
		clr.l	$3C(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)
		clr.w	$30(a1)
		subq.b	#2,obRoutine(a0)
		rts	
; ===========================================================================

loc2_1A646:
		cmpi.w	#$10,$3C(a0)
		blt.s	loc2_1A656
		addi.l	#$28000+FZpinch,$3C(a0)

loc2_1A656:
		addi.l	#$8000+FZpinch,$3C(a0)
		cmpi.w	#$A0,$3C(a0)
		blt.s	locret2_1A674
		clr.w	$3E(a0)
		move.w	#$A0,$3C(a0)
		clr.b	$29(a0)

locret2_1A674:
		rts	



; ===========================================================================
; ---------------------------------------------------------------------------
; Sprite mappings - cylinders Eggman hides in (FZ)
; ---------------------------------------------------------------------------
Map_obj84:
		include	"_maps\obj84.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 86 - energy balls (FZ)
; ---------------------------------------------------------------------------

Obj86:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj86_Index(pc,d0.w),d0
		jmp	Obj86_Index(pc,d0.w)
; ===========================================================================
Obj86_Index:	dc.w Obj86_Main-Obj86_Index
		dc.w Obj86_Generator-Obj86_Index
		dc.w Obj86_MakeBalls-Obj86_Index
		dc.w loc_1A962-Obj86_Index
		dc.w Obj86_Ball-Obj86_Index
; ===========================================================================

Obj86_Main:				; XREF: Obj86_Index
		move.w	#$2588,obX(a0)
		move.w	#$538,obY(a0)
		move.w	#$300,obGfx(a0)
		move.l	#Map_obj86,obMap(a0)
		move.b	#0,obAnim(a0)
		move.b	#5,obPriority(a0)
		move.b	#8,obWidth(a0)
		move.b	#8,obHeight(a0)
		move.b	#4,obRender(a0)
		bset	#7,obRender(a0)
		addq.b	#2,obRoutine(a0)

Obj86_Generator:			; XREF: Obj86_Index
		; spawn bonus explosions in pinch mode
		cmpi.b	#10,(HUD_BossHealth).w
		bhi.s	@Continue
		move.b	($FFFFFE05).w,d0
		andi.b 	#%00001111,d0
		tst.b 	d0
		bne.s 	@Continue
		jsr	SingleObjLoad
		bne.s	@Continue
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)

@Continue:
		; light generator fall effect after boss is defeated
		cmpi.b 	#$0A, ($FFFFF742).w ; check resize subroutine
		bne.s 	@NoFall
	;	move.b	#$E,obColType(a0) ; breakable
		move.b	#0,obColType(a0) ; not breakable (must hit the saw or post boss graphics won't load)
		jsr	ObjectFall
		sub.w 	#$10,obVelY(a0)
		jsr	SpeedToPos
@NoFall:
		movea.l	$34(a0),a1
		cmpi.w	#$5C0,obY(a0)
		blt.w	loc_1A850

@ExplodeGenerator:
		move.b	#$3F,0(a0)	; load explosion object
		move.b	#0,obRoutine(a0)
		move.b	#0,$31(a0)

		lea	($FFFFD800).w,a1
		moveq	#$3F,d0
@deletesaw:	cmpi.b	#$6A,(a1)		; is current object the sawblade?
		bne.s	@cont			; if not, branch
		move.b	#4,obRoutine(a1)	; set to post boss routine
		bra.s	@end
@cont:		lea	$40(a1),a1
		dbf	d0,@deletesaw
@end:
		rts
; ===========================================================================

loc_1A850:
	;	move.b	#0,obAnim(a0)
		tst.b	$29(a0)
		beq.s	loc_1A86C
		addq.b	#2,obRoutine(a0)
		move.b	#1,obAnim(a0)
		move.b	#$3E,obSubtype(a0)

loc_1A86C:
		move.w	#$13,d1
		move.w	#8,d2
		move.w	#$11,d3
		move.w	obX(a0),d4
		jsr	SolidObject
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
		bmi.s	loc_1A89A
		subi.w	#$140,d0
		bmi.s	loc_1A89A
		tst.b	obRender(a0)
		bpl.w	Obj84_Delete

loc_1A89A:
		lea	Ani_obj86(pc),a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================

Obj86_MakeBalls:			; XREF: Obj86_Index
		tst.b	$29(a0)
		beq.w	loc_1A954
		clr.b	$29(a0)
		add.w	$30(a0),d0
		andi.w	#$1E,d0
		adda.w	d0,a2
		addq.w	#4,$30(a0)
		clr.w	$32(a0)
		moveq	#3,d2

Obj86_Loop:
		; load 4 energy balls
		jsr	SingleObjLoad2
		bne.w	loc_1A954
		move.b	#$86,(a1)
		move.w	obX(a0),obX(a1)
		move.w	#$53C,obY(a1)
		move.b	#8,obRoutine(a1)
		move.w	#$2300,obGfx(a1)
		move.l	#Map_obj86a,obMap(a1)
		move.b	#$C,obHeight(a1)
		move.b	#$C,obWidth(a1)
		move.b	#0,obColType(a1)
		move.b	#5,obPriority(a1)
		move.w	#$3E,obSubtype(a1)
		move.b	#4,obRender(a1)
		bset	#7,obRender(a1)
		move.l	a0,$34(a1)
		jsr	(RandomNumber).l
		move.w	$32(a0),d1
		muls.w	#-$59,d1	; horizontal spacing for ammount of balls (3=6F, 4=4F, 5=3F, 6=2F)
		addi.w	#$2578,d1
		andi.w	#$1F,d0
		subi.w	#$10,d0
		add.w	d1,d0

		btst	#0,d2
		beq.s	@noanimoffset
		addq.b	#1,obAniFrame(a1)
@noanimoffset:

		; limit energy balls to stay on screen horizontally, cause if one ever spawns offscreen the game will softlock
		; (not my bug, blame Sega)
		cmpi.w	#$2480,d0	; left boundary
		bhs.s	@0
		move.w	#$2480,d0
@0:		cmpi.w	#$2570,d0	; right boundary
		bls.s	@1
		move.w	#$2570,d0
@1:

		move.w	d0,$30(a1)	; target X pos of energy ball
		
		addq.w	#1,$32(a0)
		move.w	$32(a0),$38(a0)
		dbf	d2,Obj86_Loop	; repeat sequence 3 more times

loc_1A954:
		tst.w	$32(a0)
		bne.s	loc_1A95E
		addq.b	#2,obRoutine(a0)

loc_1A95E:
		bra.w	loc_1A86C
; ===========================================================================

loc_1A962:				; XREF: Obj86_Index
		move.b	#2,obAnim(a0)
	;	tst.w	$38(a0)
	;	bne.s	loc_1A97E
		move.b	#2,obRoutine(a0)
		movea.l	$34(a0),a1
		move.w	#-1,$32(a1)

loc_1A97E:
		bra.w	loc_1A86C
; ===========================================================================

Obj86_Ball:				; XREF: Obj86_Index
		moveq	#0,d0
		move.b	ob2ndRout(a0),d0
		move.w	Obj86_Index2(pc,d0.w),d0
		jsr	obj86_Index2(pc,d0.w)
		lea	Ani_obj86a(pc),a1
		jsr	AnimateSprite
		jmp	DisplaySprite
; ===========================================================================
Obj86_Index2:	dc.w loc_1A9A6-Obj86_Index2
		dc.w loc_1A9C0-Obj86_Index2
		dc.w loc_1AA1E-Obj86_Index2
; ===========================================================================

loc_1A9A6:				; XREF: Obj86_Index2
		addq.b	#2,ob2ndRout(a0)

		move.w	#180,obSubtype(a0)	; time limit before ball falls
		cmpi.b	#10,(HUD_BossHealth).w	; are we in pinch mode?
		bhi.s	@nopinch		; if not, branch
		subi.w	#45,obSubtype(a0)	; make balls fall faster during pinch (mostly done to avoid sprite flicker)

@nopinch:
		move.w	$30(a0),d0
		sub.w	obX(a0),d0
		asl.w	#4,d0
		move.w	d0,obVelX(a0)
		move.w	d0,$38(a0)
		move.w	obY(a0),$3A(a0)
		rts	
; ===========================================================================

loc_1A9C0:				; XREF: Obj86_Index2
		tst.w	obVelX(a0)
		beq.s	loc_1A9E6
		jsr	SpeedToPos
		move.w	obX(a0),d0
		sub.w	$30(a0),d0
		bcc.s	loc_1A9E6
		clr.w	obVelX(a0)
		sub.w	d0,obX(a0)
		movea.l	$34(a0),a1
		subq.w	#1,$32(a1)

loc_1A9E6:
		; sway
		moveq	#1,d2			; regular sway speed
		cmpi.b	#10,(HUD_BossHealth).w	; are we in pinch mode?
		bhi.s	@0			; if not, branch
		moveq	#3,d2			; pinch mode sway speed
@0:
		move.w	($FFFFFE04).w,d0
		add.w	obX(a0),d0
		lsl.w	d2,d0
		jsr	(CalcSine).l

		asr.w	#5,d0
		add.w	$3A(a0),d0
		move.w	d0,obY(a0)

		move.b	#0,obAnim(a0)
		subq.w	#1,obSubtype(a0)
		bne.s	locret_1AA1C
		addq.b	#2,ob2ndRout(a0)

		move.b	#1,obAnim(a0)
		move.b	#$9A,obColType(a0)
		move.w	#$B4,obSubtype(a0)
		moveq	#0,d0
		move.w	($FFFFD008).w,d0
		sub.w	obX(a0),d0
	;	move.w	d0,obVelX(a0)
	;	move.w	#$240,obVelY(a0)
		move.w	#$50,obVelY(a0)

locret_1AA1C:
		rts	
; ===========================================================================

loc_1AA1E:				; XREF: Obj86_Index2
		jsr	ObjectFall
		jsr	SpeedToPos
		cmpi.w	#$5C0,obY(a0)
		blt.s	Obj86_DoNothing

		move.b	#$C4,d0				; load boost SFX
		jsr	PlaySound_Special		; play boost SFX
		jsr	SingleObjLoad
		bne.s	Obj86_NoExplode
		move.b	#$3F,0(a1)			; change bomb into an explosion
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)

Obj86_NoExplode:
		movea.l	$34(a0),a1
		subq.w	#1,$38(a1)
		bra.w	Obj84_Delete

Obj86_DoNothing:
		rts
; ===========================================================================
Ani_obj86:
		include	"_anim\obj86.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - energy ball	launcher (FZ)
; ---------------------------------------------------------------------------
Map_obj86:
		include	"_maps\obj86.asm"

Ani_obj86a:
		include	"_anim\obj86a.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - energy balls (FZ)
; ---------------------------------------------------------------------------
Map_obj86a:
		include	"_maps\obj86a.asm"

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 3E - prison capsule
; ---------------------------------------------------------------------------

Obj3E:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj3E_Index(pc,d0.w),d1
		jsr	obj3E_Index(pc,d1.w)
		move.w	obX(a0),d0
		andi.w	#$FF80,d0
		move.w	($FFFFF700).w,d1
		subi.w	#$80,d1
		andi.w	#$FF80,d1
		sub.w	d1,d0
		cmpi.w	#$280,d0
		bhi.s	Obj3E_Delete
		jmp	DisplaySprite
; ===========================================================================

Obj3E_Delete:
		jmp	DeleteObject
; ===========================================================================
Obj3E_Index:	dc.w Obj3E_Main-Obj3E_Index		; 0
		dc.w Obj3E_BodyMain-Obj3E_Index		; 2
		dc.w Obj3E_Switched-Obj3E_Index		; 4
		dc.w Obj3E_Explosion-Obj3E_Index	; 6
		dc.w Obj3E_Explosion-Obj3E_Index	; 8
		dc.w Obj3E_Explosion-Obj3E_Index	; A
		dc.w Obj3E_Nuke-Obj3E_Index		; C
		dc.w Obj3E_EndAct-Obj3E_Index		; E

Obj3E_Var:	dc.b 2,	$20, 4,	0	; routine, width, priority, frame
		dc.b 4,	$C, 5, 1
		dc.b 6,	$10, 4,	3
		dc.b 8,	$10, 3,	5
; ===========================================================================

Obj3E_Main:				; XREF: Obj3E_Index
		move.l	#Map_obj3E,obMap(a0)
		move.w	#$6000/$20,obGfx(a0)
		move.b	#4,obRender(a0)
		move.w	obY(a0),$30(a0)
		moveq	#0,d0
		move.b	obSubtype(a0),d0
		lsl.w	#2,d0
		lea	Obj3E_Var(pc,d0.w),a1
		move.b	(a1)+,obRoutine(a0)
		move.b	(a1)+,obActWid(a0)
		move.b	(a1)+,obPriority(a0)
		move.b	(a1)+,obFrame(a0)
		cmpi.w	#8,d0		; is object type number	02?
		bne.s	Obj3E_Not02	; if not, branch
		move.b	#6,obColType(a0)
		move.b	#8,obColProp(a0)

Obj3E_Not02:
		rts	
; ===========================================================================

Obj3E_BodyMain:				; XREF: Obj3E_Index
		cmpi.b	#2,($FFFFF7A7).w
		beq.s	Obj3E_ChkOpened
		move.w	#43,d1		; width
		move.w	#24*3-8,d2	; height / 2 (when jumping)
		move.w	#24*3-8,d3	; height / 2 (when walking)
		move.w	obX(a0),d4	; x-axis position
		jmp	SolidObject
; ===========================================================================

Obj3E_ChkOpened:
		tst.b	ob2ndRout(a0)		; has the prison been opened?
		beq.s	Obj3E_DoOpen	; if yes, branch
		clr.b	ob2ndRout(a0)
		bclr	#3,($FFFFD022).w
		bset	#1,($FFFFD022).w

Obj3E_DoOpen:
		move.b	#2,obFrame(a0)	; use frame number 2 (destroyed	prison)
		rts	
; ===========================================================================

Obj3E_Switched:				; XREF: Obj3E_Index
		move.w	#$17,d1
		move.w	#8,d2
		move.w	#8,d3
		move.w	obX(a0),d4
		jsr	SolidObject
		lea	(Ani_obj3E).l,a1
		jsr	AnimateSprite
		move.w	$30(a0),obY(a0)
		tst.b	ob2ndRout(a0)
		beq.s	locret_1AC60
		
		addq.w	#8,obY(a0)
		move.b	#$A,obRoutine(a0)
		move.w	#$3C,obTimeFrame(a0)
	;	move.b	#1,($FFFFFFA5).w	; move HUD off screen (and start FZEscape sequence)
		clr.b	ob2ndRout(a0)
		bclr	#3,($FFFFD022).w
		bset	#1,($FFFFD022).w

locret_1AC60:
		rts	
; ===========================================================================

Obj3E_Explosion:			; XREF: Obj3E_Index
		moveq	#7,d0
		and.b	($FFFFFE05).w,d0
		bne.s	loc_1ACA0
		jsr	SingleObjLoad
		bne.s	loc_1ACA0
		move.b	#$3F,0(a1)	; load explosion object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)
		move.b	#1,$30(a1)
		move.b	#0,$31(a1)
		jsr	(RandomNumber).l
		moveq	#0,d1
		move.b	d0,d1
		lsr.b	#2,d1
		subi.w	#$20,d1
		add.w	d1,obX(a1)
		lsr.w	#8,d0
		lsr.b	#3,d0
		add.w	d0,obY(a1)

loc_1ACA0:
		subq.w	#1,obTimeFrame(a0)
		beq.s	Obj3E_MakeNuke
		rts	
; ===========================================================================

Obj3E_MakeNuke:
		move.b	#2,($FFFFF7A7).w
		move.b	#$C,obRoutine(a0)
		move.b	#6,obFrame(a0)
		addi.w	#$20,obY(a0)
		
		; load nuke object
		jsr	SingleObjLoad
		bne.s	locret_1ACF8
		move.b	#$81,0(a1)
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

locret_1ACF8:
		rts	
; ===========================================================================

Obj3E_Nuke:				; XREF: Obj3E_Index
Obj3E_EndAct:				; XREF: Obj3E_Index
		rts
; ===========================================================================

Ani_obj3E:	include	"_anim\obj3E.asm"
Map_obj3E:	include	"_maps\obj3E.asm"
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 81 - Nuke.
; ---------------------------------------------------------------------------

Obj81:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj81_Index(pc,d0.w),d1
		jmp	Obj81_Index(pc,d1.w)
; ===========================================================================
Obj81_Index:	dc.w Obj81_Init-Obj81_Index
		dc.w Obj81_Wait-Obj81_Index
		dc.w Obj81_FlyUp-Obj81_Index
		dc.w Obj81_FlyDown-Obj81_Index
		dc.w Obj81_FlyUp2-Obj81_Index
		dc.w Obj81_Boom-Obj81_Index
; ===========================================================================

Obj81_Init:				; XREF: Obj81_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_Obj81,obMap(a0)
		move.w	#$2000|($8000/$20),obGfx(a0)
		ori.b	#$94,obRender(a0)
		move.b	#6,obPriority(a0)
		move.b	#0,obFrame(a0)
		move.b  #0,obAnim(a0)
		move.b	#$40,obHeight(a0)

		clr.w	obVelY(a0)
		move.w	#2*60,$30(a0)	; start delay
; ---------------------------------------------------------------------------

Obj81_Wait:
		subq.w	#1,$30(a0)		; sub 1 from sequence time limit
		bne.s	@display		; if time remains, branch

		addq.b	#2,obRoutine(a0)	; start movement
		jsr	SingleObjLoad
		bne.s	@display
		move.b	#$6D,(a1)		; load flamethrower object
		move.l	a0,$30(a1)		; set parent

@display:
		jmp	DisplaySprite
; ===========================================================================

Obj81_FlyUp:
		subi.w	#3,obVelY(a0)
		cmpi.w	#-$E0,obVelY(a0)
		bgt.s	Obj81_Move
		addq.b	#2,obRoutine(a0)	; move down
		bra.s	Obj81_Move
; ---------------------------------------------------------------------------
Obj81_FlyDown:
		addi.w	#3,obVelY(a0)
		cmpi.w	#$F0,obVelY(a0)
		blt.s	Obj81_Move
		addq.b	#2,obRoutine(a0)	; move up again
		bra.s	Obj81_Move
; ---------------------------------------------------------------------------
Obj81_FlyUp2:
		subi.w	#$30,obVelY(a0)
		cmpi.w	#$400,obY(a0)
		bhi.s	Obj81_Move
		addq.b	#2,obRoutine(a0)	; boom
; ---------------------------------------------------------------------------

Obj81_Move:
		jsr	SpeedToPos
		jmp	DisplaySprite
		
; ===========================================================================
		
Obj81_Boom:
		move.b	#1,($FFFFFFA5).w	; move HUD off screen (and start FZEscape sequence)
		move.w	#$DB,d0			; play medium boom sound
		jsr	PlaySound
		jsr	WhiteFlash2		; mini flash
		jmp	DeleteObject

; ---------------------------------------------------------------------------
Map_obj81:	include	"_maps\Nuke.asm"
; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Object 6D - Flamethrower attached to the Nuke
; ---------------------------------------------------------------------------

Obj6D:					; XREF: Obj_Index
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj6D_Index(pc,d0.w),d1
		jmp	Obj6D_Index(pc,d1.w)
; ===========================================================================
Obj6D_Index:	dc.w Obj6D_Main-Obj6D_Index
		dc.w Obj6D_Action-Obj6D_Index
; ===========================================================================

Obj6D_Main:				; XREF: Obj6D_Index
		addq.b	#2,obRoutine(a0)
		move.l	#Map_obj6D,obMap(a0)
		move.w	#($5A00/$20),obGfx(a0)
		ori.b	#$94,obRender(a0)
		move.b	#7,obPriority(a0)	; behind the nuke
		move.b	#$40,obHeight(a0)

Obj6D_Action:				; XREF: Obj6D_Index
		move.w	($FFFFFE04).w,d0	; get frame counter
		andi.w	#$F,d0			; every 16 frames
		bne.s	@updatepos		; if not, branch
		move.w	#$C8,d0			; play...
		jsr	PlaySound		; ...flamethrower sound

@updatepos:
		movea.l	$30(a0),a1		; get nuke parent object
		cmpi.b	#$81,(a1)		; does it still exist?
		bne.s	@delete			; if not, delete flamethrower too

		move.w	obX(a1),obX(a0)		; update flamethrower X pos

		move.w	obY(a1),d0		; get nuke Y pos
		addi.w	#$44,d0			; adjust
		move.w	d0,obY(a0)		; update flamethrower Y pos

		; sprite
		move.b	obRoutine(a1),d1
		cmpi.b	#4,d1
		blo.s	@display
		cmpi.b	#8,d1
		bhs.s	@flyup2

		moveq	#3,d0
		bra.s	@flicker

@flyup2:	moveq	#9,d0

@flicker:
		btst	#1,($FFFFFE05).w
		beq.s	@display
		addq.b	#1,d0
@display:	move.b	d0,obFrame(a0)
		jmp	DisplaySprite

@delete:
		jmp	DeleteObject

; ---------------------------------------------------------------------------
Map_obj6D:	include	"_maps\obj6D.asm"
; ---------------------------------------------------------------------------
; ===========================================================================


; ---------------------------------------------------------------------------
; Object touch response	subroutine - obColType(a0) in	the object RAM
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


TouchResponse:	; Touch_Response:		; XREF: Obj01
		nop	
		move.w	obX(a0),d2	; load Sonic's x-axis value
		move.w	obY(a0),d3	; load Sonic's y-axis value
		subq.w	#8,d2
		moveq	#0,d5
		move.b	obHeight(a0),d5	; load Sonic's height
		subq.b	#3,d5
		sub.w	d5,d3
		cmpi.b	#$39,obFrame(a0)	; is Sonic ducking?
		bne.s	Touch_NoDuck	; if not, branch
		addi.w	#$C,d3
		moveq	#$A,d5

Touch_NoDuck:
		move.w	#$10,d4
		add.w	d5,d5
		lea	($FFFFD800).w,a1 ; begin checking the object RAM
		move.w	#$5F,d6

Touch_Loop:
		tst.b	obRender(a1)
		bpl.s	Touch_NextObj
		move.b	obColType(a1),d0	; load touch response number
		bne.s	Touch_Height	; if touch response is not 0, branch

Touch_NextObj:
		lea	$40(a1),a1	; next object RAM
		dbf	d6,Touch_Loop	; repeat $5F more times

		moveq	#0,d0
		rts	
; ===========================================================================
Touch_Sizes:	dc.b  $14, $14		; width, height
		dc.b   $C, $14
		dc.b  $14,  $C
		dc.b	4, $10
		dc.b   $C, $12
		dc.b  $10, $10
		dc.b	6,   6
		dc.b  $18,  $C
		dc.b   $C, $10
		dc.b  $10,  $C
		dc.b	8,   8
		dc.b  $14, $10
		dc.b  $14,   8
		dc.b   $E,  $E
		dc.b  $18, $18
		dc.b  $28, $10
		dc.b  $10, $18
		dc.b	8, $10
		dc.b  $20, $70
		dc.b  $40, $20
		dc.b  $80, $20
		dc.b  $20, $20
		dc.b	8,   8
		dc.b	4,   4
		dc.b  $20,   8
		dc.b   $C,  $C
		dc.b	8,   4
		dc.b  $18,   4
		dc.b  $28,   4
		dc.b	4,   8
		dc.b	4, $18
		dc.b	4, $28
		dc.b	4, $20
		dc.b  $18, $18
		dc.b   $C, $18
		dc.b  $48,   8
; ===========================================================================

Touch_Height:				; XREF: TouchResponse
		andi.w	#$3F,d0
		add.w	d0,d0
		lea	Touch_Sizes-obGfx(pc,d0.w),a2
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	obX(a1),d0
		sub.w	d1,d0
		sub.w	d2,d0
		bcc.s	loc_1AE98
		add.w	d1,d1
		add.w	d1,d0
		bcs.s	Touch_Width
		bra.w	Touch_NextObj
; ===========================================================================

loc_1AE98:
		cmp.w	d4,d0
		bhi.w	Touch_NextObj

Touch_Width:
		moveq	#0,d1
		move.b	(a2)+,d1
		move.w	obY(a1),d0
		sub.w	d1,d0
		sub.w	d3,d0
		bcc.s	loc_1AEB6
		add.w	d1,d1
		add.w	d0,d1
		bcs.s	Touch_ChkValue
		bra.w	Touch_NextObj
; ===========================================================================

loc_1AEB6:
		cmp.w	d5,d0
		bhi.w	Touch_NextObj

Touch_ChkValue:
		tst.b	obColType(a1)
		beq.s	locret_1AEF2
		move.b	obColType(a1),d1	; load touch response number
		andi.b	#$C0,d1		; is touch response $40	or higher?
		beq.w	Touch_Enemy	; if not, branch
		cmpi.b	#$C0,d1		; is touch response $C0	or higher?
		beq.w	Touch_Special	; if yes, branch
		tst.b	d1		; is touch response $80-$BF ?
		bmi.w	Touch_ChkHurt	; if yes, branch

; touch	response is $40-$7F

		move.b	obColType(a1),d0
		andi.b	#$3F,d0
		cmpi.b	#6,d0
		beq.s	Touch_Monitor
		cmpi.w	#$5A,$30(a0)
		bcc.w	locret_1AEF2
		addq.b	#2,obRoutine(a1)

locret_1AEF2:
		rts	
; ===========================================================================

Touch_Monitor:
		tst.w	obVelY(a0)		; is Sonic falling down?
		bpl.s	Touch_Monitor_ChkBreak	; if yes, branch
		tst.b	($FFFFFFEB).w		; is homing flag set?
		bne.s	Touch_Monitor_ChkBreak	; if yes, treat as touching from top

		; bounce from below effect
		move.w	obY(a0),d0
		subi.w	#$10,d0
		cmp.w	obY(a1),d0
		bcs.s	Touch_Monitor_End		
		neg.w	obVelY(a0)		; reverse Sonic's y-motion
		move.w	#-$180,obVelY(a1)	; bounce monitor a little
		tst.b	ob2ndRout(a1)
		bne.s	Touch_Monitor_End
		addq.b	#4,ob2ndRout(a1)	; make monitor fall down
		rts
; ===========================================================================

Touch_Monitor_ChkBreak:
		tst.b	($FFFFFF77).w		; is antigrav enabled?
		bne.s	@break_nobounce		; if yes, break open with no bounce
		cmpi.b	#2,obAnim(a0)		; is Sonic rolling/jumping?
		beq.s	@break			; if yes, break open
		cmpi.b	#$25,obAnim(a0)		; is death anim shown (inhuman mode)?
		beq.s	@break			; if yes, break open

		btst	#1,obStatus(a0)		; is Sonic in air?
		bne.s	Touch_Monitor_End	; if yes, no speed break
		cmpi.w	#$502,($FFFFFE10).w	; are we in FP?
		beq.s	Touch_Monitor_End	; if yes, disallow speed break
		move.w	obInertia(a0),d0	; move Sonic's interia to d0
		bpl.s	@chkspeed		; if positive, branch
		neg.w	d0			; otherwie negate d0
@chkspeed:	cmpi.w	#$A00,d0		; is Sonic fast enough to break monitor by touching?
		blo.s	Touch_Monitor_End	; if not, branch
		bclr	#5,obStatus(a0)		; clear pushing flag

@break:
		neg.w	obVelY(a0)		; reverse Sonic's y-motion
		bsr	BounceJD		; jump to BounceJD
@break_nobounce:
		addq.b	#2,obRoutine(a1)	; break monitor open

Touch_Monitor_End:
		rts	
; ===========================================================================

Touch_Enemy:				; XREF: Touch_ChkValue
		tst.b	($FFFFFFE7).w	; is sonic immortal?
		bne.s	loc_1AF40	; if yes, branch
		tst.b	($FFFFFE2D).w	; is Sonic invincible?
		bne.s	loc_1AF40	; if yes, branch
		cmpi.b	#$1F,obAnim(a0)	; is Sonic spindashing?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#$28,obAnim(a0)	; is Sonic homing?
		beq.w	loc_1AF40	; if yes, branch
		cmpi.b	#$23,obAnim(a0)	; is Sonic double jumping?
		beq.w	loc_1AF40	; if yes, branchz
		cmpi.w	#$A00,obInertia(a0)	; is sonic at figure-8 speed? (right)
		bge.s	loc_1AF40	; if yes, branch
		cmpi.w	#-$A00,obInertia(a0)	; is sonic at figure-8 speed? (left)
		ble.s	loc_1AF40	; if yes, branch
		cmpi.b	#2,obAnim(a0)	; is Sonic rolling?
		bne.w	Touch_ChkHurt	; if not, branch

loc_1AF40:
		tst.b	obColProp(a1)
		beq.s	Touch_KillEnemy
		neg.w	obVelX(a0)
		neg.w	obVelY(a0)
		asr	obVelX(a0)
		asr	obVelY(a0)
		move.b	#0,obColType(a1)
		subq.b	#1,obColProp(a1)
		bne.s	locret_1AF68
		bset	#7,obStatus(a1)

locret_1AF68:
		rts	
; ===========================================================================

Touch_KillEnemy:
		bset	#7,obStatus(a1)
		moveq	#0,d0
		move.w	($FFFFF7D0).w,d0
		addq.w	#2,($FFFFF7D0).w ; add 2 to item bonus counter
		cmpi.w	#6,d0
		bcs.s	loc_1AF82
		moveq	#6,d0

loc_1AF82:
		move.w	d0,$3E(a1)
		move.w	Enemy_Points(pc,d0.w),d0
		cmpi.w	#$20,($FFFFF7D0).w ; have 16 enemies been destroyed?
		bcs.s	loc_1AF9C	; if not, branch
		move.w	#1000,d0	; fix bonus to 10000
		move.w	#$A,$3E(a1)

loc_1AF9C:
		bsr	AddPoints
		move.b	#$27,0(a1)	; change object	to points
		move.b	#0,obRoutine(a1)

		bsr	BounceJD	; jump to BounceJD

		tst.w	obVelY(a0)
		bmi.s	loc_1AFC2
		move.w	obY(a0),d0
		cmp.w	obY(a1),d0
		bcc.s	loc_1AFCA
		neg.w	obVelY(a0)
		rts	
; ===========================================================================

loc_1AFC2:
		addi.w	#$100,obVelY(a0)
		rts	
; ===========================================================================

loc_1AFCA:
		subi.w	#$100,obVelY(a0)
		rts	
; ===========================================================================
Enemy_Points:	dc.w 100, 200, 500, 1000
		even
; ===========================================================================

; -----------------------------------------------------------------------------------
; Subroutine to bounce Sonic up when he has used a Jumpdash on an Enemy or
; a Monitor and to give him the ability to Jumpdash again
; -----------------------------------------------------------------------------------

BounceJD:
		tst.b	($FFFFFFEB).w		; was jumpdash flag set?
		beq.s	BounceJD_End		; if not, branch
		clr.b	($FFFFFFEB).w		; if yes, clear jumpdash flag (make sonic jumpdash again)
		move.w	#-$600,obVelY(a0)	; bounce Sonic upwards
		clr.w	obVelX(a0)		; clear X-velocity (stop sonic horizontally)
BounceJD_End:
		rts				; return
; End of function BounceJD

; ===========================================================================

loc_1AFDA:				; XREF: Touch_CatKiller
		bset	#7,obStatus(a1)

Touch_ChkHurt:				; XREF: Touch_ChkValue
		tst.b	($FFFFFE2D).w	; is Sonic invincible?
		bne.s	loc_1AFE6	; if yes, branch

		cmpi.w	#$101,($FFFFFE10).w	; are we in LZ?
		bne.s	Touch_Hurt		; if not, regular hurt
		tst.b 	($FFFFFFFE).w		; is the =P monitor enabled?
		bne.s	Touch_Hurt		; if yes, all good
		jmp	KillSonic		; force kill on the gargoyle no matter what

		tst.b	($FFFFFE2D).w	; is Sonic invincible?
		beq.s	Touch_Hurt	; if not, branch

loc_1AFE6:				; XREF: Touch_Hurt
		moveq	#-1,d0
		rts	
; ===========================================================================

Touch_Hurt:				; XREF: Touch_ChkHurt
		nop
		tst.w	$30(a0)			; is invin time counter empty?
		bne.s	loc_1AFE6		; if not, branch


Touch_MakeHurt:
		movea.l	a1,a2

; End of function TouchResponse
; Continue straight to HurtSonic

; ---------------------------------------------------------------------------
; Hurting Sonic	subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HurtSonic:
		tst.b	($FFFFFFE7).w	; is inhuman mode enabeld?
		bne.w	Hurt_NoRings	; if yes, branch
		tst.b	($FFFFFE2C).w	; does Sonic have any shields?
		bne.s	Hurt_Shield	; if yes, branch
		tst.w	($FFFFFE20).w	; does Sonic have any rings?
		beq.w	Hurt_NoRings	; if not, branch
		cmpi.w	#$302,($FFFFFE10).w
		beq.s	HS_NotEmpty
		jsr	SingleObjLoad
		bne.s	Hurt_Shield
		move.b	#$37,0(a1)	; load bouncing	multi rings object
		move.w	obX(a0),obX(a1)
		move.w	obY(a0),obY(a1)

Hurt_Shield:
	;	subq.b	#1,($FFFFFFFC).w ; sub 1 from shield X counter
	;	bne.s	HS_NotEmpty	; if counter is not empty, branch
	;	clr.b	($FFFFFFFC).w	 ; clear shield counter
	;	sub.b	#1,($FFFFFE2C).w ; sub 1 from shield counter
		clr.b	($FFFFFE2C).w	 ; remove shield	

HS_NotEmpty:
		move.b	#4,obRoutine(a0)
		jsr	Sonic_ResetOnFloor
		bset	#1,obStatus(a0)
		move.w	#-$400,obVelY(a0)	; make Sonic bounce away from the object
		move.w	#-$200,obVelX(a0)
		btst	#6,obStatus(a0)
		beq.s	Hurt_Reverse
		move.w	#-$200,obVelY(a0)
		move.w	#-$100,obVelX(a0)

Hurt_Reverse:
		move.w	obX(a0),d0
		cmp.w	obX(a2),d0
		bcs.s	Hurt_ChkSpikes	; if Sonic is left of the object, branch
		neg.w	obVelX(a0)		; if Sonic is right of the object, reverse

Hurt_ChkSpikes:
		move.b	#0,$39(a0)	; clear spindash flag
		move.w	#0,obInertia(a0)
		move.b	#$1A,obAnim(a0)
		move.w	#$78,$30(a0)
		move.w	#$A3,d0		; load normal damage sound
		cmpi.b	#$36,(a2)	; was damage caused by spikes?
		bne.s	Hurt_Sound	; if not, branch
		cmpi.b	#$16,(a2)	; was damage caused by LZ harpoon?
		bne.s	Hurt_Sound	; if not, branch
		move.w	#$A6,d0		; load spikes damage sound

Hurt_Sound:
		jsr	(PlaySound_Special).l
		moveq	#-1,d0
		rts	
; ===========================================================================

Hurt_NoRings:
	if DebugSurviveNoRings=1
		tst.b	($FFFFFFE7).w	; has sonic destroyed a S monitor?
		bne.s	KillSonic	; if yes, do the funny spinny thingy
		
		tst.w	($FFFFFFFA).w	; is debug mode	cheat on?
		bne.w	Hurt_Shield	; if yes, don't kill us
	endif
; End of function HurtSonic
; Continue straight to KillSonic

; ---------------------------------------------------------------------------
; Subroutine to	kill Sonic - rewritten for the inhuman mode
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


KillSonic:
		tst.w	($FFFFFE08).w		; is debug mode	active?
		bne.w	Kill_End		; if yes, branch
		clr.b	($FFFFFE2C).w		; clear shield
		clr.w	obInertia(a0)		; clear interia
		moveq	#0,d0			; clear d0
		clr.b	($FFFFFFAF).w		; clear automatic extended camera flag
		move.w	#-$600,d0		; move sonic upwards (inhuman)
		clr.b	($FFFFFE2D).w		; remove invincibility
		tst.b	($FFFFFFE7).w		; is Inhuman Mode enabled?
		beq.s	Kill_DoKill		; if not, skip this stuff anyway
		tst.b	($FFFFFFA1).w		; did Sonic die because of touching the boundary bottom?
		beq.w	Kill_InhumanMode	; if not, don't stop the time counter / don't kill sonic

Kill_DoKill:
		move.b	#1,($FFFFF5D1).w	; set death flag
		jsr	Pal_MakeBlackWhite	; turn palette black and white
		
		move.w	($FFFFF700).w,($FFFFF728).w	; lock left screen position
		move.w	($FFFFF700).w,($FFFFF72A).w	; lock right screen position		
		move.w	($FFFFF704).w,($FFFFF72C).w	; lock top screen position
		move.w	($FFFFF704).w,($FFFFF72E).w	; lock bottom screen position

		cmpi.b	#$18,($FFFFF600).w	; is this the ending sequence?
		bne.s	SH_NotEnding		; if not, branch
		move.w	#0,($FFFFF72A).w	; lock screen

SH_NotEnding:
		clr.b	($FFFFFFAA).w		; clear crabmeat boss flag 1
		clr.b	($FFFFFFAB).w		; clear crabmeat boss flag 2
		clr.b	($FFFFFFBB).w
		move.b	#1,($FFFFF7CC).w	; lock controls
		move.b	#0,($FFFFFFD3).w	; $FFD3
		move.b	#1,($FFFFFFAC).w	; set flag to delete afterimage
		clr.b	($FFFFFFA9).w		; clear crabmeat boss flag 3
		clr.w	($FFFFFE20).w		; clear rings
		move.b	#70,($FFFFFFDD).w	; set delay for restart when sonic hits ground
		clr.b	($FFFFFE1E).w		; stop time counter
		clr.b 	($FFFFFFF9).w		; clear LZ palette change flag (lol)
		move.b	#6,obRoutine(a0)	; comment this out, and sonic can't die (the main line for the inhuman mode)
		move.w	obY(a0),$38(a0)		; something with Y and bosses...
		bset	#7,obGfx(a0)		; make sonic being on the foreground
		move.w	#-$700,d0		; move sonic upwards (normal)
	
Kill_InhumanMode:
		jsr	Sonic_ResetOnFloor	; do all the shit which is in Sonic_ResetOnFloor
		bset	#1,obStatus(a0)		; make sonic to be in the air

		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	@moveup			; if not, branch
		btst	#1,obStatus(a2)		; is killer object vertically flipped?
		beq.s	@moveup			; if not, branch
		cmpi.b	#$36,(a2)		; was damage caused by spikes?
		bne.s	@moveup			; if not, branch
		move.w	#$500,d0		; move sonic downwards
@moveup:
		move.w	d0,obVelY(a0)		; move sonic upwards

		tst.b	($FFFFFFE7).w		; has sonic destroyed a S monitor?
		bne.s	KS_AllTheRest		; if yes, don't do anything with the X-velocity

		move.w	obVelX(a0),d0		; get Sonic's X speed has he died
		move.w	d0,d1			; copy to d1
		bpl.s	@xpos			; if positive, branch
		neg.w	d1			; make positive
@xpos:		cmpi.w	#$100,d1		; did Sonic die with a speed below $100?
		bhi.s	@speedfine		; if not, branch
		moveq	#0,d0			; otherwise, set to 0 straight cause otherwise it looks ugly
@speedfine:
		asr.w	#1,d0			; half speed
		move.w	d0,obVelX(a0)		; apply

KS_AllTheRest:
		move.b	#$25,obAnim(a0)		; use death animation
		move.w	#$A3,d0			; play normal death sound
		cmpi.b	#$36,(a2)		; was sonic killed by spikes?
		bne.s	Kill_PlaySound		; if not, branch
		move.w	#$A6,d0			; play spikes death sound

Kill_PlaySound:
		clr.b	($FFFFFFA1).w		; clear "died because of boundary bottom" flag
		jsr	(PlaySound_Special).l	; play the selected sound

Kill_End:
	;	cmpi.w	#$302,($FFFFFE10).w	; is level SlZ3?
	;	bne.s	@cont			; if not, branch
	;	addq.w	#4,sp			; make sure game branches back to the correct routine (whatever the fuck I meant with that)

@cont:
		moveq	#-1,d0			; sub 1 from d0, although I don't know why...
		rts				; return
; ---------------------------------------------------------------------------

; special routine to kill Sonic programmaticaly while he is in inhuman mode
KillSonic_Inhuman:
		lea	($FFFFD000).w,a0	; set self to Sonic
		movea.l	a0,a2			; set killer to self
		clr.b	($FFFFFFE7).w		; disable inhuman mode
		bra.w	KillSonic		; get fucking trolled lmao
; End of function KillSonic

; ===========================================================================

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Touch_Special:				; XREF: Touch_ChkValue
		move.b	obColType(a1),d1
		andi.b	#$3F,d1
		cmpi.b	#$B,d1		; is touch response $CB	?
		beq.s	Touch_CatKiller	; if yes, branch
		cmpi.b	#$C,d1		; is touch response $CC	?
		beq.s	Touch_Yadrin	; if yes, branch
		cmpi.b	#$17,d1		; is touch response $D7	?
		beq.s	Touch_D7orE1	; if yes, branch
		cmpi.b	#$21,d1		; is touch response $E1	?
		beq.s	Touch_D7orE1	; if yes, branch
		rts	
; ===========================================================================

Touch_CatKiller:			; XREF: Touch_Special
		bra.w	loc_1AFDA
; ===========================================================================

Touch_Yadrin:				; XREF: Touch_Special
		sub.w	d0,d5
		cmpi.w	#8,d5
		bcc.s	loc_1B144
		move.w	obX(a1),d0
		subq.w	#4,d0
		btst	#0,obStatus(a1)
		beq.s	loc_1B130
		subi.w	#$10,d0

loc_1B130:
		sub.w	d2,d0
		bcc.s	loc_1B13C
		addi.w	#$18,d0
		bcs.s	loc_1B140
		bra.s	loc_1B144
; ===========================================================================

loc_1B13C:
		cmp.w	d4,d0
		bhi.s	loc_1B144

loc_1B140:
		bra.w	Touch_ChkHurt
; ===========================================================================

loc_1B144:
		bra.w	Touch_Enemy
; ===========================================================================

Touch_D7orE1:				; XREF: Touch_Special
		addq.b	#1,obColProp(a1)
		rts	
; End of function Touch_Special

; ---------------------------------------------------------------------------
; Subroutine to	show the special stage layout
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_ShowLayout:				; XREF: SpecialStage
		bsr	SS_AniWallsRings
		bsr	SS_AniItems
		move.w	d5,-(sp)
		lea	($FFFF8000).w,a1
		move.b	($FFFFF780).w,d0
	;	andi.b	#$FC,d0
		jsr	(CalcSine).l
		move.w	d0,d4
		move.w	d1,d5
		muls.w	#$18,d4
		muls.w	#$18,d5
		moveq	#0,d2
		move.w	($FFFFF700).w,d2
		divu.w	#$18,d2
		swap	d2
		neg.w	d2
		addi.w	#-$B4,d2
		moveq	#0,d3
		move.w	($FFFFF704).w,d3
		divu.w	#$18,d3
		swap	d3
		neg.w	d3
		addi.w	#-$B4,d3
		move.w	#$F,d7

loc_1B19E:
		movem.w	d0-d2,-(sp)
		movem.w	d0-d1,-(sp)
		neg.w	d0
		muls.w	d2,d1
		muls.w	d3,d0
		move.l	d0,d6
		add.l	d1,d6
		movem.w	(sp)+,d0-d1
		muls.w	d2,d0
		muls.w	d3,d1
		add.l	d0,d1
		move.l	d6,d2
		move.w	#$F,d6

loc_1B1C0:
		move.l	d2,d0
		asr.l	#8,d0
		move.w	d0,(a1)+
		move.l	d1,d0
		asr.l	#8,d0
		move.w	d0,(a1)+
		add.l	d5,d2
		add.l	d4,d1
		dbf	d6,loc_1B1C0

		movem.w	(sp)+,d0-d2
		addi.w	#$18,d3
		dbf	d7,loc_1B19E

		move.w	(sp)+,d5
		lea	($FF0000).l,a0
		moveq	#0,d0
		move.w	($FFFFF704).w,d0
		divu.w	#$18,d0
		mulu.w	#$80,d0
		adda.l	d0,a0
		moveq	#0,d0
		move.w	($FFFFF700).w,d0
		divu.w	#$18,d0
		adda.w	d0,a0
		lea	($FFFF8000).w,a4
		move.w	#$F,d7

loc_1B20C:
		move.w	#$F,d6

loc_1B210:
		moveq	#0,d0
		move.b	(a0)+,d0
		beq.s	loc_1B268
		cmpi.b	#$4E,d0
		bhi.s	loc_1B268
		move.w	(a4),d3
		addi.w	#$120,d3
		cmpi.w	#$70,d3
		bcs.s	loc_1B268
		cmpi.w	#$1D0,d3
		bcc.s	loc_1B268
		move.w	obGfx(a4),d2
		addi.w	#$F0,d2
		cmpi.w	#$70,d2
		bcs.s	loc_1B268
		cmpi.w	#$170,d2
		bcc.s	loc_1B268
		lea	($FF4000).l,a5
		lsl.w	#3,d0
		lea	(a5,d0.w),a5
		movea.l	(a5)+,a1
		move.w	(a5)+,d1
		add.w	d1,d1
		adda.w	(a1,d1.w),a1
		movea.w	(a5)+,a3
		moveq	#0,d1
		move.b	(a1)+,d1
		subq.b	#1,d1
		bmi.s	loc_1B268
		jsr	sub_D762

loc_1B268:
		addq.w	#4,a4
		dbf	d6,loc_1B210

		lea	$70(a0),a0
		dbf	d7,loc_1B20C

		move.b	d5,($FFFFF62C).w
		cmpi.b	#$50,d5
		beq.s	loc_1B288
		move.l	#0,(a2)
		rts	
; ===========================================================================

loc_1B288:
		move.b	#0,-5(a2)
		rts	
; End of function SS_ShowLayout

; ---------------------------------------------------------------------------
; Subroutine to	animate	walls and rings	in the special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_AniWallsRings:			; XREF: SS_ShowLayout
		lea	($FF400C).l,a1
		moveq	#0,d0
		move.b	($FFFFF780).w,d0
	;	add.b	($FFFFFFB0).w,d0
	;	addq.b	#1,($FFFFFFB0).w
		lsr.b	#2,d0
		andi.w	#$F,d0
		moveq	#$23,d1

loc_1B2A4:
		move.w	d0,(a1)
		addq.w	#8,a1
		dbf	d1,loc_1B2A4

		lea	($FF4005).l,a1
		subq.b	#1,($FFFFFEC2).w
		bpl.s	loc_1B2C8
		move.b	#7,($FFFFFEC2).w
		addq.b	#1,($FFFFFEC3).w
		andi.b	#3,($FFFFFEC3).w

loc_1B2C8:
		move.b	($FFFFFEC3).w,$1D0(a1)
		subq.b	#1,($FFFFFEC4).w
		bpl.s	loc_1B2E4
		move.b	#7,($FFFFFEC4).w
		addq.b	#1,($FFFFFEC5).w
		andi.b	#1,($FFFFFEC5).w

loc_1B2E4:
		move.b	($FFFFFEC5).w,d0
		move.b	d0,$160(a1)
		move.b	d0,$148(a1)
		move.b	d0,$150(a1)
		move.b	d0,$1D8(a1)
		move.b	d0,$1E0(a1)
		move.b	d0,$1E8(a1)
		move.b	d0,$1F0(a1)
		move.b	d0,$1F8(a1)
		move.b	d0,$200(a1)

		; goal block animation
		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		bne.s	@regular		; if yes, branch
		moveq	#1,d0			; force to white goal block
@regular:
		move.b	d0,$138(a1)		; controls the animations for goal blocks
		
		; skull blocks
		tst.b	($FFFFFF5F).w		; is this the blackout special stage?
		beq.s	@notblackout		; if not, branch
		bclr	#0,$138(a1)		; normal skull icon
		tst.b	($FFFFFFAE).w		; whiteflash in progress?
		bne.s	@lightup		; if yes, branch
		cmpi.b	#2,($FFFFFE57).w 	; are we in part 2?
		bne.s	@notblackout		; if not, branch
		move.b	($FFFFF602).w,d0	; get button presses
		andi.b	#$C,d0			; is left/right	held?
		bne.s	@notblackout		; if yes, branch
@lightup:	bset	#0,$138(a1)		; use lit-up skull icon

@notblackout:
		subq.b	#1,($FFFFFEC6).w
		bpl.s	loc_1B326
		move.b	#4,($FFFFFEC6).w
		addq.b	#1,($FFFFFEC7).w
		andi.b	#3,($FFFFFEC7).w

loc_1B326:
		move.b	($FFFFFEC7).w,d0
		move.b	d0,$168(a1)
		move.b	d0,$170(a1)
		move.b	d0,$178(a1)
		move.b	d0,$180(a1)
		subq.b	#1,($FFFFFEC0).w
		bpl.s	loc_1B350
		move.b	#7,($FFFFFEC0).w
		subq.b	#1,($FFFFFEC1).w
		andi.b	#7,($FFFFFEC1).w

loc_1B350:
		lea	($FF4016).l,a1
		lea	(SS_WaRiVramSet).l,a0
		moveq	#0,d0
		move.b	($FFFFFEC1).w,d0
		add.w	d0,d0
		lea	(a0,d0.w),a0
		move.w	(a0),(a1)
		move.w	obGfx(a0),obX(a1)
		move.w	obMap(a0),obVelX(a1)
		move.w	6(a0),obPriority(a1)
		move.w	obX(a0),obColType(a1)
		move.w	obScreenY(a0),obSubtype(a1)
		move.w	obY(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	obGfx(a0),obX(a1)
		move.w	obMap(a0),obVelX(a1)
		move.w	6(a0),obPriority(a1)
		move.w	obX(a0),obColType(a1)
		move.w	obScreenY(a0),obSubtype(a1)
		move.w	obY(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	obGfx(a0),obX(a1)
		move.w	obMap(a0),obVelX(a1)
		move.w	6(a0),obPriority(a1)
		move.w	obX(a0),obColType(a1)
		move.w	obScreenY(a0),obSubtype(a1)
		move.w	obY(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		move.w	(a0),(a1)
		move.w	obGfx(a0),obX(a1)
		move.w	obMap(a0),obVelX(a1)
		move.w	6(a0),obPriority(a1)
		move.w	obX(a0),obColType(a1)
		move.w	obScreenY(a0),obSubtype(a1)
		move.w	obY(a0),$30(a1)
		move.w	$E(a0),$38(a1)
		adda.w	#$20,a0
		adda.w	#$48,a1
		rts	
; End of function SS_AniWallsRings

; ===========================================================================
SS_WaRiVramSet:	dc.w $142, $6142, $142,	$142, $142, $142, $142,	$6142
		dc.w $142, $6142, $142,	$142, $142, $142, $142,	$6142
		dc.w $2142, $142, $2142, $2142,	$2142, $2142, $2142, $142
		dc.w $2142, $142, $2142, $2142,	$2142, $2142, $2142, $142
		dc.w $4142, $2142, $4142, $4142, $4142,	$4142, $4142, $2142
		dc.w $4142, $2142, $4142, $4142, $4142,	$4142, $4142, $2142
		dc.w $6142, $4142, $6142, $6142, $6142,	$6142, $6142, $4142
		dc.w $6142, $4142, $6142, $6142, $6142,	$6142, $6142, $4142
; ---------------------------------------------------------------------------
; Subroutine to	remove items when you collect them in the special stage
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_RemoveCollectedItem:			; XREF: Obj09_ChkItems_Collectible
		lea	($FF4400).l,a2
		move.w	#$1F,d0

loc_1B4C4:
		tst.b	(a2)
		beq.s	locret_1B4CE
		addq.w	#8,a2
		dbf	d0,loc_1B4C4

locret_1B4CE:
		rts	
; End of function SS_RemoveCollectedItem

; ---------------------------------------------------------------------------
; Subroutine to	animate	special	stage items when you touch them
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_AniItems:				; XREF: SS_ShowLayout
		lea	($FF4400).l,a0
		move.w	#$1F,d7

loc_1B4DA:
		moveq	#0,d0
		move.b	(a0),d0
		beq.s	loc_1B4E8
		lsl.w	#2,d0
		movea.l	SS_AniIndex-obMap(pc,d0.w),a1
		jsr	(a1)

loc_1B4E8:
		addq.w	#8,a0

loc_1B4EA:
		dbf	d7,loc_1B4DA

		rts	
; End of function SS_AniItems

; ===========================================================================
SS_AniIndex:	dc.l SS_AniRingSparks
		dc.l SS_AniBumper
		dc.l SS_Ani1Up
		dc.l SS_AniReverse
		dc.l SS_AniEmeraldSparks
		dc.l SS_AniGlassBlock
; ===========================================================================

SS_AniRingSparks:			; XREF: SS_AniIndex
		subq.b	#1,obGfx(a0)
		bpl.s	locret_1B530
		move.b	#5,obGfx(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	obMap(a0),a1
		move.b	SS_AniRingData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B530
		clr.l	(a0)
		clr.l	obMap(a0)

locret_1B530:
		rts	
; ===========================================================================
SS_AniRingData:	dc.b $42, $43, $44, $45, 0, 0
; ===========================================================================

SS_AniBumper:				; XREF: SS_AniIndex
		subq.b	#1,obGfx(a0)
		bpl.s	locret_1B566
		move.b	#7,obGfx(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	obMap(a0),a1
		move.b	SS_AniBumpData(pc,d0.w),d0
		bne.s	loc_1B564
		clr.l	(a0)
		clr.l	obMap(a0)
		move.b	#$25,(a1)
		rts	
; ===========================================================================

loc_1B564:
		move.b	d0,(a1)

locret_1B566:
		rts	
; ===========================================================================
SS_AniBumpData:	dc.b $32, $33, $32, $33, 0, 0
; ===========================================================================

SS_Ani1Up:				; XREF: SS_AniIndex
		subq.b	#1,obGfx(a0)
		bpl.s	locret_1B596
		move.b	#5,obGfx(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	obMap(a0),a1
		move.b	SS_Ani1UpData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B596
		clr.l	(a0)
		clr.l	obMap(a0)

locret_1B596:
		rts	
; ===========================================================================
SS_Ani1UpData:	dc.b $46, $47, $48, $49, 0, 0
; ===========================================================================

SS_AniReverse:				; XREF: SS_AniIndex
		subq.b	#1,obGfx(a0)
		bpl.s	locret_1B5CC
		move.b	#7,obGfx(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	obMap(a0),a1
		move.b	SS_AniRevData(pc,d0.w),d0
		bne.s	loc_1B5CA
		clr.l	(a0)
		clr.l	obMap(a0)
		move.b	#$2B,(a1)
		rts	
; ===========================================================================

loc_1B5CA:
		move.b	d0,(a1)

locret_1B5CC:
		rts	
; ===========================================================================
SS_AniRevData:	dc.b $2B, $31, $2B, $31, 0, 0
; ===========================================================================

; animation of emerald sparks my ass, this routine straight up controls the stage ending...
; this was like finding a needle in a haystack
SS_AniEmeraldSparks:			; XREF: SS_AniIndex
		subq.b	#1,obGfx(a0)
		bpl.s	locret_1B60C
		move.b	#5,obGfx(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	obMap(a0),a1
		move.b	SS_AniEmerData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B60C
		clr.l	(a0)
		clr.l	obMap(a0)

		move.b	#4,($FFFFD024).w	; set to Obj09_Exit

		move.w	#$A8,d0			; play special stage GOAL sound
		tst.b	($FFFFFF5F).w		; is this the blackout special stage?
		beq.s	@playsound		; if not, branch
		jsr	Set_BlackoutDone	; you have beaten the blackout challenge, congrats
		jsr	SRAM_SaveNow		; save
		move.w	#$91,d0			; play true ending music
@playsound:
		jsr	(PlaySound_Special).l

locret_1B60C:
		rts	
; ===========================================================================
SS_AniEmerData:	dc.b $46, $47, $48, $49, 0, 0
; ===========================================================================

SS_AniGlassBlock:			; XREF: SS_AniIndex
		subq.b	#1,obGfx(a0)
		bpl.s	locret_1B640
		move.b	#1,obGfx(a0)
		moveq	#0,d0
		move.b	3(a0),d0
		addq.b	#1,3(a0)
		movea.l	obMap(a0),a1
		move.b	SS_AniGlassData(pc,d0.w),d0
		move.b	d0,(a1)
		bne.s	locret_1B640
		move.b	obMap(a0),(a1)
		clr.l	(a0)
		clr.l	obMap(a0)

locret_1B640:
		rts	
; ===========================================================================
SS_AniGlassData:
		dc.b	$4B, $4C, $4D, $4E, $4B, $4C, $4D, $4E, 0, 0
		even

; ---------------------------------------------------------------------------
; Subroutine to	load special stage layout
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


; ===========================================================================
; ---------------------------------------------------------------------------
; Starting Location for the Special Stage
; ---------------------------------------------------------------------------

SS_Load:				; XREF: SpecialStage
		; load layout and starting location
		cmpi.w	#$300,($FFFFFE10).w	; is this Special Place?
		bne.s	@unreal			; if not, we're in Unreal Place (or the Blackout Challenge)
		move.w	#$03E8,($FFFFD008).w	; start X pos for Sonic
		move.w	#$0310,($FFFFD00C).w	; start Y pos for Sonic
		lea	(SS_1_Casual).l,a0	; load casual Special Place layout
		frantic				; are we in frantic mode?
		beq.s	SS_LoadLevel		; if not, branch
		lea	(SS_1_Frantic).l,a0	; load frantic Special Place layout
		bra.s	SS_LoadLevel		; branch
@unreal:
		move.w	#$031F,($FFFFD008).w	; start X pos for Sonic
		move.w	#$0587,($FFFFD00C).w	; start Y pos for Sonic
		tst.b	($FFFFFF5F).w		; is this the blackout special stage?
		beq.s	@notblackout		; if not, branch

		lea	(SS_Blackout_Part1).l,a0 ; load regular blackout layout
		move.b	($FFFFF604).w,d0	; get button presses
		cmpi.b	#$70,d0			; is exactly ABC held?
		bne.s	SS_LoadLevel		; if not, branch
		lea	(SS_Blackout_Part2).l,a0 ; I guess this works as hard part skipper, meh
		bra.s	SS_LoadLevel		; branch
@notblackout:
		lea	(SS_2_Casual).l,a0	; load casual Unreal Place layout
		frantic				; are we in frantic mode?
		beq.s	SS_LoadLevel		; if not, branch
		lea	(SS_2_Frantic).l,a0	; load frantic Unreal Place layout
; ---------------------------------------------------------------------------

SS_LoadLevel:
		lea	($FF4000).l,a1			; set destination
		move.w	#$3FC,d0			; set number of repeats to $3FC
SS_LoadLoop:	move.l	(a0)+,(a1)+			; move 4 bytes from pointer into location
		dbf	d0,SS_LoadLoop			; loop

SSAS_End:
		lea	($FF0000).l,a1
		move.w	#$FFF,d0
SS_ClrRAM3:	clr.l	(a1)+
		dbf	d0,SS_ClrRAM3

		lea	($FF1020).l,a1
		lea	($FF4000).l,a0
		moveq	#$3F,d1
loc_1B6F6:	moveq	#$3F,d2
loc_1B6F8:	move.b	(a0)+,(a1)+
		dbf	d2,loc_1B6F8
		lea	$40(a1),a1
		dbf	d1,loc_1B6F6

		lea	($FF4008).l,a1
		lea	(SS_MapIndex).l,a0
		moveq	#$4D,d1
loc_1B714:	move.l	(a0)+,(a1)+
		move.w	#0,(a1)+
		move.b	-obMap(a0),-obRender(a1)
		move.w	(a0)+,(a1)+
		dbf	d1,loc_1B714

		lea	($FF4400).l,a1
		move.w	#$3F,d1
loc_1B730:	clr.l	(a1)+
		dbf	d1,loc_1B730

		lea	($FF1020).l,a1		; load SS blocks (layout?) into a1
		moveq	#$3F,d1			; set normal loop
SSL_GoalLoop2:
		moveq	#$3F,d2			; set alternate loop
SSL_GoalLoop:
		cmpi.b	#$2C,(a1)		; is the item a	goal block?
		bne.s	SSL_NoReplace2	; if not, branch
		addi.b	#1,($FFFFFFD7).w	; increase counter
		cmpi.b	#24,($FFFFFFD7).w	; is counter over 24 (end of normal blocks)?
		blt.s	SSL_NoResetFFD7	; if not, branch
		move.b	#2,($FFFFFFD7).w	; else, reset to first block

SSL_NoResetFFD7:
		cmpi.b	#1,($FFFFFFD7).w	; is block number 1 (static block)?
		beq.s	SSL_SkipBlockX	; if yes, branch
		cmpi.b	#2,($FFFFFFD7).w	; is the item a blue block (2)?
		beq.s	SSL_SkipBlock		; if yes, branch
		cmpi.b	#6,($FFFFFFD7).w	; is the item a blue block (6)?
		beq.s	SSL_SkipBlock		; if yes, branch		
		cmpi.b	#$A,($FFFFFFD7).w	; is block number $A (static block)?
		beq.s	SSL_SkipBlock		; if yes, branch
		cmpi.b	#$13,($FFFFFFD7).w	; is block number $13 (static block)?
		beq.s	SSL_SkipBlock		; if yes, branch
		cmpi.b	#$1C,($FFFFFFD7).w	; is block number $1C (static block)?
		beq.s	SSL_SkipBlock		; if yes, branch
		bra.s	SSL_ReplaceNormal	; skip

SSL_SkipBlockX:
		addi.b	#1,($FFFFFFD7).w	; use next blinking block

SSL_SkipBlock:
		addi.b	#1,($FFFFFFD7).w	; use next blinking block

SSL_ReplaceNormal:
		move.b	($FFFFFFD7).w,(a1)	; replace goal block with a solid block

SSL_NoReplace2:
		addq.w	#1,a1			; go to next block
		dbf	d2,SSL_GoalLoop	; loop
		lea	$40(a1),a1		; increase pointer by $40
		dbf	d1,SSL_GoalLoop2	; loop

		rts	
; End of function SS_Load

; ===========================================================================
; ---------------------------------------------------------------------------
; Special stage	mappings and VRAM pointers
; ---------------------------------------------------------------------------
SS_MapIndex:
		dc.l Map_SSWalls	; address of mappings
		dc.w $142		; VRAM setting
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $2142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $4142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_SSWalls
		dc.w $6142
		dc.l Map_obj47
		dc.w $23B
		dc.l Map_SS_R
		dc.w $570
		dc.l Map_SS_R
		dc.w $251
		dc.l Map_SS_R
		dc.w $370
		dc.l Map_SS_Up
		dc.w $263
		dc.l Map_SS_Down
		dc.w $263
		dc.l Map_SS_R
		dc.w $22F0
		dc.l Map_SS_Glass
		dc.w $470
		dc.l Map_SS_Glass
		dc.w $5F0
		dc.l Map_SS_Glass
		dc.w $65F0
		dc.l Map_SS_Glass
		dc.w $25F0
		dc.l Map_SS_Glass
		dc.w $45F0
		dc.l Map_SS_R
		dc.w $2F0
		dc.l Map_obj47+$1000000	; add frame no.	* $1000000
		dc.w $23B
		dc.l Map_obj47+$2000000
		dc.w $23B
		dc.l Map_SS_R
		dc.w $797
		dc.l Map_SS_R
		dc.w $7A0
		dc.l Map_SS_R
		dc.w $7A9
		dc.l Map_SS_R
		dc.w $797
		dc.l Map_SS_R
		dc.w $7A0
		dc.l Map_SS_R
		dc.w $7A9
		dc.l Map_obj25
		dc.w $27B2
		dc.l Map_SS_Chaos3
		dc.w $770
		dc.l Map_SS_Chaos3
		dc.w $2770
		dc.l Map_SS_Chaos3
		dc.w $4770
		dc.l Map_SS_Chaos3
		dc.w $6770
		dc.l Map_SS_Chaos1
		dc.w $770
		dc.l Map_SS_Chaos2
		dc.w $770
		dc.l Map_SS_R
		dc.w $4F0
		dc.l Map_obj25+$4000000
		dc.w $27B2
		dc.l Map_obj25+$5000000
		dc.w $27B2
		dc.l Map_obj25+$6000000
		dc.w $27B2
		dc.l Map_obj25+$7000000
		dc.w $27B2
		dc.l Map_SS_Glass
		dc.w $23F0
		dc.l Map_SS_Glass+$1000000
		dc.w $23F0
		dc.l Map_SS_Glass+$2000000
		dc.w $23F0
		dc.l Map_SS_Glass+$3000000
		dc.w $23F0
		dc.l Map_SS_R+$2000000
		dc.w $4F0
		dc.l Map_SS_Glass
		dc.w $5F0
		dc.l Map_SS_Glass
		dc.w $65F0
		dc.l Map_SS_Glass
		dc.w $25F0
		dc.l Map_SS_Glass
		dc.w $45F0
		even

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "R" block
; ---------------------------------------------------------------------------
Map_SS_R:
		include	"_maps\SSRblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage breakable glass blocks and red-white blocks
; ---------------------------------------------------------------------------
Map_SS_Glass:
		include	"_maps\SSglassblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "UP" block
; ---------------------------------------------------------------------------
Map_SS_Up:
		include	"_maps\SSUPblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage "DOWN" block
; ---------------------------------------------------------------------------
Map_SS_Down:
		include	"_maps\SSDOWNblock.asm"

; ---------------------------------------------------------------------------
; Sprite mappings - special stage chaos	emeralds
; ---------------------------------------------------------------------------
Map_SS_Chaos1:	dc.w byte_1B96C-Map_SS_Chaos1
		dc.w byte_1B97E-Map_SS_Chaos1
Map_SS_Chaos2:	dc.w byte_1B972-Map_SS_Chaos2
		dc.w byte_1B97E-Map_SS_Chaos2
Map_SS_Chaos3:	dc.w byte_1B978-Map_SS_Chaos3
		dc.w byte_1B97E-Map_SS_Chaos3
byte_1B96C:	dc.b 1
		dc.b $F8, 5, 0,	0, $F8
byte_1B972:	dc.b 1
		dc.b $F8, 5, 0,	4, $F8
byte_1B978:	dc.b 1
		dc.b $F8, 5, 0,	8, $F8
byte_1B97E:	dc.b 1
		dc.b $F8, 5, 0,	$C, $F8
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; Object 09 - Sonic (special stage)
; ---------------------------------------------------------------------------

Obj09:					; XREF: Obj_Index
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		beq.s	Obj09_Normal	; if not, branch
		bsr	SS_FixCamera
		bra.w	DebugMode
; ===========================================================================

Obj09_Normal:
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj09_Index(pc,d0.w),d1
		jmp	Obj09_Index(pc,d1.w)
; ===========================================================================
Obj09_Index:	dc.w Obj09_Main-Obj09_Index
		dc.w Obj09_ChkDebug-Obj09_Index
		dc.w Obj09_ExitStage-Obj09_Index
		dc.w Obj09_Exit2-Obj09_Index
; ===========================================================================

Obj09_Main:				; XREF: Obj09_Index
		addq.b	#2,obRoutine(a0)
		move.b	#$E,obHeight(a0)
		move.b	#7,obWidth(a0)
		move.l	#Map_Sonic,obMap(a0)
		move.w	#$780,obGfx(a0)
		move.b	#4,obRender(a0)
		move.b	#1,obPriority(a0)
		move.b	#2,obAnim(a0)	; use rolling animation
		bset	#2,obStatus(a0)
		bset	#1,obStatus(a0)
		clr.b	($FFFFFFAE).w
		move.w	obX(a0),($FFFFFF86).w	; copy starting X position to last checkoing X-pos
		move.w	obY(a0),($FFFFFF88).w	; copy starting Y position to last checkoing Y-pos
; ---------------------------------------------------------------------------

Obj09_ChkDebug:				; XREF: Obj09_Index
		tst.w	($FFFFFFFA).w	; is debug mode	cheat enabled?
		beq.s	Obj09_NoDebug	; if not, branch
		btst	#4,($FFFFF605).w ; is button B pressed?
		beq.s	Obj09_NoDebug	; if not, branch
		move.w	#1,($FFFFFE08).w ; change Sonic	into a ring

Obj09_NoDebug:
		cmpi.b	#1,($FFFFFFD6).w	; is a W-block being touched in the special stage?
		bne.s	Obj09_NoW		; if not, skip this routine
		jsr	obj09_MakeGoalSolid	; go to solid making code

Obj09_NoW:
		cmpi.b	#1,($FFFFFF9F).w	; is flag set to 1?
		bne.s	Obj09_NoRot		; if not, branch
		jsr	obj09_Rotation		; go to rotation code

Obj09_NoRot:
		tst.b	($FFFFFFAE).w		; is white flash counter empty?
		beq.s	SS_NoTeleport		; if yes, branch
		subq.b	#1,($FFFFFFB1).w	; substract from counter
		bpl.s	SS_NoTeleport		; if there's still something in, branch
		jsr	WhiteFlash_Restore
		clr.b	($FFFFFFAE).w		; clear WF2 flag

SS_NoTeleport:
		move.b	#0,$30(a0)
		moveq	#0,d0
		move.b	obStatus(a0),d0
		andi.w	#2,d0
		move.w	Obj09_Modes(pc,d0.w),d1
		jsr	obj09_Modes(pc,d1.w)
		jsr	LoadSonicDynPLC

		; slow down Sonic when collecting the last emerald
		tst.b	($FFFFF7CC).w
		beq.s	@notlocked
		move.w	obVelX(a0),d0
		asr.w	#1,d0
		move.w	d0,obVelX(a0)
		move.w	obVelY(a0),d0
		asr.w	#1,d0
		move.w	d0,obVelY(a0)
		
@notlocked:
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	@notnonstopinhuman	; if not, branch
		add.w	#$0100,($FFFFFB04)	; increase Sonic's palette (color 3)
		add.w	#$0100,($FFFFFB06)	; increase Sonic's palette (color 4)
		add.w	#$0100,($FFFFFB08)	; increase Sonic's palette (color 5)
@notnonstopinhuman:
		
		; prevent players from going out of bounds
		move.w	obX(a0),d0		; get Sonic's X pos
		bmi.s	@oob			; if it's negative, we're out of bounds to the left
		cmpi.w	#$9FF,d0		; did we go out of bounds to the right?
		bhs.s	@oob			; if yes, branch
		move.w	obY(a0),d0		; get Sonic's Y pos
		bmi.s	@oob			; if it's negative, we're out of bounds to the top
		cmpi.w	#$9FF,d0		; did we go out of bounds to the bottom?
		blo.s	@display		; if not, we're all good
@oob:
		bsr	TouchGoalBlock		; reset Sonic to never go out of bounds
@display:
		jmp	DisplaySprite
; ===========================================================================
Obj09_Modes:	dc.w Obj09_OnWall-Obj09_Modes
		dc.w Obj09_InAir-Obj09_Modes
; ===========================================================================

Obj09_OnWall:				; XREF: Obj09_Modes
		bclr	#7,obStatus(a0)	; clear "Sonic has jumped" flag
		jsr	obj09_Jump
		jsr	obj09_Move
		jsr	obj09_Fall
		bra.s	Obj09_Display
; ===========================================================================

Obj09_InAir:				; XREF: Obj09_Modes
		jsr	obj09_JumpHeight
		jsr	obj09_Move
		jsr	obj09_Fall

Obj09_Display:				; XREF: Obj09_OnWall
		jsr	Obj09_ChkItems_Collectible
		jsr	Obj09_ChkItems_Solid
		jsr	SpeedToPos
		bsr	SS_FixCamera
		move.w	($FFFFF780).w,d0
		add.w	($FFFFF782).w,d0
		move.w	d0,($FFFFF780).w
		jsr	Sonic_Animate
		rts	

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Unreal_Speed = $160
Unreal_Accel = 8

Obj09_Move:				; XREF: Obj09_OnWall; Obj09_InAir
		tst.b	($FFFFF7CC).w		; are controls locked?
		beq.s	@cont			; if not, branch
		rts				; block affecting controls

@cont:
		tst.b	($FFFFFF5F).w		; is easter egg SS enabled?
		bne.s	loc_1BA78		; disabled movement

		btst	#2,($FFFFF602).w ; is left being pressed?
		beq.s	Obj09_ChkRight	; if not, branch
		jsr	obj09_MoveLeft

Obj09_ChkRight:
		btst	#3,($FFFFF602).w ; is right being pressed?
		beq.s	loc_1BA78	; if not, branch
		jsr	obj09_MoveRight

loc_1BA78:
		; Unreal Place Sonic movement logic
		tst.b	($FFFFFFBF).w			; is unreal challenge enabled?
		beq.s	@unrealend			; if not, branch
		cmpi.b	#1,($FFFFFFBF).w		; are we going up?
		bne.s	@checkdown			; if not, branch
		cmpi.w	#-Unreal_Speed,obVelY(a0)	; did we reach the max up speed?
		bmi.s	@unrealend			; if yes, branch
		subq.w	#Unreal_Accel,obVelY(a0)	; increase up speed
		bra.s	@unrealend			; branch
@checkdown:
		cmpi.b	#2,($FFFFFFBF).w		; are we going down?
		bne.s	@unrealend			; if not, branch
		cmpi.w	#Unreal_Speed,obVelY(a0)	; did we reach the max down speed?
		bhi.s	@unrealend			; if yes, branch
		addq.w	#Unreal_Accel,obVelY(a0)	; increase down speed
@unrealend:

		move.b	($FFFFF602).w,d0
		andi.b	#$C,d0
		bne.s	loc_1BAA8
		move.w	obInertia(a0),d0
		beq.s	loc_1BAA8
		bmi.s	loc_1BA9A
		subi.w	#$C,d0
		bcc.s	loc_1BA94
		move.w	#0,d0

loc_1BA94:
		move.w	d0,obInertia(a0)
		bra.s	loc_1BAA8
; ===========================================================================

loc_1BA9A:
		addi.w	#$C,d0
		bcc.s	loc_1BAA4
		move.w	#0,d0

loc_1BAA4:
		move.w	d0,obInertia(a0)

loc_1BAA8:
		move.b	($FFFFF780).w,d0
		addi.b	#$20,d0
		andi.b	#$C0,d0
		neg.b	d0
		jsr	(CalcSine).l
		muls.w	obInertia(a0),d1
		add.l	d1,obX(a0)
		muls.w	obInertia(a0),d0
		add.l	d0,obY(a0)
		movem.l	d0-d1,-(sp)
		move.l	obY(a0),d2
		move.l	obX(a0),d3
		bsr	Obj09_Collision
		beq.s	loc_1BAF2
		movem.l	(sp)+,d0-d1
		sub.l	d1,obX(a0)
		sub.l	d0,obY(a0)
		move.w	#0,obInertia(a0)
		rts	
; ===========================================================================

loc_1BAF2:
		movem.l	(sp)+,d0-d1
		rts	
; End of function Obj09_Move


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_MoveLeft:				; XREF: Obj09_Move
		bset	#0,obStatus(a0)
		move.w	obInertia(a0),d0
		beq.s	loc_1BB06
		bpl.s	loc_1BB1A

loc_1BB06:
		subi.w	#$C,d0
		cmpi.w	#-$800,d0
		bgt.s	loc_1BB14
		move.w	#-$800,d0

loc_1BB14:
		move.w	d0,obInertia(a0)
		rts	
; ===========================================================================

loc_1BB1A:
		subi.w	#$40,d0
		bcc.s	loc_1BB22
		nop	

loc_1BB22:
		move.w	d0,obInertia(a0)
		rts	
; End of function Obj09_MoveLeft


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_MoveRight:			; XREF: Obj09_Move
		bclr	#0,obStatus(a0)
		move.w	obInertia(a0),d0
		bmi.s	loc_1BB48
		addi.w	#$C,d0
		cmpi.w	#$800,d0
		blt.s	loc_1BB42
		move.w	#$800,d0

loc_1BB42:
		move.w	d0,obInertia(a0)
		bra.s	locret_1BB54
; ===========================================================================

loc_1BB48:
		addi.w	#$40,d0
		bcc.s	loc_1BB50
		nop	

loc_1BB50:
		move.w	d0,obInertia(a0)

locret_1BB54:
		rts	
; End of function Obj09_MoveRight


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Jump:				; XREF: Obj09_OnWall
		tst.b	($FFFFFF5F).w		; is easter egg SS enabled?
		beq.s	@cont			; if not, branch
		

		bra.s	Obj09_NoJump		; disabled movement

@cont:
		move.b	($FFFFF603).w,d0	; get button press
		andi.b	#$70,d0			; is A,	B or C pressed?
		beq.s	Obj09_NoJump		; if not, branch
		tst.b	($FFFFFFBF).w
		bne.s	Obj09_NoJump
		tst.w	($FFFFFFFA).w		; is debug mode on?
		beq.s	Obj09_Jump_NoDebug	; if not, branch
		move.b	($FFFFF603).w,d0	; get button press
		andi.b	#$10,d0			; is B pressed?
		beq.s	Obj09_Jump_NoDebug	; if not, branch
		rts				; else, don't perform jump
; ===========================================================================

Obj09_Jump_NoDebug:
		move.b	($FFFFF780).w,d0
	;	andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$680,d1
		asr.l	#8,d1
		move.w	d1,obVelX(a0)
		muls.w	#$680,d0
		asr.l	#8,d0
		move.w	d0,obVelY(a0)
		bset	#1,obStatus(a0)
		bset	#7,obStatus(a0)	; set "Sonic has jumped" flag
		move.w	#$A0,d0
		jsr	(PlaySound_Special).l ;	play jumping sound
Obj09_NoJump:
		rts	
; End of function Obj09_Jump

; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to limit Sonic's upward vertical speed
; ---------------------------------------------------------------------------

Obj09_JumpHeight:				; XREF: Obj09_InAir
		move.b	($FFFFF602).w,d0	; is the jump button up?
		andi.b	#$30,d0
		bne.s	locret_1BBB4		; if not, branch to return
		btst	#7,obStatus(a0)		; did Sonic jump or is he just falling or hit by a bumper?
		beq.s	locret_1BBB4		; if not, branch to return
		move.b	($FFFFF780).w,d0	; get SS angle
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l			
		move.w	obVelY(a0),d2		; get Y speed
		muls.w	d2,d0			; multiply Y speed by sin
		asr.l	#8,d0			; find the new Y speed
		move.w	obVelX(a0),d2		; get X speed
		muls.w	d2,d1			; multiply X speed by cos
		asr.l	#8,d1			; find the new X speed
		add.w	d0,d1			; combine the two speeds
		cmpi.w	#$400,d1		; compare the combined speed with the jump release speed
		ble.s	locret_1BBB4		; if it's less, branch to return
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		neg.b	d0
		subi.b	#$40,d0
		jsr	(CalcSine).l
		muls.w	#$400,d1
		asr.l	#8,d1
		move.w	d1,obVelX(a0)
		muls.w	#$400,d0
		asr.l	#8,d0
		move.w	d0,obVelY(a0)		; set the speed to the jump release speed
		bclr	#7,obStatus(a0)		; clear "Sonic has jumped" flag
 
locret_1BBB4:
		rts

; ---------------------------------------------------------------------------
; Subroutine to	fix the	camera on Sonic's position (special stage)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


SS_FixCamera:				; XREF: Obj09
		move.w	obY(a0),d2
		move.w	obX(a0),d3
		move.w	($FFFFF700).w,d0
		subi.w	#$A0,d3
		bcs.s	loc_1BBCE
		sub.w	d3,d0
		sub.w	d0,($FFFFF700).w

loc_1BBCE:
		move.w	($FFFFF704).w,d0
		subi.w	#$70,d2
		bcs.s	locret_1BBDE
		sub.w	d2,d0
		sub.w	d0,($FFFFF704).w

locret_1BBDE:
		rts	
; End of function SS_FixCamera

; ===========================================================================

Obj09_ExitStage:			; XREF: Obj09_Index
		move.w	($FFFFF782).w,d0	; get current spinniness
		addi.w	#$40,d0			; increase spinniness of stage

		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		beq.s	@notblackout		; if not, branch
		cmpi.w	#$700,d0		; reached $1800 spinniness?
		bge.s	@notblackout		; if yes, stop slowing down
		subi.w	#$38,d0			; make it slower to celebrate the victory
@notblackout:
		move.w	d0,($FFFFF782).w	; set new spinniness
		
		cmpi.w	#$1800,($FFFFF782).w	; reached $1800 spinniness?
		blt.s	loc_1BBF4		; if not, branch
		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		beq.s	@notblackout2		; if not, branch
		move.b	($FFFFF600).w,d0
		andi.w	#$F,d0
		cmpi.w	#$C,d0
		beq.s	@notblackout2
		move.w	#$A8,d0			; play special stage GOAL sound
		jsr	(PlaySound_Special).l
@notblackout2:
		move.b	#$C,($FFFFF600).w	; set game mode to level (this effectively starts the white fade-in)

loc_1BBF4:
		cmpi.w	#$3000,($FFFFF782).w	; did we reach max spinniness?
		blt.s	loc_1BC12		; if not, branch
		move.w	#0,($FFFFF782).w
		move.w	#$4000,($FFFFF780).w
		addq.b	#2,obRoutine(a0)	; set to Obj09_Exit2 (this effectively ends the special stage)
		move.w	#$3C,$38(a0)

loc_1BC12:
		move.w	($FFFFF780).w,d0
		add.w	($FFFFF782).w,d0
		move.w	d0,($FFFFF780).w
		jsr	Sonic_Animate
		jsr	LoadSonicDynPLC
		bsr	SS_FixCamera
		jmp	DisplaySprite
; ===========================================================================

Obj09_Exit2:				; XREF: Obj09_Index
		subq.w	#1,$38(a0)
		bne.s	loc_1BC40
		move.b	#$C,($FFFFF600).w

loc_1BC40:
		jsr	Sonic_Animate
		jsr	LoadSonicDynPLC
		bsr	SS_FixCamera
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

Obj09_EasterEggSpecial:
		move.l	obY(a0),d2
		move.l	obX(a0),d3
		move.b	($FFFFF780).w,d0
		andi.b	#$FC,d0
		jsr	(CalcSine).l
	;	move.w	obVelX(a0),d4
		moveq	#0,d4
		ext.l	d4
		asl.l	#8,d4
	;	muls.w	#$2A,d0
		muls.w	#$160,d0
		add.l	d4,d0
	;	move.w	obVelY(a0),d4
		moveq	#0,d4
		ext.l	d4
		asl.l	#8,d4
	;	muls.w	#$2A,d1
		muls.w	#$160,d1
		add.l	d4,d1
		add.l	d0,d3
		bsr	Obj09_Collision
		beq.w	loc_1BCB0
		sub.l	d0,d3
		moveq	#0,d0
		move.w	d0,obVelX(a0)
		bclr	#1,obStatus(a0)
		add.l	d1,d2
		bsr	Obj09_Collision
		beq.w	loc_1BCC6
		sub.l	d1,d2
		moveq	#0,d1
		move.w	d1,obVelY(a0)
		rts
;-------------

Obj09_Fall:				; XREF: Obj09_OnWall; Obj09_InAir
		tst.b	($FFFFFF5F).w	; is this the blackout blackout special stage?
		bne.w	Obj09_EasterEggSpecial
		tst.b	($FFFFFFBF).w
		bne.s	O9F_Return

		move.l	obY(a0),d2
		move.l	obX(a0),d3
		move.b	($FFFFF780).w,d0
	;	andi.b	#$FC,d0
		jsr	(CalcSine).l
		move.w	obVelX(a0),d4
		ext.l	d4
		asl.l	#8,d4
		muls.w	#$2A,d0
		add.l	d4,d0
		move.w	obVelY(a0),d4
		ext.l	d4
		asl.l	#8,d4
		muls.w	#$2A,d1
		add.l	d4,d1
		add.l	d0,d3
		bsr	Obj09_Collision
		beq.s	loc_1BCB0
		sub.l	d0,d3
		moveq	#0,d0
		move.w	d0,obVelX(a0)
		bclr	#1,obStatus(a0)
		add.l	d1,d2
		bsr	Obj09_Collision
		beq.s	loc_1BCC6
		sub.l	d1,d2
		moveq	#0,d1
		move.w	d1,obVelY(a0)
O9F_Return:
		rts	
; ===========================================================================

loc_1BCB0:
		add.l	d1,d2
		bsr	Obj09_Collision
		beq.s	loc_1BCD4
		sub.l	d1,d2
		moveq	#0,d1
		move.w	d1,obVelY(a0)
		bclr	#1,obStatus(a0)

loc_1BCC6:
		asr.l	#8,d0
		asr.l	#8,d1
		move.w	d0,obVelX(a0)
		move.w	d1,obVelY(a0)
		rts	
; ===========================================================================

loc_1BCD4:
		asr.l	#8,d0
		asr.l	#8,d1
		move.w	d0,obVelX(a0)
		move.w	d1,obVelY(a0)
		bset	#1,obStatus(a0)
		rts	
; End of function Obj09_Fall


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_Collision:				; XREF: Obj09_Move; Obj09_Fall
		lea	($FF0000).l,a1      ; the magic buffer of doom
		moveq	#0,d4
		swap	d2
		move.w	d2,d4
		swap	d2
		addi.w	#$44,d4
		divu.w	#$18,d4
		mulu.w	#$80,d4
		adda.l	d4,a1
		moveq	#0,d4
		swap	d3
		move.w	d3,d4
		swap	d3
		addi.w	#$14,d4
		divu.w	#$18,d4
		adda.w	d4,a1

		; collision basically works by taking a 2x2 grid
		; of the four nearest blocks to Sonic and checking them one by one
		moveq	#0,d5		; set to no collision detected
		move.b	(a1)+,d4	; get top left block
		bsr.s	Obj09_ColCheck
		move.b	(a1)+,d4	; get top right block
		bsr.s	Obj09_ColCheck
		adda.w	#$7E,a1		; go to next row
		move.b	(a1)+,d4	; get bottom left block
		bsr.s	Obj09_ColCheck
		move.b	(a1)+,d4	; get bottom right block
		bsr.s	Obj09_ColCheck
		tst.b	d5		; set ccr for whether we hit anything (0 no, 1 yes)
		rts	
; End of function Obj09_Collision


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_ColCheck:				; XREF: Obj09_Collision
		beq.s	@notsolid    	; if current block is just an empty space, branch

		cmpi.b	#$3A,d4		; is block in range $3A-$4B (rings, emeralds...)?
		blo.s	@solid		; if not, it's a solid block0
		cmpi.b	#$4B,d4		; $4B is the end of shiny collectibles
		blo.s	@notsolid
@solid:
		move.b	d4,$30(a0)	; copy collided ID of block to d4
		move.l	a1,$32(a0)	; copy RAM location of collided block to a1
		cmpi.b	#$27,d4		; is object a goal block?
		beq.s	@goalradius   	; if yes, don't collide normally (special logic is run from the block itself)
@setsolid:	moveq	#-1,d5		; set to block
@notsolid:
		rts			; block is not solid

@goalradius:		
 		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		bne.s	@setsolid		; if yes, make sure we don't suck by this alternate collision
		tst.b	$31(a0)				; has goal already been touched?
		bne.s	@notsolid			; if so, bypass another check
		movem.l	d0-d2,-(sp)			; store registers
		bsr.w	Obj09_RadiusGoal		; has Sonic touched the goal?
		movem.l	(sp)+,d0-d2			; restore registers
		sls.b	$31(a0)				; mark goal as touched or not
		bls.s	@Touch				; if so, branch
		rts					; no touch

@Touch:
		move.b	d4,$30(a0)
		addq.w	#4,sp				; force this block to be touched only
		tst.b	d5				; check collision for return
		rts					; done
; End of function Obj09_ColCheck


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Obj09_ChkItems_Collectible:			; XREF: Obj09_Display
		tst.b	$31(a0)				; was the goal touched during wall detection?
		bne.w	Obj09_TouchGoal			; if so, bypass all checks and go straight to goal reaction
		lea	($FF0000).l,a1
		moveq	#0,d4
		move.w	obY(a0),d4
		addi.w	#$50,d4
		divu.w	#$18,d4
		mulu.w	#$80,d4
		adda.l	d4,a1
		moveq	#0,d4
		move.w	obX(a0),d4
		addi.w	#$20,d4
		divu.w	#$18,d4
		adda.w	d4,a1
		move.b	(a1),d4			; load nearest items to Sonic into d4
		bne.s	Obj09_ChkRing		; if it's not empty, begin checking which item we hit

		tst.b	$3A(a0)			; are ghost blocks set to be made solid?
		bne.w	Obj09_MakeGhostSolid	; if yes, make them solid
		moveq	#0,d4			; set to no collision
		rts	
; ===========================================================================

Obj09_ChkRing:
		cmpi.b	#$3A,d4		; is the item a	ring?
		bne.s	Obj09_Chk1Up
		bsr	SS_RemoveCollectedItem
		bne.s	Obj09_GetCont
		move.b	#1,(a2)
		move.l	a1,obMap(a2)

Obj09_GetCont:
		move.b	#0,($FF244A).l
		move.b	#0,($FF24CA).l
		move.b	#0,($FF254A).l
		move.b	#0,($FF25CA).l
		
		jsr	CollectRing
		tst.b	($FFFFFF5F).w	; is this the blackout blackout special stage?
		beq.s	@cont
		move.w	#$B7,d0
		jsr	(PlaySound).l	; play rumbling sound

@cont:
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_Chk1Up:
		cmpi.b	#$28,d4		; is the item an extra life?
		bne.s	Obj09_ChkEmer
		bsr	SS_RemoveCollectedItem
		bne.s	Obj09_Get1Up
		move.b	#3,(a2)
		move.l	a1,obMap(a2)

Obj09_Get1Up:
		addq.w	#1,($FFFFFE12).w ; add 1 to number of lives
		addq.b	#1,($FFFFFE1C).w ; add 1 to lives counter
		move.w	#$C5,d0
		jsr	(PlaySound).l	; play extra life music
		moveq	#0,d4
		rts	
; ===========================================================================

Obj09_ChkEmer:
		cmpi.b	#$3B,d4		; is the item an emerald?
		bcs.w	Obj09_ChkGhost
		cmpi.b	#$40,d4
		bhi.w	Obj09_ChkGhost
		bsr	SS_RemoveCollectedItem
		move.l	a1,4(a2)
		move.b	#1,(a2)

		addq.b	#1,($FFFFFE57).w ; add 1 to number of emeralds

		cmpi.b	#4,($FFFFFE57).w ; do you have all the emeralds?
		beq.s	Emershit
		cmpi.w	#$401,($FFFFFE10).w	; is this Unreal Place?
		bne.s	Obj09_EmerNotAll
		cmpi.b	#2,($FFFFFE57).w ; do you have all the emeralds?
		bne.s	Obj09_EmerNotAll

		; load part 2 of the blackout challenge
		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		beq.s	Emershit		; if not, branch
		move.w	obX(a0),($FFFFFF86).w	; save Sonic's X-position
		move.w	obY(a0),($FFFFFF88).w	; save Sonic's Y-position
		movem.l	a0-a2,-(sp)
		jsr	WhiteFlash2
		lea	(SS_Blackout_Part2).l,a0 ; load part 2 blackout layout
		jsr	SS_LoadLevel
		movem.l	(sp)+,a0-a2
		move.b	#$DD,d0
		jsr	(PlaySound).l
		move.w	#$E2,d0
		bra.s	Obj09_EmerPlaySound

Emershit:
		move.b	#1,($FFFFF7CC).w	; lock controls
		move.w	#$8014,($C00004).l	; enable h-ints for the black bars

		move.b	#5,(a2)			; this is important to end the stage
		move.w	#$88,d0			; play special stage beaten jingle
		bra.s	Obj09_EmerPlaySound

Obj09_EmerNotAll:
		move.w	#$C5,d0			; play single emerald collected sound
		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		beq.s	Obj09_EmerPlaySound	; if not, branch
		move.w	#$A6,d0			; play spike hurt sound instead

Obj09_EmerPlaySound:
		jsr	(PlaySound_Special).l	; play music
		moveq	#0,d4
		rts
; ===========================================================================

Obj09_ChkGhost:
		cmpi.b	#$41,d4			; is the item a	ghost block?
		bne.w	@end			; if not, branch
		
		moveq	#-1,d4			; mark ghost blocks as non solid

		move.w	#$A1,d0			; set checkpoint sound
		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		beq.s	@cont			; if not, branch
		move.w	#$B2,d0			; set drown sound
@cont:		jsr	(PlaySound_Special).l	; play it

		move.w	obX(a0),($FFFFFF86).w	; save Sonic's X-position
		move.w	obY(a0),($FFFFFF88).w	; save Sonic's Y-position

		bsr	SS_RemoveCollectedItem	; prepare removing code
		bne.s	@nocollect		; if it's impossible branch	
		move.b	#3,(a2)			; overwrite...
		move.l	a1,4(a2)		; ...it with ring collection animation

@nocollect:
		; shitty old code that attempts to collect multiple checkpoints at once
		; there's about a 50/50 chance it works and I never figured out why
	;	moveq	#0,d4			; clear d4

		cmpi.b	#$41,1(a1)
		bne.s	@cont1
		move.b	#0,1(a1)
		move.b	#3,8(a2)
		move.l	a1,4(a2)
		addq.l	#1,4(a2)
		addq.w	#8,a2

@cont1:
		cmpi.b	#$41,-1(a1)
		bne.s	@cont2
		move.b	#0,-1(a1)
                move.b  #3,8(a2)
                move.l  a1,4(a2)
                subq.l  #1,4(a2)
		addq.w	#8,a2

@cont2:
		cmpi.b	#$41,2(a1)
		bne.s	@cont3
		move.b	#0,2(a1)
                move.b  #3,8(a2)
                move.l  a1,4(a2)
                addq.l  #2,4(a2)
		addq.w	#8,a2

@cont3:
		cmpi.b	#$41,-2(a1)
		bne.s	@end
		move.b	#0,-2(a1)
		move.b	#0,2(a1)
                move.b  #3,8(a2)
                move.l  a1,4(a2)
                subq.l  #2,4(a2)

@end:
		rts
; ===========================================================================

Obj09_ChkItems_Solid:		; I never understood why this is a subroutine
		move.b	$30(a0),d0	; get ID of collided item
		bne.s	Obj09_ChkGOAL	; if it isn't empty, start check

		tst.b	$36(a0)
		beq.s	locret_1BEAC
		subq.b	#1,$36(a0)	; subtract 1 from disabled block timer (after touching R, up, down)

locret_1BEAC:
		rts	
; ===========================================================================

Obj09_RadiusGoal:
		move.w	$34(a0),d2			; load layout address
		subq.w	#$01,d2				; align to first block
		moveq	#$7F,d1				; get only X range of the layout
		and.w	d2,d1				; ''
		lsr.w	#$07,d2				; get only Y range of the layout
		moveq	#24,d0				; multiply positions by 24 pixels
		mulu.w	d0,d1				; '' for X
		mulu.w	d0,d2				; '' for Y
		addi.w	#(24/2)-$20,d1			; get centre position of block (minus $10 discrepency of Sonic's X)
		addi.w	#(24/2)-$50,d2			; '' (minus $58 discrepency of Sonic's Y)
		sub.w	obX(a0),d1			; get relative to Sonic on X
		bpl.s	.PosX				; keep positive
		neg.w	d1				; ''
	.PosX:	sub.w	obY(a0),d2			; get relative to Sonic on Y
		bpl.s	.PosY				; keep positive
		neg.w	d2				; ''
	.PosY:	mulu.w	d1,d1				; setup pythagorean
		mulu.w	d2,d2				; ''
		add.l	d1,d2				; ''
		cmpi.l	#((24+24)/2)*((24+24)/2),d2	; is Sonic touching the goal circularly?
		rts					; return touch status
; ===========================================================================

; Obj09_GOAL:
Obj09_ChkGOAL:
		cmpi.b	#$27,d0			; is the item a	"GOAL"?
		bne.w	Obj09_ChkBumper		; if not, branch
 		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		bne.w	Obj09_DoBumper		; if yes, convert goal block into bumber
		bsr.s	Obj09_RadiusGoal		; has Sonic touched the goal?
		bls.s	Obj09_TouchGoal			; if so, branch
		rts					; no touch

Obj09_TouchGoal:
		sf.b	$31(a0)				; clear goal touch flag

TouchGoalBlock:
		jsr	WhiteFlash2

		move.w	($FFFFFF86).w,obX(a0)	; restore saved X-pos
		move.w	($FFFFFF88).w,obY(a0)	; restore saved Y-pos

		clr.w	obVelX(a0)
		clr.w	obVelY(a0)
		clr.w	obInertia(a0)

		move.w	#$C3,d0			; play giant ring sound by default

		cmpi.w	#$401,($FFFFFE10).w	; are we in Unreal Place?
		beq.s	TouchGoal_Unreal	; if yes, branch

		; restoration for Special Place
		clr.w	($FFFFF780).w		; clear rotation
		clr.b	($FFFFFF9F).w		; make R block usable again

		tst.b	($FFFFFFD6).w		; has W block already been touched?
		beq.s	@notw			; if not, branch
		move.b	#0,($FF11AC).l		; remove blocks next to first R blocks
		move.b	#0,($FF122C).l		; remove blocks next to first R blocks

@notw:
		move.b	#$2F,($FF1DA7).l	; restore yellow glass block
		frantic				; are we in frantic?
		bne.w	TouchGoal_PlaySound	; skip the pink glass block
		move.b	#$30,($FF1C28).l	; restore pink glass block
		bra.w	TouchGoal_PlaySound

TouchGoal_Unreal:
		tst.b	($FFFFFF5F).w	; is this the blackout blackout special stage?
		beq.s	@notblackout		; if not, branch
		cmpi.b	#2,($FFFFFE57).w	; are we in part 2?
		beq.s	@norestore		; if yes, branch
		clr.b	($FFFFFE57).w		; clear emerald counter
		move.b	#$3F,($FF11BD).l	; restore red emerald
		move.b	#$40,($FF11C1).l	; restore grey emerald
		move.b	#$3A,($FF1EC7).l	; reset ring to open glass blocks door
		move.b	#$2F,($FF24CA).l	; reset glass blocks
		move.b	#$2F,($FF254A).l
		move.b	#$2F,($FF25CA).l
@norestore:
		move.w	#$B9,d0			; play annoying crumbling sound instead
		jsr	PlaySound		; play sound
		move.w	#$DB,d0			; play annoying crumbling sound instead
		bra.s	TouchGoal_PlaySound

@notblackout:
		clr.b	($FFFFFE57).w		; clear emerald counter
		move.b	#$3F,($FF11BD).l	; restore red emerald
		move.b	#$40,($FF11C1).l	; restore grey emerald
		move.b	#$3A,($FF1EC7).l	; reset ring to open glass blocks door
		move.b	#$2D,($FF244A).l	; reset glass blocks
		move.b	#$2E,($FF24CA).l
		move.b	#$2F,($FF254A).l
		move.b	#$30,($FF25CA).l

TouchGoal_PlaySound:
		jmp	PlaySound_Special	; play selected sound
; ===========================================================================

Obj09_ChkBumper:
		cmpi.b	#$25,d0		; is the item a	bumper?
		bne.w	Obj09_ChkW
Obj09_DoBumper:
		move.l	$32(a0),d1
		subi.l	#$FF0001,d1
		move.w	d1,d2
		andi.w	#$7F,d1
		mulu.w	#$18,d1
		subi.w	#$14,d1
		lsr.w	#7,d2
		andi.w	#$7F,d2
		mulu.w	#$18,d2
		subi.w	#$44,d2
		sub.w	obX(a0),d1
		sub.w	obY(a0),d2
		jsr	(CalcAngle).l
		jsr	(CalcSine).l
		muls.w	#-$100,d1
		asr.l	#8,d1
		move.w	d1,obVelX(a0)
		muls.w	#-$100,d0
		asr.l	#8,d0
		move.w	d0,obVelY(a0)
		bset	#1,obStatus(a0)
		bclr	#7,obStatus(a0)	; clear "Sonic has jumped" flag

		tst.b	($FFFFFFBF).w		; Unreal Place floating challenge enabled?
		beq.s	@notnonstopinhuman	; if not, branch
		btst	#4,(OptionsBits).w	; is nonstop inhuman enabled?
		beq.s	@notnonstopinhuman	; if not, branch
		clr.w	obVelX(a0)		; clear Sonic's X velocity
		clr.w	obInertia(a0)		; clear Sonic's inertia

@notnonstopinhuman:
		bsr	SS_RemoveCollectedItem
		bne.s	Obj09_BumpSnd
		move.b	#2,(a2)
		move.l	$32(a0),d0
		subq.l	#1,d0
		move.l	d0,obMap(a2)

Obj09_BumpSnd:
		move.w	#$B4,d0
		jmp	(PlaySound_Special).l ;	play bumper sound
; ===========================================================================

Obj09_ChkW:
		cmpi.b	#$26,d0 	; is the item a	W-block?
		bne.s	Obj09_UPblock
		cmpi.b	#2,($FFFFFFD6).w	; has W block already been touched?
		beq.s	Obj09_ChkW_NoChange	; if yes, branch
		move.b	#1,($FFFFFFD6).w	; change every goal block into a normal one

		move.w	obX(a0),($FFFFFF86).w	; save Sonic's X-position
		move.w	obY(a0),($FFFFFF88).w	; save Sonic's Y-position
		
		move.w	#$C3,d0			; play giant ring sound
		jsr	(PlaySound_Special).l

Obj09_ChkW_NoChange:
		rts
; ===========================================================================

Obj09_UPblock:
		cmpi.b	#$29,d0			; is the item an "UP" block?
		bne.w	Obj09_DOWNblock		; if not, branch

		tst.b	$36(a0)			; has an up block been touched recently?
		bne.w	Obj09_ChkItemsEnd		; if yes, branch
		move.b	#$1E,$36(a0)		; disable interaction with this block $1E frames
		
		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		bne.s	Obj09_UPsnd		; if yes, branch

		move.w	#$D9,d0			; set sound to D9 (bleep)
		tst.b	($FFFFFFBF).w		; is Unreal Place floating challenge already active?
		bne.s	Obj09_UPsnd		; if yes, branch
		move.w	#$9A,d0			; set music to 9A
		jsr	(PlaySound).l		; play

		move.b	#$27,($FF2AA6).l	; block off the entrance you came from 1
		move.b	#$27,($FF2B26).l	; block off the entrance you came from 2
		move.b	#$27,($FF2BA6).l	; block off the entrance you came from 3
		
		move.w	#$0000,($FFFFFB40).w	; make background black

		move.w	#$C3,d0			; play giant ring collected sound

Obj09_UPsnd:
		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		beq.s	@conty			; if not, branch
		addi.w	#$8000,($FFFFF780).w	; rotate screen by 180 degrees
		move.w	#$BB,d0			; play flip sound
		bra.s	Obj09_UPsnd2		; go to sound

@conty:
		move.w	#-Unreal_Speed,obVelY(a0) ; move Sonic upwards

Obj09_UPsnd2:
		move.b	#1,($FFFFFFBF).w	; set Unreal Place floating challenge flag
		jmp	(PlaySound_Special).l	; play sound
; ===========================================================================

Obj09_DOWNblock:
		cmpi.b	#$2A,d0		; is the item a	"DOWN" block?
		bne.s	Obj09_Rblock
		tst.b	$36(a0)
		bne.w	Obj09_ChkItemsEnd
		move.b	#$1E,$36(a0)
	;	btst	#6,($FFFFF783).w
	;	bne.s	Obj09_DOWNsnd
		move.b	#2,($FFFFFFBF).w
		tst.b	($FFFFFF5F).w	; is this the blackout blackout special stage?
		beq.s	@conty
		addi.w	#$8000,($FFFFF780).w
		move.w	#$BB,d0
		bra.s	Obj09_DOWNsnd
@conty:

		move.w	#Unreal_Speed,obVelY(a0) ; move Sonic downwards
		move.w	#$DA,d0


Obj09_DOWNsnd:
		jmp	(PlaySound_Special).l ;	play up/down sound
; ===========================================================================

Obj09_Rblock:
		cmpi.b	#$2B,d0		; is the item an "R" block?
		bne.s	Obj09_ChkGlass
		tst.b	$36(a0)
		bne.w	Obj09_ChkItemsEnd
		move.b	#$1E,$36(a0)
		bsr	SS_RemoveCollectedItem
		bne.s	Obj09_RevStage
		move.b	#4,(a2)
		move.l	$32(a0),d0
		subq.l	#1,d0
		move.l	d0,obMap(a2)

Obj09_RevStage:
		move.b	#1,($FFFFFF9F).w	; set flag
		tst.b	($FFFFFFD6).w
		beq.s	@cont
		move.b	#1,($FF11AC).l		; place blocks next to R blocks
		move.b	#1,($FF122C).l		; place blocks next to R blocks

@cont:
		move.w	#$C3,d0			; set giant ring sound
		jmp	(PlaySound_Special).l	; play it
; ===========================================================================

Obj09_ChkGlass:
		cmpi.b	#$2D,d0		; is the item a	glass block?
		beq.s	Obj09_Glass	; if yes, branch
		cmpi.b	#$2E,d0
		beq.s	Obj09_Glass
		cmpi.b	#$2F,d0
		beq.s	Obj09_Glass
		cmpi.b	#$30,d0
		bne.s	Obj09_ChkItemsEnd	; if not, branch

Obj09_Glass:
		cmpi.w	#$401,($FFFFFE10).w	; are we in Unreal?
		bne.s	@regular		; if not, branch
		rts				; glass blocks are decorative walls only
@regular:
		bsr	SS_RemoveCollectedItem
		bne.s	Obj09_GlassSnd
		move.b	#6,(a2)
		movea.l	$32(a0),a1
		subq.l	#1,a1
		move.l	a1,obMap(a2)
		move.b	(a1),d0
		addq.b	#1,d0		; change glass type when touched
		cmpi.b	#$30,d0
		bls.s	Obj09_GlassUpdate ; if glass is	still there, branch
		clr.b	d0		; remove the glass block when it's destroyed

Obj09_GlassUpdate:
		move.b	d0,obMap(a2)	; update the stage layout

Obj09_GlassSnd:
		move.w	#$BA,d0
		jmp	(PlaySound_Special).l ;	play glass block sound
; ===========================================================================

Obj09_ChkItemsEnd:
		rts	
; End of function Obj09_ChkItems_Solid

; ===========================================================================
; ===========================================================================


; ===========================================================================

Obj09_Rotation:
		move.b	#$81,($FFFFF7C8).w	; lock controls
		clr.w	obVelX(a0)			; clear Sonic's X-speed
		clr.w	obVelY(a0)			; clear Sonic's Y-speed
		add.w	#$400,($FFFFF780).w	; increase stage-rotation by $400
		tst.b	($FFFFFFD6).w
		bne.s	@cont
		cmpi.w	#$8000,($FFFFF780).w	; is rotation = $8000?
		bne.s	Obj09_Rot_End		; if not, branch
		bra.s	@cont2

@cont:
		tst.w	($FFFFF780).w		; is rotation = $0000?
		bne.s	Obj09_Rot_End		; if not, branch

@cont2:
		move.b	#2,($FFFFFF9F).w	; tell the game, the process is done
		clr.b	($FFFFF7C8).w		; unlock controls

Obj09_Rot_End:
		rts				; return
; ===========================================================================

Obj09_MakeGoalSolid:
		lea	($FF1020).l,a1		; load SS blocks (layout?) into a1
		moveq	#$3F,d1			; set normal loop

Obj09_GoalLoop2:
		moveq	#$3F,d2			; set alternate loop

Obj09_GoalLoop:
		cmpi.b	#$27,(a1)		; is the item a	goal block?
		bne.s	Obj09_NoReplace2	; if not, branch

		move.b	#$2C,(a1)		; replace goal block with a solid block

Obj09_NoReplace2:
		addq.w	#1,a1			; go to next block
		dbf	d2,Obj09_GoalLoop	; loop
		lea	$40(a1),a1		; increase pointer by $40
		dbf	d1,Obj09_GoalLoop2	; loop

Obj09_GoalNotSolid:
		moveq	#0,d4			; clear d4

		btst	#7,(OptionsBits).w	; are flashy lights enabled?
		beq.s	@noflash		; if not, no flash
	;	movem.l	d0-a7,-(sp)		; backup to stack
	;	jsr	Pal_MakeWhite		; make white flash
	;	movem.l (sp)+,d0-a7		; restore from stack
		jsr	WhiteFlash2
@noflash:
		move.b	#2,($FFFFFFD6).w	; make sure it doesn't happen again

		tst.b	($FFFFFF5F).w		; is this the blackout blackout special stage?
		beq.s	@notblackout		; if not, branch

		move.b	#1,($FFFFF7CC).w	; lock controls
		move.w	#$8014,($C00004).l	; enable h-ints for the black bars

		bsr	SS_RemoveCollectedItem
		move.b	#5,(a2)			; this is important to end the stage
		rts

@notblackout:
		move.b	#0,($FF1C28).l		; make sure there is no pink glass block
		move.b	#0,($FF1DA7).l		; make sure there is no yellow glass block

		move.b	#1,($FF1E2C).l		; place block
		move.b	#1,($FF1EAC).l		; place block
		move.b	#1,($FF1F2C).l		; place block

		move.b	#0,($FF1FAD).l		; remove blocks over emerald cave
		move.b	#0,($FF1FAE).l		; remove blocks over emerald cave

		move.b	#1,($FF12BD).l		; place blocks over W blocks
		move.b	#1,($FF12BE).l		; place blocks over W blocks

		move.b	#0,($FF11BC).l		; remove blocks next to W blocks
		move.b	#0,($FF123C).l		; remove blocks next to W blocks

		move.b	#0,($FF11AC).l		; remove blocks next to R blocks
		move.b	#0,($FF122C).l		; remove blocks next to R blocks
		move.b	#0,($FF112A).l		; remove blocks next to R blocks
		move.b	#0,($FF112B).l		; remove blocks next to R blocks

		rts
; ===========================================================================

Obj09_MakeGhostSolid:
		cmpi.b	#2,$3A(a0)	; is the ghost marked as "solid"?
		bne.s	Obj09_GhostNotSolid ; if not, branch

Obj09_MakeGhostSolid2:
		lea	($FF1020).l,a1
		moveq	#$3F,d1

Obj09_GhostLoop2:
		moveq	#$3F,d2

Obj09_GhostLoop:
		cmpi.b	#$41,(a1)	; is the item a	ghost block?
		bne.s	Obj09_NoReplace	; if not, branch
		move.b	#$2C,(a1)	; replace ghost	block with a solid block ($2C)

Obj09_NoReplace:
		addq.w	#1,a1
		dbf	d2,Obj09_GhostLoop
		lea	$40(a1),a1
		dbf	d1,Obj09_GhostLoop2

Obj09_GhostNotSolid:
		clr.b	$3A(a0)
		moveq	#0,d4
		rts
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 10 - Unused
; ---------------------------------------------------------------------------

Obj10:
		jmp	DeleteObject

; ---------------------------------------------------------------------------
; ===========================================================================


; ===========================================================================
; ---------------------------------------------------------------------------
; Subroutine to	animate	level graphics
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AniArt_Load:				; XREF: ; loc_F54
	;	tst.w	($FFFFF63A).w	; is the game paused?
	;	bne.s	AniArt_Pause	; if yes, branch
		lea	($C00000).l,a6
		bsr	AniArt_GiantRing
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0
		add.w	d0,d0
		move.w	AniArt_Index(pc,d0.w),d0
		jmp	AniArt_Index(pc,d0.w)
; ===========================================================================

AniArt_Pause:
		rts	
; End of function AniArt_Load

; ===========================================================================
AniArt_Index:	dc.w AniArt_GHZ-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_MZ-AniArt_Index, AniArt_none-AniArt_Index
		dc.w AniArt_none-AniArt_Index, AniArt_SBZ-AniArt_Index
		dc.w AniArt_Ending-AniArt_Index
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Green Hill
; ---------------------------------------------------------------------------

AniArt_GHZ:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B1).w
		bpl.s	loc_1C08A
		move.b	#5,($FFFFF7B1).w ; time	to display each	frame for
		lea	(Art_GhzWater).l,a1 ; load waterfall patterns
		move.b	($FFFFF7B0).w,d0
		addq.b	#1,($FFFFF7B0).w
		andi.w	#1,d0
		beq.s	loc_1C078
		lea	$100(a1),a1	; load next frame

loc_1C078:
		move.l	#$6F000001,($C00004).l ; VRAM address
		move.w	#7,d1		; number of 8x8	tiles
		bra.w	LoadTiles
; ===========================================================================

loc_1C08A:
		subq.b	#1,($FFFFF7B3).w
		bpl.s	loc_1C0C0
		move.b	#$F,($FFFFF7B3).w
		lea	(Art_GhzFlower1).l,a1 ;	load big flower	patterns
		move.b	($FFFFF7B2).w,d0
		addq.b	#1,($FFFFF7B2).w
		andi.w	#1,d0
		beq.s	loc_1C0AE
		lea	$200(a1),a1

loc_1C0AE:
		move.l	#$6B800001,($C00004).l
		move.w	#$F,d1
		bra.w	LoadTiles
; ===========================================================================

loc_1C0C0:
		subq.b	#1,($FFFFF7B5).w
		bpl.s	locret_1C10C
		move.b	#7,($FFFFF7B5).w
		move.b	($FFFFF7B4).w,d0
		addq.b	#1,($FFFFF7B4).w
		andi.w	#3,d0
		move.b	byte_1C10E(pc,d0.w),d0
		btst	#0,d0
		bne.s	loc_1C0E8
		move.b	#$7F,($FFFFF7B5).w

loc_1C0E8:
		lsl.w	#7,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		move.l	#$6D800001,($C00004).l
		lea	(Art_GhzFlower2).l,a1 ;	load small flower patterns
		lea	(a1,d0.w),a1
		move.w	#$B,d1
		bsr	LoadTiles

locret_1C10C:
		rts	
; ===========================================================================
byte_1C10E:	dc.b 0,	1, 2, 1
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Marble
; ---------------------------------------------------------------------------

AniArt_MZ:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B1).w
		bpl.s	loc_1C150
		move.b	#$13,($FFFFF7B1).w
		lea	(Art_MzLava1).l,a1 ; load lava surface patterns
		moveq	#0,d0
		move.b	($FFFFF7B0).w,d0
		addq.b	#1,d0
		cmpi.b	#3,d0
		bne.s	loc_1C134
		moveq	#0,d0

loc_1C134:
		move.b	d0,($FFFFF7B0).w
		mulu.w	#$100,d0
		adda.w	d0,a1
		move.l	#$5C400001,($C00004).l
		move.w	#7,d1
		bsr	LoadTiles

loc_1C150:
		subq.b	#1,($FFFFF7B3).w
		bpl.s	loc_1C1AE
		move.b	#1,($FFFFF7B3).w
		moveq	#0,d0
		move.b	($FFFFF7B0).w,d0
		lea	(Art_MzLava2).l,a4 ; load lava patterns
		ror.w	#7,d0
		adda.w	d0,a4
		move.l	#$5A400001,($C00004).l
		moveq	#0,d3
		move.b	($FFFFF7B2).w,d3
		addq.b	#1,($FFFFF7B2).w
		move.b	($FFFFFE68).w,d3
		move.w	#3,d2

loc_1C188:
		move.w	d3,d0
		add.w	d0,d0
		andi.w	#$1E,d0
		lea	(AniArt_MZextra).l,a3
		move.w	(a3,d0.w),d0
		lea	(a3,d0.w),a3
		movea.l	a4,a1
		move.w	#$1F,d1
		jsr	(a3)
		addq.w	#4,d3
		dbf	d2,loc_1C188
		rts	
; ===========================================================================

loc_1C1AE:
		subq.b	#1,($FFFFF7B5).w
		bpl.w	locret_1C1EA
		move.b	#7,($FFFFF7B5).w
		lea	(Art_MzTorch).l,a1 ; load torch	patterns
		moveq	#0,d0
		move.b	($FFFFF7B6).w,d0
		addq.b	#1,($FFFFF7B6).w
		andi.b	#3,($FFFFF7B6).w
		mulu.w	#$C0,d0
		adda.w	d0,a1
		move.l	#$5E400001,($C00004).l
		move.w	#5,d1
		bra.w	LoadTiles
; ===========================================================================

locret_1C1EA:
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - Scrap Brain
; ---------------------------------------------------------------------------

AniArt_SBZ:				; XREF: AniArt_Index
		rts	
; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - ending sequence
; ---------------------------------------------------------------------------

AniArt_Ending:				; XREF: AniArt_Index
		subq.b	#1,($FFFFF7B3).w
		bpl.s	loc_1C2F4
		move.b	#7,($FFFFF7B3).w
		lea	(Art_GhzFlower1).l,a1 ;	load big flower	patterns
		lea	($FFFF9400).w,a2
		move.b	($FFFFF7B2).w,d0
		addq.b	#1,($FFFFF7B2).w
		andi.w	#1,d0
		beq.s	loc_1C2CE
		lea	$200(a1),a1
		lea	$200(a2),a2

loc_1C2CE:
		move.l	#$6B800001,($C00004).l
		move.w	#$F,d1
		bsr	LoadTiles
		movea.l	a2,a1
		move.l	#$72000001,($C00004).l
		move.w	#$F,d1
		bra.w	LoadTiles
; ===========================================================================

loc_1C2F4:
		subq.b	#1,($FFFFF7B5).w
		bpl.s	loc_1C33C
		move.b	#7,($FFFFF7B5).w
		move.b	($FFFFF7B4).w,d0
		addq.b	#1,($FFFFF7B4).w
		andi.w	#7,d0
		move.b	byte_1C334(pc,d0.w),d0
		lsl.w	#7,d0
		move.w	d0,d1
		add.w	d0,d0
		add.w	d1,d0
		move.l	#$6D800001,($C00004).l
		lea	(Art_GhzFlower2).l,a1 ;	load small flower patterns
		lea	(a1,d0.w),a1
		move.w	#$B,d1
		bra.w	LoadTiles
; ===========================================================================
byte_1C334:	dc.b 0,	0, 0, 1, 2, 2, 2, 1
; ===========================================================================

loc_1C33C:
		subq.b	#1,($FFFFF7B9).w
		bpl.s	loc_1C37A
		move.b	#$E,($FFFFF7B9).w
		move.b	($FFFFF7B8).w,d0
		addq.b	#1,($FFFFF7B8).w
		andi.w	#3,d0
		move.b	byte_1C376(pc,d0.w),d0
		lsl.w	#8,d0
		add.w	d0,d0
		move.l	#$70000001,($C00004).l
		lea	($FFFF9800).w,a1 ; load	special	flower patterns	(from RAM)
		lea	(a1,d0.w),a1
		move.w	#$F,d1
		bra.w	LoadTiles
; ===========================================================================
byte_1C376:	dc.b 0,	1, 2, 1
; ===========================================================================

loc_1C37A:
		subq.b	#1,($FFFFF7BB).w
		bpl.s	locret_1C3B4
		move.b	#$B,($FFFFF7BB).w
		move.b	($FFFFF7BA).w,d0
		addq.b	#1,($FFFFF7BA).w
		andi.w	#3,d0
		move.b	byte_1C376(pc,d0.w),d0
		lsl.w	#8,d0
		add.w	d0,d0
		move.l	#$68000001,($C00004).l
		lea	($FFFF9E00).w,a1 ; load	special	flower patterns	(from RAM)
		lea	(a1,d0.w),a1
		move.w	#$F,d1
		bra.w	LoadTiles
; ===========================================================================

locret_1C3B4:
		rts	
; ===========================================================================

AniArt_none:				; XREF: AniArt_Index
		rts	

; ---------------------------------------------------------------------------
; Subroutine to	load (d1 - 1) 8x8 tiles
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


LoadTiles:
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		move.l	(a1)+,(a6)
		dbf	d1,LoadTiles
		rts	
; End of function LoadTiles

; ===========================================================================
; ---------------------------------------------------------------------------
; Animated pattern routine - more Marble Zone
; ---------------------------------------------------------------------------
AniArt_MZextra:	dc.w loc_1C3EE-AniArt_MZextra, loc_1C3FA-AniArt_MZextra
		dc.w loc_1C410-AniArt_MZextra, loc_1C41E-AniArt_MZextra
		dc.w loc_1C434-AniArt_MZextra, loc_1C442-AniArt_MZextra
		dc.w loc_1C458-AniArt_MZextra, loc_1C466-AniArt_MZextra
		dc.w loc_1C47C-AniArt_MZextra, loc_1C48A-AniArt_MZextra
		dc.w loc_1C4A0-AniArt_MZextra, loc_1C4AE-AniArt_MZextra
		dc.w loc_1C4C4-AniArt_MZextra, loc_1C4D2-AniArt_MZextra
		dc.w loc_1C4E8-AniArt_MZextra, loc_1C4FA-AniArt_MZextra
; ===========================================================================

loc_1C3EE:				; XREF: AniArt_MZextra
		move.l	(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C3EE
		rts	
; ===========================================================================

loc_1C3FA:				; XREF: AniArt_MZextra
		move.l	obGfx(a1),d0
		move.b	obRender(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C3FA
		rts	
; ===========================================================================

loc_1C410:				; XREF: AniArt_MZextra
		move.l	obGfx(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C410
		rts	
; ===========================================================================

loc_1C41E:				; XREF: AniArt_MZextra
		move.l	obMap(a1),d0
		move.b	3(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C41E
		rts	
; ===========================================================================

loc_1C434:				; XREF: AniArt_MZextra
		move.l	obMap(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C434
		rts	
; ===========================================================================

loc_1C442:				; XREF: AniArt_MZextra
		move.l	6(a1),d0
		move.b	5(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C442
		rts	
; ===========================================================================

loc_1C458:				; XREF: AniArt_MZextra
		move.l	6(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C458
		rts	
; ===========================================================================

loc_1C466:				; XREF: AniArt_MZextra
		move.l	obX(a1),d0
		move.b	7(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C466
		rts	
; ===========================================================================

loc_1C47C:				; XREF: AniArt_MZextra
		move.l	obX(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C47C
		rts	
; ===========================================================================

loc_1C48A:				; XREF: AniArt_MZextra
		move.l	obScreenY(a1),d0
		move.b	9(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C48A
		rts	
; ===========================================================================

loc_1C4A0:				; XREF: AniArt_MZextra
		move.l	obScreenY(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C4A0
		rts	
; ===========================================================================

loc_1C4AE:				; XREF: AniArt_MZextra
		move.l	obY(a1),d0
		move.b	$B(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C4AE
		rts	
; ===========================================================================

loc_1C4C4:				; XREF: AniArt_MZextra
		move.l	obY(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C4C4
		rts	
; ===========================================================================

loc_1C4D2:				; XREF: AniArt_MZextra
		move.l	obY(a1),d0
		rol.l	#8,d0
		move.b	0(a1),d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C4D2
		rts	
; ===========================================================================

loc_1C4E8:				; XREF: AniArt_MZextra
		move.w	$E(a1),(a6)
		move.w	0(a1),(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C4E8
		rts	
; ===========================================================================

loc_1C4FA:				; XREF: AniArt_MZextra
		move.l	0(a1),d0
		move.b	$F(a1),d0
		ror.l	#8,d0
		move.l	d0,(a6)
		lea	obVelX(a1),a1
		dbf	d1,loc_1C4FA
		rts	

; ---------------------------------------------------------------------------
; Animated pattern routine - giant ring
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AniArt_GiantRing:			; XREF: AniArt_Load
		cmpi.w	#1,($FFFFF7BE).w	; are giant ring patterns set to be loaded for the first time?
		beq.s	@loadgiantringart	; if yes, branch
		rts

@loadgiantringart:
		VBlank_SetMusicOnly
		lea	(PLC_GiantRing).l,a1
		jsr	LoadPLC_Direct
		VBlank_UnsetMusicOnly
		ori.w	#2,($FFFFF7BE).w		; make sure art doesn't get loaded again
		rts
; ---------------------------------------------------------------------------
PLC_GiantRing:
		dc.l ArtKospM_BigRing
		dc.w $8000
		dc.l ArtKospM_RingFlash
		dc.w $8C40
		dc.w -1
; End of function AniArt_GiantRing

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 4F - Warning signs for bottomless pits (SAP)
; ---------------------------------------------------------------------------

Obj4F:
		moveq	#0,d0			; clear d0
		move.b	obRoutine(a0),d0		; move routine counter to d0
		move.w	Obj4F_Index(pc,d0.w),d1 ; move the index to d1
		jmp	Obj4F_Index(pc,d1.w)	; find out the current position in the index
; ===========================================================================
Obj4F_Index:	dc.w Obj4F_Setup-Obj4F_Index		; Set up the object (art etc.)		[$0]
		dc.w Obj4F_ChkDisplay-Obj4F_Index	; Make the object flashing (Main Code)	[$2]
; ===========================================================================

Obj4F_Setup:
		addq.b	#2,obRoutine(a0)
		move.l	#Map_Obj4F,obMap(a0)
		move.w	#$6400/$20,obGfx(a0)
		move.b	#$84,obRender(a0)
		move.b	#3,obPriority(a0)
		move.b	#$F,obHeight(a0)
		move.b	#$F,obWidth(a0)
		move.b	#$F,obActWid(a0)

		move.w	obY(a0),$32(a0)		; set base Y position for sway
		jsr	RandomNumber
		andi.w	#$7F,d0
		move.w	d0,$34(a0)		; random offset for the sway
; ---------------------------------------------------------------------------

Obj4F_ChkDisplay:
		move.w	($FFFFFE04).w,d0
		add.w	$34(a0),d0
		jsr	(CalcSine).l
		asr.w	#5,d0
		add.w	$32(a0),d0
		move.w	d0,obY(a0)
	;	bsr	Obj4F_FixPosition	; looked like ass, static objects are better
		jmp	MarkObjGone		; display sprite
; ---------------------------------------------------------------------------

Obj4F_FixPosition:
		move.w	($FFFFD008).w,d0
		addi.w	#8,d0
		move.w	d0,obX(a0)
		
		move.w	($FFFFF704).w,d0
		addi.w	#224-32,d0
		move.w	d0,obY(a0)
		rts
; ===========================================================================

Map_Obj4F:	include	"_maps\SLZWarningSign.asm"
; ---------------------------------------------------------------------------
; ===========================================================================

; ===========================================================================
; ---------------------------------------------------------------------------
; Object 21 - SCORE, TIME, RINGS (HUD)
; ---------------------------------------------------------------------------

Obj21:
		cmpi.w	#$601,($FFFFFE10).w	; is this the ending sequence?
		bne.s	Obj21_NoEnding		; if not, branch
		rts				; if yes, don't display HUD
; ===========================================================================

Obj21_NoEnding:
		cmpi.w	#$001,($FFFFFE10).w	; is level GHZ2?
		bne.s	Obj21_NotGHZ2		; if not, branch
		rts				; if yes, don't display HUD
; ===========================================================================

Obj21_NotGHZ2:
		cmpi.w	#$000,($FFFFFE10).w	; is level GHZ1?
		bne.s	Obj21_ShowHUD		; if not, branch
		tst.b	($FFFFFFBB).w		; has Sonic passed the point where he can move?
		bne.s	Obj21_ShowHUD		; if yes, branch
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	Obj21_ShowHUD		; if yes, branch
		rts				; otherwise don't display HUD
; ===========================================================================

Obj21_ShowHUD:
		moveq	#0,d0
		move.b	obRoutine(a0),d0
		move.w	Obj21_Index(pc,d0.w),d1
		jmp	Obj21_Index(pc,d1.w)
; ===========================================================================
Obj21_Index:	dc.w Obj21_Main-Obj21_Index
		dc.w Obj21_Flash-Obj21_Index
		dc.w Obj21_Delete-Obj21_Index
; ===========================================================================

Obj21_Main:
		tst.w	BlackBars.Height
		beq.s	@noblackbars
		tst.w	BlackBars.TargetHeight	; are any black bars currently visible?
		beq.s	@noblackbars		; if not, branch
		rts				; if yes, don't load HUD yet

@noblackbars:
		moveq	#0,d0
		move.l	d0,$32(a0)
		move.l	d0,$36(a0)
		move.l	d0,$3A(a0)
		move.w	d0,$3E(a0)
		
		addq.b	#2,obRoutine(a0)		; increase routine counter
		move.w	#0,obScreenY(a0)		; Y-position
		move.l	#Map_obj21,obMap(a0)	; load mappings

Obj21_ChkScore:
		cmpi.b	#1,$30(a0)		; is object set to SCORE?
		bne.s	Obj21_ChkRings		; if not, branch
		move.b	#1,obFrame(a0)		; use SCORE frame
		move.w	#$C5,$36(a0)		; set X-position
		move.w	#$94,obScreenY(a0)		; set Y-position
		move.w	#$1D1,obX(a0)
		bra.w	Obj21_FrameSelected	; skip

Obj21_ChkRings:
		cmpi.b	#2,$30(a0)		; is object set to RINGS?
		bne.s	Obj21_ChkTime		; if not, branch
		move.b	#2,obFrame(a0)		; use RINGS frame
		move.w	#$18F,obX(a0)		; set X-position
		move.w	#$94,$38(a0)		; set Y-position
		move.w	#$1A0,obScreenY(a0)
		bra.s	Obj21_FrameSelected	; skip

Obj21_ChkTime:
		cmpi.b	#3,$30(a0)		; is object set to TIME?
		bne.s	Obj21_ChkLives		; if not, branch
		move.b	#4,obFrame(a0)		; use TIME frame (3 is the red ring frame, so we have to use 4)
		move.w	#$AD,obX(a0)		; set X-position
		move.w	#$43,obScreenY(a0)
		move.w	#$14B,$38(a0)		; set Y-position
		bra.s	Obj21_FrameSelected	; skip

Obj21_ChkLives:
		cmpi.b	#4,$30(a0)		; is object set to LIVES?
		bne.s	Obj21_FrameSelected	; if not, branch
		move.b	#5,obFrame(a0)		; use LIVES frame
		move.w	#$19B,$36(a0)		; set X-position
		cmpi.w	#$400,($FFFFFE10).w
		bne.s	@cont
		move.w	#$130,$36(a0)		; set X-position
@cont:
		move.w	#$14B,obScreenY(a0)		; set Y-position
		move.w	#$8F,obX(a0)

Obj21_FrameSelected:
		move.b	#0,obRender(a0)
		move.b	#0,obPriority(a0)
		move.w	#$6CA,obGfx(a0)
		cmpi.b	#$10,($FFFFF600).w
		bne.s	Obj21_Flash
		move.w	#$370,obGfx(a0)

; ===========================================================================

Obj21_Flash:
		tst.w	BlackBars.Height	; are any black bars currently visible?
		beq.s	@noblackbars		; if not, branch
		tst.w	BlackBars.TargetHeight	; are any black bars currently visible?
		beq.s	@noblackbars		; if not, display
		tst.w	($FFFFF63A).w		; is the game paused?
		bne.s	@noblackbars		; if yes, display anyway
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	@noblackbars		; if yes, display anyway
		move.b	#0,obRoutine(a0)	; make the HUD redo the animation once the bars are gone
		rts				; if yes, don't display HUD

@noblackbars:
		tst.b	($FFFFFFA5).w		; has flag to move off HUD been set?
		beq.s	Obj21_NoMoveOff		; if not, branch

		addq.w	#1,$3C(a0)		; make HUD move faster
		move.w	$3C(a0),d0		; move HUD speed add to d0
		lsr.w	#2,d0			; devide by 2

		cmpi.b	#1,$30(a0)		; is HUD ID = SCORE?
		beq.s	Obj21_AltSpeed		; if yes, branch
		cmpi.b	#3,$30(a0)		; is HUD ID = TIME?
		beq.s	Obj21_FZEscapeTimer	; if yes, branch
		bra.s	Obj21_ChkOffScreen	; otherwise, branch
Obj21_AltSpeed:
		neg.w	d0			; negate to go to the other direction
Obj21_ChkOffScreen:
		add.w	d0,obX(a0)		; move HUD
		cmpi.w	#$20,obX(a0)		; is object before $20 on X-axis?
		blt.s	Obj21_Delete2		; if yes, branch
		cmpi.w	#$1F0,obX(a0)		; is object after $1F0 on X-axis?
		blt.s	Obj21_Display2		; if not, branch
Obj21_Delete2:
		jmp	DeleteObject		; delete object

Obj21_FZEscapeTimer:
		tst.b	(FZEscape).w		; are we in the escape sequence?
		beq.s	Obj21_AltSpeed		; if not, branch
		cmpi.w	#$11C,obX(a0)		; is object after $11C on X-axis?
		bhs.s	Obj21_Display2		; if not, branch
		add.w	d0,obX(a0)		; move HUD

Obj21_Display2:
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	@displayhud		; if yes, branch

		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	@dontdisplay		; if yes, don't render HUD
		tst.b	($FFFFF7CC).w		; are controls locked?
		beq.s	@displayhud		; if yes, don't render HUD either

@dontdisplay:
		rts				; don't render HUD

@displayhud:
		jmp	DisplaySprite		; display sprite
; ---------------------------------------------------------------------------

Obj21_NoMoveOff:
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		blo.s	Obj21_NotDying		; if not, branch
		
		cmpi.b	#4,$30(a0)		; is object set to LIVES?
		bne.s	@nodeathsmove		; if not, branch

		cmpi.w	#$130,obX(a0)		; reached target X position?
		bls.s	@xreached		; if yes, branch
		subi.w	#6,obX(a0)		; move to the left	
@xreached:
		move.w	#$14B-$30,d0		; default target height
		cmpi.b	#1,($FFFFFE10).w	; are we in LZ?
		bne.s	@notlz			; if not, branch
		move.w	#$14B-$10,d0		; use lower target height (cause black bars are missing) 
@notlz:
		cmp.w	obScreenY(a0),d0	; reached target Y position?
		bhi.s	Obj21_NotDying		; if yes, branch
		subi.w	#3,obScreenY(a0)	; move upwards
		bra.s	Obj21_NotDying		; branch

@nodeathsmove:
		cmpi.w	#$30,obScreenY(a0)	; is Y-position < $30?
		bmi.w	Obj21_Delete		; if yes, delete object
		cmpi.w	#$170,obScreenY(a0)	; is Y-position > $170?
		bpl.w	Obj21_Delete		; if yes, delete object
		move.w	$32(a0),d0		; move $32(a0) to d0
		add.w	d0,obX(a0)		; add $32(a0) pixels to X-position
		move.w	$34(a0),d0		; move $34(a0) to d0
		add.w	d0,obScreenY(a0)	; add $34(a0) pixels to Y-position
		addq.w	#1,$34(a0)		; increase falling speed
		jmp	DisplaySprite		; display sprite
; ---------------------------------------------------------------------------

Obj21_NotDying:
		tst.b	$3A(a0)			; is the intro movement done?
		bne.w	Obj21_NoUpdate		; if yes, don't do anything

		cmpi.b	#1,$30(a0)
		bne.s	Obj21_ChkRings2
		move.w	obX(a0),d0		; move X-pos into d0
		sub.w	#HudSpeed,d0		; substract HUDSpeed - 1 from it
		cmp.w	$36(a0),d0		; check current position on goal position
		bge.s	Obj21_NormalUpdateX	; if current position is bigger than goal position, move it normally
		bra.s	Obj21_XEnd

Obj21_ChkRings2:
		cmpi.b	#2,$30(a0)
		bne.s	Obj21_ChkTime2
		move.w	obScreenY(a0),d0		; move Y-pos into d0
		sub.w	#HudSpeed,d0		; substract HUDSpeed - 1 from it
		cmp.w	$38(a0),d0		; check current position on goal position
		bge.s	Obj21_NormalUpdateY	; if current position is bigger than goal position, move it normally
		bra.s	Obj21_YEnd

Obj21_ChkTime2:
		cmpi.b	#3,$30(a0)
		bne.s	Obj21_ChkLives2
		cmpi.b	#$10,($FFFFF600).w
		bne.s	@cont
		move.w	obX(a0),d0		; move X-pos into d0
		sub.w	#HudSpeed,d0		; substract HUDSpeed - 1 from it
		cmp.w	$36(a0),d0		; check current position on goal position
		bge.s	Obj21_NormalUpdateX	; if current position is bigger than goal position, move it normally
		bra.s	Obj21_XEnd

@cont:
		move.w	obScreenY(a0),d0		; move Y-pos into d0
		add.w	#HudSpeed,d0		; add the HUDSpeed - 1 to it
		cmp.w	$38(a0),d0		; check current position on goal position
		blt.s	Obj21_NormalUpdateY	; if current position is smaller than goal position, move it normally
		bra.s	Obj21_YEnd

Obj21_ChkLives2:
		move.w	obX(a0),d0		; move X-pos into d0
		add.w	#HudSpeed,d0		; add the HUDSpeed - 1 to it
		cmp.w	$36(a0),d0		; check current position on goal position
		blt.s	Obj21_NormalUpdateX	; if current position is smaller than goal position, move it normally

Obj21_XEnd:
		move.w	$36(a0),obX(a0)		; make sure the position is really at the correct spot
		bra.s	Obj21_SkipYEnd		; skip
; ---------------------------------------------------------------------------

Obj21_YEnd:
		move.w	$38(a0),obScreenY(a0)		; make sure the position is really at the correct spot

Obj21_SkipYEnd:
		move.b	#1,$3A(a0)		; tell the game, everything's done
		bra.s	Obj21_NoUpdate		; skip
; ---------------------------------------------------------------------------

Obj21_NormalUpdateX:
		move.w	d0,obX(a0)		; set X-pos to calculation
		bra.s	Obj21_NoUpdate		; skip
; ---------------------------------------------------------------------------

Obj21_NormalUpdateY:
		move.w	d0,obScreenY(a0)		; set Y-pos to calculation

Obj21_NoUpdate:
		cmpi.b	#2,$30(a0)		; is object set to RINGS?
		beq.s	@ringshud		; if yes, branch
		cmpi.b	#3,$30(a0)		; is object set to TIMES?
		beq.s	@timeshud		; if yes, branch
		cmpi.b	#4,$30(a0)		; is object set to LIVES?
		bne.s	Obj21_Display		; if not, branch

@liveshud:
		move.b	#5,obFrame(a0)
		tst.b	(HUD_BossHealth).w		; is boss health currently meant to be displayed?
		beq.s	Obj21_Display		; if yes, branch
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	Obj21_Display		; if yes, branch
		move.b	#6,obFrame(a0)
		bra.s	Obj21_Display
; ---------------------------------------------------------------------------

@timeshud:
		cmpi.b	#9,($FFFFFE23).w	; is hundredth digit currently showing a 9?
		bne.s	Obj21_Display		; if not, branch
		move.w	#$06CA,obGfx(a0)	; use palette line 1
		ori.b	#1,($FFFFFE1E).w 	; update time counter
		btst	#3,($FFFFFE05).w	; change the time counter palette every X frames
		bne.s	Obj21_Display		; if that time isn't over yet, branch
		move.w	#$26CA,obGfx(a0)	; use palette line 2
		bra.s	Obj21_Display
; ---------------------------------------------------------------------------

@ringshud:
		moveq	#2,d0			; set default ring frame to d0
		tst.w	($FFFFFE20).w		; do you have any rings?
		beq.s	Obj21_Flash2		; if not, make ring counter flash
		move.w	($FFFFFE20).w,d1	; get current rings
		cmp.w	$3E(a0),d1		; compare against previous rings
		bhs.s	@nodrainflash		; if we have the same or more rings than previously, branch
		addq.w	#1,d0			; otherwise, ring count got reduced, make flash
@nodrainflash:
		bra.s	Obj21_Cont

Obj21_Flash2:
		ori.b	#1,($FFFFFE1D).w	; update ring counter
		btst	#3,($FFFFFE05).w	; change the rings counter design every X frames
		bne.s	Obj21_Cont		; if that time isn't over yet, branch
		cmpi.b	#$4,($FFFFFE10).w	; are we in Uberhub?
		beq.s	Obj21_Cont		; if yes, never flash ring HUD (annoying af over time)
		addq.w	#1,d0			; make ring counter flash red

Obj21_Cont:
		move.b	d0,obFrame(a0)
		move.w	($FFFFFE20).w,$3E(a0)

Obj21_Display:
		cmpi.b	#6,($FFFFD024).w	; is Sonic dying?
		bhs.s	@cont			; if yes, branch

		btst	#3,(OptionsBits).w	; is cinematic HUD enabled?
		bne.s	@cont2			; if yes, don't render HUD
		tst.b	($FFFFF7CC).w		; are controls locked?
		beq.s	@cont			; if yes, don't render HUD either

@cont2:
		rts				; don't render HUD
		
@cont:
		jmp	DisplaySprite
; ===========================================================================

Obj21_Delete:
		jmp	DeleteObject

; ---------------------------------------------------------------------------
; Sprite mappings - SCORE, TIME, RINGS
; ---------------------------------------------------------------------------
Map_obj21:
		include	"_maps\obj21.asm"
	;	incbin	_maps\status.bin

; ---------------------------------------------------------------------------
; Add points subroutine
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


AddPoints:
		move.b	#1,($FFFFFE1F).w ; set score counter to	update
		lea	($FFFFFFC0).w,a2
		lea	($FFFFFE26).w,a3
		add.l	d0,(a3)		; add d0*10 to the score
		move.l	#999999,d1
		cmp.l	(a3),d1		; is #999999 higher than the score?
		bhi.w	loc_1C6AC	; if yes, branch
	;	move.l	d1,(a3)		; reset	score to #999999
		move.l	#0,(a3)		; reset	score to #0
		move.l	d1,(a2)

loc_1C6AC:
		move.l	(a3),d0
		cmp.l	(a2),d0
		bcs.w	locret_1C6B6
		move.l	d0,(a2)

locret_1C6B6:
		rts	
; End of function AddPoints

; ---------------------------------------------------------------------------
; Subroutine to	update the HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudUpdate:
		tst.w	($FFFFFE08).w	; is debug mode	being used?
		bne.w	HudDebug	; if yes, branch
		tst.b	($FFFFFE1F).w	; does the score need updating?
		beq.s	Hud_ChkRings	; if not, branch
		clr.b	($FFFFFE1F).w
		move.l	#$5C800003,d0	; set VRAM address
		move.l	($FFFFFE26).w,d1 ; load	score
		bsr	Hud_Score
		ori.b	#1,($FFFFFE1C).w	; update lives counter as well to display the third digit properly

Hud_ChkRings:
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	Hud_ChkTime	; if not, branch
		cmpi.w	#999,($FFFFFE20).w ; does sonic have over 999 rings?
		blo.s	Hud_Not999	; if equal or less, branch
		move.w	#999,($FFFFFE20).w ; if it's over 999, set to 999
		ori.b	#1,($FFFFFE1D).w ; update the ring counter
		
Hud_Not999:
		bpl.s	loc_1C6E4
		bsr	Hud_LoadZero

loc_1C6E4:
		clr.b	($FFFFFE1D).w
		move.l	#$5F400003,d0	; set VRAM address
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1 ; load	number of rings
		bsr	Hud_Rings

Hud_ChkTime:
		tst.b	($FFFFFE1E).w	; does the time	need updating?
		beq.w	Hud_ChkLives	; if not, branch
		cmpi.w	#$400,($FFFFFE10).w ; is level SYZ1?
		beq.w	Hud_ChkLives	; if yes, branch
		cmpi.w	#$501,($FFFFFE10).w ; is level SBZ1?
		beq.w	Hud_ChkLives	; if yes, branch
		tst.w	($FFFFF63A).w	; is the game paused?
		bne.w	Hud_ChkLives	; if yes, branch

		lea	($FFFFFE22).w,a1
		cmpi.l	#(9*$10000)|(99*$100),(a1)+	; is the time 999? ($96300)
		bhi.w	TimeOver			; if yes, time over noob

		moveq	#1,d0			; regular timer speed (1 tick per second; at 999 ticks, that's roughly 16 minutes)
		frantic				; are we in frantic?
		beq.s	@notfrantic		; if not, branch
		moveq	#3,d0			; otherwise, triple regular timer speed (3 ticks per second; this changes the effective time limit to roughly 5.5 minutes)
@notfrantic:
		cmpi.w	#$502,($FFFFFE10).w	; are we in FP?
		bne.s	@notfzescape		; if not, branch
		cmpi.b	#2,(FZEscape).w		; are we in the escape sequence?
		beq.s	@fzescapetimer		; if yes, branch
		bra.s	@notfzescape		; skip
@fzescapetimer:
		sub.b	d0,-(a1)		; sub from current timer
		tst.b	(a1)			; did we reach 60 frames?
		bpl.s	Hud_ChkLives		; if not, branch
		move.b	#60,(a1)		; reset frame counter

		subq.b	#1,-(a1)		; sub 1 from seconds
		tst.b	(a1)			; did we underflow seconds?
		bpl.s	Hud_TimeUpdate		; if not, branch
		move.b	#99,(a1)		; reset seconds to 99

		subq.b	#1,-(a1)		; sub 1 from minutes counter
		tst.b	(a1)			; did we underflow minutes?
		bpl.s	Hud_TimeUpdate		; if not, branch

		bsr.w	TimeOver		; rip sonic...
		jmp	FZEscape_ScreenBoom	; ...nuke went off

@notfzescape:
		add.b	d0,-(a1)		; add to current timer
		cmpi.b	#60,(a1)		; did we reach 60 frames?
		blo.s	Hud_ChkLives		; if not, branch
		move.b	#0,(a1)			; clear frame counter

		addq.b	#1,-(a1)		; add 1 to seconds
		cmpi.b	#100,(a1)		; did we reach 100 seconds?
		blo.s	Hud_TimeUpdate		; if not, branch
		move.b	#0,(a1)			; set seconds to 0

		addq.b	#1,-(a1)		; add 1 to minutes counter
		cmpi.b	#9,(a1)			; are we at 9 minutes?
		blo.s	Hud_TimeUpdate		; if not, branch
		move.b	#9,(a1)			; force to not exceed 9 minutes

Hud_TimeUpdate:
		move.l	#$5E400003,d0
		moveq	#0,d1
		move.b	($FFFFFE23).w,d1 ; load	minutes
		bsr.w	Hud_Mins

		move.l	#$5EC00003,d0
		moveq	#0,d1
		move.b	($FFFFFE24).w,d1 ; load	seconds
		bsr.w	Hud_Secs

Hud_ChkLives:
		tst.b	(HUD_BossHealth).w		; is boss health currently meant to be displayed?
		bne.s	@boss			; if yes, branch
		tst.b	($FFFFFE1C).w	; does the lives counter need updating?
		beq.s	Hud_ChkBonus	; if not, branch
		clr.b	($FFFFFE1C).w
@boss:
		bsr	Hud_Lives

Hud_ChkBonus:
		tst.b	($FFFFF7D6).w	; do time/ring bonus counters need updating?
		beq.s	Hud_End		; if not, branch
		clr.b	($FFFFF7D6).w
		move.l	#$6E000002,($C00004).l
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bsr	Hud_TimeRingBonus

Hud_End:
		rts	
; ===========================================================================

TimeOver:				; XREF: Hud_ChkTime
		clr.b	($FFFFFE1E).w
		lea	($FFFFD000).w,a0
		movea.l	a0,a2
		clr.b	($FFFFFFE7).w	; disable inhuman mode (to prevent softlocks)
		bsr	KillSonic
	;	move.b	#1,($FFFFFE1A).w
		rts	
; ===========================================================================

HudDebug:				; XREF: HudUpdate
		bsr	HudDb_XY
		tst.b	($FFFFFE1D).w	; does the ring	counter	need updating?
		beq.s	HudDb_ObjCount	; if not, branch
		bpl.s	HudDb_Rings
		bsr	Hud_LoadZero

HudDb_Rings:
		clr.b	($FFFFFE1D).w
		move.l	#$5F400003,d0	; set VRAM address
		moveq	#0,d1
		move.w	($FFFFFE20).w,d1 ; load	number of rings
		bsr	Hud_Rings

HudDb_ObjCount:
		move.l	#$5EC00003,d0	; set VRAM address
		moveq	#0,d1
		move.b	($FFFFF62C).w,d1 ; load	"number	of objects" counter
		bsr	Hud_Secs

		tst.b	(HUD_BossHealth).w	; is boss health currently meanth to be displayed?
		bne.s	@boss		; if yes, branch
		tst.b	($FFFFFE1C).w	; does the lives counter need updating?
		beq.s	HudDb_ChkBonus	; if not, branch
		clr.b	($FFFFFE1C).w
@boss:
		bsr	Hud_Lives

HudDb_ChkBonus:
		tst.b	($FFFFF7D6).w	; does the ring/time bonus counter need	updating?
		beq.s	HudDb_End	; if not, branch
		clr.b	($FFFFF7D6).w
		move.l	#$6E000002,($C00004).l ; set VRAM address
		moveq	#0,d1
		move.w	($FFFFF7D2).w,d1 ; load	time bonus
		bsr	Hud_TimeRingBonus
		moveq	#0,d1
		move.w	($FFFFF7D4).w,d1 ; load	ring bonus
		bsr	Hud_TimeRingBonus

HudDb_End:
		rts	
; End of function HudUpdate

; ---------------------------------------------------------------------------
; Subroutine to	load "0" on the	HUD
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_LoadZero:				; XREF: HudUpdate
		move.l	#$5F400003,($C00004).l
		lea	Hud_TilesZero(pc),a2
		move.w	#2,d2
		bra.s	loc_1C83E
; End of function Hud_LoadZero

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed HUD patterns ("E", "0", colon)
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Base:				; XREF: Level; SS_EndLoop; EndingSequence
		lea	($C00000).l,a6
		bsr	Hud_Lives
		move.l	#$5C400003,($C00004).l
		lea	Hud_TilesBase(pc),a2
		move.w	#$E,d2

loc_1C83E:				; XREF: Hud_LoadZero
		lea	Art_Hud(pc),a1

loc_1C842:
		move.w	#$F,d1
		move.b	(a2)+,d0
		bmi.s	loc_1C85E
		ext.w	d0
		lsl.w	#5,d0
		lea	(a1,d0.w),a3

loc_1C852:
		move.l	(a3)+,(a6)
		dbf	d1,loc_1C852

loc_1C858:
		dbf	d2,loc_1C842

		rts	
; ===========================================================================

loc_1C85E:
		move.l	#0,(a6)
		dbf	d1,loc_1C85E

		bra.s	loc_1C858
; End of function Hud_Base

; ===========================================================================
Hud_TilesBase:	dc.b $16, $FF, $FF, $FF, $FF, $FF, $FF,	0, 0, $14, 0, 0
Hud_TilesZero:	dc.b $FF, $FF, 0, 0
; ---------------------------------------------------------------------------
; Subroutine to	load debug mode	numbers	patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY:				; XREF: HudDebug
		move.l	#$5C400003,($C00004).l ; set VRAM address
		move.w	($FFFFF700).w,d1 ; load	camera x-position
		swap	d1
		move.w	($FFFFD008).w,d1 ; load	Sonic's x-position
		bsr.s	HudDb_XY2
		move.w	($FFFFF704).w,d1 ; load	camera y-position
		swap	d1
		move.w	($FFFFD00C).w,d1 ; load	Sonic's y-position
; End of function HudDb_XY


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


HudDb_XY2:
		moveq	#7,d6
		lea	(Art_Text).l,a1

HudDb_XYLoop:
		rol.w	#4,d1
		move.w	d1,d2
		andi.w	#$F,d2
		cmpi.w	#$A,d2
		bcs.s	loc_1C8B2
		addq.w	#5,d2	; changed from 7

loc_1C8B2:
		lsl.w	#5,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		swap	d1
		dbf	d6,HudDb_XYLoop	; repeat 7 more	times

		rts	
; End of function HudDb_XY2

; ---------------------------------------------------------------------------
; Subroutine to	load rings numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Rings:				; XREF: HudUpdate
		lea	(Hud_100).l,a2
		moveq	#2,d6
		bra.s	Hud_LoadArt
; End of function Hud_Rings

; ---------------------------------------------------------------------------
; Subroutine to	load score numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Score:				; XREF: HudUpdate
		lea	(Hud_100000).l,a2
		moveq	#5,d6

Hud_LoadArt:
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_ScoreLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C8EC:
		sub.l	d3,d1
		bcs.s	loc_1C8F4
		addq.w	#1,d2
		bra.s	loc_1C8EC
; ===========================================================================

loc_1C8F4:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1C8FE
		move.w	#1,d4

loc_1C8FE:
		tst.w	d4
	;	beq.s	loc_1C92C	; comment out to add extra 0s for SCORE and RINGS counter
		lsl.w	#6,d2
		move.l	d0,obMap(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc_1C92C:
		addi.l	#$400000,d0
		dbf	d6,Hud_ScoreLoop

		rts	
; End of function Hud_Score

; ---------------------------------------------------------------------------
; Subroutine to	load countdown numbers on the continue screen
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


ContScrCounter:				; XREF: ContinueScreen
		move.l	#$5F800003,($C00004).l ; set VRAM address
		lea	($C00000).l,a6
		lea	(Hud_10).l,a2
		moveq	#1,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1 ; load numbers patterns

ContScr_Loop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C95A:
		sub.l	d3,d1
		bcs.s	loc_1C962
		addq.w	#1,d2
		bra.s	loc_1C95A
; ===========================================================================

loc_1C962:
		add.l	d3,d1
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		dbf	d6,ContScr_Loop	; repeat 1 more	time

		rts	
; End of function ContScrCounter

; ===========================================================================
; ---------------------------------------------------------------------------
; HUD counter sizes
; ---------------------------------------------------------------------------
Hud_100000:	dc.l 100000		; XREF: Hud_Score
Hud_10000:	dc.l 10000
Hud_1000:	dc.l 1000		; XREF: Hud_TimeRingBonus
Hud_100:	dc.l 100		; XREF: Hud_Rings
Hud_10:		dc.l 10			; XREF: ContScrCounter; Hud_Secs; Hud_Lives
Hud_1:		dc.l 1			; XREF: Hud_Mins

; ---------------------------------------------------------------------------
; Subroutine to	load time numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||

; Hud_Time:
Hud_Mins:				; XREF: Hud_ChkTime
		lea	(Hud_1).l,a2
		moveq	#0,d6
		bra.s	loc_1C9BA
; End of function Hud_Mins


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Secs:				; XREF: Hud_ChkTime
		lea	(Hud_10).l,a2
		moveq	#1,d6

loc_1C9BA:
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_TimeLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1C9C4:
		sub.l	d3,d1
		bcs.s	loc_1C9CC
		addq.w	#1,d2
		bra.s	loc_1C9C4
; ===========================================================================

loc_1C9CC:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1C9D6
		move.w	#1,d4

loc_1C9D6:
		lsl.w	#6,d2
		move.l	d0,obMap(a6)
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		addi.l	#$400000,d0
		dbf	d6,Hud_TimeLoop

		rts	
; End of function Hud_Secs

; ---------------------------------------------------------------------------
; Subroutine to	load time/ring bonus numbers patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_TimeRingBonus:			; XREF: Hud_ChkBonus
		lea	(Hud_1000).l,a2
		moveq	#3,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_BonusLoop:
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1CA1E:
		sub.l	d3,d1
		bcs.s	loc_1CA26
		addq.w	#1,d2
		bra.s	loc_1CA1E
; ===========================================================================

loc_1CA26:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1CA30
		move.w	#1,d4

loc_1CA30:
		tst.w	d4
		beq.s	Hud_ClrBonus
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc_1CA5A:
		dbf	d6,Hud_BonusLoop ; repeat 3 more times

		rts	
; ===========================================================================

Hud_ClrBonus:
		moveq	#$F,d5

Hud_ClrBonusLoop:
		move.l	#0,(a6)
		dbf	d5,Hud_ClrBonusLoop

		bra.s	loc_1CA5A
; End of function Hud_TimeRingBonus

; ---------------------------------------------------------------------------
; Subroutine to	load uncompressed lives	counter	patterns
; ---------------------------------------------------------------------------

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Hud_Lives:				; XREF: Hud_ChkLives
		moveq	#0,d1			; clear d1
		tst.b	(HUD_BossHealth).w		; is boss HUD currently meant to be displayed?
		beq.s	@notboss		; if not, branch
		move.b	(HUD_BossHealth).w,d1	; load boss health as lives instead
		bra.w	@tenandone		; skip displaying the 100th digit

@notboss:
		move.w	($FFFFFE12).w,d1	; load number of lives		
		moveq	#0,d2			; disable 100th digit
@modulo:
		cmpi.w	#100,d1			; do we have at least 100 deaths?
		blo.s	@hundred		; if not, branch
		subi.w	#100,d1			; sub 100 deaths
		addq.w	#1,d2			; add one to modulo counter
		bra.s	@modulo			; modulo loop

@hundred:
		tst.w	d2			; is third digit meant to be displayed?
		beq.s	@tenandone		; if not, branch
		
		vram	$DDC0			; third overwrites the 10th digit from the Score HUD (replaced with a fake 0)
		lea	(Art_Hud).l,a1		; load number font
		lsl.w	#6,d2			; multiply counter by $40
		adda.w	d2,a1			; add that to the address
		rept	16
		move.l	(a1)+,(a6)
		endr

@tenandone:
		move.l	#$7B800003,d0	; set VRAM address
		lea	(Hud_10).l,a2
		moveq	#1,d6
		moveq	#0,d4
		lea	Art_Hud(pc),a1

Hud_LivesLoop:
		move.l	d0,4(a6)
		moveq	#0,d2
		move.l	(a2)+,d3

loc_1CA90:
		sub.l	d3,d1
		bcs.s	loc_1CA98
		addq.w	#1,d2
		bra.s	loc_1CA90
; ===========================================================================

loc_1CA98:
		add.l	d3,d1
		tst.w	d2
		beq.s	loc_1CAA2
		move.w	#1,d4

loc_1CAA2:
	;	tst.w	d4
	;	beq.s	Hud_ClrLives

loc_1CAA6:
		lsl.w	#6,d2
		lea	(a1,d2.w),a3
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)
		move.l	(a3)+,(a6)

loc_1CABC:
		addi.l	#$400000,d0
		dbf	d6,Hud_LivesLoop ; repeat 1 more time

		rts	
; ===========================================================================

Hud_ClrLives:
		tst.w	d6
		beq.w	loc_1CAA6
		moveq	#7,d5

Hud_ClrLivesLoop:
		move.l	#0,(a6)
		dbf	d5,Hud_ClrLivesLoop
		bra.w	loc_1CABC
; End of function Hud_Lives

; ===========================================================================
Art_Hud:	incbin	artunc\HUD.bin		; 8x16 pixel numbers on HUD
		even
Art_LivesNums:	incbin	artunc\livescnt.bin	; 8x8 pixel numbers on lives counter
		even
; ===========================================================================
; ---------------------------------------------------------------------------
; When debug mode is currently in use
; ---------------------------------------------------------------------------

DebugMode:				; XREF: Obj01; Obj09
		moveq	#0,d0
		move.b	($FFFFFE08).w,d0
		move.w	Debug_Index(pc,d0.w),d1
		jmp	Debug_Index(pc,d1.w)
; ===========================================================================
Debug_Index:	dc.w Debug_Main-Debug_Index
		dc.w Debug_Skip-Debug_Index
; ===========================================================================

Debug_Main:				; XREF: Debug_Index
		addq.b	#2,($FFFFFE08).w	; to to Debug_Skip next frame

		move.b	#0,obFrame(a0)	; use first frame for the ring
		move.b	#0,obAnim(a0)	; clear animation byte
		clr.w	obVelX(a0)	; clear Sonic's x-speed
		clr.w	obVelY(a0)	; clear Sonic's y-speed
		clr.w	obInertia(a0)	; clear Sonic's inertia

	;	move.w	($FFFFF72C).w,($FFFFFEF0).w	; buffer level x-boundary
	;	move.w	($FFFFF726).w,($FFFFFEF2).w	; buffer level y-boundary
	;	move.w	#0,($FFFFF72C).w		; unset upper level boundary
	;	move.w	#$720,($FFFFF726).w		; set target lower boundary
	;	andi.w	#$7FF,($FFFFD00C).w		; limit Sonic's Y pos
	;	andi.w	#$7FF,($FFFFF704).w		; limit camera's Y pos (plane A)
	;	andi.w	#$3FF,($FFFFF70C).w		; limit camera's Y pos (plane B)

		cmpi.b	#$10,($FFFFF600).w ; is	game mode = $10	(special stage)?
		bne.s	Debug_Zone	; if not, branch
		move.w	#0,($FFFFF782).w ; stop	special	stage rotating
		
		moveq	#6,d0		; use 6th debug	item list
		tst.b	($FFFFFF5F).w		; is this the blackout special stage?
		beq.s	Debug_UseList		; if not, branch
		move.w	#0,($FFFFF780).w 	; make	special	stage "upright"
		bra.s	Debug_UseList
; ===========================================================================
DebugList:	; just a ring
		dc.w	1
		dc.l	Map_obj25+$25000000
		dc.b	0, 0, $27, $B2
; ===========================================================================

Debug_Zone:
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0

Debug_UseList:
		lea	(DebugList).l,a2
		move.w	(a2)+,d6
		cmp.b	($FFFFFE06).w,d6
		bhi.s	loc_1CF9E
		move.b	#0,($FFFFFE06).w

loc_1CF9E:
		bsr	Debug_ShowItem
		move.b	#$C,($FFFFFE0A).w
		move.b	#1,($FFFFFE0B).w

Debug_Skip:				; XREF: Debug_Index
		moveq	#6,d0
		cmpi.b	#$10,($FFFFF600).w
		beq.s	loc_1CFBE
		moveq	#0,d0
		move.b	($FFFFFE10).w,d0

loc_1CFBE:
		lea	(DebugList).l,a2
		move.w	(a2)+,d6
		bsr	Debug_Control
		jmp	DisplaySprite

; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_Control:
		moveq	#0,d4
		move.w	#1,d1
		move.b	($FFFFF605).w,d4
		andi.w	#$F,d4		; is up/down/left/right	pressed?
		bne.s	Debug_MoveStart	; if yes, branch
		move.b	($FFFFF604).w,d0
		andi.w	#$F,d0
		bne.s	Debug_MoveContinue
		move.b	#$C,($FFFFFE0A).w
		move.b	#$F,($FFFFFE0B).w
		bra.w	Debug_Exit
; ===========================================================================

Debug_MoveContinue:
		subq.b	#1,($FFFFFE0A).w
		bne.s	loc_1D01C
		move.b	#1,($FFFFFE0A).w
		addq.b	#1,($FFFFFE0B).w
		bne.s	Debug_MoveStart
		move.b	#-1,($FFFFFE0B).w

Debug_MoveStart:
		move.b	($FFFFF604).w,d4

loc_1D01C:
		moveq	#1,d6			; enable camera capping
		cmpi.b	#$10,($FFFFF600).w	; are we in a special stage?
		bne.s	@notspecial		; if not, branch
		moveq	#0,d6			; disable camera capping

@notspecial:
		moveq	#0,d1
		move.b	($FFFFFE0B).w,d1
		addq.w	#1,d1
		swap	d1
		asr.l	#4,d1
		
		; slightly increase top debug movement speed
		move.l	d1,d2
		asr.l	#6,d2
		add.l	d2,d1
		move.l	obY(a0),d2
		move.l	obX(a0),d3

Debug_ChkUp:
		btst	#0,d4		; is up	being pressed?
		beq.s	Debug_ChkDown	; if not, branch
		sub.l	d1,d2
	;	bcc.s	@no
	;	moveq	#0,d2
@no:
		; prevent debug object going off-screen to the top
		tst.b	d6		; is capping enabled?
		beq.s	Debug_ChkDown	; if not, branch
		moveq	#0,d5			
		move.w	($FFFFF72C).w,d5
		swap	d5
		cmp.l	d5,d2
		bgt.s	Debug_ChkDown
		move.l	d5,d2

Debug_ChkDown:
		btst	#1,d4		; is down being	pressed?
		beq.s	Debug_ChkLeft	; if not, branch
		add.l	d1,d2
	;	cmpi.l	#$7FF0000,d2
	;	bcs.s	@no
	;	move.l	#$7FF0000,d2
@no:		
		; prevent debug object going off-screen to the bottom
		tst.b	d6		; is capping enabled?
		beq.s	Debug_ChkLeft	; if not, branch
		moveq	#0,d5			
		move.w	($FFFFF72E).w,d5
		addi.w	#224,d5
		swap	d5
		cmp.l	d5,d2
		bcs.s	Debug_ChkLeft
		move.l	d5,d2
		
Debug_ChkLeft:
		btst	#2,d4		; is left being pressed?
		beq.s	Debug_ChkRight	; if not, branch
		sub.l	d1,d3
	;	bcc.s	@no
	;	moveq	#0,d3
@no:		
		; prevent debug object going off-screen to the left
		tst.b	d6		; is capping enabled?
		beq.s	Debug_ChkRight	; if not, branch
		moveq	#0,d5			
		move.w	($FFFFF728).w,d5
		swap	d5
		cmp.l	d5,d3
		bgt.s	Debug_ChkRight
		move.l	d5,d3

Debug_ChkRight:
		btst	#3,d4		; is right being pressed?
		beq.s	Debug_SetPos	; if not, branch
		add.l	d1,d3
		
		; prevent debug object going off-screen to the right
		tst.b	d6		; is capping enabled?
		beq.s	Debug_SetPos	; if not, branch
		moveq	#0,d5			
		move.w	($FFFFF72A).w,d5
		addi.w	#320,d5
		swap	d5
		cmp.l	d5,d3
		bcs.s	Debug_SetPos
		move.l	d5,d3

Debug_SetPos:
		move.l	d2,obY(a0)	; set final Y position of debug object
		move.l	d3,obX(a0)	; set final X position of debug object

Debug_Exit:
		moveq	#0,d0
		move.b	($FFFFF605).w,d0	; get button presses
		andi.b	#$70,d0			; any of ABC pressed?
		beq.w	Debug_DoNothing		; if not, branch
		cmpi.b	#$10,($FFFFF600).w	; are we in a special stage?
		beq.s	@notc			; if yes, branch

		btst	#6,d0			; is button A pressed?
		beq.s	@nota
		jsr	SingleObjLoad
		bne.s	@nota
		move.b	#$3F,(a1)		; spawn explosion object
		clr.b	obRoutine(a1)
		move.b	#0,$31(a1)
		move.w	($FFFFD008).w,obX(a1)
		move.w	($FFFFD00C).w,obY(a1)
		bra.w	Debug_DoNothing
		
@nota:
		btst	#5,d0			; is button C pressed?
		beq.s	@notc			; if not, branch
		jsr	SingleObjLoad
		bne.s	@notc
		move.b	#$25,(a1)		; spawn ring
		clr.b	obRoutine(a1)
		move.w	($FFFFD008).w,obX(a1)
		move.w	($FFFFD00C).w,obY(a1)
		clr.b	($FFFFFC02).w		; clear 1st entry in object state table
		bra.w	Debug_DoNothing

@notc:
		btst	#4,d0			; is button B pressed?
		beq.s	Debug_DoNothing	; if not, branch
		moveq	#0,d0
		move.w	d0,($FFFFFE08).w ; deactivate debug mode
		
		move.b	#1,($FFFFFE1F).w ; update score	counter
		clr.w	obVelX(a0)	; clear x-speed
		clr.w	obVelY(a0)	; clear y-speed
		clr.w	obInertia(a0)	; clear inertia
		
		move.l	#Map_Sonic,($FFFFD004).w
		move.w	#$780,($FFFFD002).w
		move.b	d0,($FFFFD01C).w
		move.w	d0,obScreenY(a0)
		move.w	d0,$E(a0)
	;	move.w	($FFFFFEF0).w,($FFFFF72C).w ; restore level boundaries
	;	move.w	($FFFFFEF2).w,($FFFFF726).w
		cmpi.b	#$10,($FFFFF600).w	; are you in the special stage?
		beq.s	Debug_Exit_SS		; if yes, branch
		jsr	Hud_Base		; restore HUD after using debug mode
		ori.b	#1,($FFFFFE1D).w	; update rings counter
		bra.s	Debug_DoNothing

Debug_Exit_SS:
		move.l	#Map_Sonic,($FFFFD004).w
		move.w	#$780,($FFFFD002).w
		move.b	#2,($FFFFD01C).w
		bset	#2,($FFFFD022).w
		bset	#1,($FFFFD022).w

Debug_DoNothing:
		rts	
; End of function Debug_Control


; ||||||||||||||| S U B	R O U T	I N E |||||||||||||||||||||||||||||||||||||||


Debug_ShowItem:				; XREF: Debug_Main
		moveq	#0,d0
		move.b	($FFFFFE06).w,d0
		lsl.w	#3,d0
		move.l	(a2,d0.w),obMap(a0)	; load mappings	for item
		move.w	6(a2,d0.w),obGfx(a0) ; load	VRAM setting for item
		move.b	5(a2,d0.w),obFrame(a0) ; load frame	number for item
		rts	
; End of function Debug_ShowItem

; ===========================================================================
; ---------------------------------------------------------------------------
; Main level load blocks
;
; ===FORMAT===
; level	patterns + (1st	PLC num	* 10^6)
; 16x16	mappings + (2nd	PLC num	* 10^6)
; 256x256 mappings
; blank, music (unused), pal index (unused), pal index
; ---------------------------------------------------------------------------
MainLoadBlocks:
		dc.l ArtKospM_GHZ+$4000000
		dc.l Blk16_GHZ+$5000000
		dc.l Blk256_GHZ
		dc.b 0,	$81, 4,	4
		
		dc.l ArtKospM_LZ+$6000000
		dc.l Blk16_LZ+$7000000
		dc.l Blk256_LZ
		dc.b 0,	$82, 5,	5
		
		dc.l ArtKospM_MZ+$8000000
		dc.l Blk16_MZ+$9000000
		dc.l Blk256_MZ
		dc.b 0,	$83, 6,	6
		
		dc.l ArtKospM_SLZ+$A000000
		dc.l Blk16_SLZ+$B000000
		dc.l Blk256_SLZ
		dc.b 0,	$84, 7,	7
		
		dc.l ArtKospM_SYZ+$C000000
		dc.l Blk16_SYZ+$D000000
		dc.l Blk256_SYZ
		dc.b 0,	$85, 8,	8
		
		dc.l ArtKospM_SBZ+$E000000
		dc.l Blk16_SBZ+$F000000
		dc.l Blk256_SBZ
		dc.b 0,	$86, 9,	9
		
		dc.l ArtKospM_GHZ	; main load block for ending
		dc.l Blk16_GHZ
		dc.l Blk256_END
		dc.b 0,	$86, $13, $13
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Pattern load cues (merged from the _inc file)
; ---------------------------------------------------------------------------

ArtLoadCues:
	dc.w PLC_Main-ArtLoadCues	; $00
	dc.w PLC_Main2-ArtLoadCues	; $01
	dc.w PLC_Explode-ArtLoadCues	; $02
	dc.w PLC_Null-ArtLoadCues	; $03
	dc.w PLC_GHZ-ArtLoadCues	; $04
	dc.w PLC_GHZ2-ArtLoadCues	; $05
	dc.w PLC_LZ-ArtLoadCues		; $06
	dc.w PLC_LZ2-ArtLoadCues	; $07
	dc.w PLC_MZ-ArtLoadCues		; $08
	dc.w PLC_MZ2-ArtLoadCues	; $09
	dc.w PLC_SLZ-ArtLoadCues	; $0A
	dc.w PLC_SLZ2-ArtLoadCues	; $0B
	dc.w PLC_SYZ-ArtLoadCues	; $0C
	dc.w PLC_SYZ2-ArtLoadCues	; $0D
	dc.w PLC_SBZ-ArtLoadCues	; $0E
	dc.w PLC_SBZ2-ArtLoadCues	; $0F
	dc.w PLC_TitleCard-ArtLoadCues	; $10
	dc.w PLC_Boss-ArtLoadCues	; $11
	dc.w PLC_Signpost-ArtLoadCues	; $12
	dc.w PLC_Warp-ArtLoadCues	; $13
	dc.w PLC_SpeStage-ArtLoadCues	; $14
	dc.w PLC_Null-ArtLoadCues	; $15
	dc.w PLC_Null-ArtLoadCues	; $16
	dc.w PLC_Null-ArtLoadCues	; $17
	dc.w PLC_Null-ArtLoadCues	; $18
	dc.w PLC_Null-ArtLoadCues	; $19
	dc.w PLC_Null-ArtLoadCues	; $1A
	dc.w PLC_SSBlackout-ArtLoadCues ; $1B
	dc.w PLC_Ending-ArtLoadCues	; $1C
	dc.w PLC_Null-ArtLoadCues	; $1D
	dc.w PLC_EggmanSBZ2-ArtLoadCues	; $1E
	dc.w PLC_FZBoss-ArtLoadCues	; $1F

PLC_Null:	dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - standard block 1
; ---------------------------------------------------------------------------
PLC_Main:
		dc.l ArtKospM_Lamp		; lamppost
		dc.w $D800
		dc.l ArtKospM_Hud		; HUD
		dc.w $D940
		dc.l ArtKospM_Deaths		; HUD deaths counter
		dc.w $FA80
		dc.l ArtKospM_Ring		; rings
		dc.w $F640
		dc.l ArtKospM_ExplBall	; exploding balls from Inhuman Mode
		dc.w $D700
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - standard block 2
; ---------------------------------------------------------------------------
PLC_Main2:
		dc.l ArtKospM_Monitors	; monitors
		dc.w $D000
		dc.l ArtKospM_Shield		; shield
		dc.w $A820
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - explosion
; ---------------------------------------------------------------------------
PLC_Explode:
		dc.l ArtKospM_Explode	; explosion
		dc.w $B400
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - Green Hill
; ---------------------------------------------------------------------------
PLC_GHZ:
		dc.l ArtKospM_GHZ		; GHZ main patterns
		dc.w 0
		dc.l ArtKospM_Stalk		; flower stalk
		dc.w $6B00
		dc.l ArtKospM_PplRock	; purple rock
		dc.w $7A00
		dc.l ArtKospM_Crabmeat	; crabmeat enemy
		dc.w $8000
		dc.l ArtKospM_Buzz		; buzz bomber enemy
		dc.w $8880
		dc.l ArtKospM_Chopper	; chopper enemy
		dc.w $8F60
		dc.l ArtKospM_HardPS		; hard part skipper
		dc.w $9360
		dc.l ArtKospM_OkCool		; ok cool
		dc.w $9600
		dc.l ArtKospM_Motobug	; motobug enemy
		dc.w $9E00
		dc.l ArtKospM_Spikes		; spikes
		dc.w $A360
		dc.l ArtKospM_HSpring	; horizontal spring
		dc.w $A460
		dc.l ArtKospM_VSpring	; vertical spring
		dc.w $A660
		dc.w -1

PLC_GHZ2:
		dc.l ArtKospM_Swing		; swinging platform
		dc.w $7000
		dc.l ArtKospM_Bridge		; bridge
		dc.w $71C0
	;	dc.l ArtKospM_SpikePole	; spiked pole
	;	dc.w $7300
		dc.l ArtKospM_Ball		; giant	ball
		dc.w $7540
		dc.l ArtKospM_GhzWall1	; breakable wall
		dc.w $A1E0
		dc.l ArtKospM_GhzWall2	; normal wall
		dc.w $6980
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - Labyrinth
; ---------------------------------------------------------------------------
PLC_LZ:
		dc.l ArtKospM_LZ		; LZ main patterns
		dc.w 0
	;	dc.l ArtKospM_LzBlock1	; block
	;	dc.w $3C00
	;	dc.l ArtKospM_LzBlock2	; blocks
	;	dc.w $3E00
		dc.l ArtKospM_Splash		; waterfalls and splash
		dc.w $4B20
	;	dc.l ArtKospM_LzSpikeBall	; spiked ball
	;	dc.w $6200
		dc.l ArtKospM_FlapDoor	; flapping door
		dc.w $6500
		dc.l ArtKospM_Bubbles	; bubbles and numbers
		dc.w $6900
		dc.l ArtKospM_LzBlock3	; block
		dc.w $7780
	;	dc.l ArtKospM_LzDoor1	; vertical door
	;	dc.w $7880
		dc.l ArtKospM_Cork		; cork block
		dc.w $7980
		dc.l ArtKospM_HardPS		; hard part skipper
		dc.w $94C0
		dc.l ArtKospM_OkCool		; ok cool
		dc.w $9800
		dc.w -1

PLC_LZ2:
		dc.l ArtKospM_LzPole		; pole that breaks
		dc.w $7BC0
		dc.l ArtKospM_LzDoor2	; large	horizontal door
		dc.w $7CC0
	;	dc.l ArtKospM_LzWheel	; wheel
	;	dc.w $7EC0
		dc.l ArtKospM_Gargoyle	; gargoyle head
		dc.w $5D20
		dc.l ArtKospM_LzPlatfm	; rising platform
		dc.w $89E0
	;	dc.l ArtKospM_Orbinaut	; orbinaut enemy
	;	dc.w $8CE0
		dc.l ArtKospM_Jaws		; jaws enemy
		dc.w $90C0
		dc.l ArtKospM_Switch	; switch
		dc.w $A1E0
		dc.l ArtKospM_Spikes		; spikes
		dc.w $A360
		dc.l ArtKospM_HSpring	; horizontal spring
		dc.w $A460
		dc.l ArtKospM_VSpring	; vertical spring
		dc.w $A660
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - Marble
; ---------------------------------------------------------------------------
PLC_MZ:
		dc.l ArtKospM_MZ		; MZ main patterns
		dc.w 0
		dc.l ArtKospM_MzMetal	; metal	blocks
		dc.w $6000
	;	dc.l ArtKospM_MzFire		; fireballs
	;	dc.w $68A0
		dc.l ArtKospM_OkCool		; ok cool
		dc.w $6A00
		dc.l ArtKospM_Swing		; swinging platform
		dc.w $7000
		dc.l ArtKospM_MzGlass	; green	glassy block
		dc.w $71C0
		dc.l ArtKospM_Lava		; lava
		dc.w $7500
		dc.l ArtKospM_Buzz		; buzz bomber enemy
		dc.w $8880
		dc.l ArtKospM_Yadrin		; yadrin enemy
		dc.w $8F60
		dc.l ArtKospM_Basaran	; basaran enemy
		dc.w $9700
		dc.l ArtKospM_HardPS		; hard part skipper
		dc.w $9FE0
		dc.w -1

PLC_MZ2:
		dc.l ArtKospM_MzSwitch	; switch
		dc.w $A260
		dc.l ArtKospM_Spikes		; spikes
		dc.w $A360
		dc.l ArtKospM_HSpring	; horizontal spring
		dc.w $A460
		dc.l ArtKospM_VSpring	; vertical spring
		dc.w $A660
		dc.l ArtKospM_MzBlock	; green	stone block
		dc.w $5700
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - Star Light
; ---------------------------------------------------------------------------
PLC_SLZ:
		dc.l ArtKospM_SLZ		; SLZ main patterns
		dc.w 0
		dc.l ArtKospM_Bomb		; bomb enemy
		dc.w $8000
		dc.l ArtKospM_Switch		; switch
		dc.w $9000
		dc.l ArtKospM_Spikes		; spikes
		dc.w $A360
		dc.l ArtKospM_HSpring		; horizontal spring
		dc.w $A460
		dc.l ArtKospM_VSpring		; vertical spring
		dc.w $A660
		dc.w -1

PLC_SLZ2:
		dc.l ArtKospM_WarningSign	; yellow warning sign
		dc.w $6400
		dc.l ArtKospM_OkCool		; ok cool
		dc.w $6600
		dc.l ArtKospM_ACIcons		; A and C icons
		dc.w $6880
		dc.l ArtKospM_Fan		; fan
		dc.w $7400
		dc.l ArtKospM_Pylon		; foreground pylon
		dc.w $7980
		dc.l ArtKospM_GiantBomb		; giant bomb
		dc.w $8580
		dc.l ArtKospM_Bonus		; bonus points
		dc.w $96C0
		dc.l ArtKospM_SLZPlatform	; SLZ platform
		dc.w $9C00
		dc.l ArtKospM_HardPS		; hard part skipper
		dc.w $9200
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - Spring Yard
; ---------------------------------------------------------------------------
PLC_SYZ:
		dc.l ArtKospM_SYZ		; SYZ main patterns
		dc.w 0
		dc.l ArtKospM_SYZDoors		; SYZ doors
		dc.w $6000
		dc.l ArtKospM_LevelSigns	; level signs
		dc.w $6200
		dc.l ArtKospM_SYZEmblemsCasual	; SYZ casual progression emblems
		dc.w $6C00
		dc.l ArtKospM_SYZEmblemsFrantic	; SYZ frantic progression emblems
		dc.w $7A00
		dc.w -1

PLC_SYZ2:
		dc.l ArtKospM_OkCool		; ok cool
		dc.w $8800
		dc.l ArtKospM_BigRing		; big rings
		dc.w $8E00
		dc.l ArtKospM_RingFlash		; ring flash
		dc.w $8E00+$C40
		dc.l ArtKospM_SYZPlat		; exploding platform
		dc.w $A660
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - Scrap Brain
; ---------------------------------------------------------------------------
PLC_SBZ:
		dc.l ArtKospM_SBZ		; SBZ main patterns
		dc.w 0
		dc.l ArtKospM_HardPS_Tut	; hard part skipper
		dc.w $6C00
		dc.l ArtKospM_Switch	; switch
		dc.w $70A0
		dc.l ArtKospM_LevelSigns	; level signs
		dc.w $7300
		dc.l ArtKospM_SbzDoor1	; door
		dc.w $9800
		dc.l ArtKospM_HSpring		; horizontal spring
		dc.w $A460
		dc.w -1

PLC_SBZ2:
		dc.l ArtKospM_Spikes		; spikes
		dc.w $A360
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - title card
; ---------------------------------------------------------------------------
PLC_TitleCard:
		dc.l ArtKospM_TitleCard
		dc.w $AB80
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - act 3 boss
; ---------------------------------------------------------------------------
PLC_Boss:
		dc.l ArtKospM_Eggman		; Eggman main patterns
		dc.w $8000
		dc.l ArtKospM_Weapons	; Eggman's weapons
		dc.w $8D80
		dc.l ArtKospM_Bomb		; bomb enemy (gets overwritten)
		dc.w $A300
		dc.l ArtKospM_Exhaust	; exhaust flame
		dc.w $A540
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - act 1/2 signpost
; ---------------------------------------------------------------------------
PLC_Signpost:
		dc.l ArtKospM_SignPost	; signpost
		dc.w $D000
	;	dc.l ArtKospM_HSpring	; horizontal spring
	;	dc.w $A460
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - invicibility stars
; ---------------------------------------------------------------------------
PLC_Warp:
		dc.l ArtKospM_Stars		; invincibility	stars
		dc.w $AB80
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - special stage
; ---------------------------------------------------------------------------
PLC_SpeStage:
		dc.l ArtKospM_SSBgCloud	; bubble and cloud background
		dc.w 0
		dc.l ArtKospM_TitleCard	; title cards
		dc.w $0A20
		dc.l ArtKospM_SSWalls	; walls
		dc.w $2840
		dc.l ArtKospM_Bumper		; bumper
		dc.w $4760
		dc.l ArtKospM_SSGOAL		; GOAL block
		dc.w $4A20
		dc.l ArtKospM_SSUpDown	; UP and DOWN blocks
		dc.w $4C60
		dc.l ArtKospM_SSRBlock	; R block
		dc.w $5E00
		dc.l ArtKospM_SSEmStars	; emerald collection stars
		dc.w $7E00
		dc.l ArtKospM_SSRedWhite	; red and white	block
		dc.w $8E00
		dc.l ArtKospM_SSGhost	; ghost	block
		dc.w $9E00
		dc.l ArtKospM_SSWBlock	; W block
		dc.w $AE00
		dc.l ArtKospM_SSGlass	; glass	block
		dc.w $BE00
		dc.l ArtKospM_SSEmerald	; emeralds
		dc.w $EE00
		dc.l ArtKospM_Ring		; rings
		dc.w $F640
		dc.w -1

PLC_SSBlackout:
		dc.l ArtKospM_SSSkull	; Skull block (overrides GOAL blocks in blackout challenge)
		dc.w $4A20
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - ending sequence
; ---------------------------------------------------------------------------
PLC_Ending:
		dc.l ArtKospM_GHZ		; GHZ patterns
		dc.w 0
		dc.l ArtKospM_Stalk		; flower stalk
		dc.w $6B00
		dc.l ArtKospM_EndFan		; fan
		dc.w $7400
		dc.l ArtKospM_OkCool		; ok cool
		dc.w $BA00
		dc.l ArtKospM_UMadBro	; U Mad Bro?!
		dc.w $A480
		dc.l ArtKospM_Rabbit		; rabbit
		dc.w $AA60
		dc.l ArtKospM_Chicken	; chicken
		dc.w $ACA0
		dc.l ArtKospM_BlackBird	; blackbird
		dc.w $AE60
		dc.l ArtKospM_Seal		; seal
		dc.w $B0A0
		dc.l ArtKospM_Pig		; pig
		dc.w $B260
		dc.l ArtKospM_Flicky		; flicky
		dc.w $B4A0
		dc.l ArtKospM_Squirrel	; squirrel
		dc.w $B660
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - Bomb Machine Cutscene
; ---------------------------------------------------------------------------
PLC_EggmanSBZ2:
		dc.l ArtKospM_Sbz2Eggman	; Eggman
		dc.w $8000
		dc.l ArtKospM_Switch	; switch
		dc.w $9400
		dc.l ArtKospM_BombOld	; bomb enemy
		dc.w $A660
		dc.l ArtKospM_BombMach	; bomb machine
		dc.w $5600
		dc.w -1

; ---------------------------------------------------------------------------
; Pattern load cues - final boss
; ---------------------------------------------------------------------------
PLC_FZBoss:
		dc.l ArtKospM_SbzDoor1	; door
		dc.w $5500
	;	dc.l ArtKospM_FzEggman	; Eggman after boss
	;	dc.w $7400
		dc.l ArtKospM_Cutter
		dc.w $76A0
		dc.l ArtKospM_FzBoss		; FZ boss
		dc.w $6000
		dc.l ArtKospM_Eggman		; Eggman main patterns
		dc.w $8000
		dc.l ArtKospM_Sbz2Eggman	; Eggman without ship
		dc.w $8E00
		dc.l ArtKospM_Exhaust	; exhaust flame
		dc.w $A540
		dc.w -1
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; The massive list of resource includes
; ---------------------------------------------------------------------------

Art_Text:	incbin	Screens\OptionsScreen\Options_TextArt.bin	; uncompressed text for various text screens (not just options)
		even

ArtKospM_SegaLogo:	incbin	artkosp\segalogo.kospm	; large Sega logo
		even
Maps_SegaLogo:	incbin	misc\mapunc_segalogo.bin	; large Sega logo (uncompressed mappings)
		even
;Eni_SegaLogo:	incbin	misc\eni_segalogo.bin	; large Sega logo (mappings)
;		even
Maps_Title:	incbin	misc\mapunc_titlescr.bin	; title screen foreground (uncompressed mappings)
		even
;Eni_Title:	incbin	misc\eni_titlescr.bin	; title screen foreground (mappings)
;		even
ArtKospM_TitleFg:	incbin	artkosp\titlefor.kospm	; title screen foreground
		even
ArtKospM_TitleSonic:	incbin	artkosp\titleson.kospm	; Sonic on title screen
		even
; ---------------------------------------------------------------------------
; Sprite mappings - Sonic
; Uncompressed graphics	loading	array for Sonic
; Uncompressed graphics	- Sonic
; ---------------------------------------------------------------------------
Map_Sonic:	include	"_maps\Sonic.asm"
		even
SonicDynPLC:	include	"_maps\Sonic DPLC.asm"
		even
Art_Sonic:	incbin	artunc\sonic.bin	; Sonic Normal
		even
Art_Dust:	incbin	artunc\spindust.bin	; spindash dust art
		even
; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
ArtKospM_ERaZor:	incbin	artkosp\ERaZor.kospm	; ERaZor banner art
		even
ArtKospM_ERaZorNoBG:	incbin	artkosp\ERaZor_NoBG.kospm	; ERaZor banner art (no background)
		even
ArtKospM_Null:	incbin	artkosp\null.kospm		; just a file with one blank tile
		even
ArtKospM_Shield:	incbin	artkosp\shield.kospm	; shield
		even
ArtKospM_Stars:	incbin	artkosp\invstars.kospm	; invincibility stars
		even
;ArtKospM_TutHUD:	incbin	artkosp\TutorialHUD.kospm	; tutorial HUD
;		even
ArtKospM_UMadBro:	incbin	artkosp\UMadBro.kospm	; U Mad Bro?!
		even
; ---------------------------------------------------------------------------
; Compressed graphics - animals
; ---------------------------------------------------------------------------
ArtKospM_Rabbit:	incbin	artkosp\rabbit.kospm	; rabbit
		even
ArtKospM_Chicken:	incbin	artkosp\chicken.kospm	; chicken
		even
ArtKospM_BlackBird:	incbin	artkosp\blackbrd.kospm	; blackbird
		even
ArtKospM_Seal:	incbin	artkosp\seal.kospm		; seal
		even
ArtKospM_Pig:	incbin	artkosp\pig.kospm		; pig
		even
ArtKospM_Flicky:	incbin	artkosp\flicky.kospm	; flicky
		even
ArtKospM_Squirrel:	incbin	artkosp\squirrel.kospm	; squirrel
		even
; ---------------------------------------------------------------------------
; Sprite mappings - walls of the special stage
; ---------------------------------------------------------------------------
Map_SSWalls:
		include	"_maps\SSwalls.asm"
; ---------------------------------------------------------------------------
; Compressed graphics - special stage
; ---------------------------------------------------------------------------
ArtKospM_SSWalls:	incbin	artkosp\sswalls.kospm	; special stage walls
		even
Eni_SSBg2:	incbin	misc\eni_ssbg2.bin	; special stage background (mappings)
		even
ArtKospM_SSBgCloud:	incbin	artkosp\ssbg2.kospm	; special stage clouds background
		even
ArtKospM_SSGOAL:	incbin	artkosp\ssgoal.kospm	; special stage GOAL block
		even
ArtKospM_SSSkull:	incbin	artkosp\ssgoal_skull.kospm	; special stage skull block (restored from the S1 proto)
		even
ArtKospM_SSRBlock:	incbin	artkosp\ssr.kospm		; special stage R block
		even
ArtKospM_SSEmStars:	incbin	artkosp\ssemstar.kospm	; special stage stars from a collected emerald
		even
ArtKospM_SSRedWhite:	incbin	artkosp\ssredwhi.kospm	; special stage red/white block
		even
ArtKospM_SSUpDown:	incbin	artkosp\ssupdown.kospm	; special stage UP/DOWN block
		even
ArtKospM_SSEmerald:	incbin	artkosp\ssemeral.kospm	; special stage chaos emeralds
		even
ArtKospM_SSGhost:	incbin	artkosp\ssghost.kospm	; special stage ghost block
		even
ArtKospM_SSWBlock:	incbin	artkosp\ssw.kospm		; special stage W block
		even
ArtKospM_SSGlass:	incbin	artkosp\ssglass.kospm	; special stage destroyable glass block
		even
ArtKospM_Bumper:	incbin	artkosp\syzbumpe.kospm	; bumper
		even
;ArtKospM_ResultEm:	incbin	artkosp\ssresems.kospm	; chaos emeralds on special stage results screen
;		even
; ---------------------------------------------------------------------------
; Compressed graphics - GHZ stuff
; ---------------------------------------------------------------------------
ArtKospM_Stalk:	incbin	artkosp\ghzstalk.kospm	; GHZ flower stalk
		even
ArtKospM_Swing:	incbin	artkosp\ghzswing.kospm	; GHZ swinging platform
		even
ArtKospM_Bridge:	incbin	artkosp\ghzbridg.kospm	; GHZ bridge
		even
ArtKospM_Ball:	incbin	artkosp\ghzball.kospm	; GHZ giant ball
		even
ArtKospM_Spikes:	incbin	artkosp\spikes_bloody.kospm	; spikes
		even
ArtKospM_SpikesBlood: incbin	artkosp\spikes_lava.kospm	; damn those bloody spikes
		even
;ArtKospM_SpikePole:	incbin	artkosp\ghzlog.kospm	; GHZ spiked log
;		even
ArtKospM_PplRock:	incbin	artkosp\ghzrock.kospm	; GHZ purple rock
		even
ArtKospM_GhzWall1:	incbin	artkosp\ghzwall1.kospm	; GHZ destroyable wall
		even
ArtKospM_GhzWall2:	incbin	artkosp\ghzwall2.kospm	; GHZ normal wall
		even
; ---------------------------------------------------------------------------
; Compressed graphics - LZ stuff
; ---------------------------------------------------------------------------
ArtKospM_Water:	incbin	artkosp\lzwater.kospm	; LZ water surface
		even
ArtKospM_Splash:	incbin	artkosp\lzsplash.kospm	; LZ waterfalls and splashes
		even
;ArtKospM_LzSpikeBall:incbin	artkosp\lzspball.kospm	; LZ spiked ball on chain
;		even
ArtKospM_FlapDoor:	incbin	artkosp\lzflapdo.kospm	; LZ flapping door
		even
ArtKospM_Bubbles:	incbin	artkosp\lzbubble.kospm	; LZ bubbles and countdown numbers
		even
ArtKospM_LzBlock3:	incbin	artkosp\lzblock3.kospm	; LZ 32x16 block
		even
;ArtKospM_LzDoor1:	incbin	artkosp\lzvdoor.kospm	; LZ vertical door
;		even
;ArtKospM_Harpoon:	incbin	artkosp\lzharpoo.kospm	; LZ harpoon
;		even
ArtKospM_LzPole:	incbin	artkosp\lzpole.kospm	; LZ pole that breaks
		even
ArtKospM_LzDoor2:	incbin	artkosp\lzhdoor.kospm	; LZ large horizontal door
		even
;ArtKospM_LzWheel:	incbin	artkosp\lzwheel.kospm	; LZ wheel from corner of conveyor belt
;		even
ArtKospM_Gargoyle:	incbin	artkosp\lzgargoy.kospm	; LZ gargoyle head and spitting fire
		even
;ArtKospM_LzBlock2:	incbin	artkosp\lzblock2.kospm	; LZ blocks
;		even
ArtKospM_LzPlatfm:	incbin	artkosp\lzptform.kospm	; LZ rising platforms
		even
ArtKospM_Cork:	incbin	artkosp\lzcork.kospm	; LZ cork block
		even
;ArtKospM_LzBlock1:	incbin	artkosp\lzblock1.kospm	; LZ 32x32 block
;		even
; ---------------------------------------------------------------------------
; Compressed graphics - MZ stuff
; ---------------------------------------------------------------------------
ArtKospM_MzMetal:	incbin	artkosp\mzmetal.kospm	; MZ metal blocks
		even
ArtKospM_MzSwitch:	incbin	artkosp\mzswitch.kospm	; MZ switch
		even
ArtKospM_MzGlass:	incbin	artkosp\mzglassy.kospm	; MZ green glassy block
		even
;ArtKospM_MzFire:	incbin	artkosp\mzfire.kospm	; MZ fireballs
;		even
ArtKospM_Lava:	incbin	artkosp\mzlava.kospm	; MZ lava
		even
ArtKospM_MzBlock:	incbin	artkosp\mzblock.kospm	; MZ green pushable block
		even
; ---------------------------------------------------------------------------
; Compressed graphics - SLZ stuff
; ---------------------------------------------------------------------------
;ArtKospM_Seesaw:	incbin	artkosp\slzseesa.kospm	; SLZ seesaw
;		even
;ArtKospM_SlzSpike:	incbin	artkosp\slzspike.kospm	; SLZ spikeball that sits on a seesaw
;		even
ArtKospM_Fan:	incbin	artkosp\slzfan.kospm	; SLZ fan
		even
ArtKospM_EndFan:	incbin	artkosp\endfan.kospm	; ending sequence fan
		even
;ArtKospM_SlzWall:	incbin	artkosp\slzwall.kospm	; SLZ smashable wall
;		even
ArtKospM_Pylon:	incbin	artkosp\slzpylon.kospm	; SLZ foreground pylon / girders
		even
;ArtKospM_SlzSwing:	incbin	artkosp\slzswing.kospm	; SLZ swinging platform
;		even
;ArtKospM_SlzBlock:	incbin	artkosp\slzblock.kospm	; SLZ 32x32 block
;		even
;ArtKospM_SlzCannon:	incbin	artkosp\slzcanno.kospm	; SLZ fireball launcher cannon
;		even
ArtKospM_SLZPlatform:	incbin	artkosp\SLZPlatform.kospm	; SLZ platform
		even
ArtKospM_WarningSign:	incbin	artkosp\SLZWarningSign.kospm	; warning sign for bottomless pits
		even
ArtKospM_ACIcons:	incbin	artkosp\SLZACIcons.kospm	; A and C icons
		even
ArtKospM_GiantBomb:	incbin	artkosp\GiantBomb.kospm	; Giant Bomb
		even
; ---------------------------------------------------------------------------
; Compressed graphics - SYZ stuff
; ---------------------------------------------------------------------------
ArtKospM_Switch:	incbin	artkosp\switch.kospm	; LZ/SYZ/SBZ switch (ArtKospM_LzSwitch)
		even
ArtKospM_SYZDoors:	incbin	artkosp\SYZDoors.kospm	; SYZ doors
		even
ArtKospM_LevelSigns:	incbin	artkosp\LevelSigns.kospm	; SYZ level signs
		even
ArtKospM_SYZPlat:	incbin	artkosp\SYZPlatform.kospm	; SLZ Platform
		even
ArtKospM_SYZEmblemsCasual:	incbin	artkosp\SYZEmblems.kospm	; SYZ casual emblems
		even
ArtKospM_SYZEmblemsFrantic:	incbin	artkosp\SYZEmblems_Frantic.kospm	; SYZ frantic emblems
		even
; ---------------------------------------------------------------------------
; Compressed graphics - SBZ stuff
; ---------------------------------------------------------------------------
;ArtKospM_SbzWheel1:	incbin	artkosp\sbzwhee1.kospm	; SBZ spot on rotating wheel that Sonic runs around
;		even
;ArtKospM_SbzWheel2:	incbin	artkosp\sbzwhee2.kospm	; SBZ wheel that grabs Sonic
;		even
ArtKospM_Cutter:	incbin	artkosp\sbzcutte.kospm	; SBZ pizza cutter
		even
;ArtKospM_Stomper:	incbin	artkosp\sbzstomp.kospm	; SBZ stomper
;		even
;ArtKospM_SpinPform:	incbin	artkosp\sbzpform.kospm	; SBZ spinning platform
;		even
;ArtKospM_TrapDoor:	incbin	artkosp\sbztrapd.kospm	; SBZ trapdoor
;		even
;ArtKospM_SbzFloor:	incbin	artkosp\sbzfloor.kospm	; SBZ collapsing floor
;		even
;ArtKospM_Electric:	incbin	artkosp\sbzshock.kospm	; SBZ electric shock orb
;		even
;ArtKospM_SbzBlock:	incbin	artkosp\sbzvanis.kospm	; SBZ vanishing block
;		even
ArtKospM_FlamePipe:	incbin	artkosp\sbzflame.kospm	; SBZ flaming pipe
		even
ArtKospM_SbzDoor1:	incbin	artkosp\sbzvdoor.kospm	; SBZ small vertical door
		even
;ArtKospM_SlideFloor:	incbin	artkosp\sbzslide.kospm	; SBZ floor that slides away
;		even
;ArtKospM_SbzDoor2:	incbin	artkosp\sbzhdoor.kospm	; SBZ large horizontal door
;		even
;ArtKospM_Girder:	incbin	artkosp\sbzgirde.kospm	; SBZ crushing girder
;		even
; ---------------------------------------------------------------------------
; Compressed graphics - enemies
; ---------------------------------------------------------------------------
;ArtKospM_BallHog:	incbin	artkosp\ballhog.kospm	; ball hog
;		even
ArtKospM_Crabmeat:	incbin	artkosp\crabmeat.kospm	; crabmeat
		even
ArtKospM_Buzz:	incbin	artkosp\buzzbomb.kospm	; buzz bomber
		even
ArtKospM_ExplBall:	incbin	artkosp\explodingballs.kospm ; exploding balls
		even
;ArtKospM_Burrobot:	incbin	artkosp\burrobot.kospm	; burrobot
;		even
ArtKospM_Chopper:	incbin	artkosp\chopper.kospm	; chopper
		even
ArtKospM_Jaws:	incbin	artkosp\jaws.kospm		; jaws
		even
;ArtKospM_Roller:	incbin	artkosp\roller.kospm	; roller
;		even
ArtKospM_Motobug:	incbin	artkosp\motobug.kospm	; moto bug
		even
;ArtKospM_Newtron:	incbin	artkosp\newtron.kospm	; newtron
;		even
ArtKospM_Yadrin:	incbin	artkosp\yadrin.kospm	; yadrin
		even
ArtKospM_Basaran:	incbin	artkosp\basaran.kospm	; basaran
		even
ArtKospM_Bomb:	incbin	artkosp\bomb.kospm		; bomb
		even
ArtKospM_BombOld:	incbin	artkosp\bomb_old.kospm	; old bomb
		even
;ArtKospM_Orbinaut:	incbin	artkosp\orbinaut.kospm	; orbinaut
;		even
;ArtKospM_Cater:	incbin	artkosp\caterkil.kospm	; caterkiller
;		even
; ---------------------------------------------------------------------------
; Compressed graphics - various
; ---------------------------------------------------------------------------
ArtKospM_TitleCard:	incbin	artkosp\TitleCards.kospm	; title cards
		even
;ArtKospM_TCCont:	incbin	artkosp\ttlcards_continue.kospm	; title cards used for continue screen
;		even
ArtKospM_Hud:	incbin	artkosp\hud.kospm		; HUD (rings, time, score)
		even
ArtKospM_Deaths:	incbin	artkosp\hud_deaths.kospm ; HUD (deaths)
		even
;XArtKospM_Lives:	incbin	artkosp\lifeicon.kospm	; load normal life counter icon
;		even
ArtKospM_Ring:	incbin	artkosp\rings.kospm	; rings
		even
ArtKospM_Monitors:	incbin	artkosp\monitors.kospm	; monitors
		even
ArtKospM_Explode:	incbin	artkosp\explosio.kospm	; explosion
		even
;ArtKospM_Points:	incbin	artkosp\points.kospm	; points from destroyed enemy or object
;		even
;ArtKospM_GameOver:	incbin	artkosp\gameover.kospm	; game over / time over
;		even
ArtKospM_HSpring:	incbin	artkosp\springh.kospm	; horizontal spring
		even
ArtKospM_VSpring:	incbin	artkosp\springv.kospm	; vertical spring
		even
ArtKospM_SignPost:	incbin	artkosp\signpost.kospm	; end of level signpost
		even
ArtKospM_Lamp:	incbin	artkosp\lamppost.kospm	; lamppost
		even
ArtKospM_BigFlash:	incbin	artkosp\rngflash.kospm	; flash from giant ring
		even
ArtKospM_Bonus:	incbin	artkosp\bonus.kospm	; hidden bonuses at end of a level
		even
;ArtKospM_DEMO:	incbin	artkosp\Art_DEMO.kospm	; blinking DEMO banner [scrapped idea]
;		even
ArtKospM_HardPS:	incbin	artkosp\HardPartSkipper.kospm ; Hard Part Skipper
		even
ArtKospM_HardPS_Tut:	incbin	artkosp\HardPartSkipper_Tutorial.kospm ; Hard Part Skipper in the tutorial (includes info boxes)
		even
ArtKospM_BombMach:	incbin	artkosp\BombMachine.kospm	; bomb machine
		even
ArtKospM_OkCool:	incbin	artkosp\okcool.kospm ; ok cool
		even
; ---------------------------------------------------------------------------
; Compressed graphics - continue screen
; ---------------------------------------------------------------------------
;ArtKospM_ContSonic:	incbin	artkosp\cntsonic.kospm	; Sonic on continue screen
;		even
;ArtKospM_MiniSonic:	incbin	artkosp\cntother.kospm	; mini Sonic and text on continue screen
;		even
; ---------------------------------------------------------------------------
; Compressed graphics - primary patterns and block mappings
; ---------------------------------------------------------------------------
ArtKospM_TitleScreen:	incbin	artkosp\8x8title.kospm	; TS primary patterns
			even
Blk16_TitleScreen:	incbin	LevelData\map16\title.unc
			even
Blk256_TitleScreen:	incbin	LevelData\map256\title.bin
			even
Blk16_GHZ:	incbin	LevelData\map16\ghz.unc
		even
ArtKospM_GHZ:	incbin	artkosp\8x8ghz.kospm	; New GHZ file.
		even
Blk256_GHZ:	incbin	LevelData\map256\ghz.bin
		even
Blk16_LZ:	incbin	LevelData\map16\lz.unc
		even
ArtKospM_LZ:	incbin	artkosp\8x8lz.kospm	; LZ primary patterns
		even
Blk256_LZ:	incbin	LevelData\map256\lz.bin
		even
Blk16_MZ:	incbin	LevelData\map16\mz.unc
		even
ArtKospM_MZ:	incbin	artkosp\8x8mz.kospm	; MZ primary patterns
		even
Blk256_MZ:	incbin	LevelData\map256\mz.bin
		even
Blk16_SLZ:	incbin	LevelData\map16\slz.unc
		even
ArtKospM_SLZ:	incbin	artkosp\8x8slz.kospm	; SLZ primary patterns
		even
Blk256_SLZ:	incbin	LevelData\map256\slz.bin
		even
Blk16_SYZ:	incbin	LevelData\map16\syz.unc
		even
ArtKospM_SYZ:	incbin	artkosp\8x8syz.kospm	; SYZ primary patterns
		even
Blk256_SYZ:	incbin	LevelData\map256\syz.bin
		even
Blk16_SBZ:	incbin	LevelData\map16\sbz.unc
		even
ArtKospM_SBZ:	incbin	artkosp\8x8sbz.kospm	; SBZ primary patterns
		even
Blk256_SBZ:	incbin	LevelData\map256\sbz.bin
		even
Blk256_END:	incbin	LevelData\map256\ghz_end.bin
		even
; ---------------------------------------------------------------------------
; Compressed graphics - bosses and ending sequence
; ---------------------------------------------------------------------------
ArtKospM_Eggman:	incbin	artkosp\bossmain.kospm	; boss main patterns
		even
ArtKospM_Weapons:	incbin	artkosp\bossxtra.kospm	; boss add-ons and weapons
		even
;Unc_Prison:	incbin	artunc\prison.bin	; prison capsule (uncompressed)
ArtKospM_Prison:	incbin	artkosp\PrisonCapsule.kospm	; prison capsule
		even
ArtKospM_Nuke:	incbin	artkosp\Nuke.kospm	; nuke
		even
ArtKospM_Sbz2Eggman:	incbin	artkosp\sbz2boss.kospm	; Eggman in SBZ2 and FZ
		even
ArtKospM_FzBoss:	incbin	artkosp\fzboss.kospm	; FZ boss
		even
ArtKospM_FzEggman:	incbin	artkosp\fzboss2.kospm	; Eggman after the FZ boss
		even
ArtKospM_Exhaust:	incbin	artkosp\bossflam.kospm	; boss exhaust flame
		even
;ArtKospM_EndEm:	incbin	artkosp\endemera.kospm	; ending sequence chaos emeralds
;		even
ArtKospM_EndSonic:	incbin	artkosp\endsonic.kospm	; ending sequence Sonic
		even
;ArtKospM_TryAgain:	incbin	artkosp\tryagain.kospm	; ending "try again" screen
;		even
;Kos_EndFlowers:	incbin	artkos\flowers.bin	; ending sequence animated flowers
;		even
;ArtKospM_EndFlower:	incbin	artkosp\endflowe.kospm	; ending sequence flowers
;		even
;ArtKospM_CreditText:	incbin	artkosp\credits.kospm	; credits alphabet
;		even
;ArtKospM_EndStH:	incbin	artkosp\endtext.kospm	; ending sequence "Sonic the Hedgehog" text
;		even
	;	incbin	misc\padding2.bin
	;	even
; ---------------------------------------------------------------------------
; Collision data
; ---------------------------------------------------------------------------
AngleMap:	incbin	LevelData\collide\anglemap.bin	; floor angle map
		even
CollArray1:	incbin	LevelData\collide\carray_n.bin	; normal collision array
		even
CollArray2:	incbin	LevelData\collide\carray_r.bin	; rotated collision array
		even
Col_GHZ:	incbin	LevelData\collide\ghz.bin		; GHZ index
		even
Col_LZ:		incbin	LevelData\collide\lz.bin		; LZ index
		even
Col_MZ:		incbin	LevelData\collide\mz.bin		; MZ index
		even
Col_SLZ:	incbin	LevelData\collide\slz.bin		; SLZ index
		even
Col_SYZ:	incbin	LevelData\collide\syz.bin		; SYZ index
		even
Col_SBZ:	incbin	LevelData\collide\sbz.bin		; SBZ index
		even
; ---------------------------------------------------------------------------
; Special layouts
; ---------------------------------------------------------------------------
SS_1_Casual:	incbin	LevelData\sslayout\1-Casual.bin
		even
SS_1_Frantic:	incbin	LevelData\sslayout\1-Frantic.bin
		even
SS_2_Casual:	incbin	LevelData\sslayout\2-Casual.bin
		even
SS_2_Frantic:	incbin	LevelData\sslayout\2-Frantic.bin
		even
SS_Blackout_Part1:
		incbin	LevelData\sslayout\Blackout-Part1.bin
		even
SS_Blackout_Part2:
		incbin	LevelData\sslayout\Blackout-Part2.bin
		even
; ---------------------------------------------------------------------------
; Animated uncompressed graphics
; ---------------------------------------------------------------------------
Art_GhzWater:	incbin	artunc\ghzwater.bin	; GHZ waterfall
		even
Art_GhzFlower1:	incbin	artunc\ghzflowl.bin	; GHZ large flower
		even
Art_GhzFlower2:	incbin	artunc\ghzflows.bin	; GHZ small flower
		even
Art_MzLava1:	incbin	artunc\mzlava1.bin	; MZ lava surface
		even
Art_MzLava2:	incbin	artunc\mzlava2.bin	; MZ lava
		even
Art_MzTorch:	incbin	artunc\mztorch.bin	; MZ torch in background
		even
;Art_RingFlash:	incbin	artunc\ringflash.bin	; ring flash that appears when you enter a giant ring
;		even
; ---------------------------------------------------------------------------
; Level layout index entry macro
; ---------------------------------------------------------------------------
LayoutEntry:	macro Layout, Background
	dc.w \Layout-Level_Index, \Background-Level_Index
	endm
	
; ---------------------------------------------------------------------------
; Level	layout index
; ---------------------------------------------------------------------------
Level_Index:
		; 00XX
		LayoutEntry Level_GHZ1, Level_GHZbg ; Night Hill Place
		LayoutEntry Level_GHZ2, Level_GHZbg ; Intro
		LayoutEntry Level_GHZ3, Level_GHZbg ; Green Hill Place
		LayoutEntry LevelIndexPadding, LevelIndexPadding

		; 01XX
		LayoutEntry Level_LZ1, Level_LZbg ; 
		LayoutEntry Level_LZ2, Level_LZbg ; Labyrinthy Place
		LayoutEntry Level_LZ3, Level_LZbg ; 
		LayoutEntry Level_SBZ3, Level_LZbg ;

		; 02XX
		LayoutEntry Level_MZ1, Level_MZ1bg ; Ruined Place
		LayoutEntry Level_MZ2, Level_MZ2bg ; 
		LayoutEntry Level_MZ3, Level_MZ3bg ; (ADDRESS ERROR)
		LayoutEntry LevelIndexPadding, LevelIndexPadding

		; 03XX
		LayoutEntry Level_SLZ1, Level_SLZbg ; Special Place
		LayoutEntry Level_SLZ2, Level_SLZbg ; Scar Night Place
		LayoutEntry Level_SLZ3, Level_SLZbg ; Star Agony Place
		LayoutEntry LevelIndexPadding, LevelIndexPadding

		; 04XX
		LayoutEntry Level_SYZ1, Level_SYZbg ; ~Uberhub~
		LayoutEntry Level_SYZ2, Level_SYZbg ; Unreal Place
		LayoutEntry Level_SLZ4, Level_SYZbg ;
		LayoutEntry LevelIndexPadding, LevelIndexPadding

		; 05XX
		LayoutEntry Level_SBZ1, Level_SBZ1bg ; Tutorial
		LayoutEntry Level_SBZ2, Level_SBZ2bg ; Bomb Cutscene
		LayoutEntry Level_SBZ2, Level_FZbg ; Finalor Place
		LayoutEntry LevelIndexPadding, LevelIndexPadding

		; 06XX
		LayoutEntry Level_End, Level_GHZbg ; Ending
		LayoutEntry Level_End, Level_GHZbg ; Also ending
		LayoutEntry LevelIndexPadding, LevelIndexPadding
		LayoutEntry LevelIndexPadding, LevelIndexPadding

		dc.b "HAM EBIMOGE"

LevelIndexPadding:	dc.b 0,	0, 0, 0

Level_GHZ1:	incbin	'LevelData/levels/ghz1.kosp'
		even
byte_68D70:	dc.b 0,	0, 0, 0
Level_GHZ2:	incbin	'LevelData/levels/ghz2.kosp'
		even
byte_68E3C:	dc.b 0,	0, 0, 0
Level_GHZ3:	incbin	'LevelData/levels/ghz3.kosp'
		even
Level_GHZbg:	incbin	'LevelData/levels/ghzbg.kosp'
		even
byte_68F84:	dc.b 0,	0, 0, 0
byte_68F88:	dc.b 0,	0, 0, 0

Level_LZ1:	;incbin	levels\lz1.bin
		even
Level_LZbg:	incbin	'LevelData/levels/lzbg.kosp'
		even
byte_69190:	dc.b 0,	0, 0, 0
Level_LZ2:	incbin	'LevelData/levels/lz2.kosp'
		even
byte_6922E:	dc.b 0,	0, 0, 0
Level_LZ3:	;incbin	levels\lz3.bin
		even
byte_6934C:	dc.b 0,	0, 0, 0
Level_SBZ3:	;incbin	levels\sbz3.bin
		even
byte_6940A:	dc.b 0,	0, 0, 0

Level_MZ1:	incbin	'LevelData/levels/mz1.kosp'
		even
Level_MZ1bg:	incbin	'LevelData/levels/mz1bg.kosp'
		even
Level_MZ2:	;incbin	levels\mz2.bin
		even
Level_MZ2bg:	;incbin	levels\mz2bg.bin
		even
byte_6965C:	dc.b 0,	0, 0, 0
Level_MZ3:	;incbin	levels\mz3.bin
		even
Level_MZ3bg:	;incbin	levels\mz3bg.bin
		even
byte_697E6:	dc.b 0,	0, 0, 0
byte_697EA:	dc.b 0,	0, 0, 0

Level_SLZ1:;	incbin	levels\slz1.bin
		even
Level_SLZbg:	incbin	'LevelData/levels/slzbg.kosp'
		even
Level_SLZ2:	incbin	'LevelData/levels/slz2.kosp'
		even
Level_SLZ3:	incbin	'LevelData/levels/slz2.kosp'
		even
byte_69B84:	dc.b 0,	0, 0, 0

Level_SYZ1:	incbin	'LevelData/levels/syz1.kosp'
		even
Level_SYZbg:	incbin	'LevelData/levels/syzbg.kosp'
		even
byte_69C7E:	dc.b 0,	0, 0, 0
Level_SYZ2:	;incbin	levels\syz2.bin
		even
byte_69D86:	dc.b 0,	0, 0, 0
Level_SLZ4:;	incbin	levels\slz2casual.bin
		even
byte_69EE4:	dc.b 0,	0, 0, 0
byte_69EE8:	dc.b 0,	0, 0, 0

Level_SBZ1:	incbin	'LevelData/levels/sbz2.kosp'
		even
Level_SBZ2:	incbin	'LevelData/levels/sbz2.kosp'
		even
Level_SBZ1bg:	incbin	'LevelData/levels/sbz2bg.kosp'
		even
Level_SBZ2bg:	incbin	'LevelData/levels/sbz2bg.kosp'
		even
Level_FZbg:	incbin	'LevelData/levels/fzbg.kosp'
		even
byte_6A2F8:	dc.b 0,	0, 0, 0
byte_6A2FC:	dc.b 0,	0, 0, 0
Level_End:	incbin	'LevelData/levels/ending.kosp'
		even
byte_6A320:	dc.b 0,	0, 0, 0

; ---------------------------------------------------------------------------
; Animated uncompressed giant ring graphics
; ---------------------------------------------------------------------------
;Art_BigRing:	incbin	artunc\bigring.bin
;		even
ArtKospM_BigRing: incbin artkosp\bigring.kospm
		  even
ArtKospM_RingFlash:	incbin	artkosp\ringflash.kospm	; ring flash that appears when you enter a giant ring
		even
;ArtKospM_SGMC:	incbin artkosp\sgmc.kospm
;		even
		
	;	incbin	misc\padding3.bin
	;	even

; ---------------------------------------------------------------------------
; Sprite locations index
; ---------------------------------------------------------------------------
ObjPos_Index:	dc.w ObjPos_GHZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_GHZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_LZ2-ObjPos_Index,  ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_MZ1-ObjPos_Index,  ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SLZ3-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SYZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ1-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_SBZ2-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_FZ-ObjPos_Index,   ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index,  ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index,  ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index,  ObjPos_Null-ObjPos_Index
		dc.w ObjPos_End-ObjPos_Index,  ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
		dc.w ObjPos_Null-ObjPos_Index, ObjPos_Null-ObjPos_Index
	
ObjPos_GHZ1:	incbin	LevelData\objpos\ghz1.bin
		even
ObjPos_GHZ2:	incbin	LevelData\objpos\ghz2.bin
		even
ObjPos_GHZ3:	incbin	LevelData\objpos\ghz3.bin
		even

ObjPos_LZ2:	incbin	LevelData\objpos\lz2.bin
		even
ObjPos_LZ2pf1:	incbin	LevelData\objpos\lz2pf1.bin
		even
ObjPos_LZ2pf2:	incbin	LevelData\objpos\lz2pf2.bin
		even

		dc.w    $FFFF,$0000,$0000
ObjPos_MZ1:	incbin	LevelData\objpos\mz1.bin
		even

ObjPos_SLZ2:	incbin	LevelData\objpos\slz2.bin
		even
ObjPos_SLZ3:	incbin	LevelData\objpos\slz2.bin
		even

ObjPos_SYZ1:	incbin	LevelData\objpos\syz1.bin
		even

ObjPos_SBZ1:	incbin	LevelData\objpos\fz.bin
		even
ObjPos_SBZ2:	incbin	LevelData\objpos\fz.bin
		even
ObjPos_FZ:	incbin	LevelData\objpos\fz.bin
		even

		dc.w    $FFFF,$0000,$0000
ObjPos_End:	incbin	LevelData\objpos\ending.bin
		even

ObjPos_Null:	dc.w    $FFFF,$0000,$0000
		even

; ===========================================================================
; ---------------------------------------------------------------------------
; Various includes
; ---------------------------------------------------------------------------
; WARNING!
;	DO NOT put any data from now on! DO NOT use ROM padding!
;	Symbol data should be appended here after ROM is compiled
;	by ConvSym utility, otherwise debugger modules won't be able
;	to resolve symbol names.
; ---------------------------------------------------------------------------

; Screens
		include "Screens/ExitLogic.asm"
		include "Screens/BackgroundEffects.asm"
		include "Screens/SelbiSplash/SelbiSplash.asm"
		include "Screens/ChapterScreens/ChapterScreen.asm"
		include "Screens/OptionsScreen/OptionsScreen.asm"
		include "Screens/SoundTestScreen/SoundTestScreen.asm"
		include "Screens/StoryScreen/StoryScreen.asm"
		include	"Screens/CreditsScreen/CreditsScreen.asm"
		include	"Screens/TutorialBox/TutorialBox.asm"
		include	"Screens/GameplayStyleScreen/GameplayStyleScreen.asm"
; ---------------------------------------------------------------------------

; Level Renderer
		include	'modules\Level Renderer.asm'
; ---------------------------------------------------------------------------
		
; Sound Driver (MegaPCM)
		include	'SoundDriver\MegaPCM.asm'
		include	'SoundDriver\SampleTable.asm'

		pusho		; save previous options
		opt	l+	; use "." for local labels (AS compatibility)
FixBugs:	equ	1	; want to fix SMPS bugs

		include	'SoundDriver\s1.sounddriver.defs.asm'
		include	'SoundDriver\s1.sounddriver.asm'
		popo		; restore previous options
; ---------------------------------------------------------------------------

; Benchmark stuff
	if def(__BENCHMARK__)
		include "Benchmark/Benchmark.asm"
	endif
	if def(__MD_REPLAY__)
		MDReplay_IncludeMovie "Benchmark/bench-ghp.mdr"
	endif

; ---------------------------------------------------------------------------

; Vladik's Debugging modules
		include   'Debugger/ErrorHandler.asm'

; Sanity check for __DEBUG__ symbol to avoid pitfals
	if def(__DEBUG__)
	if __DEBUG__=0
		; "if def(__DEBUG__)" will always be true, even if __DEBUG__=0
		inform 2, "__DEBUG__=0 doesn't have any effect, comment it out instead"
	endif
	endif

; Sanity check for __BENCHMARK__ symbol to avoid pitfals
	if def(__BENCHMARK__)
	if __BENCHMARK__=0
		; "if def(__BENCHMARK__)" will always be true, even if __BENCHMARK__=0
		inform 2, "__BENCHMARK__=0 doesn't have any effect, comment it out instead"
	endif	
	endif
; ---------------------------------------------------------------------------
; ===========================================================================

; ===========================================================================
EndOfRom:	END	; it's joever
; ===========================================================================
		
